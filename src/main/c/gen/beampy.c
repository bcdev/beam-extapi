/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * This code has been generated using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */

// <<<<<<<< Begin include from PyCModuleGenerator-stub-init.c

#include "beampy.h"

#include <Python.h>
#include "structmember.h"
#include <jni.h>

#include "../beam_util.h"

static PyObject* BeamPy_Error;

int beam_initApi();

jboolean BPy_InitApi()
{
    int errCode = beam_initApi();
    if (errCode != 0) {
        char msg[64];
        sprintf(msg, "beam_initApi() failed with error code %d", errCode);
        PyErr_SetString(BeamPy_Error, msg);
        return 0;
    }
    return 1;
}
// >>>>>>>> End include from PyCModuleGenerator-stub-init.c

/* Wrapped API classes */
typedef void* GeoCoding;
typedef void* ProductWriter;
typedef void* GPF;
typedef void* IndexCoding;
typedef void* PixelPos;
typedef void* ProductIO;
typedef void* Placemark;
typedef void* MetadataElement;
typedef void* Product;
typedef void* ColorPaletteDef;
typedef void* ImageInfo;
typedef void* ProductManager;
typedef void* ImageGeometry;
typedef void* Band;
typedef void* PlacemarkGroup;
typedef void* TiePointGrid;
typedef void* AngularDirection;
typedef void* FlagCoding;
typedef void* Map;
typedef void* ProductReader;
typedef void* RGBChannelDef;
typedef void* ProductData;
typedef void* GeoPos;
typedef void* ProductNodeGroup;
typedef void* ProductUtils;
typedef void* MetadataAttribute;


/* Non-API classes used in the API */
typedef void* String;
typedef void* ProgressMonitor;
typedef void* MultiLevelImage;
typedef void* Parser;
typedef void* Term;
typedef void* WritableNamespace;
typedef void* Color;
typedef void* Dimension;
typedef void* Rectangle;
typedef void* RenderingHints;
typedef void* RenderingHints_Key;
typedef void* Shape;
typedef void* AffineTransform;
typedef void* Area;
typedef void* GeneralPath;
typedef void* Point2D;
typedef void* BufferedImage;
typedef void* ComponentColorModel;
typedef void* IndexColorModel;
typedef void* RenderedImage;
typedef void* File;
typedef void* Class;
typedef void* Double;
typedef void* Integer;
typedef void* Object;
typedef void* Collection;
typedef void* Iterator;
typedef void* Set;
typedef void* ImageInputStream;
typedef void* ImageOutputStream;
typedef void* ROI;
typedef void* ProductReaderPlugIn;
typedef void* ProductSubsetDef;
typedef void* ProductWriterPlugIn;
typedef void* BitmaskDef;
typedef void* ColorPaletteDef_Point;
typedef void* ImageInfo_HistogramMatching;
typedef void* Mask;
typedef void* PlacemarkDescriptor;
typedef void* Pointing;
typedef void* PointingFactory;
typedef void* Product_AutoGrouping;
typedef void* ProductData_UTC;
typedef void* ProductManager_Listener;
typedef void* ProductNode;
typedef void* ProductNodeListener;
typedef void* ProductVisitor;
typedef void* RasterDataNode;
typedef void* SampleCoding;
typedef void* Scaling;
typedef void* Stx;
typedef void* TransectProfileData;
typedef void* VectorDataNode;
typedef void* Datum;
typedef void* MapInfo;
typedef void* MapProjection;
typedef void* MapTransform;
typedef void* Operator;
typedef void* OperatorSpiRegistry;
typedef void* BitRaster;
typedef void* GeoTIFFMetadata;
typedef void* Histogram;
typedef void* IndexValidator;
typedef void* SimpleFeature;
typedef void* SimpleFeatureType;
typedef void* CoordinateReferenceSystem;
typedef void* MathTransform;

// <<<<<<<< Begin include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.h
/*
 * Java VM functions that must be used if this module is used in stand-alone
 * mode (= not loaded as shared library by a Java VM).
 */
boolean beam_isJvmCreated();
boolean beam_createJvm(const char* option_strings[], int option_count);
boolean beam_createJvmWithDefaults();
boolean beam_destroyJvm();

// todo - the following functions actually belong in another module because they expect String and Object typedefs to be present

String String_newString(const char* chars);
void Object_delete(Object object);
// >>>>>>>> End include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.h

PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_toString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args);
PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scale(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyMap_size(PyObject* self, PyObject* args);
PyObject* BeamPyMap_isEmpty(PyObject* self, PyObject* args);
PyObject* BeamPyMap_containsKey(PyObject* self, PyObject* args);
PyObject* BeamPyMap_containsValue(PyObject* self, PyObject* args);
PyObject* BeamPyMap_get(PyObject* self, PyObject* args);
PyObject* BeamPyMap_put(PyObject* self, PyObject* args);
PyObject* BeamPyMap_remove(PyObject* self, PyObject* args);
PyObject* BeamPyMap_putAll(PyObject* self, PyObject* args);
PyObject* BeamPyMap_clear(PyObject* self, PyObject* args);
PyObject* BeamPyMap_keySet(PyObject* self, PyObject* args);
PyObject* BeamPyMap_values(PyObject* self, PyObject* args);
PyObject* BeamPyMap_entrySet(PyObject* self, PyObject* args);
PyObject* BeamPyMap_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMap_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args);

//
// Global functions of module ${libName}
//
static PyMethodDef BeamPy_Functions[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

/* java.lang classes. */
jclass classBoolean;
jclass classByte;
jclass classCharacter;
jclass classShort;
jclass classInteger;
jclass classLong;
jclass classFloat;
jclass classDouble;
jclass classString;

/* java.util classes. */
jclass classHashMap;
jclass classHashSet;
jclass classArrayList;

/* API classes. */
jclass classGeoCoding;
jclass classProductWriter;
jclass classGPF;
jclass classIndexCoding;
jclass classPixelPos;
jclass classProductIO;
jclass classPlacemark;
jclass classMetadataElement;
jclass classProduct;
jclass classColorPaletteDef;
jclass classImageInfo;
jclass classProductManager;
jclass classImageGeometry;
jclass classBand;
jclass classPlacemarkGroup;
jclass classTiePointGrid;
jclass classAngularDirection;
jclass classFlagCoding;
jclass classMap;
jclass classProductReader;
jclass classRGBChannelDef;
jclass classProductData;
jclass classGeoPos;
jclass classProductNodeGroup;
jclass classProductUtils;
jclass classMetadataAttribute;

/* Used non-API classes. */
jclass classProgressMonitor;
jclass classMultiLevelImage;
jclass classParser;
jclass classTerm;
jclass classWritableNamespace;
jclass classColor;
jclass classDimension;
jclass classRectangle;
jclass classRenderingHints;
jclass classRenderingHints_Key;
jclass classShape;
jclass classAffineTransform;
jclass classArea;
jclass classGeneralPath;
jclass classPoint2D;
jclass classBufferedImage;
jclass classComponentColorModel;
jclass classIndexColorModel;
jclass classRenderedImage;
jclass classFile;
jclass classClass;
jclass classObject;
jclass classCollection;
jclass classIterator;
jclass classSet;
jclass classImageInputStream;
jclass classImageOutputStream;
jclass classROI;
jclass classProductReaderPlugIn;
jclass classProductSubsetDef;
jclass classProductWriterPlugIn;
jclass classBitmaskDef;
jclass classColorPaletteDef_Point;
jclass classImageInfo_HistogramMatching;
jclass classMask;
jclass classPlacemarkDescriptor;
jclass classPointing;
jclass classPointingFactory;
jclass classProduct_AutoGrouping;
jclass classProductData_UTC;
jclass classProductManager_Listener;
jclass classProductNode;
jclass classProductNodeListener;
jclass classProductVisitor;
jclass classRasterDataNode;
jclass classSampleCoding;
jclass classScaling;
jclass classStx;
jclass classTransectProfileData;
jclass classVectorDataNode;
jclass classDatum;
jclass classMapInfo;
jclass classMapProjection;
jclass classMapTransform;
jclass classOperator;
jclass classOperatorSpiRegistry;
jclass classBitRaster;
jclass classGeoTIFFMetadata;
jclass classHistogram;
jclass classIndexValidator;
jclass classSimpleFeature;
jclass classSimpleFeatureType;
jclass classCoordinateReferenceSystem;
jclass classMathTransform;


static PyMemberDef Shape_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Shape_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Shape_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Shape",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Shape_Methods,         /* tp_methods */
    Shape_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MapTransform_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MapTransform_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MapTransform",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides a parameterized, mathematical algorithm for a map transformation.\n\n@deprecated since BEAM 4.7, use geotools {@link org.geotools.referencing.operation.projection.MapProjection} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapTransform_Methods,         /* tp_methods */
    MapTransform_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ImageGeometry_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ImageGeometry_Methods[] = 
{
    {"newImageGeometry", (PyCFunction) BeamPyImageGeometry_newImageGeometry, METH_VARARGS | METH_STATIC, ""},
    {"getImage2MapTransform", (PyCFunction) BeamPyImageGeometry_getImage2MapTransform, METH_VARARGS, ""},
    {"getImageRect", (PyCFunction) BeamPyImageGeometry_getImageRect, METH_VARARGS, ""},
    {"getMapCrs", (PyCFunction) BeamPyImageGeometry_getMapCrs, METH_VARARGS, ""},
    {"changeYAxisDirection", (PyCFunction) BeamPyImageGeometry_changeYAxisDirection, METH_VARARGS, ""},
    {"calculateEastingNorthing", (PyCFunction) BeamPyImageGeometry_calculateEastingNorthing, METH_VARARGS | METH_STATIC, ""},
    {"calculateProductSize", (PyCFunction) BeamPyImageGeometry_calculateProductSize, METH_VARARGS | METH_STATIC, ""},
    {"createTargetGeometry", (PyCFunction) BeamPyImageGeometry_createTargetGeometry, METH_VARARGS | METH_STATIC, ""},
    {"createCollocationTargetGeometry", (PyCFunction) BeamPyImageGeometry_createCollocationTargetGeometry, METH_VARARGS | METH_STATIC, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageGeometry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ImageGeometry",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageGeometry_Methods,         /* tp_methods */
    ImageGeometry_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Parser_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Parser_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Parser_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Parser",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Instances of the <code>Parser</code> interface are used to convert a code\nstring representing an arithmetic expression in a tree of terms\nwhich can then be executed by using one of the evaluation methods of\nthe <code>{@link Term}</code> class.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Parser_Methods,         /* tp_methods */
    Parser_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef GeoCoding_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef GeoCoding_Methods[] = 
{
    {"isCrossingMeridianAt180", (PyCFunction) BeamPyGeoCoding_isCrossingMeridianAt180, METH_VARARGS, "Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.\n@return <code>true</code>, if so"},
    {"canGetPixelPos", (PyCFunction) BeamPyGeoCoding_canGetPixelPos, METH_VARARGS, "Checks whether or not this geo-coding can determine the pixel position from a geodetic position.\n@return <code>true</code>, if so"},
    {"canGetGeoPos", (PyCFunction) BeamPyGeoCoding_canGetGeoPos, METH_VARARGS, "Checks whether or not this geo-coding can determine the geodetic position from a pixel position.\n@return <code>true</code>, if so"},
    {"getPixelPos", (PyCFunction) BeamPyGeoCoding_getPixelPos, METH_VARARGS, "Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.\n@param geoPos   the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\n@param pixelPos an instance of <code>Point</code> to be used as retun value. If this parameter is\n<code>null</code>, the method creates a new instance which it then returns.\n@return the pixel co-ordinates as x/y"},
    {"getGeoPos", (PyCFunction) BeamPyGeoCoding_getGeoPos, METH_VARARGS, "Returns the latitude and longitude value for a given pixel co-ordinate.\n@param pixelPos the pixel's co-ordinates given as x,y\n@param geoPos   an instance of <code>GeoPos</code> to be used as retun value. If this parameter is\n<code>null</code>, the method creates a new instance which it then returns.\n@return the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}"},
    {"getDatum", (PyCFunction) BeamPyGeoCoding_getDatum, METH_VARARGS, "Gets the datum, the reference point or surface against which {@link GeoPos} measurements are made.\n@return the datum\n@deprecated use the datum of the associated {@link #getMapCRS() map CRS}."},
    {"dispose", (PyCFunction) BeamPyGeoCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined."},
    {"getImageCRS", (PyCFunction) BeamPyGeoCoding_getImageCRS, METH_VARARGS, "@return The image coordinate reference system (CRS). It is usually derived from the base CRS by including\na linear or non-linear transformation from base (geodetic) coordinates to image coordinates."},
    {"getMapCRS", (PyCFunction) BeamPyGeoCoding_getMapCRS, METH_VARARGS, "@return The map coordinate reference system (CRS). It may be either a geographical CRS (nominal case is\n\"WGS-84\") or a derived projected CRS, e.g. \"UTM 32 - North\"."},
    {"getGeoCRS", (PyCFunction) BeamPyGeoCoding_getGeoCRS, METH_VARARGS, "@return The geographical coordinate reference system (CRS). It may be either \"WGS-84\" (nominal case) or\nany other geographical CRS."},
    {"getImageToMapTransform", (PyCFunction) BeamPyGeoCoding_getImageToMapTransform, METH_VARARGS, "@return The math transformation used to convert image coordinates to map coordinates."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "GeoCoding",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>GeoCoding</code> interface provides geo-spatial latitude and longitude information for a given X/Y position\nof any (two-dimensional) raster.\n <b> Note: New geo-coding implementations shall implement the abstract class {@link AbstractGeoCoding},\ninstead of implementing this interface.</b>\n\n\nAll <code>GeoCoding</code> implementations should override\nthe {@link Object#equals(Object) equals()} and  {@link Object#hashCode() hashCode()} methods.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoCoding_Methods,         /* tp_methods */
    GeoCoding_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductData_Members[] = {
//     {"TYPE_UNDEFINED", 0, 0, READONLY, NULL}
//     {"TYPE_INT8", 0, 0, READONLY, NULL}
//     {"TYPE_INT16", 0, 0, READONLY, NULL}
//     {"TYPE_INT32", 0, 0, READONLY, NULL}
//     {"TYPE_UINT8", 0, 0, READONLY, NULL}
//     {"TYPE_UINT16", 0, 0, READONLY, NULL}
//     {"TYPE_UINT32", 0, 0, READONLY, NULL}
//     {"TYPE_FLOAT32", 0, 0, READONLY, NULL}
//     {"TYPE_FLOAT64", 0, 0, READONLY, NULL}
//     {"TYPE_ASCII", 0, 0, READONLY, NULL}
//     {"TYPE_UTC", 0, 0, READONLY, NULL}
//     {"TYPESTRING_INT8", 0, 0, READONLY, NULL}
//     {"TYPESTRING_INT16", 0, 0, READONLY, NULL}
//     {"TYPESTRING_INT32", 0, 0, READONLY, NULL}
//     {"TYPESTRING_UINT8", 0, 0, READONLY, NULL}
//     {"TYPESTRING_UINT16", 0, 0, READONLY, NULL}
//     {"TYPESTRING_UINT32", 0, 0, READONLY, NULL}
//     {"TYPESTRING_FLOAT32", 0, 0, READONLY, NULL}
//     {"TYPESTRING_FLOAT64", 0, 0, READONLY, NULL}
//     {"TYPESTRING_ASCII", 0, 0, READONLY, NULL}
//     {"TYPESTRING_UTC", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductData_Methods[] = 
{
    {"createInstance1", (PyCFunction) BeamPyProductData_createInstance1, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with exactly one element.\n@param type the value's type\n@return a new value instance, <code>null</code> if the given type is not known"},
    {"createInstance2", (PyCFunction) BeamPyProductData_createInstance2, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with the specified number of elements.\n@param type     the value's type\n@param numElems the number of elements, must be greater than zero if type is not {@link ProductData#TYPE_UTC}\n@return a new value instance, <code>null</code> if the given type is not known\n@throws IllegalArgumentException if one of the arguments is invalid"},
    {"createInstance3", (PyCFunction) BeamPyProductData_createInstance3, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with the specified number of elements.\n@param type the value's type\n@param data if <code>type</code> is <code>TYPE_ASCII</code> the <code>String</code>, otherwise the primitive array type corresponding to <code>type</code>\n@return a new value instance, <code>null</code> if the given type is not known\n@throws IllegalArgumentException if one of the arguments is invalid"},
    {"createInstance5", (PyCFunction) BeamPyProductData_createInstance5, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance1", (PyCFunction) BeamPyProductData_createUnsignedInstance1, METH_VARARGS | METH_STATIC, ""},
    {"createInstance10", (PyCFunction) BeamPyProductData_createInstance10, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance3", (PyCFunction) BeamPyProductData_createUnsignedInstance3, METH_VARARGS | METH_STATIC, ""},
    {"createInstance8", (PyCFunction) BeamPyProductData_createInstance8, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance2", (PyCFunction) BeamPyProductData_createUnsignedInstance2, METH_VARARGS | METH_STATIC, ""},
    {"createInstance9", (PyCFunction) BeamPyProductData_createInstance9, METH_VARARGS | METH_STATIC, ""},
    {"createInstance4", (PyCFunction) BeamPyProductData_createInstance4, METH_VARARGS | METH_STATIC, ""},
    {"createInstance7", (PyCFunction) BeamPyProductData_createInstance7, METH_VARARGS | METH_STATIC, ""},
    {"createInstance6", (PyCFunction) BeamPyProductData_createInstance6, METH_VARARGS | METH_STATIC, ""},
    {"getType1", (PyCFunction) BeamPyProductData_getType1, METH_VARARGS, "Returns this value's type ID."},
    {"getElemSize2", (PyCFunction) BeamPyProductData_getElemSize2, METH_VARARGS | METH_STATIC, "Gets the element size of an element of the given type in bytes.\n@param type the element type\n@return the size of a single element in bytes.\n@throws IllegalArgumentException if the type is not supported."},
    {"getElemSize1", (PyCFunction) BeamPyProductData_getElemSize1, METH_VARARGS, "Gets the element size of an element of this product data in bytes.\n@return the size of a single element in bytes"},
    {"getTypeString2", (PyCFunction) BeamPyProductData_getTypeString2, METH_VARARGS | METH_STATIC, "Returns a textual representation of the given data type.\n@return a data type string, <code>null</code> if the type is unknown"},
    {"getType2", (PyCFunction) BeamPyProductData_getType2, METH_VARARGS | METH_STATIC, "Returns a integer representation of the given data type string.\n@return a data type integer, <code>null</code> if the type is unknown"},
    {"getTypeString1", (PyCFunction) BeamPyProductData_getTypeString1, METH_VARARGS, "Returns this value's data type String."},
    {"isInt", (PyCFunction) BeamPyProductData_isInt, METH_VARARGS, "Tests whether this value has an integer.\n@return true, if so"},
    {"isIntType", (PyCFunction) BeamPyProductData_isIntType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is a signed or unsigned integer type.\n@return true, if so"},
    {"isSigned", (PyCFunction) BeamPyProductData_isSigned, METH_VARARGS, "Tests whether the actual instance is an signed data type.\n@return true, if so"},
    {"isUnsigned", (PyCFunction) BeamPyProductData_isUnsigned, METH_VARARGS, "Tests whether the actual instance is an unsigned data type.\n@return true, if so"},
    {"isUIntType", (PyCFunction) BeamPyProductData_isUIntType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is an unsigned integer type.\n@return true, if so"},
    {"isFloatingPointType", (PyCFunction) BeamPyProductData_isFloatingPointType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is a floating point type.\n@return true, if so"},
    {"isScalar", (PyCFunction) BeamPyProductData_isScalar, METH_VARARGS, "Tests if this value is a scalar.\n@return true, if so"},
    {"getNumElems", (PyCFunction) BeamPyProductData_getNumElems, METH_VARARGS, "Returns the number of data elements this value has."},
    {"getElemInt", (PyCFunction) BeamPyProductData_getElemInt, METH_VARARGS, "Returns the value as an <code>int</code>. The method assumes that this value is a scalar and therefore simply\nreturns <code>getElemIntAt(0)</code>.\n@see #getElemIntAt(int index)"},
    {"getElemUInt", (PyCFunction) BeamPyProductData_getElemUInt, METH_VARARGS, "Returns the value as an unsigned <code>int</code> given as a <code>long</code>. The method assumes that this\nvalue is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.\n@see #getElemUIntAt(int index)"},
    {"getElemFloat", (PyCFunction) BeamPyProductData_getElemFloat, METH_VARARGS, "Returns the value as an <code>float</code>. The method assumes that this value is a scalar and therefore\nsimply returns <code>getElemFloatAt(0)</code>.\n@see #getElemFloatAt(int index)"},
    {"getElemDouble", (PyCFunction) BeamPyProductData_getElemDouble, METH_VARARGS, "Returns the value as an <code>double</code>. The method assumes that this value is a scalar and therefore\nsimply returns <code>getElemDoubleAt(0)</code>.\n@see #getElemDoubleAt(int index)"},
    {"getElemString", (PyCFunction) BeamPyProductData_getElemString, METH_VARARGS, "Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained\nin this value.\n@return a text representing this fields value, never <code>null</code>"},
    {"getElemBoolean", (PyCFunction) BeamPyProductData_getElemBoolean, METH_VARARGS, "Returns the value as an <code>boolean</code>. The method assumes that this value is a scalar and therefore\nsimply returns <code>getElemBooleanAt(0)</code>.\n@see #getElemBooleanAt(int index)"},
    {"getElemIntAt", (PyCFunction) BeamPyProductData_getElemIntAt, METH_VARARGS, "Gets the value element with the given index as an <code>int</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemUIntAt", (PyCFunction) BeamPyProductData_getElemUIntAt, METH_VARARGS, "Gets the value element with the given index as a <code>long</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemFloatAt", (PyCFunction) BeamPyProductData_getElemFloatAt, METH_VARARGS, "Gets the value element with the given index as a <code>float</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemDoubleAt", (PyCFunction) BeamPyProductData_getElemDoubleAt, METH_VARARGS, "Gets the value element with the given index as a <code>double</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemStringAt", (PyCFunction) BeamPyProductData_getElemStringAt, METH_VARARGS, "Gets the value element with the given index as a <code>String</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemBooleanAt", (PyCFunction) BeamPyProductData_getElemBooleanAt, METH_VARARGS, "Gets the value element with the given index as a <code>boolean</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemInt", (PyCFunction) BeamPyProductData_setElemInt, METH_VARARGS, "Sets the value as an <code>int</code>. The method assumes that this value is a scalar and therefore simply\ncalls <code>setElemInt(0, value)</code>.\n@param value the value to be set\n@see #setElemIntAt(int index, int value)"},
    {"setElemUInt", (PyCFunction) BeamPyProductData_setElemUInt, METH_VARARGS, "Sets the value as an unsigned <code>int</code> given as a <code>long</code>. The method assumes that this\nvalue is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.\n@param value the value to be set\n@see #setElemUIntAt(int index, long value)"},
    {"setElemFloat", (PyCFunction) BeamPyProductData_setElemFloat, METH_VARARGS, "Sets the value as a <code>float</code>. The method assumes that this value is a scalar and therefore simply\ncalls <code>setElemFloatAt(0, value)</code>.\n@param value the value to be set\n@see #setElemFloatAt(int index, float value)"},
    {"setElemDouble", (PyCFunction) BeamPyProductData_setElemDouble, METH_VARARGS, "Sets the value as a <code>double</code>. The method assumes that this value is a scalar and therefore simply\ncalls <code>setElemDoubleAt(0)</code>.\n@param value the value to be set\n@see #setElemDoubleAt(int index, double value)"},
    {"setElemString", (PyCFunction) BeamPyProductData_setElemString, METH_VARARGS, "Sets the value as a <code>String</code>. The method assumes that this value is a scalar and therefore simply\ncalls <code>setElemStringAt(0)</code>.\n@param value the value to be set\n@see #setElemStringAt"},
    {"setElemBoolean", (PyCFunction) BeamPyProductData_setElemBoolean, METH_VARARGS, "Sets the value as a <code>boolean</code>. The method assumes that this value is a scalar and therefore simply\ncalls <code>setElemDoubleAt(0)</code>.\n@param value the value to be set\n@see #setElemBooleanAt(int index, boolean value)"},
    {"setElemIntAt", (PyCFunction) BeamPyProductData_setElemIntAt, METH_VARARGS, "Sets the value at the specified index as an <code>int</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemUIntAt", (PyCFunction) BeamPyProductData_setElemUIntAt, METH_VARARGS, "Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemFloatAt", (PyCFunction) BeamPyProductData_setElemFloatAt, METH_VARARGS, "Sets the value at the specified index as a <code>float</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemDoubleAt", (PyCFunction) BeamPyProductData_setElemDoubleAt, METH_VARARGS, "Sets the value at the specified index as a <code>double</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemStringAt", (PyCFunction) BeamPyProductData_setElemStringAt, METH_VARARGS, "Sets the value at the specified index as a <code>String</code>.\n\n<i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemBooleanAt", (PyCFunction) BeamPyProductData_setElemBooleanAt, METH_VARARGS, "Sets the value at the specified index as a <code>boolean</code>.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n@param value the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElems", (PyCFunction) BeamPyProductData_getElems, METH_VARARGS, "Returns the internal value. The actual type of the returned object should only be one of <ol>\n<li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\nsigned/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\nfields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\nfor signed 64-bit floating point fields</li> </ol>\n@return an array of one of the described types"},
    {"setElems", (PyCFunction) BeamPyProductData_setElems, METH_VARARGS, "Sets the internal value. The actual type of the given data object should only be one of <ol>\n<li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\nsigned/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\nfields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\nfor signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>\n@param data an array of one of the described types"},
    {"readFrom4", (PyCFunction) BeamPyProductData_readFrom4, METH_VARARGS, "Reads all elements of this <code>ProductData</code> instance from to the given input stream.\n\n The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n<code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position\nwithin the input stream.\n@param input a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom3", (PyCFunction) BeamPyProductData_readFrom3, METH_VARARGS, "Reads a single element of this <code>ProductData</code> instance from to the given output stream.\n\n The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given\noutput stream.<br> Reading starts at the current seek position within the output stream.\n@param pos   the destination position (zero-based)\n@param input a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom1", (PyCFunction) BeamPyProductData_readFrom1, METH_VARARGS, "Reads elements of this <code>ProductData</code> instance from the given output stream.\n\n The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\nthis <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek\nposition of the input stream.\n@param startPos the destination start position (zero-based)\n@param numElems the number of elements to read\n@param input    a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom2", (PyCFunction) BeamPyProductData_readFrom2, METH_VARARGS, "Reads elements into this <code>ProductData</code> instance from the given input stream.\n\n The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\nthis <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>\nwithin the output stream. The method multiplies this position with the value returned by\n<code>getElemSize()</code> in order to find the correct stream offset in bytes.\n@param startPos the destination start position (zero-based)\n@param numElems the number of elements to read\n@param input    a seekable data input stream\n@param inputPos the (zero-based) position in the data output stream where reading starts\n@throws IOException if an I/O error occurs"},
    {"writeTo4", (PyCFunction) BeamPyProductData_writeTo4, METH_VARARGS, "Writes all elements of this <code>ProductData</code> instance to to the given output stream.\n\n The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n<code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position\nwithin the output stream.\n@param output a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo3", (PyCFunction) BeamPyProductData_writeTo3, METH_VARARGS, "Writes a single element of this <code>ProductData</code> instance to to the given output stream.\n\n The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given\noutput stream.<br> Writing starts at the current seek position within the output stream.\n@param pos    the source position (zero-based)\n@param output a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo1", (PyCFunction) BeamPyProductData_writeTo1, METH_VARARGS, "Writes elements of this <code>ProductData</code> instance to to the given output stream.\n\n The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\nof this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek\nposition within the output stream.\n@param startPos the source start position (zero-based)\n@param numElems the number of elements to be written\n@param output   a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo2", (PyCFunction) BeamPyProductData_writeTo2, METH_VARARGS, "Writes elements of this <code>ProductData</code> instance to to the given output stream.\n\n The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\nof this <code>ProductData</code> instance to the given output stream.<br> Writing starts at\n<code>outputPos</code> within the output stream. The method multiplies this position with the value returned by\n<code>getElemSize()</code> in order to find the correct stream offset in bytes.\n@param startPos  the source start position (zero-based)\n@param numElems  the number of elements to be written\n@param output    a seekable data output stream\n@param outputPos the position in the data output stream where writing starts\n@throws IOException if an I/O error occurs"},
    {"toString", (PyCFunction) BeamPyProductData_toString, METH_VARARGS, "Returns a string representation of this value which can be used for debugging purposes."},
    {"hashCode", (PyCFunction) BeamPyProductData_hashCode, METH_VARARGS, "Returns {@link Object#hashCode()}."},
    {"equals", (PyCFunction) BeamPyProductData_equals, METH_VARARGS, "Returns {@link Object#equals(Object)}.\nUse {@link #equalElems} in order to perform an element-wise comparision."},
    {"equalElems", (PyCFunction) BeamPyProductData_equalElems, METH_VARARGS, "Tests whether this ProductData is equal to another one.\nPerforms an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.\nOtherwise the method behaves like {@link Object#equals(Object)}.\n@param other the other one"},
    {"dispose", (PyCFunction) BeamPyProductData_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductData_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductData",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract <code>ProductData</code> class represents a generic data buffer used to hold the actual data values\nstored in remote sensing data products.\n\n A single <code>ProductData</code> instance can have one or more elements of a primitive type. The primitive types\nare: <ld> <li> {@link ProductData.Byte signed 8-bit integer} </li> <li> {@link ProductData.UByte unsigned 16-bit\ninteger} </li> <li> {@link ProductData.Short signed 32-bit integer} </li> <li> {@link ProductData.UShort unsigned\n16-bit integer} </li> <li> {@link ProductData.Int signed 32-bit integer} </li> <li> {@link ProductData.UInt unsigned\n32-bit integer} </li> <li> {@link ProductData.Float 32-bit floating point} </li> <li> {@link ProductData.Double\n64-bit floating point} </li> <li> {@link ProductData.ASCII a character string (8-bit ASCII encoding)} </li> <li>\n{@link ProductData.UTC a MJD-2000 encoded data/time value} </li> </ld>\n\nThe number of elements is an inmutable property of a <code>ProductData</code> instance.\n\nIn order to access the data in a <code>ProductData</code> instance, multiple setters and getters are provided\nwhich use generic <i>transfer data types</i> in order to make the data transfer in and out of a\n<code>ProductData</code> instance easy for programmers.<br> For scalar (one-element) values the prototypes are\n<pre>\nvoid setElem<b>Type</b>(<b>Type</b> elem);\n<b>Type</b> getElem<b>Type</b>();\n</pre>\nFor vector (multiple-element) values the prototypes are\n<pre>\nvoid setElem<b>Type</b>At(int index, <b>Type</b> elem);\n<b>Type</b> getElem<b>Type</b>At(int index);\n</pre>\nWhere the transfer data type <code><b>Type</b></code> is one of <code>int</code>, <code>long</code>,\n<code>float</code>, <code>double</code> and <code>String</code>.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductData_Methods,         /* tp_methods */
    ProductData_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef AffineTransform_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef AffineTransform_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject AffineTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "AffineTransform",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    AffineTransform_Methods,         /* tp_methods */
    AffineTransform_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Mask_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Mask_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Mask_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Mask",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A {@code Mask} is used to mask image pixels of other raster data nodes.\n\nThis is a preliminary API under construction for BEAM 4.7. Not intended for public use.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Mask_Methods,         /* tp_methods */
    Mask_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Double_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Double_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Double_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Double",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Double_Methods,         /* tp_methods */
    Double_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef GPF_Members[] = {
//     {"DISABLE_TILE_CACHE_PROPERTY", 0, 0, READONLY, NULL}
//     {"USE_FILE_TILE_CACHE_PROPERTY", 0, 0, READONLY, NULL}
//     {"TILE_COMPUTATION_OBSERVER_PROPERTY", 0, 0, READONLY, NULL}
//     {"SOURCE_PRODUCT_FIELD_NAME", 0, 0, READONLY, NULL}
//     {"TARGET_PRODUCT_FIELD_NAME", 0, 0, READONLY, NULL}
//     {"KEY_TILE_SIZE", 0, 0, READONLY, NULL}
//     {"NO_PARAMS", 0, 0, READONLY, NULL}
//     {"NO_SOURCES", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef GPF_Methods[] = 
{
    {"createProductWithoutSourceProducts", (PyCFunction) BeamPyGPF_createProductWithoutSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\n@param operatorName the name of the operator to use.\n@param parameters   the named parameters needed by the operator.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromSourceProduct", (PyCFunction) BeamPyGPF_createProductFromSourceProduct, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\n@param operatorName  the name of the operator to use.\n@param parameters    the named parameters needed by the operator.\n@param sourceProduct a source product.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromSourceProducts", (PyCFunction) BeamPyGPF_createProductFromSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\n@param operatorName   the name of the operator to use.\n@param parameters     the named parameters needed by the operator.\n@param sourceProducts the source products.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromNamedSourceProducts", (PyCFunction) BeamPyGPF_createProductFromNamedSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\n@param operatorName   the name of the operator to use.\n@param parameters     the named parameters needed by the operator.\n@param sourceProducts the map of named source products.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductNS", (PyCFunction) BeamPyGPF_createProductNS, METH_VARARGS, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nAll static {@code createProduct} methods delegate to this non-static (= NS) version.\nIt can be overriden by clients in order to alter product creation behaviour of the static\n{@code createProduct} methods of the current GPF instance.\n@param operatorName   the name of the operator to use.\n@param parameters     the named parameters needed by the operator.\n@param sourceProducts the map of named source products.\n@param renderingHints the rendering hints, may be {@code null}.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createOperator", (PyCFunction) BeamPyGPF_createOperator, METH_VARARGS, "Creates an operator instance by using the given operator (alias) name.\n@param operatorName   the name of the operator to use.\n@param parameters     the named parameters needed by the operator.\n@param sourceProducts the map of named source products.\n@param renderingHints the rendering hints, may be {@code null}.\n@return the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"getOperatorSpiRegistry", (PyCFunction) BeamPyGPF_getOperatorSpiRegistry, METH_VARARGS, "Gets the registry for operator SPIs.\n@return the registry for operator SPIs."},
    {"setOperatorSpiRegistry", (PyCFunction) BeamPyGPF_setOperatorSpiRegistry, METH_VARARGS, "Sets the registry for operator SPIs.\n@param spiRegistry the registry for operator SPIs."},
    {"getDefaultInstance", (PyCFunction) BeamPyGPF_getDefaultInstance, METH_VARARGS | METH_STATIC, "Gets the default GPF instance.\n@return the singelton instance."},
    {"setDefaultInstance", (PyCFunction) BeamPyGPF_setDefaultInstance, METH_VARARGS | METH_STATIC, "Sets the default GPF instance.\n@param defaultInstance the GPF default instance."},
    {"writeProduct", (PyCFunction) BeamPyGPF_writeProduct, METH_VARARGS | METH_STATIC, "Writes a product with the specified format to the given file.\n@param product     the product\n@param file        the product file\n@param formatName  the name of a supported product format, e.g. \"HDF5\". If <code>null</code>, the default format\n\"BEAM-DIMAP\" will be used\n@param incremental switch the product writer in incremental mode or not.\n@param pm          a monitor to inform the user about progress"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GPF_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "GPF",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The facade for the Graph Processing Framework.\nThe Graph Processing Framework makes extensive use of Java Advanced Imaging (JAI).\nTherefore, configuring the JAI {@link javax.media.jai.TileCache TileCache} and\n{@link javax.media.jai.TileScheduler TileScheduler} will also affect the overall performance of\nthe Graph Processing Framework.\nThis class may be overridden in order to alter product creation behaviour of the static\n{@code createProduct} methods of the GPF instance.\nThe current instance can be set by {@link #setDefaultInstance(GPF)}.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GPF_Methods,         /* tp_methods */
    GPF_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef IndexCoding_Members[] = {
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef IndexCoding_Methods[] = 
{
    {"newIndexCoding", (PyCFunction) BeamPyIndexCoding_newIndexCoding, METH_VARARGS | METH_STATIC, "Constructs a new index coding object with the given name.\n@param name the name"},
    {"getIndex", (PyCFunction) BeamPyIndexCoding_getIndex, METH_VARARGS, "Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to\ngetPropertyValue(String).\n@param name the flag name\n@return a metadata attribute wich is the representation of the flag with the given name"},
    {"getIndexNames", (PyCFunction) BeamPyIndexCoding_getIndexNames, METH_VARARGS, "Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.\n@return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n<code>FlagCoding</code> does not contain any flag, <code>null</code> is returned"},
    {"addIndex", (PyCFunction) BeamPyIndexCoding_addIndex, METH_VARARGS, "Adds a new index definition to this flags coding.\n@param name        the index name\n@param value       the index value\n@param description the description text\n@throws IllegalArgumentException if <code>name</code> is null\n@return A new attribute representing the coded index."},
    {"getIndexValue", (PyCFunction) BeamPyIndexCoding_getIndexValue, METH_VARARGS, "Returns the flag mask value for the specified flag name.\n@param name the flag name\n@return flagMask the flag's bit mask as a 32 bit integer\n@throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist"},
    {"acceptVisitor", (PyCFunction) BeamPyIndexCoding_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls <code>visitor.visit(this)</code>.\n@param visitor the visitor, must not be <code>null</code>"},
    {"addElement", (PyCFunction) BeamPyIndexCoding_addElement, METH_VARARGS, "Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\nbecause flag codings do not support inner elements.\n@param element the element to be added, always ignored"},
    {"addAttribute", (PyCFunction) BeamPyIndexCoding_addAttribute, METH_VARARGS, "Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n@param attribute the attribute to be added\n@throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value"},
    {"addSample", (PyCFunction) BeamPyIndexCoding_addSample, METH_VARARGS, "Adds a new coding value to this sample coding.\n@param name        the coding name\n@param value       the value\n@param description the description text\n@throws IllegalArgumentException if <code>name</code> is null\n@return A new attribute representing the coded sample."},
    {"getSampleCount", (PyCFunction) BeamPyIndexCoding_getSampleCount, METH_VARARGS, "Gets the number of coded sample values.\n@return the number of coded sample values"},
    {"getSampleName", (PyCFunction) BeamPyIndexCoding_getSampleName, METH_VARARGS, "Gets the sample name at the specified attribute index.\n@param index the attribute index.\n@return the sample name."},
    {"getSampleValue", (PyCFunction) BeamPyIndexCoding_getSampleValue, METH_VARARGS, "Gets the sample value at the specified attribute index.\n@param index the attribute index.\n@return the sample value."},
    {"getElementGroup", (PyCFunction) BeamPyIndexCoding_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\n@return The child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyIndexCoding_getParentElement, METH_VARARGS, ""},
    {"addElementAt", (PyCFunction) BeamPyIndexCoding_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\n@param element the element to added, ignored if <code>null</code>\n@param index   where to put it"},
    {"removeElement", (PyCFunction) BeamPyIndexCoding_removeElement, METH_VARARGS, "Removes the given element from this element.\n@param element the element to be removed, ignored if <code>null</code>\n@return true, if so"},
    {"getNumElements", (PyCFunction) BeamPyIndexCoding_getNumElements, METH_VARARGS, "@return the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyIndexCoding_getElementAt, METH_VARARGS, "Returns the element at the given index.\n@param index the element index\n@return the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyIndexCoding_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\n@return a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyIndexCoding_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\n@return an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyIndexCoding_getElement, METH_VARARGS, "Returns the element with the given name.\n@param name the element name\n@return the element with the given name or <code>null</code> if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyIndexCoding_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyIndexCoding_getElementIndex, METH_VARARGS, "Gets the index of the given element.\n@param element The element .\n@return The element's index, or -1."},
    {"removeAttribute", (PyCFunction) BeamPyIndexCoding_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n@return <code>true</code> if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyIndexCoding_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\n@return the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyIndexCoding_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\n@param index the attribute index\n@return the attribute, or <code>null</code> if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyIndexCoding_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\n@return the attribute name array, never <code>null</code>"},
    {"getAttributes", (PyCFunction) BeamPyIndexCoding_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\n@return an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyIndexCoding_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\n@param name the attribute name\n@return the attribute with the given name or <code>null</code> if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyIndexCoding_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\n@param name the attribute name\n@return <code>true</code> if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyIndexCoding_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\n@param attribute The attribute.\n@return The attribute's index, or -1."},
    {"getAttributeDouble", (PyCFunction) BeamPyIndexCoding_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC", (PyCFunction) BeamPyIndexCoding_getAttributeUTC, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as UTC."},
    {"getAttributeInt", (PyCFunction) BeamPyIndexCoding_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyIndexCoding_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\n<code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyIndexCoding_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\n<code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyIndexCoding_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\n<code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"getAttributeString", (PyCFunction) BeamPyIndexCoding_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyIndexCoding_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\n<code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setModified", (PyCFunction) BeamPyIndexCoding_setModified, METH_VARARGS, ""},
    {"createDeepClone", (PyCFunction) BeamPyIndexCoding_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyIndexCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyIndexCoding_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyIndexCoding_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyIndexCoding_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyIndexCoding_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyIndexCoding_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyIndexCoding_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyIndexCoding_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyIndexCoding_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyIndexCoding_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyIndexCoding_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyIndexCoding_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyIndexCoding_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyIndexCoding_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyIndexCoding_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyIndexCoding_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyIndexCoding_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "IndexCoding",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nrepresent index values (e.g. types, classes, categories).",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexCoding_Methods,         /* tp_methods */
    IndexCoding_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Term_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Term_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Term_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Term",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract <code>Term</code> class is an in-memory representation of an\nelement within an arbitrary expression tree. The class defines a number of\nconcrete <code>Term</code> implementations each representing either an\nan atomic leave (number constant, symbol reference) or a node\n(e.g. binary operator, function call) within an expression tree.\n\n Instances of this class are normally created using an expression parser\nwhich implements the <code>{@link com.bc.jexp.Parser}</code> interface.\nThe <code>{@link com.bc.jexp.impl.ParserImpl}</code> class provides a default\nimplementation of such a parser.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Term_Methods,         /* tp_methods */
    Term_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef RasterDataNode_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef RasterDataNode_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RasterDataNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RasterDataNode",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>RasterDataNode</code> class ist the abstract base class for all objects in the product package that contain\nrasterized data. i.e. <code>Band</code> and <code>TiePointGrid</code>. It unifies the access to raster data in the\nproduct model. A raster is considered as a rectangular raw data array with a fixed width and height. A raster data\nnode can scale its raw raster data samples in order to return geophysically meaningful pixel values.\n@see #getRasterData()\n@see #getRasterWidth()\n@see #getRasterHeight()\n@see #isScalingApplied()\n@see #isLog10Scaled()\n@see #getScalingFactor()\n@see #getScalingOffset()",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RasterDataNode_Methods,         /* tp_methods */
    RasterDataNode_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Class_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Class_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Class_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Class",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Class_Methods,         /* tp_methods */
    Class_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Product_AutoGrouping_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Product_AutoGrouping_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Product_AutoGrouping_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Product_AutoGrouping",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "AutoGrouping can be used by an application to auto-group a long list of product nodes (e.g. bands)\nas a tree of product nodes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Product_AutoGrouping_Methods,         /* tp_methods */
    Product_AutoGrouping_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef PixelPos_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef PixelPos_Methods[] = 
{
    {"newPixelPos1", (PyCFunction) BeamPyPixelPos_newPixelPos1, METH_VARARGS | METH_STATIC, "Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0)."},
    {"newPixelPos2", (PyCFunction) BeamPyPixelPos_newPixelPos2, METH_VARARGS | METH_STATIC, "Constructs and initializes a <code>PixelPos</code> with the specified coordinate.\n@param x the x component of the coordinate\n@param y the y component of the coordinate"},
    {"isValid", (PyCFunction) BeamPyPixelPos_isValid, METH_VARARGS, "Tests whether or not this pixel position is valid.\n@return true, if so"},
    {"setInvalid", (PyCFunction) BeamPyPixelPos_setInvalid, METH_VARARGS, "Sets this pixel position so that is becomes invalid."},
    {"getX", (PyCFunction) BeamPyPixelPos_getX, METH_VARARGS, ""},
    {"getY", (PyCFunction) BeamPyPixelPos_getY, METH_VARARGS, ""},
    {"setLocation1", (PyCFunction) BeamPyPixelPos_setLocation1, METH_VARARGS, ""},
    {"setLocation2", (PyCFunction) BeamPyPixelPos_setLocation2, METH_VARARGS, ""},
    {"toString", (PyCFunction) BeamPyPixelPos_toString, METH_VARARGS, ""},
    {"setLocation3", (PyCFunction) BeamPyPixelPos_setLocation3, METH_VARARGS, ""},
    {"distanceSq2", (PyCFunction) BeamPyPixelPos_distanceSq2, METH_VARARGS | METH_STATIC, ""},
    {"distance2", (PyCFunction) BeamPyPixelPos_distance2, METH_VARARGS | METH_STATIC, ""},
    {"distanceSq1", (PyCFunction) BeamPyPixelPos_distanceSq1, METH_VARARGS, ""},
    {"distanceSq3", (PyCFunction) BeamPyPixelPos_distanceSq3, METH_VARARGS, ""},
    {"distance1", (PyCFunction) BeamPyPixelPos_distance1, METH_VARARGS, ""},
    {"distance3", (PyCFunction) BeamPyPixelPos_distance3, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyPixelPos_clone, METH_VARARGS, ""},
    {"hashCode", (PyCFunction) BeamPyPixelPos_hashCode, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyPixelPos_equals, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PixelPos_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "PixelPos",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A <code>PixelPos</code> represents a position or point in a pixel coordinate system.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PixelPos_Methods,         /* tp_methods */
    PixelPos_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef BitRaster_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef BitRaster_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BitRaster_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "BitRaster",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A pixel mask provides a boolean value for a given pixel position.\nIt is used to identify valid pixels in a raster.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BitRaster_Methods,         /* tp_methods */
    BitRaster_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ImageOutputStream_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ImageOutputStream_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageOutputStream_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ImageOutputStream",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageOutputStream_Methods,         /* tp_methods */
    ImageOutputStream_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Stx_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Stx_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Stx_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Stx",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides statistic information for a raster data node at a given image resolution level.\nInstances of the <code>Stx</code> class are created using the {@link StxFactory}.\n\n<i>Important note: This class has been revised in BEAM 4.10. All behaviour has been moved to {@link StxFactory}\nleaving behind this class as a pure data container. Statistics are now furthermore derived upon\ngeo-physically interpreted image data (before it operated on the raw, unscaled data). Thus, it is\nnot required to scale the returned statistical properties, e.g. we used to write\n{@code band.scale(stx.getMean())}. This is not required anymore.</i>",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Stx_Methods,         /* tp_methods */
    Stx_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Rectangle_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Rectangle_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Rectangle_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Rectangle",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Rectangle_Methods,         /* tp_methods */
    Rectangle_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Dimension_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Dimension_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Dimension_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Dimension",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Dimension_Methods,         /* tp_methods */
    Dimension_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductIO_Members[] = {
//     {"DEFAULT_FORMAT_NAME", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductIO_Methods[] = 
{
    {"getProductReader", (PyCFunction) BeamPyProductIO_getProductReader, METH_VARARGS | METH_STATIC, "Gets a product reader for the given format name.\n@param formatName the product format name\n@return a suitable product reader or <code>null</code> if none was found"},
    {"getProductWriterExtensions", (PyCFunction) BeamPyProductIO_getProductWriterExtensions, METH_VARARGS | METH_STATIC, "Gets an array of writer product file extensions for the given format name.\n@param formatName the format name\n@return an array of extensions or null if the format does not exist"},
    {"getProductWriter", (PyCFunction) BeamPyProductIO_getProductWriter, METH_VARARGS | METH_STATIC, "Gets a product writer for the given format name.\n@param formatName the product format name\n@return a suitable product writer or <code>null</code> if none was found"},
    {"readProduct", (PyCFunction) BeamPyProductIO_readProduct, METH_VARARGS | METH_STATIC, "Reads the data product specified by the given file path.\nThe product returned will be associated with the reader appropriate for the given\nfile format (see also {@link Product#getProductReader() Product.productReader}).\nThe method does not automatically read band data, thus\n{@link Band#getRasterData() Band.rasterData} will always be null\nfor all bands in the product returned by this method.\n@param filePath the data product file path\n@return a data model as an in-memory representation of the given product file or <code>null</code> if no\nappropriate reader was found for the given product file\n@throws IOException if an I/O error occurs\n@see #readProduct(File)"},
    {"getProductReaderForFile", (PyCFunction) BeamPyProductIO_getProductReaderForFile, METH_VARARGS | METH_STATIC, "Returns a product reader instance for the given file if any registered product reader can decode the given file.\n@param file the file to decode.\n@return a product reader for the given file or <code>null</code> if the file cannot be decoded.\n@deprecated Since BEAM 4.10. Use {@link #getProductReaderForInput(Object)} instead."},
    {"getProductReaderForInput", (PyCFunction) BeamPyProductIO_getProductReaderForInput, METH_VARARGS | METH_STATIC, "Tries to find a product reader instance suitable for the given input.\nThe method returns {@code null}, if no\nregistered product reader can handle the given {@code input} value.\n\nThe {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or\n{@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.\n@param input the input object.\n@return a product reader for the given {@code input} or {@code null} if no registered reader can handle\nthe it.\n@see ProductReaderPlugIn#getDecodeQualification(Object)\n@see ProductReader#readProductNodes(Object, ProductSubsetDef)"},
    {"writeProduct", (PyCFunction) BeamPyProductIO_writeProduct, METH_VARARGS | METH_STATIC, "Writes a product with the specified format to the given file path.\nThe method also writes all band data to the file. Therefore the band data must either\n<ld>\n<li>be completely loaded ({@link Band#getRasterData() Band.rasterData} is not null)</li>\n<li>or the product must be associated with a product reader ({@link Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>\n</ld>.\n@param product    the product, must not be <code>null</code>\n@param filePath   the file path\n@param formatName the name of a supported product format, e.g. \"HDF5\". If <code>null</code>, the default format\n\"BEAM-DIMAP\" will be used\n@throws IOException if an IOException occurs"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductIO_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductIO",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductIO</code> class provides several utility methods concerning data I/O for remote sensing data\nproducts.\n\n For example, a product can be read in using a single method call:\n<pre>\nProduct product =  ProductIO.readProduct(\"test.prd\");\n</pre>\nand written out in a similar way:\n<pre>\nProductIO.writeProduct(product, \"HDF5\", \"test.h5\", null);\n</pre>",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductIO_Methods,         /* tp_methods */
    ProductIO_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductNode_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductNode_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductNode",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductNode</code> is the base class for all nodes within a remote sensing data product and even the data\nproduct itself.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNode_Methods,         /* tp_methods */
    ProductNode_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef AngularDirection_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef AngularDirection_Methods[] = 
{
    {"newAngularDirection", (PyCFunction) BeamPyAngularDirection_newAngularDirection, METH_VARARGS | METH_STATIC, ""},
    {"equals", (PyCFunction) BeamPyAngularDirection_equals, METH_VARARGS, ""},
    {"toString", (PyCFunction) BeamPyAngularDirection_toString, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject AngularDirection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "AngularDirection",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    AngularDirection_Methods,         /* tp_methods */
    AngularDirection_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef SimpleFeatureType_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef SimpleFeatureType_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SimpleFeatureType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "SimpleFeatureType",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SimpleFeatureType_Methods,         /* tp_methods */
    SimpleFeatureType_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef SampleCoding_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef SampleCoding_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SampleCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "SampleCoding",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nare combined of single flags (bit indexes).",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SampleCoding_Methods,         /* tp_methods */
    SampleCoding_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Object_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Object_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Object_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Object",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Object_Methods,         /* tp_methods */
    Object_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductReader_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductReader_Methods[] = 
{
    {"getReaderPlugIn", (PyCFunction) BeamPyProductReader_getReaderPlugIn, METH_VARARGS, "Returns the plug-in which created this product reader.\n@return the product reader plug-in, should never be <code>null</code>"},
    {"getInput", (PyCFunction) BeamPyProductReader_getInput, METH_VARARGS, "Retrives the current input destination object. Thie return value might be <code>null</code> if the\n<code>setInput</code> has not been called so far."},
    {"getSubsetDef", (PyCFunction) BeamPyProductReader_getSubsetDef, METH_VARARGS, "Returns the subset information with which this a data product is read from its physical source.\n@return the subset information, can be <code>null</code>"},
    {"readProductNodes", (PyCFunction) BeamPyProductReader_readProductNodes, METH_VARARGS, "Reads a data product and returns a in-memory representation of it.\n\n The given subset info can be used to specify spatial and spectral portions of the original proudct. If the\nsubset is omitted, the complete product is read in.\n\n Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,\nis up to the implementation.\n@param input     an object representing a valid output for this product reader, might be a\n<code>ImageInputStream</code> or other <code>Object</code> to use for future decoding.\n@param subsetDef a spectral or spatial subset (or both) of the product. If <code>null</code>, the entire product\nis read in\n@throws IllegalArgumentException   if <code>input</code> is <code>null</code> or it's type is not one of the\nsupported input sources.\n@throws IOException                if an I/O error occurs\n@throws IllegalFileFormatException if the file format is illegal"},
    {"readBandRasterData", (PyCFunction) BeamPyProductReader_readBandRasterData, METH_VARARGS, "Reads raster data from the data source specified by the given destination band into the given in-memory buffer\nand region.\n\n<h3>Destination band</h3> The destination band is used to identify the data source from which this method\ntransfers the sample values into the given destination buffer. The method does not modify the given destination\nband at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method\nshould also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.\n\n<h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,\n<code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's\nraster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and\nsub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset\nand sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The\ndestination region should always specify a sub-region of the band's scene raster.\n\n<h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given\n<code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are\n<b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *\ndestHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies\nfaster than the Y co-ordinate.\n@param destBand    the destination band which identifies the data source from which to read the sample values\n@param destOffsetX the X-offset in the band's raster co-ordinates\n@param destOffsetY the Y-offset in the band's raster co-ordinates\n@param destWidth   the width of region to be read given in the band's raster co-ordinates\n@param destHeight  the height of region to be read given in the band's raster co-ordinates\n@param destBuffer  the destination buffer which receives the sample values to be read\n@throws IOException              if an I/O error occurs\n@throws IllegalArgumentException if the number of elements destination buffer not equals <code>destWidth *\ndestHeight</code> or the destination region is out of the band's scene raster\n@see Band#getSceneRasterWidth()\n@see Band#getSceneRasterHeight()"},
    {"close", (PyCFunction) BeamPyProductReader_close, METH_VARARGS, "Closes the access to all currently opened resources such as file input streams and all resources of this children\ndirectly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>close()</code> are undefined.\n\nOverrides of this method should always call <code>super.close();</code> after disposing this instance.\n@throws IOException if an I/O error occurs"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductReader_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductReader",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Classes implementing the <code>ProductReader</code> interface know how to create an in-memory representation of a\ngiven data product as input source.\n@see ProductWriter",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductReader_Methods,         /* tp_methods */
    ProductReader_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductReaderPlugIn_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductReaderPlugIn_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductReaderPlugIn_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductReaderPlugIn",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductReaderPlugIn</code> interface is implemented by data product reader plug-ins.\n\nXMLDecoder plug-ins are used to provide meta-information about a particular data format and to create instances of\nthe actual reader objects.\n\n A plug-in can register itself in the <code>ProductIO</code> plug-in registry or it is automatically found during\na classpath scan.\n@see ProductWriterPlugIn",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductReaderPlugIn_Methods,         /* tp_methods */
    ProductReaderPlugIn_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Integer_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Integer_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Integer_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Integer",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Integer_Methods,         /* tp_methods */
    Integer_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductData_UTC_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductData_UTC_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductData_UTC_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductData_UTC",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductData.UTC</code> class is a <code>ProductData.UInt</code> specialisation for UTC date/time\nvalues.\n\n Internally, data is stored in an <code>int[3]</code> array which represents a Modified Julian Day 2000\n({@link ProductData.UTC#getMJD() MJD}) as a {@link\nProductData.UTC#getDaysFraction() days}, a {@link\nProductData.UTC#getSecondsFraction() seconds} and a {@link\nProductData.UTC#getMicroSecondsFraction() micro-seconds} fraction.\n@see ProductData.UTC#getMJD()\n@see ProductData.UTC#getDaysFraction()\n@see ProductData.UTC#getSecondsFraction()\n@see ProductData.UTC#getMicroSecondsFraction()",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductData_UTC_Methods,         /* tp_methods */
    ProductData_UTC_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Band_Members[] = {
//     {"PROPERTY_NAME_SAMPLE_CODING", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SOLAR_FLUX", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SPECTRAL_BAND_INDEX", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SPECTRAL_BANDWIDTH", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SPECTRAL_WAVELENGTH", 0, 0, READONLY, NULL}
//     {"VIEW_MODE_ORTHO", 0, 0, READONLY, NULL}
//     {"VIEW_MODE_FORWARD", 0, 0, READONLY, NULL}
//     {"VIEW_MODE_NADIR", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_IMAGE_INFO", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_LOG_10_SCALED", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_ROI_DEFINITION", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SCALING_FACTOR", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SCALING_OFFSET", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NO_DATA_VALUE", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NO_DATA_VALUE_USED", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_VALID_PIXEL_EXPRESSION", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_GEOCODING", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_STX", 0, 0, READONLY, NULL}
//     {"NO_DATA_TEXT", 0, 0, READONLY, NULL}
//     {"INVALID_POS_TEXT", 0, 0, READONLY, NULL}
//     {"IO_ERROR_TEXT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DATA", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_READ_ONLY", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SYNTHETIC", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_UNIT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Band_Methods[] = 
{
    {"newBand", (PyCFunction) BeamPyBand_newBand, METH_VARARGS | METH_STATIC, "Constructs a new <code>Band</code>.\n@param name     the name of the new object\n@param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\nconstants, with the exception of <code>ProductData.TYPE_UINT32</code>\n@param width    the width of the raster in pixels\n@param height   the height of the raster in pixels"},
    {"getFlagCoding", (PyCFunction) BeamPyBand_getFlagCoding, METH_VARARGS, "Gets the flag coding for this band.\n@return a non-null value if this band is a flag dataset, <code>null</code> otherwise"},
    {"isFlagBand", (PyCFunction) BeamPyBand_isFlagBand, METH_VARARGS, "Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).\n@return <code>true</code> if so"},
    {"getIndexCoding", (PyCFunction) BeamPyBand_getIndexCoding, METH_VARARGS, "Gets the index coding for this band.\n@return a non-null value if this band is a flag dataset, <code>null</code> otherwise"},
    {"isIndexBand", (PyCFunction) BeamPyBand_isIndexBand, METH_VARARGS, "Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).\n@return <code>true</code> if so"},
    {"getSampleCoding", (PyCFunction) BeamPyBand_getSampleCoding, METH_VARARGS, "Gets the sample coding.\n@return the sample coding, or {@value null} if not set."},
    {"setSampleCoding", (PyCFunction) BeamPyBand_setSampleCoding, METH_VARARGS, "Sets the sample coding for this band.\n@param sampleCoding the sample coding\n@throws IllegalArgumentException if this band does not contain integer pixels"},
    {"getSpectralBandIndex", (PyCFunction) BeamPyBand_getSpectralBandIndex, METH_VARARGS, "Gets the (zero-based) spectral band index.\n@return the (zero-based) spectral band index or <code>-1</code> if it is unknown"},
    {"setSpectralBandIndex", (PyCFunction) BeamPyBand_setSpectralBandIndex, METH_VARARGS, "Sets the (zero-based) spectral band index.\n@param spectralBandIndex the (zero-based) spectral band index or <code>-1</code> if it is unknown"},
    {"getSpectralWavelength", (PyCFunction) BeamPyBand_getSpectralWavelength, METH_VARARGS, "Gets the spectral wavelength in <code>nm</code> (nanomater) units.\n@return the wave length in nanometers of this band, or zero if this is not a spectral band or the wave length is\nnot known."},
    {"setSpectralWavelength", (PyCFunction) BeamPyBand_setSpectralWavelength, METH_VARARGS, "Sets the spectral wavelength in <code>nm</code> (nanomater) units.\n@param spectralWavelength the wavelength in nanometers of this band, or zero if this is not a spectral band or\nthe wavelength is not known."},
    {"getSpectralBandwidth", (PyCFunction) BeamPyBand_getSpectralBandwidth, METH_VARARGS, "Gets the spectral bandwidth in <code>nm</code> (nanomater) units.\n@return the bandwidth in nanometers of this band, or zero if this is not a spectral band or the bandwidth is not\nknown."},
    {"setSpectralBandwidth", (PyCFunction) BeamPyBand_setSpectralBandwidth, METH_VARARGS, "Sets the spectral bandwidth in <code>nm</code> (nanomater) units.\n@param spectralBandwidth the spectral bandwidth in nanometers of this band, or zero if this is not a spectral band\nor the spectral bandwidth is not known."},
    {"getSolarFlux", (PyCFunction) BeamPyBand_getSolarFlux, METH_VARARGS, "Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\nunits for the wavelength of this band.\n@return the solar flux for the wavelength of this band, or zero if this is not a spectral band or the solar flux\nis not known."},
    {"setSolarFlux", (PyCFunction) BeamPyBand_setSolarFlux, METH_VARARGS, "Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\nunits for the wavelength of this band.\n@param solarFlux the solar flux for the wavelength of this band, or zero if this is not a spectral band or the\nsolar flux is not known."},
    {"acceptVisitor", (PyCFunction) BeamPyBand_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls <code>visitor.visit(this)</code>.\n@param visitor the visitor, must not be <code>null</code>"},
    {"toString", (PyCFunction) BeamPyBand_toString, METH_VARARGS, "Creates a string defining this band object."},
    {"removeFromFile", (PyCFunction) BeamPyBand_removeFromFile, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyBand_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"getViewModeId", (PyCFunction) BeamPyBand_getViewModeId, METH_VARARGS, ""},
    {"computeBand", (PyCFunction) BeamPyBand_computeBand, METH_VARARGS, "(Re-)Computes this band's data using the given arithmetic expression.\n@param expression          the arithmetic expression string, e.g. \"1 + log(radiance_5 / radiance_13)\"\n@param validMaskExpression the arithmetic expression identifying valid source pixels, e.g. \"radiance_5 > 0.0 && radiance_13 > 0.0\"\n@param sourceProducts      the list of source products possibly referenced in the expression\n@param defaultProductIndex the index of the product for which also symbols without the\nproduct prefix <code>$<i>ref-no</i></code> are registered in the namespace\n@param checkInvalids       if true, the method recognizes numerically invalid values (NaN, Infinity)\n@param useInvalidValue     if true, numerically invalid values (NaN, Infinity) are set to <code>invalidValue</code>,\nignored if <code>checkInvalids = false</code>\n@param noDataValue         the value used in place of  numerically invalid values if <code>useInvalidValue =\ntrue</code>, ignored if  <code>checkInvalids = false</code>\n@param pm                  a monitor to inform the user about progress\n@return the number of invalid pixels, zero if  <code>checkInvalids = false</code>\n@throws IOException    if an I/O error occurs\n@throws ParseException if the expression syntax is invalid\n@deprecated Since BEAM 4.10. Use {@link VirtualBand} or {@link org.esa.beam.jai.VirtualBandOpImage}."},
    {"getSceneRasterData", (PyCFunction) BeamPyBand_getSceneRasterData, METH_VARARGS, "Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so\nfar the method returns <code>null</code>.\n\nIn opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n<code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the\nscene's pixels.\n@return raster data covering the pixels for a complete scene\n@see #getRasterData\n@see RasterDataNode#getSceneRasterWidth\n@see RasterDataNode#getSceneRasterHeight\n@deprecated since BEAM 4.11, use {@link #getSourceImage()} instead."},
    {"getPixelInt", (PyCFunction) BeamPyBand_getPixelInt, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as an integer value.\n@param x The X co-ordinate of the pixel location\n@param y The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleInt(int, int)} instead."},
    {"getPixelFloat", (PyCFunction) BeamPyBand_getPixelFloat, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as a float value.\n@param x The X co-ordinate of the pixel location\n@param y The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead."},
    {"getPixelDouble", (PyCFunction) BeamPyBand_getPixelDouble, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as a double value.\n@param x The X co-ordinate of the pixel location\n@param y The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead."},
    {"setPixelInt", (PyCFunction) BeamPyBand_setPixelInt, METH_VARARGS, "Sets the pixel at the given pixel co-ordinate to the given pixel value.\n@param x          The X co-ordinate of the pixel location\n@param y          The Y co-ordinate of the pixel location\n@param pixelValue the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelFloat", (PyCFunction) BeamPyBand_setPixelFloat, METH_VARARGS, "Sets the pixel at the given pixel coordinate to the given pixel value.\n@param x          The X co-ordinate of the pixel location\n@param y          The Y co-ordinate of the pixel location\n@param pixelValue the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelDouble", (PyCFunction) BeamPyBand_setPixelDouble, METH_VARARGS, "Sets the pixel value at the given pixel coordinate to the given pixel value.\n@param x          The X co-ordinate of the pixel location\n@param y          The Y co-ordinate of the pixel location\n@param pixelValue the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelsInt", (PyCFunction) BeamPyBand_setPixelsInt, METH_VARARGS, "Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of\ndata at the specified location. Throws exception when the target buffer is not in memory.\n@param x      x offset into the band\n@param y      y offset into the band\n@param w      width of the pixel array to be written\n@param h      height of the pixel array to be written.\n@param pixels integer array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"setPixelsFloat", (PyCFunction) BeamPyBand_setPixelsFloat, METH_VARARGS, "Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data\nat the specified location. Throws exception when the target buffer is not in memory.\n@param x      x offset into the band\n@param y      y offset into the band\n@param w      width of the pixel array to be written\n@param h      height of the pixel array to be written.\n@param pixels float array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"setPixelsDouble", (PyCFunction) BeamPyBand_setPixelsDouble, METH_VARARGS, "Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data\nat the specified location. Throws exception when the target buffer is not in memory.\n@param x      x offset into the band\n@param y      y offset into the band\n@param w      width of the pixel array to be written\n@param h      height of the pixel array to be written.\n@param pixels double array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"ensureRasterData", (PyCFunction) BeamPyBand_ensureRasterData, METH_VARARGS, "Ensures that raster data exists\n@deprecated since BEAM 4.11. No replacement."},
    {"unloadRasterData", (PyCFunction) BeamPyBand_unloadRasterData, METH_VARARGS, "Un-loads the raster data for this band.\n\nAfter this method has been called successfully, the <code>hasRasterData()</code> method returns\n<code>false</code> and <code>getRasterData()</code> returns <code>null</code>.\n\n@see #loadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"getSceneRasterWidth", (PyCFunction) BeamPyBand_getSceneRasterWidth, METH_VARARGS, "Returns the width in pixels of the scene represented by this product raster. By default, the method simply\nreturns <code>getRasterWidth()</code>.\n@return the scene width in pixels"},
    {"getSceneRasterHeight", (PyCFunction) BeamPyBand_getSceneRasterHeight, METH_VARARGS, "Returns the height in pixels of the scene represented by this product raster. By default, the method simply\nreturns <code>getRasterHeight()</code>.\n@return the scene height in pixels"},
    {"getRasterWidth", (PyCFunction) BeamPyBand_getRasterWidth, METH_VARARGS, "Returns the width of the raster used by this product raster.\n@return the width of the raster"},
    {"getRasterHeight", (PyCFunction) BeamPyBand_getRasterHeight, METH_VARARGS, "Returns the height of the raster used by this product raster.\n@return the height of the raster"},
    {"setModified", (PyCFunction) BeamPyBand_setModified, METH_VARARGS, ""},
    {"getGeoCoding", (PyCFunction) BeamPyBand_getGeoCoding, METH_VARARGS, "Returns the geo-coding of this {@link RasterDataNode}.\n@return the geo-coding"},
    {"setGeoCoding", (PyCFunction) BeamPyBand_setGeoCoding, METH_VARARGS, "Sets the geo-coding for this {@link RasterDataNode}.\nAlso sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_GEOCODING}.\n@param geoCoding the new geo-coding\n@see Product#setGeoCoding(GeoCoding)"},
    {"getPointing", (PyCFunction) BeamPyBand_getPointing, METH_VARARGS, "Gets a {@link Pointing} if one is available for this raster.\nThe methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\nsince the last creation of this raster's {@link Pointing} instance.\n@return the pointing object, or null if a pointing is not available"},
    {"canBeOrthorectified", (PyCFunction) BeamPyBand_canBeOrthorectified, METH_VARARGS, "Tests if this raster data node can be orthorectified.\n@return true, if so"},
    {"isFloatingPointType", (PyCFunction) BeamPyBand_isFloatingPointType, METH_VARARGS, "Returns <code>true</code> if the pixel data contained in this band is \"naturally\" a floating point number type.\n@return true, if so"},
    {"getGeophysicalDataType", (PyCFunction) BeamPyBand_getGeophysicalDataType, METH_VARARGS, "Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the\n<code>ProductData.TYPE_XXX</code> constants.\n@return the geophysical data type\n@see ProductData\n@see #isScalingApplied()"},
    {"getScalingFactor", (PyCFunction) BeamPyBand_getScalingFactor, METH_VARARGS, "Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n<code>1.0</code> (no factor).\n@return the scaling factor\n@see #isScalingApplied()"},
    {"setScalingFactor", (PyCFunction) BeamPyBand_setScalingFactor, METH_VARARGS, "Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n@param scalingFactor the scaling factor\n@see #isScalingApplied()"},
    {"getScalingOffset", (PyCFunction) BeamPyBand_getScalingOffset, METH_VARARGS, "Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n<code>0.0</code> (no offset).\n@return the scaling offset\n@see #isScalingApplied()"},
    {"setScalingOffset", (PyCFunction) BeamPyBand_setScalingOffset, METH_VARARGS, "Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n@param scalingOffset the scaling offset\n@see #isScalingApplied()"},
    {"isLog10Scaled", (PyCFunction) BeamPyBand_isLog10Scaled, METH_VARARGS, "Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n<code>false</code>.\n@return whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"setLog10Scaled", (PyCFunction) BeamPyBand_setLog10Scaled, METH_VARARGS, "Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data.\n@param log10Scaled whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"isScalingApplied", (PyCFunction) BeamPyBand_isScalingApplied, METH_VARARGS, "Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\npixel values. The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n{@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n{@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n<code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n{@link #setPixelFloat(int, int, float)}.\n@return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n@see #getScalingOffset\n@see #getScalingFactor\n@see #isLog10Scaled"},
    {"isValidMaskProperty", (PyCFunction) BeamPyBand_isValidMaskProperty, METH_VARARGS | METH_STATIC, "Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n@param propertyName the  name to test\n@return {@code true}, if so."},
    {"isNoDataValueSet", (PyCFunction) BeamPyBand_isNoDataValueSet, METH_VARARGS, "Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n{@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n@return true, if so\n@see #isNoDataValueUsed()\n@see #setNoDataValue(double)"},
    {"clearNoDataValue", (PyCFunction) BeamPyBand_clearNoDataValue, METH_VARARGS, "Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>."},
    {"isNoDataValueUsed", (PyCFunction) BeamPyBand_isNoDataValueUsed, METH_VARARGS, "Tests whether or not the no-data value is used.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return true, if so\n@see #setNoDataValueUsed(boolean)\n@see #isNoDataValueSet()"},
    {"setNoDataValueUsed", (PyCFunction) BeamPyBand_setNoDataValueUsed, METH_VARARGS, "Sets whether or not the no-data value is used.\nIf the no-data value is enabled and the no-data value has not been set so far,\na default no-data value it is set with a value of to zero.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n@param noDataValueUsed true, if so\n@see #isNoDataValueUsed()"},
    {"getNoDataValue", (PyCFunction) BeamPyBand_getNoDataValue, METH_VARARGS, "Gets the no-data value as a primitive <code>double</code>.\nNote that the value returned is NOT necessarily the same as the value returned by\n{@link #getGeophysicalNoDataValue()} because no scaling is applied.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nThe method returns <code>0.0</code>, if no no-data value has been specified so far.\n@return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n@see #setNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"setNoDataValue", (PyCFunction) BeamPyBand_setNoDataValue, METH_VARARGS, "Sets the no-data value as a primitive <code>double</code>.\nNote that the given value is related to the \"raw\", un-scaled raster data.\nIn order to set the geophysical, scaled no-data value use the method\n{@link #setGeophysicalNoDataValue(double)}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n@see #getNoDataValue()\n@see #isNoDataValueSet()"},
    {"getGeophysicalNoDataValue", (PyCFunction) BeamPyBand_getGeophysicalNoDataValue, METH_VARARGS, "Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return the geophysical no-data value\n@see #setGeophysicalNoDataValue(double)"},
    {"setGeophysicalNoDataValue", (PyCFunction) BeamPyBand_setGeophysicalNoDataValue, METH_VARARGS, "Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n@param noDataValue the new geophysical no-data value\n@see #setGeophysicalNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"getValidPixelExpression", (PyCFunction) BeamPyBand_getValidPixelExpression, METH_VARARGS, "Gets the expression that is used to determine whether a pixel is valid or not.\nFor more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return the valid mask expression."},
    {"setValidPixelExpression", (PyCFunction) BeamPyBand_setValidPixelExpression, METH_VARARGS, "Sets the expression that is used to determine whether a pixel is valid or not.\nThe valid-pixel expression is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n@param validPixelExpression the valid mask expression, can be null"},
    {"isValidMaskUsed", (PyCFunction) BeamPyBand_isValidMaskUsed, METH_VARARGS, "Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\ntrue if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\nThe data-mask is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return true, if so"},
    {"resetValidMask", (PyCFunction) BeamPyBand_resetValidMask, METH_VARARGS, "Resets the valid mask of this raster.\nThe mask will be lazily regenerated when requested the next time."},
    {"getValidMaskExpression", (PyCFunction) BeamPyBand_getValidMaskExpression, METH_VARARGS, "Gets the expression used for the computation of the mask which identifies valid pixel values.\nIt recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n{@link #getValidPixelExpression() validPixelExpression} properties, if any.\nThe method returns {@code null},  if none of these properties are set.\n@return The expression used for the computation of the mask which identifies valid pixel values,\nor {@code null}.\n@see #getValidPixelExpression()\n@see #getNoDataValue()"},
    {"updateExpression", (PyCFunction) BeamPyBand_updateExpression, METH_VARARGS, "{@inheritDoc}"},
    {"hasRasterData", (PyCFunction) BeamPyBand_hasRasterData, METH_VARARGS, "Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\nfalse.\n@return true, if so.\n@deprecated since BEAM 4.11. No replacement."},
    {"getRasterData", (PyCFunction) BeamPyBand_getRasterData, METH_VARARGS, "Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\n<code>null</code>.\n@return the raster data for this band, or <code>null</code> if data has not been loaded\n@deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\nmethod variants to retrieve or read raster data."},
    {"setRasterData", (PyCFunction) BeamPyBand_setRasterData, METH_VARARGS, "Sets the raster data of this dataset.\n\n Note that this method does not copy data at all. If the supplied raster data is compatible with this product\nraster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\ndataset's data!\n@param rasterData the raster data for this dataset\n@see #getRasterData()\n@deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"loadRasterData", (PyCFunction) BeamPyBand_loadRasterData, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. No replacement."},
    {"isPixelValid", (PyCFunction) BeamPyBand_isPixelValid, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\n\n<i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\na synchronised block was used due to problem with the JAI ROI class that has been used in\nthe former implementation.</i>\n@param x the X co-ordinate of the pixel location\n@param y the Y co-ordinate of the pixel location\n@return <code>true</code> if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getSampleInt", (PyCFunction) BeamPyBand_getSampleInt, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n\n<i>Note: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n@param x pixel X coordinate\n@param y pixel Y coordinate\n@return The geo-physical sample value."},
    {"getSampleFloat", (PyCFunction) BeamPyBand_getSampleFloat, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n\n<i>Note: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n@param x pixel X coordinate\n@param y pixel Y coordinate\n@return The geo-physical sample value."},
    {"getPixelsInt", (PyCFunction) BeamPyBand_getPixelsInt, METH_VARARGS, "@see #getPixels(int, int, int, int, int[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixelsFloat", (PyCFunction) BeamPyBand_getPixelsFloat, METH_VARARGS, "@see #getPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixelsDouble", (PyCFunction) BeamPyBand_getPixelsDouble, METH_VARARGS, "@see #getPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixelsInt", (PyCFunction) BeamPyBand_readPixelsInt, METH_VARARGS, "@see #readPixels(int, int, int, int, int[], ProgressMonitor)"},
    {"readPixelsFloat", (PyCFunction) BeamPyBand_readPixelsFloat, METH_VARARGS, "@see #readPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixelsDouble", (PyCFunction) BeamPyBand_readPixelsDouble, METH_VARARGS, "@see #readPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writePixelsInt", (PyCFunction) BeamPyBand_writePixelsInt, METH_VARARGS, "@see #writePixels(int, int, int, int, int[], ProgressMonitor)"},
    {"writePixelsFloat", (PyCFunction) BeamPyBand_writePixelsFloat, METH_VARARGS, "@see #writePixels(int, int, int, int, float[], ProgressMonitor)"},
    {"writePixelsDouble", (PyCFunction) BeamPyBand_writePixelsDouble, METH_VARARGS, "@see #writePixels(int, int, int, int, double[], ProgressMonitor)"},
    {"readValidMask", (PyCFunction) BeamPyBand_readValidMask, METH_VARARGS, ""},
    {"writeRasterDataFully", (PyCFunction) BeamPyBand_writeRasterDataFully, METH_VARARGS, ""},
    {"writeRasterData", (PyCFunction) BeamPyBand_writeRasterData, METH_VARARGS, "@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\nreadPixels()} method variants to set or write raster data."},
    {"createCompatibleRasterData", (PyCFunction) BeamPyBand_createCompatibleRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n@return raster data compatible with this product raster\n@see #createCompatibleSceneRasterData"},
    {"createCompatibleSceneRasterData", (PyCFunction) BeamPyBand_createCompatibleSceneRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n@return raster data compatible with this product raster\n@see #createCompatibleRasterData"},
    {"createCompatibleRasterDataForRect", (PyCFunction) BeamPyBand_createCompatibleRasterDataForRect, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>width*height</code> elements of a compatible data type.\n@param width  the width of the raster data to be created\n@param height the height of the raster data to be created\n@return raster data compatible with this product raster\n@see #createCompatibleRasterData\n@see #createCompatibleSceneRasterData"},
    {"isCompatibleRasterData", (PyCFunction) BeamPyBand_isCompatibleRasterData, METH_VARARGS, "Tests whether the given parameters specify a compatible raster or not.\n@param rasterData the raster data\n@param w          the raster width\n@param h          the raster height\n@return {@code true} if so\n@deprecated since BEAM 4.11. No replacement."},
    {"checkCompatibleRasterData", (PyCFunction) BeamPyBand_checkCompatibleRasterData, METH_VARARGS, "Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n@param rasterData the raster data\n@param w          the raster width\n@param h          the raster height\n@deprecated since BEAM 4.11. No replacement."},
    {"hasIntPixels", (PyCFunction) BeamPyBand_hasIntPixels, METH_VARARGS, "Determines whether this raster data node contains integer samples.\n@return true if this raster data node contains integer samples."},
    {"createTransectProfileData", (PyCFunction) BeamPyBand_createTransectProfileData, METH_VARARGS, "Creates a transect profile for the given shape (-outline).\n@param shape the shape\n@return the profile data\n@throws IOException if an I/O error occurs"},
    {"getImageInfo", (PyCFunction) BeamPyBand_getImageInfo, METH_VARARGS, "Gets the image information for image display.\n@return the image info or null"},
    {"setImageInfo", (PyCFunction) BeamPyBand_setImageInfo, METH_VARARGS, "Sets the image information for image display.\n@param imageInfo the image info, can be null"},
    {"fireImageInfoChanged", (PyCFunction) BeamPyBand_fireImageInfoChanged, METH_VARARGS, "Notifies listeners that the image (display) information has changed."},
    {"createDefaultImageInfo", (PyCFunction) BeamPyBand_createDefaultImageInfo, METH_VARARGS, "Creates an instance of a default image information.\n\nAn <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\nthe entire area is skipped.\n@param histogram      the histogram to create the image information.\n@return a valid image information instance, never <code>null</code>."},
    {"getOverlayMaskGroup", (PyCFunction) BeamPyBand_getOverlayMaskGroup, METH_VARARGS, "@return The overlay mask group."},
    {"createColorIndexedImage", (PyCFunction) BeamPyBand_createColorIndexedImage, METH_VARARGS, "Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\nnull)</code>.\n@param pm a monitor to inform the user about progress\n@return a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createRgbImage", (PyCFunction) BeamPyBand_createRgbImage, METH_VARARGS, "Creates an RGB image for this raster data node.\n@param pm a monitor to inform the user about progress\n@return a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createPixelValidator", (PyCFunction) BeamPyBand_createPixelValidator, METH_VARARGS, "Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n@param lineOffset the absolute line offset, zero based\n@param roi        an optional ROI\n@return a new validator instance, never null\n@throws IOException if an I/O error occurs"},
    {"scale", (PyCFunction) BeamPyBand_scale, METH_VARARGS, "Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n<code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\nscaling.\n@param v the input value\n@return the scaled value"},
    {"scaleInverse", (PyCFunction) BeamPyBand_scaleInverse, METH_VARARGS, "Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n<code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\nscaling.\n@param v the input value\n@return the scaled value"},
    {"getPixelString", (PyCFunction) BeamPyBand_getPixelString, METH_VARARGS, "Returns the pixel located at (x,y) as a string value.\n@param x the X co-ordinate of the pixel location\n@param y the Y co-ordinate of the pixel location\n@return the pixel value at (x,y) as string or an error message text"},
    {"isSourceImageSet", (PyCFunction) BeamPyBand_isSourceImageSet, METH_VARARGS, "Returns whether the source image is set on this {@code RasterDataNode}.\n@return whether the source image is set.\n@see #getSourceImage()\n@see #setSourceImage(java.awt.image.RenderedImage)\n@see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n@see #createSourceImage()"},
    {"getSourceImage", (PyCFunction) BeamPyBand_getSourceImage, METH_VARARGS, "Gets the source image associated with this {@code RasterDataNode}.\n@return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\nthe method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n@see #createSourceImage()\n@see #isSourceImageSet()"},
    {"isGeophysicalImageSet", (PyCFunction) BeamPyBand_isGeophysicalImageSet, METH_VARARGS, "Returns whether the geophysical image is set on this {@code RasterDataNode}.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\n@return whether the geophysical image is set."},
    {"getGeophysicalImage", (PyCFunction) BeamPyBand_getGeophysicalImage, METH_VARARGS, "@return The geophysical source image."},
    {"isValidMaskImageSet", (PyCFunction) BeamPyBand_isValidMaskImageSet, METH_VARARGS, "Returns wether the valid mask image is set on this {@code RasterDataNode}.\n@return Wether the source image is set."},
    {"getValidMaskImage", (PyCFunction) BeamPyBand_getValidMaskImage, METH_VARARGS, "Gets the valid-mask image associated with this {@code RasterDataNode}.\n@return The rendered image."},
    {"isStxSet", (PyCFunction) BeamPyBand_isStxSet, METH_VARARGS, ""},
    {"getStx", (PyCFunction) BeamPyBand_getStx, METH_VARARGS, "Gets the statistics. If statistcs are not yet available,\nthe method will compute (possibly inaccurate) statistics and return those.\n\nIf accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\nshall be used instead.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\n@return The statistics.\n@see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n@see #setStx(Stx)"},
    {"setStx", (PyCFunction) BeamPyBand_setStx, METH_VARARGS, "Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\nare really related to this {@code RasterDataNode}'s raster data.\nThe method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\nThis method belongs to preliminary API and may be removed or changed in the future.\n@param stx The statistics."},
    {"getValidShape", (PyCFunction) BeamPyBand_getValidShape, METH_VARARGS, "Gets the shape of the area where this raster data contains valid samples.\nThe method returns <code>null</code>, if the entire raster contains valid samples.\n@return The shape of the area where the raster data has samples, can be {@code null}."},
    {"getRoiMaskGroup", (PyCFunction) BeamPyBand_getRoiMaskGroup, METH_VARARGS, "@return The roi mask group.\n@deprecated since BEAM 4.10 (no replacement)"},
    {"getDataType", (PyCFunction) BeamPyBand_getDataType, METH_VARARGS, "Gets the data type of this data node.\n@return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants"},
    {"getNumDataElems", (PyCFunction) BeamPyBand_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyBand_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyBand_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyBand_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyBand_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyBand_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyBand_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyBand_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyBand_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyBand_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyBand_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyBand_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyBand_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"createCompatibleProductData", (PyCFunction) BeamPyBand_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>numElems</code> elements of a compatible data type.\n@param numElems the number of elements, must not be less than one\n@return product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyBand_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyBand_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyBand_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyBand_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyBand_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyBand_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"isValidNodeName", (PyCFunction) BeamPyBand_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyBand_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyBand_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyBand_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyBand_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyBand_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"getExtension", (PyCFunction) BeamPyBand_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Band_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Band",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A band contains the data for geophysical parameter in remote sensing data products. Bands are two-dimensional images\nwhich hold their pixel values (samples) in a buffer of the type {@link ProductData}. The band class is just a\ncontainer for attached metadata of the band, currently: <ul> <li>the flag coding {@link FlagCoding}</li> <li>the band\nindex at which position the band is stored in the associated product</li> <li>the center wavelength of the band</li>\n<li>the bandwidth of the band</li> <li>the solar spectral flux of the band</li> <li>the width and height of the\nband</li> </ul> The band can contain a buffer to the real data, but this buffer must be read explicitely, to keep the\nmemory fingerprint small, the data is not read automatically.\n\n\nThe several <code>getPixel</code> and <code>readPixel</code> methods of this class do not necessarily return the\nvalues contained in the data buffer of type {@link ProductData}. If the <code>scalingFactor</code>,\n<code>scalingOffset</code> or <code>log10Scaled</code> are set a conversion of the form <code>scalingFactor *\nrawSample + scalingOffset</code> is applied to the raw samples before the <code>getPixel</code> and @\n<code>readPixel</code> methods return the actual pixel values. If the <code>log10Scaled</code> property is true then\nthe conversion is <code>pow(10, scalingFactor * rawSample + scalingOffset)</code>. The several <code>setPixel</code>\nand <code>writePixel</code> perform the inverse operations in this case.\n@see ProductData",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Band_Methods,         /* tp_methods */
    Band_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ColorPaletteDef_Point_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ColorPaletteDef_Point_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ColorPaletteDef_Point_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ColorPaletteDef_Point",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ColorPaletteDef_Point_Methods,         /* tp_methods */
    ColorPaletteDef_Point_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef RenderedImage_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef RenderedImage_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderedImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RenderedImage",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderedImage_Methods,         /* tp_methods */
    RenderedImage_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Placemark_Members[] = {
//     {"PLACEMARK_FEATURE_TYPE_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_LABEL", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_TEXT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_PIXELPOS", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_GEOPOS", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DATETIME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_STYLE_CSS", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Placemark_Methods[] = 
{
    {"newPlacemark", (PyCFunction) BeamPyPlacemark_newPlacemark, METH_VARARGS | METH_STATIC, "Constructor.\n@param descriptor The placemark descriptor that created this placemark.\n@param feature    The wrapped feature."},
    {"createPointPlacemark", (PyCFunction) BeamPyPlacemark_createPointPlacemark, METH_VARARGS | METH_STATIC, "Creates a point placemark.\n@param descriptor The placemark descriptor that created this placemark.\n@param name       The placemark's name.\n@param label      The placemark's label. May be {@code null}.\n@param text       The placemark's (XHTML) text. May be {@code null}.\n@param pixelPos   The placemark's pixel position. May be {@code null}, if {@code geoPos} is given.\n@param geoPos     The placemark's pixel position. May be {@code null}, if {@code pixelPos} is given.\n@param geoCoding  The placemark's geo-coding. Used to compute {@code pixelPos} from {@code geoPos}, if {@code pixelPos} is {@code null}.\n@return A new point placemark."},
    {"getDescriptor", (PyCFunction) BeamPyPlacemark_getDescriptor, METH_VARARGS, "@return The placemark descriptor that created this placemark."},
    {"getFeature", (PyCFunction) BeamPyPlacemark_getFeature, METH_VARARGS, "@return The wrapped {@link SimpleFeature} underlying this placemark."},
    {"getAttributeValue", (PyCFunction) BeamPyPlacemark_getAttributeValue, METH_VARARGS, "Gets the attribute value of the underlying feature.\n@param attributeName The feature's attribute name.\n@return The feature's attribute value, may be {@code null}."},
    {"setAttributeValue", (PyCFunction) BeamPyPlacemark_setAttributeValue, METH_VARARGS, "Sets the attribute value of the underlying feature.\n@param attributeName  The feature's attribute name.\n@param attributeValue The feature's attribute value, may be {@code null}."},
    {"setLabel", (PyCFunction) BeamPyPlacemark_setLabel, METH_VARARGS, "Sets this placemark's label.\n@param label the label, if {@code null} an empty label is set."},
    {"getLabel", (PyCFunction) BeamPyPlacemark_getLabel, METH_VARARGS, "@return This placemark's label, cannot be {@code null}."},
    {"setText", (PyCFunction) BeamPyPlacemark_setText, METH_VARARGS, "Sets this placemark's (XHTML) text.\n@param text The text, if {@code null} an empty text is set."},
    {"getText", (PyCFunction) BeamPyPlacemark_getText, METH_VARARGS, "@return This placemark's (XHTML) text, cannot be {@code null}."},
    {"setStyleCss", (PyCFunction) BeamPyPlacemark_setStyleCss, METH_VARARGS, "Sets this placemark's CSS style.\n@param styleCss The text, if {@code null} an empty text is set."},
    {"getStyleCss", (PyCFunction) BeamPyPlacemark_getStyleCss, METH_VARARGS, "@return This placemark's CSS style, cannot be {@code null}."},
    {"acceptVisitor", (PyCFunction) BeamPyPlacemark_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n@param visitor the visitor"},
    {"getPixelPos", (PyCFunction) BeamPyPlacemark_getPixelPos, METH_VARARGS, ""},
    {"setPixelPos", (PyCFunction) BeamPyPlacemark_setPixelPos, METH_VARARGS, ""},
    {"getGeoPos", (PyCFunction) BeamPyPlacemark_getGeoPos, METH_VARARGS, ""},
    {"setGeoPos", (PyCFunction) BeamPyPlacemark_setGeoPos, METH_VARARGS, ""},
    {"updatePositions", (PyCFunction) BeamPyPlacemark_updatePositions, METH_VARARGS, "Updates pixel and geo position according to the current geometry (model coordinates)."},
    {"createPinFeatureType", (PyCFunction) BeamPyPlacemark_createPinFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createGcpFeatureType", (PyCFunction) BeamPyPlacemark_createGcpFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createGeometryFeatureType", (PyCFunction) BeamPyPlacemark_createGeometryFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createPointFeatureType", (PyCFunction) BeamPyPlacemark_createPointFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"getOwner", (PyCFunction) BeamPyPlacemark_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyPlacemark_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyPlacemark_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyPlacemark_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyPlacemark_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyPlacemark_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"setModified", (PyCFunction) BeamPyPlacemark_setModified, METH_VARARGS, "Sets this node's modified flag.\n\nIf the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\ntrue.\n@param modified whether or not this node is beeing marked as modified.\n@see Product#fireNodeChanged"},
    {"toString", (PyCFunction) BeamPyPlacemark_toString, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyPlacemark_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"isValidNodeName", (PyCFunction) BeamPyPlacemark_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyPlacemark_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyPlacemark_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyPlacemark_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyPlacemark_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyPlacemark_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyPlacemark_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyPlacemark_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyPlacemark_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Placemark_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Placemark",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Placemarks are displayed as symbols at the image's pixel position corresponding to their geographical position. The name is\ndisplayed as label next to the symbol. If the user moves the mouse over a placemark, the textual description property shall\nappear as tool-tip text. Single placemarks can be selected either by mouse-click or by the ? Prev./Next Placemark tool.\nPlacemarks are contained in the active product and stored in CSV format. To share placemarks between products,\nthe placemarks of a product can be imported and exported.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Placemark_Methods,         /* tp_methods */
    Placemark_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef IndexValidator_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef IndexValidator_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexValidator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "IndexValidator",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "An interface used as parameter to several methods which perform some actions on data arrays.\nIt is used to decide whether or not an array value shall be taken into account for a particular\ncomputation.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexValidator_Methods,         /* tp_methods */
    IndexValidator_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Area_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Area_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Area_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Area",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Area_Methods,         /* tp_methods */
    Area_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ComponentColorModel_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ComponentColorModel_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ComponentColorModel_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ComponentColorModel",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ComponentColorModel_Methods,         /* tp_methods */
    ComponentColorModel_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Iterator_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Iterator_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Iterator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Iterator",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Iterator_Methods,         /* tp_methods */
    Iterator_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MathTransform_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MathTransform_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MathTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MathTransform",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MathTransform_Methods,         /* tp_methods */
    MathTransform_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef CoordinateReferenceSystem_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef CoordinateReferenceSystem_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject CoordinateReferenceSystem_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "CoordinateReferenceSystem",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    CoordinateReferenceSystem_Methods,         /* tp_methods */
    CoordinateReferenceSystem_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductWriterPlugIn_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductWriterPlugIn_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductWriterPlugIn_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductWriterPlugIn",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductWriterPlugIn</code> interface is implemented by data product writer plug-ins.\n\nXMLCoder plug-ins are used to provide meta-information about a particular data format and to create instances of\nthe actual writer objects.\n\n A plug-in can register itself in the <code>ProductIO</code> plug-in registry or it is automatically found during\na classpath scan.\n@see ProductReaderPlugIn",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductWriterPlugIn_Methods,         /* tp_methods */
    ProductWriterPlugIn_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef File_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef File_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject File_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "File",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    File_Methods,         /* tp_methods */
    File_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef GeoPos_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef GeoPos_Methods[] = 
{
    {"newGeoPos", (PyCFunction) BeamPyGeoPos_newGeoPos, METH_VARARGS | METH_STATIC, "Constructs a new geo-position with the given latitude and longitude values.\n@param lat the geographical latitude in decimal degree, valid range is -90 to +90\n@param lon the geographical longitude in decimal degree, valid range is -180 to +180"},
    {"getLat", (PyCFunction) BeamPyGeoPos_getLat, METH_VARARGS, "Gets the latitude value.\n@return the geographical latitude in decimal degree"},
    {"getLon", (PyCFunction) BeamPyGeoPos_getLon, METH_VARARGS, "Gets the longitude value.\n@return the geographical longitude in decimal degree"},
    {"setLocation", (PyCFunction) BeamPyGeoPos_setLocation, METH_VARARGS, "Sets the geographical location of this point.\n@param lat the geographical latitude in decimal degree, valid range is -90 to +90\n@param lon the geographical longitude in decimal degree, valid range is -180 to +180"},
    {"isValid", (PyCFunction) BeamPyGeoPos_isValid, METH_VARARGS, "Tests whether or not this geo-position is valid.\n@return true, if so"},
    {"areValid", (PyCFunction) BeamPyGeoPos_areValid, METH_VARARGS | METH_STATIC, "Tests whether or not all given geo-positions are valid.\n@return true, if so"},
    {"setInvalid", (PyCFunction) BeamPyGeoPos_setInvalid, METH_VARARGS, "Sets the lat/lon fields so that {@link #isValid()} will return false."},
    {"equals", (PyCFunction) BeamPyGeoPos_equals, METH_VARARGS, "Indicates whether some other object is \"equal to\" this one.\n@param obj the reference object with which to compare.\n@return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise."},
    {"hashCode", (PyCFunction) BeamPyGeoPos_hashCode, METH_VARARGS, "Returns a hash code value for the object.\n@return a hash code value for this object."},
    {"toString", (PyCFunction) BeamPyGeoPos_toString, METH_VARARGS, "Returns a string representation of the object. In general, the <code>toString</code> method returns a string that\n\"textually represents\" this object.\n@return a string representation of the object."},
    {"normalize", (PyCFunction) BeamPyGeoPos_normalize, METH_VARARGS, "Normalizes this position so that its longitude is in the range -180 to +180 degree."},
    {"normalizeLon", (PyCFunction) BeamPyGeoPos_normalizeLon, METH_VARARGS | METH_STATIC, "Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.\nNote that -180 will remain as is, although -180 is equivalent to +180 degrees.\n@param lon the longitude in degree\n@return the normalized longitude in the range"},
    {"getLatString", (PyCFunction) BeamPyGeoPos_getLatString, METH_VARARGS, "Returns a string representation of the latitude value.\n@return a string of the form DDD°[MM'[SS\"]] [N|S]."},
    {"getLonString", (PyCFunction) BeamPyGeoPos_getLonString, METH_VARARGS, "Returns a string representation of the latitude value.\n@return a string of the form DDD°[MM'[SS\"]] [W|E]."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoPos_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "GeoPos",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>GeoPos</code> class represents a geographical position measured in longitudes and latitudes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoPos_Methods,         /* tp_methods */
    GeoPos_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductNodeGroup_Members[] = {
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductNodeGroup_Methods[] = 
{
    {"newProductNodeGroup", (PyCFunction) BeamPyProductNodeGroup_newProductNodeGroup, METH_VARARGS | METH_STATIC, "Constructs a node group with no owner and which will not take ownership of added children.\n@param name The group name."},
    {"isTakingOverNodeOwnership", (PyCFunction) BeamPyProductNodeGroup_isTakingOverNodeOwnership, METH_VARARGS, "@return {@code true}, if child nodes will have this group as owner after adding."},
    {"getNodeCount", (PyCFunction) BeamPyProductNodeGroup_getNodeCount, METH_VARARGS, "@return The number of product nodes in this product group."},
    {"getAt", (PyCFunction) BeamPyProductNodeGroup_getAt, METH_VARARGS, "@param index The node index.\n@return The product node at the given index."},
    {"getNodeDisplayNames", (PyCFunction) BeamPyProductNodeGroup_getNodeDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\n@return an array containing the display names, never <code>null</code>, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getNodeNames", (PyCFunction) BeamPyProductNodeGroup_getNodeNames, METH_VARARGS, "Returns the names of all products currently managed.\n@return an array containing the names, never <code>null</code>, but the array can have zero length"},
    {"indexOfName", (PyCFunction) BeamPyProductNodeGroup_indexOfName, METH_VARARGS, ""},
    {"indexOf", (PyCFunction) BeamPyProductNodeGroup_indexOf, METH_VARARGS, ""},
    {"getByDisplayName", (PyCFunction) BeamPyProductNodeGroup_getByDisplayName, METH_VARARGS, "@param displayName the display name\n@return the product node with the given display name."},
    {"get", (PyCFunction) BeamPyProductNodeGroup_get, METH_VARARGS, "@param name the name\n@return the product node with the given name."},
    {"containsName", (PyCFunction) BeamPyProductNodeGroup_containsName, METH_VARARGS, "Tests whether a node with the given name is contained in this group.\n@param name the name\n@return true, if so"},
    {"contains", (PyCFunction) BeamPyProductNodeGroup_contains, METH_VARARGS, "Tests whether the given product is contained in this list.\n@param node the node\n@return true, if so"},
    {"add", (PyCFunction) BeamPyProductNodeGroup_add, METH_VARARGS, "Adds the given node to this group.\n@param node the node to be added, ignored if <code>null</code>\n@return true, if the node has been added"},
    {"addAt", (PyCFunction) BeamPyProductNodeGroup_addAt, METH_VARARGS, "Adds the given node to this group.\n@param index the index.\n@param node  the node to be added, ignored if <code>null</code>"},
    {"remove", (PyCFunction) BeamPyProductNodeGroup_remove, METH_VARARGS, "Removes the given node from this group.\n@param node the node to be removed\n@return true, if the node was removed"},
    {"removeAll", (PyCFunction) BeamPyProductNodeGroup_removeAll, METH_VARARGS, "Removes all nodes from this group."},
    {"clearRemovedList", (PyCFunction) BeamPyProductNodeGroup_clearRemovedList, METH_VARARGS, ""},
    {"getRemovedNodes", (PyCFunction) BeamPyProductNodeGroup_getRemovedNodes, METH_VARARGS, "Gets all removed node nodes.\n@return a collection of all removed node nodes."},
    {"setModified", (PyCFunction) BeamPyProductNodeGroup_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyProductNodeGroup_acceptVisitor, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyProductNodeGroup_dispose, METH_VARARGS, ""},
    {"updateExpression", (PyCFunction) BeamPyProductNodeGroup_updateExpression, METH_VARARGS, ""},
    {"getOwner", (PyCFunction) BeamPyProductNodeGroup_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyProductNodeGroup_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyProductNodeGroup_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyProductNodeGroup_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyProductNodeGroup_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyProductNodeGroup_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyProductNodeGroup_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyProductNodeGroup_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyProductNodeGroup_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyProductNodeGroup_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyProductNodeGroup_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyProductNodeGroup_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyProductNodeGroup_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"removeFromFile", (PyCFunction) BeamPyProductNodeGroup_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyProductNodeGroup_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNodeGroup_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductNodeGroup",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A type-safe container for elements of the type <code>ProductNode</code>.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNodeGroup_Methods,         /* tp_methods */
    ProductNodeGroup_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MapProjection_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MapProjection_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapProjection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MapProjection",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A map projection is a mathematical model for the transformation of locations from a three-dimensional earth surface\nto a two-dimensional map representation.\n\n@deprecated since BEAM 4.7, use geotools {@link org.geotools.referencing.operation.projection.MapProjection} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapProjection_Methods,         /* tp_methods */
    MapProjection_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductManager_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductManager_Methods[] = 
{
    {"newProductManager", (PyCFunction) BeamPyProductManager_newProductManager, METH_VARARGS | METH_STATIC, "Constructs an product manager with an empty list of products."},
    {"getProductCount", (PyCFunction) BeamPyProductManager_getProductCount, METH_VARARGS, "@return The number of products in this product manager."},
    {"getProduct", (PyCFunction) BeamPyProductManager_getProduct, METH_VARARGS, "Gets the product at the given index.\n@param index the index\n@return The product at the given index."},
    {"getProductDisplayNames", (PyCFunction) BeamPyProductManager_getProductDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\n@return an array containing the display names, never <code>null</code>, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getProductNames", (PyCFunction) BeamPyProductManager_getProductNames, METH_VARARGS, "Returns the names of all products currently managed.\n@return an array containing the names, never <code>null</code>, but the array can have zero length"},
    {"getProducts", (PyCFunction) BeamPyProductManager_getProducts, METH_VARARGS, "Returns an array of all products currently managed.\n@return an array containing the products, never <code>null</code>, but the array can have zero length"},
    {"getProductByDisplayName", (PyCFunction) BeamPyProductManager_getProductByDisplayName, METH_VARARGS, "@param displayName The product's display name.\n@return The product with the given display name."},
    {"getProductByRefNo", (PyCFunction) BeamPyProductManager_getProductByRefNo, METH_VARARGS, "@param refNo The reference number.\n@return The product with the given reference number."},
    {"getProductByName", (PyCFunction) BeamPyProductManager_getProductByName, METH_VARARGS, "@param name The product name.\n@return The product with the given name."},
    {"getProductIndex", (PyCFunction) BeamPyProductManager_getProductIndex, METH_VARARGS, ""},
    {"containsProduct", (PyCFunction) BeamPyProductManager_containsProduct, METH_VARARGS, "Tests whether a product with the given name is contained in this list.\n@param name the product name\n@return true, if so"},
    {"contains", (PyCFunction) BeamPyProductManager_contains, METH_VARARGS, "Tests whether the given product is contained in this list.\n@param product The product.\n@return {@code true} if so."},
    {"addProduct", (PyCFunction) BeamPyProductManager_addProduct, METH_VARARGS, "Adds the given product to this product manager if it does not already exists and sets it's reference number one\nbiger than the greatest reference number in this product manager.\n@param product the product to be added, ignored if <code>null</code>"},
    {"removeProduct", (PyCFunction) BeamPyProductManager_removeProduct, METH_VARARGS, "Removes the given product from this product manager if it exists.\n@param product the product to be removed, ignored if <code>null</code>\n@return true, if the product was removed"},
    {"removeAllProducts", (PyCFunction) BeamPyProductManager_removeAllProducts, METH_VARARGS, "Removes all product from this list."},
    {"addListener", (PyCFunction) BeamPyProductManager_addListener, METH_VARARGS, "Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is\ninformed each time a product was added or removed.\n@param listener the listener to be added.\n@return true if the listener was added, otherwise false."},
    {"removeListener", (PyCFunction) BeamPyProductManager_removeListener, METH_VARARGS, "Removes a <code>ProductManagerListener</code> from this product manager.\n@param listener The listener.\n@return true, if the listener was removed, otherwise false."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductManager_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductManager",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A type-safe container for elements of the type <code>Product</code>. ProductListeners can be added to inform if a\n<code>Product</code> was added or removed.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductManager_Methods,         /* tp_methods */
    ProductManager_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef FlagCoding_Members[] = {
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef FlagCoding_Methods[] = 
{
    {"newFlagCoding", (PyCFunction) BeamPyFlagCoding_newFlagCoding, METH_VARARGS | METH_STATIC, "Constructs a new flag coding object with the given name.\n@param name the name"},
    {"getFlag", (PyCFunction) BeamPyFlagCoding_getFlag, METH_VARARGS, "Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to\ngetPropertyValue(String).\n@param name the flag name\n@return a metadata attribute wich is the representation of the flag with the given name"},
    {"getFlagNames", (PyCFunction) BeamPyFlagCoding_getFlagNames, METH_VARARGS, "Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.\n@return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n<code>FlagCoding</code> does not contain any flag, <code>null</code> is returned"},
    {"addFlag", (PyCFunction) BeamPyFlagCoding_addFlag, METH_VARARGS, "Adds a new flag definition to this flags coding.\n@param name        the flag name\n@param flagMask    the flag's bit mask\n@param description the description text\n@throws IllegalArgumentException if <code>name</code> is null\n@return A new attribute representing the flag."},
    {"getFlagMask", (PyCFunction) BeamPyFlagCoding_getFlagMask, METH_VARARGS, "Returns the flag mask value for the specified flag name.\n@param name the flag name\n@return flagMask the flag's bit mask as a 32 bit integer\n@throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist"},
    {"acceptVisitor", (PyCFunction) BeamPyFlagCoding_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls <code>visitor.visit(this)</code>.\n@param visitor the visitor, must not be <code>null</code>"},
    {"addElement", (PyCFunction) BeamPyFlagCoding_addElement, METH_VARARGS, "Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\nbecause flag codings do not support inner elements.\n@param element the element to be added, always ignored"},
    {"addAttribute", (PyCFunction) BeamPyFlagCoding_addAttribute, METH_VARARGS, "Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n@param attribute the attribute to be added\n@throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value"},
    {"addSample", (PyCFunction) BeamPyFlagCoding_addSample, METH_VARARGS, "Adds a new coding value to this sample coding.\n@param name        the coding name\n@param value       the value\n@param description the description text\n@throws IllegalArgumentException if <code>name</code> is null\n@return A new attribute representing the coded sample."},
    {"getSampleCount", (PyCFunction) BeamPyFlagCoding_getSampleCount, METH_VARARGS, "Gets the number of coded sample values.\n@return the number of coded sample values"},
    {"getSampleName", (PyCFunction) BeamPyFlagCoding_getSampleName, METH_VARARGS, "Gets the sample name at the specified attribute index.\n@param index the attribute index.\n@return the sample name."},
    {"getSampleValue", (PyCFunction) BeamPyFlagCoding_getSampleValue, METH_VARARGS, "Gets the sample value at the specified attribute index.\n@param index the attribute index.\n@return the sample value."},
    {"getElementGroup", (PyCFunction) BeamPyFlagCoding_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\n@return The child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyFlagCoding_getParentElement, METH_VARARGS, ""},
    {"addElementAt", (PyCFunction) BeamPyFlagCoding_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\n@param element the element to added, ignored if <code>null</code>\n@param index   where to put it"},
    {"removeElement", (PyCFunction) BeamPyFlagCoding_removeElement, METH_VARARGS, "Removes the given element from this element.\n@param element the element to be removed, ignored if <code>null</code>\n@return true, if so"},
    {"getNumElements", (PyCFunction) BeamPyFlagCoding_getNumElements, METH_VARARGS, "@return the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyFlagCoding_getElementAt, METH_VARARGS, "Returns the element at the given index.\n@param index the element index\n@return the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyFlagCoding_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\n@return a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyFlagCoding_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\n@return an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyFlagCoding_getElement, METH_VARARGS, "Returns the element with the given name.\n@param name the element name\n@return the element with the given name or <code>null</code> if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyFlagCoding_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyFlagCoding_getElementIndex, METH_VARARGS, "Gets the index of the given element.\n@param element The element .\n@return The element's index, or -1."},
    {"removeAttribute", (PyCFunction) BeamPyFlagCoding_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n@return <code>true</code> if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyFlagCoding_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\n@return the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyFlagCoding_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\n@param index the attribute index\n@return the attribute, or <code>null</code> if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyFlagCoding_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\n@return the attribute name array, never <code>null</code>"},
    {"getAttributes", (PyCFunction) BeamPyFlagCoding_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\n@return an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyFlagCoding_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\n@param name the attribute name\n@return the attribute with the given name or <code>null</code> if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyFlagCoding_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\n@param name the attribute name\n@return <code>true</code> if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyFlagCoding_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\n@param attribute The attribute.\n@return The attribute's index, or -1."},
    {"getAttributeDouble", (PyCFunction) BeamPyFlagCoding_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC", (PyCFunction) BeamPyFlagCoding_getAttributeUTC, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as UTC."},
    {"getAttributeInt", (PyCFunction) BeamPyFlagCoding_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyFlagCoding_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\n<code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyFlagCoding_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\n<code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyFlagCoding_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\n<code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"getAttributeString", (PyCFunction) BeamPyFlagCoding_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyFlagCoding_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\n<code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setModified", (PyCFunction) BeamPyFlagCoding_setModified, METH_VARARGS, ""},
    {"createDeepClone", (PyCFunction) BeamPyFlagCoding_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyFlagCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyFlagCoding_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyFlagCoding_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyFlagCoding_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyFlagCoding_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyFlagCoding_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyFlagCoding_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyFlagCoding_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyFlagCoding_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyFlagCoding_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyFlagCoding_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyFlagCoding_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyFlagCoding_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyFlagCoding_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyFlagCoding_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyFlagCoding_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyFlagCoding_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject FlagCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "FlagCoding",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nare combined of single flags (bit indexes).",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    FlagCoding_Methods,         /* tp_methods */
    FlagCoding_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef IndexColorModel_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef IndexColorModel_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexColorModel_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "IndexColorModel",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexColorModel_Methods,         /* tp_methods */
    IndexColorModel_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Operator_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Operator_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Operator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Operator",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract base class for all operators intended to be extended by clients.\nThe following methods are intended to be implemented or overridden:\n<ld>\n<li>{@link #initialize()}: must be implemented in order to initialise the operator and create the target\nproduct.</li>\n<li>{@link #computeTile(Band, Tile, com.bc.ceres.core.ProgressMonitor) computeTile()}: implemented to compute the tile\nfor a single band.</li>\n<li>{@link #computeTileStack(java.util.Map, java.awt.Rectangle, com.bc.ceres.core.ProgressMonitor)}: implemented to compute the tiles\nfor multiple bands.</li>\n<li>{@link #dispose()}: can be overridden in order to free all resources previously allocated by the operator.</li>\n</ld>\n\nGenerally, only one {@code computeTile} method needs to be implemented. It depends on the type of algorithm which\nof both operations is most advantageous to implement:\n<ol>\n<li>If bands can be computed independently of each other, then it is\nbeneficial to implement the {@code computeTile()} method. This is the case for sub-sampling, map-projections,\nband arithmetic, band filtering and statistic analyses.</li>\n<li>{@code computeTileStack()} should be overridden in cases where the bands of a product cannot be computed independently, e.g.\nbecause they are a simultaneous output. This is often the case for algorithms based on neural network, cluster analyses,\nmodel inversion methods or spectral unmixing.</li>\n</ol>\n\nThe framework execute either the {@code computeTile()} or the {@code computeTileStack()} method\nbased on the current use case or request.\nIf tiles for single bands are requested, e.g. for image display, it will always prefer an implementation of\nthe {@code computeTile()} method and call it.\nIf all tiles are requested at once, e.g. writing a product to disk, it will attempt to use the {@code computeTileStack()}\nmethod. If the framework cannot use its preferred operation, it will use the one implemented by the operator.\n\ntodo - Explain the role of operator annotations (nf - 15.10.2007)\ntodo - Explain the role of the SPI (nf - 15.10.2007)\n@see OperatorSpi\n@see annotations.OperatorMetadata\n@see annotations.Parameter\n@see annotations.TargetProduct\n@see annotations.TargetProperty\n@see annotations.SourceProduct\n@see annotations.SourceProducts",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Operator_Methods,         /* tp_methods */
    Operator_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef OperatorSpiRegistry_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef OperatorSpiRegistry_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject OperatorSpiRegistry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "OperatorSpiRegistry",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A registry for operator SPI instances.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    OperatorSpiRegistry_Methods,         /* tp_methods */
    OperatorSpiRegistry_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ImageInfo_HistogramMatching_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ImageInfo_HistogramMatching_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInfo_HistogramMatching_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ImageInfo_HistogramMatching",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Enumerates the possible histogram matching modes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInfo_HistogramMatching_Methods,         /* tp_methods */
    ImageInfo_HistogramMatching_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef BitmaskDef_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef BitmaskDef_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BitmaskDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "BitmaskDef",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Represents a bitmask definition comprising the bitmask properties name, description, flag expression color and\ntransparancy.\n@deprecated since BEAM 4.7, use {@code Mask} with {@code Mask.BandMathType} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BitmaskDef_Methods,         /* tp_methods */
    BitmaskDef_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductNodeListener_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductNodeListener_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNodeListener_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductNodeListener",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A listener which listens to internal data product changes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNodeListener_Methods,         /* tp_methods */
    ProductNodeListener_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductUtils_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductUtils_Methods[] = 
{
    {"newProductUtils", (PyCFunction) BeamPyProductUtils_newProductUtils, METH_VARARGS | METH_STATIC, ""},
    {"createImageInfo", (PyCFunction) BeamPyProductUtils_createImageInfo, METH_VARARGS | METH_STATIC, "Creates image creation information.\n@param rasters                 The raster data nodes.\n@param assignMissingImageInfos if {@code true}, it is ensured that to all {@code RasterDataNode}s a valid {@code ImageInfo} will be assigned.\n@param pm                      The progress monitor.\n@return image information\n@throws IOException if an I/O error occurs"},
    {"createRgbImage", (PyCFunction) BeamPyProductUtils_createRgbImage, METH_VARARGS | METH_STATIC, "Creates a RGB image from the given array of <code>{@link RasterDataNode}</code>s.\nThe given array <code>rasters</code> containing one or three raster data nodes. If three rasters are given\nRGB image is created, if only one raster is provided a gray scale image created.\n@param rasters   an array of one or three raster nodes.\n@param imageInfo the image info provides the information how to create the image\n@param pm        a monitor to inform the user about progress\n@return the created image\n@throws IOException if the given raster data is not loaded and reload causes an I/O error\n@see RasterDataNode#setImageInfo(ImageInfo)"},
    {"createColorIndexedImage", (PyCFunction) BeamPyProductUtils_createColorIndexedImage, METH_VARARGS | METH_STATIC, "Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.\n\nThe method uses the given raster data node's image information (an instance of <code>{@link\nImageInfo}</code>) to create the image.\n@param rasterDataNode the raster data node, must not be <code>null</code>\n@param pm             a monitor to inform the user about progress\n@return the color indexed image\n@throws IOException if the given raster data is not loaded and reload causes an I/O error\n@see RasterDataNode#getImageInfo()"},
    {"createSuitableMapInfo1", (PyCFunction) BeamPyProductUtils_createSuitableMapInfo1, METH_VARARGS | METH_STATIC, "Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\nsubset of the product's scene region for the given map projection. The position of the reference pixel will be\nthe upper left pixel's center (0.5, 0.5).\n@param product       the product, must not be <code>null</code>\n@param rect          the rectangle in pixel coordinates of the product, if <code>null</code> the entire region is\nconsidered\n@param mapProjection the map projection, must not be <code>null</code>\n@return the map information instance"},
    {"createSuitableMapInfo2", (PyCFunction) BeamPyProductUtils_createSuitableMapInfo2, METH_VARARGS | METH_STATIC, "Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\nsubset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.\n@param product       the product, must not be <code>null</code>\n@param mapProjection the map projection, must not be <code>null</code>\n@param orientation   the orientation angle\n@param noDataValue   the no-data value to be used\n@return the map information instance"},
    {"getOutputRasterSize", (PyCFunction) BeamPyProductUtils_getOutputRasterSize, METH_VARARGS | METH_STATIC, ""},
    {"createMapEnvelope2", (PyCFunction) BeamPyProductUtils_createMapEnvelope2, METH_VARARGS | METH_STATIC, "Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)\nand the given map transfromation. The method delegates to {@link #createMapEnvelope(Product,\njava.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,\nstep, mapTransform)} where <code>step</code> is the half of the minimum of the product scene raster width and\nheight.\n@param product      The product.\n@param rect         The rectangle in pixel coordinates.\n@param mapTransform The map transformation.\n@return The boundary in map coordinates for the given product."},
    {"createMapEnvelope1", (PyCFunction) BeamPyProductUtils_createMapEnvelope1, METH_VARARGS | METH_STATIC, "Creates the boundary in map coordinates for the given product, source rectangle (in product\npixel coordinates) and the given map transfromation. The method delegates to\n{@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,\nstep, mapTransform)} where <code>step</code> is the half of the minimum of the product scene\nraster width and height.\n@param product      The product.\n@param rect         The rectangle in pixel coordinates.\n@param step         The step size in pixels.\n@param mapTransform The map transformation.\n@return The boundary in map coordinates for the given product."},
    {"getMinMax", (PyCFunction) BeamPyProductUtils_getMinMax, METH_VARARGS | METH_STATIC, ""},
    {"createMapBoundary", (PyCFunction) BeamPyProductUtils_createMapBoundary, METH_VARARGS | METH_STATIC, ""},
    {"createGeoBoundary1", (PyCFunction) BeamPyProductUtils_createGeoBoundary1, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.\n@param product the input product, must not be null\n@param step    the step given in pixels\n@return an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null"},
    {"createGeoBoundary2", (PyCFunction) BeamPyProductUtils_createGeoBoundary2, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given product and returns it as a list of\ngeographical coordinates.\n This method delegates to {@link #createGeoBoundary(Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}\nand the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n@param product the input product, must not be null\n@param region  the region rectangle in product pixel coordinates, can be null for entire product\n@param step    the step given in pixels\n@return an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createPixelBoundary(RasterDataNode, java.awt.Rectangle, int)"},
    {"createGeoBoundary3", (PyCFunction) BeamPyProductUtils_createGeoBoundary3, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given product and returns it as a list of\ngeographical coordinates.\n@param product        the input product, must not be null\n@param region         the region rectangle in product pixel coordinates, can be null for entire product\n@param step           the step given in pixels\n@param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n@return an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createPixelBoundary(Product, java.awt.Rectangle, int, boolean)"},
    {"createGeoBoundary4", (PyCFunction) BeamPyProductUtils_createGeoBoundary4, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given raster and returns it as a list of\ngeographical coordinates.\n@param raster the input raster, must not be null\n@param region the region rectangle in raster pixel coordinates, can be null for entire raster\n@param step   the step given in pixels\n@return an array of geographical coordinates\n@throws IllegalArgumentException if raster is null or if the raster has no {@link GeoCoding} is null\n@see #createPixelBoundary(RasterDataNode, java.awt.Rectangle, int)"},
    {"createGeoBoundaryPaths1", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths1, METH_VARARGS | METH_STATIC, "Converts the geographic boundary entire product into one, two or three shape objects. If the product does not\nintersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created\nand returned in the order from west to east.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n@param product the input product\n@return an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, int)"},
    {"createGeoBoundaryPaths2", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths2, METH_VARARGS | METH_STATIC, "Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\nthe product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\nshapes are created and returned in the order from west to east.\n\nThis method delegates to {@link #createGeoBoundaryPaths(Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}\nand the additional parameter <code>usePixelCenter</code> is <code>true</code>.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n@param product the input product\n@param region  the region rectangle in product pixel coordinates, can be null for entire product\n@param step    the step given in pixels\n@return an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, java.awt.Rectangle, int)"},
    {"createGeoBoundaryPaths3", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths3, METH_VARARGS | METH_STATIC, "Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\nthe product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\nshapes are created and returned in the order from west to east.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n@param product        the input product\n@param region         the region rectangle in product pixel coordinates, can be null for entire product\n@param step           the step given in pixels\n@param usePixelCenter <code>true</code> if the pixel center should be used to create the pathes\n@return an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, java.awt.Rectangle, int, boolean)"},
    {"createPixelBoundary1", (PyCFunction) BeamPyProductUtils_createPixelBoundary1, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n<code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n This method delegates to {@link #createPixelBoundary(Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}\nand the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n@param product the product\n@param rect    the source rectangle\n@param step    the mean distance from one pixel position to the other in the returned array\n@return the rectangular boundary"},
    {"createPixelBoundary2", (PyCFunction) BeamPyProductUtils_createPixelBoundary2, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n<code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n@param product        the product\n@param rect           the source rectangle\n@param step           the mean distance from one pixel position to the other in the returned array\n@param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n@return the rectangular boundary"},
    {"createPixelBoundary3", (PyCFunction) BeamPyProductUtils_createPixelBoundary3, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n<code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a raster boundary expressed in geographical\nco-ordinates.\n@param raster the raster\n@param rect   the source rectangle\n@param step   the mean distance from one pixel position to the other in the returned array\n@return the rectangular boundary"},
    {"createRectBoundary1", (PyCFunction) BeamPyProductUtils_createRectBoundary1, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n<code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}\nand the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n@param rect the source rectangle\n@param step the mean distance from one pixel position to the other in the returned array\n@return the rectangular boundary"},
    {"createRectBoundary2", (PyCFunction) BeamPyProductUtils_createRectBoundary2, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n<code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n\n@param rect           the source rectangle\n@param step           the mean distance from one pixel position to the other in the returned array\n@param usePixelCenter <code>true</code> if the pixel center should be used\n@return the rectangular boundary"},
    {"copyFlagCodings", (PyCFunction) BeamPyProductUtils_copyFlagCodings, METH_VARARGS | METH_STATIC, "Copies the flag codings from the source product to the target.\n@param source the source product\n@param target the target product"},
    {"copyFlagCoding", (PyCFunction) BeamPyProductUtils_copyFlagCoding, METH_VARARGS | METH_STATIC, "Copies the given source flag coding to the target product.\nIf it exists already, the method simply returns the existing instance.\n@param sourceFlagCoding the source flag coding\n@param target           the target product\n@return The flag coding."},
    {"copyIndexCoding", (PyCFunction) BeamPyProductUtils_copyIndexCoding, METH_VARARGS | METH_STATIC, "Copies the given source index coding to the target product\nIf it exists already, the method simply returns the existing instance.\n@param sourceIndexCoding the source index coding\n@param target            the target product\n@return The index coding."},
    {"copyMasks", (PyCFunction) BeamPyProductUtils_copyMasks, METH_VARARGS | METH_STATIC, "Copies the {@link Mask}s from the source product to the target product.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy overlay masks from the source bands to the target bands. Also\nnote that a source mask is not copied to the target product, when there already\nis a mask in the target product with the same name as the source mask.\n@param sourceProduct the source product\n@param targetProduct the target product"},
    {"copyOverlayMasks", (PyCFunction) BeamPyProductUtils_copyOverlayMasks, METH_VARARGS | METH_STATIC, "Copies the overlay {@link Mask}s from the source product's raster data nodes to\nthe target product's raster data nodes.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy overlay masks, which are not contained in the target product's\nmask group.\n@param sourceProduct the source product\n@param targetProduct the target product"},
    {"copyRoiMasks", (PyCFunction) BeamPyProductUtils_copyRoiMasks, METH_VARARGS | METH_STATIC, "Copies the ROI {@link Mask}s from the source product's raster data nodes to\nthe target product's raster data nodes.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy ROI masks, which are not contained in the target product's\nmask group.\n@param sourceProduct the source product\n@param targetProduct the target product\n@deprecated since BEAM 4.10 (no replacement)"},
    {"copyFlagBands2", (PyCFunction) BeamPyProductUtils_copyFlagBands2, METH_VARARGS | METH_STATIC, "Copies all bands which contain a flagcoding from the source product to the target product.\n@param sourceProduct   the source product\n@param targetProduct   the target product\n@param copySourceImage whether the source image of the source band should be copied."},
    {"copyFlagBands1", (PyCFunction) BeamPyProductUtils_copyFlagBands1, METH_VARARGS | METH_STATIC, "Copies all bands which contain a flagcoding from the source product to the target product.\n@param sourceProduct the source product\n@param targetProduct the target product\n@deprecated since BEAM 4.10, use {@link #copyFlagBands(Product, Product, boolean)} instead."},
    {"copyTiePointGrid", (PyCFunction) BeamPyProductUtils_copyTiePointGrid, METH_VARARGS | METH_STATIC, "Copies the named tie-point grid from the source product to the target product.\n@param gridName      the name of the tie-point grid to be copied.\n@param sourceProduct the source product\n@param targetProduct the target product\n@return the copied tie-point grid, or <code>null</code> if the sourceProduct does not contain a tie-point grid with the given name."},
    {"copyBand4", (PyCFunction) BeamPyProductUtils_copyBand4, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\n@param sourceBandName  the name of the band to be copied.\n@param sourceProduct   the source product.\n@param targetProduct   the target product.\n@param copySourceImage whether the source image of the source band should be copied.\n@return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name."},
    {"copyBand2", (PyCFunction) BeamPyProductUtils_copyBand2, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\n@param sourceBandName  the name of the band to be copied.\n@param sourceProduct   the source product.\n@param targetBandName  the name of the band copied.\n@param targetProduct   the target product.\n@param copySourceImage whether the source image of the source band should be copied.\n@return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name."},
    {"copyRasterDataNodeProperties", (PyCFunction) BeamPyProductUtils_copyRasterDataNodeProperties, METH_VARARGS | METH_STATIC, "Copies all properties from source band to the target band.\n@param sourceRaster the source band\n@param targetRaster the target band\n@see #copySpectralBandProperties(Band, Band)"},
    {"copyBand3", (PyCFunction) BeamPyProductUtils_copyBand3, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\n@param sourceBandName the name of the band to be copied.\n@param sourceProduct  the source product.\n@param targetProduct  the target product.\n@return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n@deprecated since BEAM 4.10, use {@link #copyBand(String, Product, Product, boolean)} instead."},
    {"copyBand1", (PyCFunction) BeamPyProductUtils_copyBand1, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\n@param sourceBandName the name of the band to be copied.\n@param sourceProduct  the source product.\n@param targetBandName the name of the band copied.\n@param targetProduct  the target product.\n@return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n@deprecated since BEAM 4.10, use {@link #copyBand(String, Product, String, Product, boolean)} instead."},
    {"copySpectralBandProperties", (PyCFunction) BeamPyProductUtils_copySpectralBandProperties, METH_VARARGS | METH_STATIC, "Copies the spectral properties from source band to target band. These properties are:\n<ul>\n<li>{@link Band#getSpectralBandIndex() spectral band index},</li>\n<li>{@link Band#getSpectralWavelength() the central wavelength},</li>\n<li>{@link Band#getSpectralBandwidth() the spectral bandwidth} and</li>\n<li>{@link Band#getSolarFlux() the solar spectral flux}.</li>\n</ul>\n@param sourceBand the source band\n@param targetBand the target band\n@see #copyRasterDataNodeProperties(RasterDataNode, RasterDataNode)"},
    {"copyGeoCoding", (PyCFunction) BeamPyProductUtils_copyGeoCoding, METH_VARARGS | METH_STATIC, "Copies the geocoding from the source product to target product.\n@param sourceProduct the source product\n@param targetProduct the target product\n@throws IllegalArgumentException if one of the params is <code>null</code>."},
    {"copyTiePointGrids", (PyCFunction) BeamPyProductUtils_copyTiePointGrids, METH_VARARGS | METH_STATIC, "Copies all tie point grids from one product to another.\n@param sourceProduct the source product\n@param targetProduct the target product"},
    {"copyVectorData", (PyCFunction) BeamPyProductUtils_copyVectorData, METH_VARARGS | METH_STATIC, ""},
    {"canGetPixelPos1", (PyCFunction) BeamPyProductUtils_canGetPixelPos1, METH_VARARGS | METH_STATIC, "Returns whether or not a product can return a pixel position from a given geographical position.\n@param product the product to be checked\n@return <code>true</code> if the given product can return a pixel position"},
    {"canGetPixelPos2", (PyCFunction) BeamPyProductUtils_canGetPixelPos2, METH_VARARGS | METH_STATIC, "Returns whether or not a raster can return a pixel position from a given geographical position.\n@param raster the raster to be checked\n@return <code>true</code> if the given raster can return a pixel position"},
    {"createDensityPlotImage", (PyCFunction) BeamPyProductUtils_createDensityPlotImage, METH_VARARGS | METH_STATIC, "Creates a density plot image from two raster data nodes.\n@param raster1    the first raster data node\n@param sampleMin1 the minimum sample value to be considered in the first raster\n@param sampleMax1 the maximum sample value to be considered in the first raster\n@param raster2    the second raster data node\n@param sampleMin2 the minimum sample value to be considered in the second raster\n@param sampleMax2 the maximum sample value to be considered in the second raster\n@param roiMask    an optional mask to be used as a ROI for the computation\n@param width      the width of the output image\n@param height     the height of the output image\n@param background the background color of the output image\n@param image      an image to be used as output image, if <code>null</code> a new image is created\n@param pm         the progress monitor\n@return the density plot image\n@throws java.io.IOException when an error occurred."},
    {"overlayMasks", (PyCFunction) BeamPyProductUtils_overlayMasks, METH_VARARGS | METH_STATIC, "Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.\n@param raster     the raster data node which contains all the activated bitmask definitions\n@param overlayBIm the source image which is used as base image for all the overlays.\n@param pm         a monitor to inform the user about progress\n@return the modified given overlayBImm which contains all the activated masks.\n@see RasterDataNode#getOverlayMaskGroup()"},
    {"getCenterGeoPos", (PyCFunction) BeamPyProductUtils_getCenterGeoPos, METH_VARARGS | METH_STATIC, ""},
    {"normalizeGeoPolygon", (PyCFunction) BeamPyProductUtils_normalizeGeoPolygon, METH_VARARGS | METH_STATIC, "Normalizes the given geographical polygon so that maximum longitude differences between two points are 180\ndegrees. The method operates only on the longitude values of the given polygon.\n@param polygon a geographical, closed polygon\n@return 0 if normalizing has not been applied , -1 if negative normalizing has been applied, 1 if positive\nnormalizing has been applied, 2 if positive and negative normalising has been applied\n@see #denormalizeGeoPolygon(GeoPos[])"},
    {"normalizeGeoPolygon_old", (PyCFunction) BeamPyProductUtils_normalizeGeoPolygon_old, METH_VARARGS | METH_STATIC, ""},
    {"denormalizeGeoPolygon", (PyCFunction) BeamPyProductUtils_denormalizeGeoPolygon, METH_VARARGS | METH_STATIC, "Denormalizes the longitude values which have been normalized using the\n{@link #normalizeGeoPolygon(GeoPos[])} method. The\nmethod operates only on the longitude values of the given polygon.\n@param polygon a geographical, closed polygon"},
    {"denormalizeGeoPos", (PyCFunction) BeamPyProductUtils_denormalizeGeoPos, METH_VARARGS | METH_STATIC, ""},
    {"denormalizeGeoPos_old", (PyCFunction) BeamPyProductUtils_denormalizeGeoPos_old, METH_VARARGS | METH_STATIC, ""},
    {"getRotationDirection", (PyCFunction) BeamPyProductUtils_getRotationDirection, METH_VARARGS | METH_STATIC, ""},
    {"getAngleSum", (PyCFunction) BeamPyProductUtils_getAngleSum, METH_VARARGS | METH_STATIC, ""},
    {"convertToPixelPath", (PyCFunction) BeamPyProductUtils_convertToPixelPath, METH_VARARGS | METH_STATIC, "Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in\npixel coordinates using the supplied geo coding.\n@param geoPath   a <code>GeneralPath</code> given in geographic lon/lat coordinates, as returned by the {@link\n#convertToGeoPath(Shape, GeoCoding)} method\n@param geoCoding the geocoding used to convert the geographic coordinates into pixel coordinates.\n@return a <code>GeneralPath</code> given in pixel coordinates.\n@throws IllegalArgumentException if one of the given parameter is null.\n@throws IllegalStateException    if the given geoPath is not a geo referenced <code>GeneralPath</code> wich\ncontains only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n@see #convertToGeoPath(Shape, GeoCoding)"},
    {"convertToGeoPath", (PyCFunction) BeamPyProductUtils_convertToGeoPath, METH_VARARGS | METH_STATIC, "Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic\ncoordinates using the supplied geo coding.\n@param shape     a <code>Shape</code> given in pixel X/Y coordinates\n@param geoCoding the geo coding used to convert the pixel coordinates into geografic coordinates.\n@return a <code>GeneralPath</code> given in geografic coordinates\n@throws IllegalArgumentException if one of the given parameter is <code>null</code> or the given geo coding can\nnot get geografic coordinates.\n@throws IllegalStateException    if this method was used with a java runtime version in which it is not guaranted\nthat a <code>PathIterator</code> returned by {@link Shape#getPathIterator(java.awt.geom.AffineTransform,\ndouble)} returnes only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n@see GeoCoding#canGetGeoPos()"},
    {"copyMetadata2", (PyCFunction) BeamPyProductUtils_copyMetadata2, METH_VARARGS | METH_STATIC, "Copies all metadata elements and attributes of the source product to the target product.\nThe copied elements and attributes are deeply cloned.\n@param source the source product.\n@param target the target product.\n@throws NullPointerException if the source or the target product is {@code null}."},
    {"copyMetadata1", (PyCFunction) BeamPyProductUtils_copyMetadata1, METH_VARARGS | METH_STATIC, "Copies all metadata elements and attributes of the source element to the target element.\nThe copied elements and attributes are deeply cloned.\n@param source the source element.\n@param target the target element.\n@throws NullPointerException if the source or the target element is {@code null}."},
    {"copyPreferredTileSize", (PyCFunction) BeamPyProductUtils_copyPreferredTileSize, METH_VARARGS | METH_STATIC, "Copies the source product's preferred tile size (if any) to the target product.\n@param sourceProduct The source product.\n@param targetProduct The target product."},
    {"createGeoTIFFMetadata2", (PyCFunction) BeamPyProductUtils_createGeoTIFFMetadata2, METH_VARARGS | METH_STATIC, ""},
    {"createGeoTIFFMetadata1", (PyCFunction) BeamPyProductUtils_createGeoTIFFMetadata1, METH_VARARGS | METH_STATIC, ""},
    {"areaToPath", (PyCFunction) BeamPyProductUtils_areaToPath, METH_VARARGS | METH_STATIC, ""},
    {"addElementToHistory", (PyCFunction) BeamPyProductUtils_addElementToHistory, METH_VARARGS | METH_STATIC, "Adds a given elem to the history of the given product. If the products metadata root\ndoes not contain a history entry a new one will be created.\n@param product the product to add the history element.\n@param elem    the element to add to the products history. If <code>null</code> nothing will be added."},
    {"removeInvalidExpressions", (PyCFunction) BeamPyProductUtils_removeInvalidExpressions, METH_VARARGS | METH_STATIC, "Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given\nproduct, the related element is removed.\n@param product the (output) product to be cleaned up\n@return an array of messages which changes are done to the given product."},
    {"findSuitableQuicklookBandName", (PyCFunction) BeamPyProductUtils_findSuitableQuicklookBandName, METH_VARARGS | METH_STATIC, "Finds the name of a band in the given product which is suitable to product a good quicklook.\nThe method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.\n@param product the product to be searched\n@return the name of a suitable band or null if the given product does not contain any bands"},
    {"computeSourcePixelCoordinates", (PyCFunction) BeamPyProductUtils_computeSourcePixelCoordinates, METH_VARARGS | METH_STATIC, ""},
    {"computeMinMaxY", (PyCFunction) BeamPyProductUtils_computeMinMaxY, METH_VARARGS | METH_STATIC, "Computes the minimum and maximum y value of the given {@link PixelPos} array.\n@param pixelPositions the {@link PixelPos} array\n@return an int array which containes the minimum and maximum y value of the given {@link PixelPos} array in the\norder:<br> &nbsp;&nbsp;&nbsp;&nbsp;[0] - the minimum value<br>&nbsp;&nbsp;&nbsp;&nbsp;[1] - the maximum\nvalue<br><br>or <code>null</code> if no minimum or maximum can be retrieved because there given array is\nempty.\n@throws IllegalArgumentException if the given pixelPositions are <code>null</code>."},
    {"copyBandsForGeomTransform1", (PyCFunction) BeamPyProductUtils_copyBandsForGeomTransform1, METH_VARARGS | METH_STATIC, "Copies only the bands from source to target.\n@see #copyBandsForGeomTransform(Product, Product, boolean, double, java.util.Map)"},
    {"copyBandsForGeomTransform2", (PyCFunction) BeamPyProductUtils_copyBandsForGeomTransform2, METH_VARARGS | METH_STATIC, "Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target\nproduct is a geometric transformation (e.g. map-projection) of the source product.\nIf\n{@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,\nthis method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},\nregardless which raw data type the source band has.\nIn this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}\nwill always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}\nwill always be 0.0 and\n{@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.\nThis ensures that source pixel resampling methods operating on floating point\ndata can be stored without loss in accuracy in the target band.\n\nFurthermore, the\n{@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}\nand {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}\nproperties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},\nwill be either the one from the source band, if any, or otherwise the one passed into this method.\n@param sourceProduct        the source product as the source for the band specifications. Must be not\n<code>null</code>.\n@param targetProduct        the destination product to receive the bands created. Must be not <code>null</code>.\n@param includeTiePointGrids if {@code true}, tie-point grids of source product will be included as bands in target product\n@param defaultNoDataValue   the default, geophysical no-data value to be used if no no-data value is used by the source band.\n@param targetToSourceMap    a mapping from a target band to a source raster data node, can be {@code null}"},
    {"getScanLineTime", (PyCFunction) BeamPyProductUtils_getScanLineTime, METH_VARARGS | METH_STATIC, ""},
    {"getGeophysicalSampleDouble", (PyCFunction) BeamPyProductUtils_getGeophysicalSampleDouble, METH_VARARGS | METH_STATIC, ""},
    {"getGeophysicalSampleLong", (PyCFunction) BeamPyProductUtils_getGeophysicalSampleLong, METH_VARARGS | METH_STATIC, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductUtils_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductUtils",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "This class provides many static factory methods to be used in conjunction with data products.\n@see Product",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductUtils_Methods,         /* tp_methods */
    ProductUtils_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Map_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Map_Methods[] = 
{
    {"size", (PyCFunction) BeamPyMap_size, METH_VARARGS, ""},
    {"isEmpty", (PyCFunction) BeamPyMap_isEmpty, METH_VARARGS, ""},
    {"containsKey", (PyCFunction) BeamPyMap_containsKey, METH_VARARGS, ""},
    {"containsValue", (PyCFunction) BeamPyMap_containsValue, METH_VARARGS, ""},
    {"get", (PyCFunction) BeamPyMap_get, METH_VARARGS, ""},
    {"put", (PyCFunction) BeamPyMap_put, METH_VARARGS, ""},
    {"remove", (PyCFunction) BeamPyMap_remove, METH_VARARGS, ""},
    {"putAll", (PyCFunction) BeamPyMap_putAll, METH_VARARGS, ""},
    {"clear", (PyCFunction) BeamPyMap_clear, METH_VARARGS, ""},
    {"keySet", (PyCFunction) BeamPyMap_keySet, METH_VARARGS, ""},
    {"values", (PyCFunction) BeamPyMap_values, METH_VARARGS, ""},
    {"entrySet", (PyCFunction) BeamPyMap_entrySet, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyMap_equals, METH_VARARGS, ""},
    {"hashCode", (PyCFunction) BeamPyMap_hashCode, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Map_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Map",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Map_Methods,         /* tp_methods */
    Map_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MetadataElement_Members[] = {
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MetadataElement_Methods[] = 
{
    {"newMetadataElement", (PyCFunction) BeamPyMetadataElement_newMetadataElement, METH_VARARGS | METH_STATIC, "Constructs a new metadata element.\n@param name the element name"},
    {"getElementGroup", (PyCFunction) BeamPyMetadataElement_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\n@return The child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyMetadataElement_getParentElement, METH_VARARGS, ""},
    {"addElement", (PyCFunction) BeamPyMetadataElement_addElement, METH_VARARGS, "Adds the given element to this element.\n@param element the element to added, ignored if <code>null</code>"},
    {"addElementAt", (PyCFunction) BeamPyMetadataElement_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\n@param element the element to added, ignored if <code>null</code>\n@param index   where to put it"},
    {"removeElement", (PyCFunction) BeamPyMetadataElement_removeElement, METH_VARARGS, "Removes the given element from this element.\n@param element the element to be removed, ignored if <code>null</code>\n@return true, if so"},
    {"getNumElements", (PyCFunction) BeamPyMetadataElement_getNumElements, METH_VARARGS, "@return the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyMetadataElement_getElementAt, METH_VARARGS, "Returns the element at the given index.\n@param index the element index\n@return the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyMetadataElement_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\n@return a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyMetadataElement_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\n@return an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyMetadataElement_getElement, METH_VARARGS, "Returns the element with the given name.\n@param name the element name\n@return the element with the given name or <code>null</code> if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyMetadataElement_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyMetadataElement_getElementIndex, METH_VARARGS, "Gets the index of the given element.\n@param element The element .\n@return The element's index, or -1."},
    {"addAttribute", (PyCFunction) BeamPyMetadataElement_addAttribute, METH_VARARGS, "Adds an attribute to this node.\n@param attribute the attribute to be added, <code>null</code> is ignored"},
    {"removeAttribute", (PyCFunction) BeamPyMetadataElement_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n@return <code>true</code> if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyMetadataElement_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\n@return the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyMetadataElement_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\n@param index the attribute index\n@return the attribute, or <code>null</code> if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyMetadataElement_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\n@return the attribute name array, never <code>null</code>"},
    {"getAttributes", (PyCFunction) BeamPyMetadataElement_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\n@return an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyMetadataElement_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\n@param name the attribute name\n@return the attribute with the given name or <code>null</code> if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyMetadataElement_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\n@param name the attribute name\n@return <code>true</code> if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyMetadataElement_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\n@param attribute The attribute.\n@return The attribute's index, or -1."},
    {"getAttributeDouble", (PyCFunction) BeamPyMetadataElement_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC", (PyCFunction) BeamPyMetadataElement_getAttributeUTC, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as UTC."},
    {"getAttributeInt", (PyCFunction) BeamPyMetadataElement_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyMetadataElement_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\n<code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyMetadataElement_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\n<code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyMetadataElement_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\n<code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"getAttributeString", (PyCFunction) BeamPyMetadataElement_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\n@param name         the attribute name\n@param defaultValue the default value\n@return the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyMetadataElement_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\n<code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\nin this node.\n@param name  the attribute name\n@param value the new value"},
    {"setModified", (PyCFunction) BeamPyMetadataElement_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyMetadataElement_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then\nvisits all attributes. Finally the method calls <code>visitor.visit(this)</code>.\n@param visitor the visitor"},
    {"createDeepClone", (PyCFunction) BeamPyMetadataElement_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyMetadataElement_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyMetadataElement_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyMetadataElement_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyMetadataElement_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyMetadataElement_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyMetadataElement_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyMetadataElement_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyMetadataElement_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyMetadataElement_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyMetadataElement_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyMetadataElement_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyMetadataElement_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyMetadataElement_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyMetadataElement_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyMetadataElement_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyMetadataElement_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyMetadataElement_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MetadataElement_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MetadataElement",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A <code>MetadataElement</code> is a data node used to store metadata. Metadata elements can have any number of\nmetadata attributes of the type {@link MetadataAttribute} and any number of inner <code>MetadataElement</code>s.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MetadataElement_Methods,         /* tp_methods */
    MetadataElement_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Datum_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Datum_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Datum_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Datum",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Represents a geodetic datum. Geodetic datums define the size and shape of the earth and the origin and orientation of\nthe coordinate systems used to map the earth.\n\n@deprecated since BEAM 4.7, use {@link org.opengis.referencing.datum.GeodeticDatum} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Datum_Methods,         /* tp_methods */
    Datum_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Pointing_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Pointing_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Pointing_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Pointing",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The interface <code>Pointing</code> wraps a {@link GeoCoding} and optionally provides more geometry\ninformation such as sun direction, satellite (view) direction and elevation at a given pixel position.\n\nAll <code>Pointing</code> implementations should override\nthe {@link Object#equals(Object) equals()} and  {@link Object#hashCode() hashCode()} methods.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Pointing_Methods,         /* tp_methods */
    Pointing_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Color_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Color_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Color_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Color",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Color_Methods,         /* tp_methods */
    Color_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef PlacemarkDescriptor_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef PlacemarkDescriptor_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PlacemarkDescriptor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "PlacemarkDescriptor",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Placemark descriptors are used to describe and create {@link Placemark}s.\n\nNew placemark descriptors can be added by using the Service Provider Interface\n{@code META-INF/services/PlacemarkDescriptor}.\n\nSince this interface is likely to change, clients should not directly implement it.\nInstead they should derive their implementation from {@link AbstractPlacemarkDescriptor}.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PlacemarkDescriptor_Methods,         /* tp_methods */
    PlacemarkDescriptor_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef PointingFactory_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef PointingFactory_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PointingFactory_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "PointingFactory",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A factory which creates instances of a {@link Pointing} for a given raster data node.\nA <code>PointingFactory</code> is usually assigned to data {@link Product} by its {@link ProductReader ProductReader}",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PointingFactory_Methods,         /* tp_methods */
    PointingFactory_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef TransectProfileData_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef TransectProfileData_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject TransectProfileData_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "TransectProfileData",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A container for data which fully describes a transect profile. Use {@link TransectProfileDataBuilder} to create\ninstances.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    TransectProfileData_Methods,         /* tp_methods */
    TransectProfileData_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef PlacemarkGroup_Members[] = {
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef PlacemarkGroup_Methods[] = 
{
    {"getVectorDataNode", (PyCFunction) BeamPyPlacemarkGroup_getVectorDataNode, METH_VARARGS, ""},
    {"getPlacemark", (PyCFunction) BeamPyPlacemarkGroup_getPlacemark, METH_VARARGS, ""},
    {"add3", (PyCFunction) BeamPyPlacemarkGroup_add3, METH_VARARGS, ""},
    {"add1", (PyCFunction) BeamPyPlacemarkGroup_add1, METH_VARARGS, ""},
    {"remove1", (PyCFunction) BeamPyPlacemarkGroup_remove1, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyPlacemarkGroup_dispose, METH_VARARGS, ""},
    {"isTakingOverNodeOwnership", (PyCFunction) BeamPyPlacemarkGroup_isTakingOverNodeOwnership, METH_VARARGS, "@return {@code true}, if child nodes will have this group as owner after adding."},
    {"getNodeCount", (PyCFunction) BeamPyPlacemarkGroup_getNodeCount, METH_VARARGS, "@return The number of product nodes in this product group."},
    {"get1", (PyCFunction) BeamPyPlacemarkGroup_get1, METH_VARARGS, "@param index The node index.\n@return The product node at the given index."},
    {"getNodeDisplayNames", (PyCFunction) BeamPyPlacemarkGroup_getNodeDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\n@return an array containing the display names, never <code>null</code>, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getNodeNames", (PyCFunction) BeamPyPlacemarkGroup_getNodeNames, METH_VARARGS, "Returns the names of all products currently managed.\n@return an array containing the names, never <code>null</code>, but the array can have zero length"},
    {"toArray1", (PyCFunction) BeamPyPlacemarkGroup_toArray1, METH_VARARGS, "Returns an array of all products currently managed.\n@return an array containing the products, never <code>null</code>, but the array can have zero length"},
    {"toArray2", (PyCFunction) BeamPyPlacemarkGroup_toArray2, METH_VARARGS, "@param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a\nnew array of the same runtime type is allocated for this purpose.\n@return an array containing the product nodes, never <code>null</code>, but the array can have zero length"},
    {"indexOf1", (PyCFunction) BeamPyPlacemarkGroup_indexOf1, METH_VARARGS, ""},
    {"indexOf2", (PyCFunction) BeamPyPlacemarkGroup_indexOf2, METH_VARARGS, ""},
    {"getByDisplayName", (PyCFunction) BeamPyPlacemarkGroup_getByDisplayName, METH_VARARGS, "@param displayName the display name\n@return the product node with the given display name."},
    {"get2", (PyCFunction) BeamPyPlacemarkGroup_get2, METH_VARARGS, "@param name the name\n@return the product node with the given name."},
    {"contains1", (PyCFunction) BeamPyPlacemarkGroup_contains1, METH_VARARGS, "Tests whether a node with the given name is contained in this group.\n@param name the name\n@return true, if so"},
    {"contains2", (PyCFunction) BeamPyPlacemarkGroup_contains2, METH_VARARGS, "Tests whether the given product is contained in this list.\n@param node the node\n@return true, if so"},
    {"add4", (PyCFunction) BeamPyPlacemarkGroup_add4, METH_VARARGS, "Adds the given node to this group.\n@param node the node to be added, ignored if <code>null</code>\n@return true, if the node has been added"},
    {"add2", (PyCFunction) BeamPyPlacemarkGroup_add2, METH_VARARGS, "Adds the given node to this group.\n@param index the index.\n@param node  the node to be added, ignored if <code>null</code>"},
    {"remove2", (PyCFunction) BeamPyPlacemarkGroup_remove2, METH_VARARGS, "Removes the given node from this group.\n@param node the node to be removed\n@return true, if the node was removed"},
    {"removeAll", (PyCFunction) BeamPyPlacemarkGroup_removeAll, METH_VARARGS, "Removes all nodes from this group."},
    {"clearRemovedList", (PyCFunction) BeamPyPlacemarkGroup_clearRemovedList, METH_VARARGS, ""},
    {"getRemovedNodes", (PyCFunction) BeamPyPlacemarkGroup_getRemovedNodes, METH_VARARGS, "Gets all removed node nodes.\n@return a collection of all removed node nodes."},
    {"getRawStorageSize2", (PyCFunction) BeamPyPlacemarkGroup_getRawStorageSize2, METH_VARARGS, ""},
    {"setModified", (PyCFunction) BeamPyPlacemarkGroup_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyPlacemarkGroup_acceptVisitor, METH_VARARGS, ""},
    {"updateExpression", (PyCFunction) BeamPyPlacemarkGroup_updateExpression, METH_VARARGS, ""},
    {"getOwner", (PyCFunction) BeamPyPlacemarkGroup_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyPlacemarkGroup_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyPlacemarkGroup_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyPlacemarkGroup_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyPlacemarkGroup_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyPlacemarkGroup_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyPlacemarkGroup_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyPlacemarkGroup_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyPlacemarkGroup_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyPlacemarkGroup_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyPlacemarkGroup_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyPlacemarkGroup_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyPlacemarkGroup_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"getRawStorageSize1", (PyCFunction) BeamPyPlacemarkGroup_getRawStorageSize1, METH_VARARGS, "Gets an estimated, raw storage size in bytes of this product node.\n@return the size in bytes."},
    {"fireProductNodeChanged1", (PyCFunction) BeamPyPlacemarkGroup_fireProductNodeChanged1, METH_VARARGS, ""},
    {"fireProductNodeChanged2", (PyCFunction) BeamPyPlacemarkGroup_fireProductNodeChanged2, METH_VARARGS, ""},
    {"removeFromFile", (PyCFunction) BeamPyPlacemarkGroup_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyPlacemarkGroup_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PlacemarkGroup_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "PlacemarkGroup",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PlacemarkGroup_Methods,         /* tp_methods */
    PlacemarkGroup_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Product_Members[] = {
//     {"METADATA_ROOT_NAME", 0, 0, READONLY, NULL}
//     {"HISTORY_ROOT_NAME", 0, 0, READONLY, NULL}
//     {"PIN_MASK_NAME", 0, 0, READONLY, NULL}
//     {"GCP_MASK_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_GEOCODING", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_PRODUCT_TYPE", 0, 0, READONLY, NULL}
//     {"GEOMETRY_FEATURE_TYPE_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Product_Methods[] = 
{
    {"newProduct", (PyCFunction) BeamPyProduct_newProduct, METH_VARARGS | METH_STATIC, "Creates a new product without any reader (in-memory product)\n@param name              the product name\n@param type              the product type\n@param sceneRasterWidth  the scene width in pixels for this data product\n@param sceneRasterHeight the scene height in pixels for this data product"},
    {"getFileLocation", (PyCFunction) BeamPyProduct_getFileLocation, METH_VARARGS, "Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no\ndisk location (pure virtual memory product)\n@return the file location, may be <code>null</code>"},
    {"setFileLocation", (PyCFunction) BeamPyProduct_setFileLocation, METH_VARARGS, "Sets the file location for this product.\n@param fileLocation the file location, may be <code>null</code>"},
    {"getProductType", (PyCFunction) BeamPyProduct_getProductType, METH_VARARGS, "Gets the product type string.\n@return the product type string"},
    {"setProductType", (PyCFunction) BeamPyProduct_setProductType, METH_VARARGS, "Sets the product type of this product.\n@param productType the product type."},
    {"setProductReader", (PyCFunction) BeamPyProduct_setProductReader, METH_VARARGS, "Sets the product reader which will be used to create this product in-memory represention from an external source\nand which will be used to (re-)load band rasters.\n@param reader the product reader.\n@throws IllegalArgumentException if the given reader is null."},
    {"getProductReader", (PyCFunction) BeamPyProduct_getProductReader, METH_VARARGS, "Returns the reader which was used to create this product in-memory represention from an external source and which\nwill be used to (re-)load band rasters.\n@return the product reader, can be <code>null</code>"},
    {"setProductWriter", (PyCFunction) BeamPyProduct_setProductWriter, METH_VARARGS, "Sets the writer which will be used to write modifications of this product's in-memory represention to an external\ndestination.\n@param writer the product writer, can be <code>null</code>"},
    {"getProductWriter", (PyCFunction) BeamPyProduct_getProductWriter, METH_VARARGS, "Returns the writer which will be used to write modifications of this product's in-memory represention to an\nexternal destination.\n@return the product writer, can be <code>null</code>"},
    {"writeHeader", (PyCFunction) BeamPyProduct_writeHeader, METH_VARARGS, "Writes the header of a data product.\n@param output an object representing a valid output for this writer, might be a <code>ImageOutputStream</code>\nor a <code>File</code> or other <code>Object</code> to use for future decoding.\n@throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is none of the\nsupported output types.\n@throws IOException              if an I/O error occurs"},
    {"closeProductReader", (PyCFunction) BeamPyProduct_closeProductReader, METH_VARARGS, "Closes and clears this product's reader (if any).\n@throws IOException if an I/O error occurs\n@see #closeIO"},
    {"closeProductWriter", (PyCFunction) BeamPyProduct_closeProductWriter, METH_VARARGS, "Closes and clears this product's writer (if any).\n@throws IOException if an I/O error occurs\n@see #closeIO"},
    {"closeIO", (PyCFunction) BeamPyProduct_closeIO, METH_VARARGS, "Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and\n<code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but\nshould be called if the product instance is no longer in use.\n@throws IOException if an I/O error occurs\n@see #closeProductReader\n@see #closeProductWriter\n@see #dispose"},
    {"dispose", (PyCFunction) BeamPyProduct_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\nThis implementation also calls the <code>closeIO</code> in order to release all open I/O resources."},
    {"getPointingFactory", (PyCFunction) BeamPyProduct_getPointingFactory, METH_VARARGS, "Gets the pointing factory associated with this data product.\n@return the pointing factory or null, if none"},
    {"setPointingFactory", (PyCFunction) BeamPyProduct_setPointingFactory, METH_VARARGS, "Sets the pointing factory for this data product.\n@param pointingFactory the pointing factory"},
    {"setGeoCoding", (PyCFunction) BeamPyProduct_setGeoCoding, METH_VARARGS, "Geo-codes this data product.\n@param geoCoding the geo-coding, if <code>null</code> geo-coding is removed\n@throws IllegalArgumentException <br>- if the given <code>GeoCoding</code> is a <code>TiePointGeoCoding</code>\nand <code>latGrid</code> or <code>lonGrid</code> are not instances of tie point\ngrids in this product. <br>- if the given <code>GeoCoding</code> is a\n<code>MapGeoCoding</code> and its <code>MapInfo</code> is <code>null</code>\n<br>- if the given <code>GeoCoding</code> is a <code>MapGeoCoding</code> and the\n<code>sceneWith</code> or <code>sceneHeight</code> of its <code>MapInfo</code>\nis not equal to this products <code>sceneRasterWidth</code> or\n<code>sceneRasterHeight</code>"},
    {"getGeoCoding", (PyCFunction) BeamPyProduct_getGeoCoding, METH_VARARGS, "Returns the geo-coding used for this data product.\n@return the geo-coding, can be <code>null</code> if this product is not geo-coded."},
    {"isUsingSingleGeoCoding", (PyCFunction) BeamPyProduct_isUsingSingleGeoCoding, METH_VARARGS, "Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing\nthe band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.\nIf this product does not have a geo-coding, the method returns false.\n@return true, if so"},
    {"transferGeoCodingTo", (PyCFunction) BeamPyProduct_transferGeoCodingTo, METH_VARARGS, "Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to\nthe given {@link ProductSubsetDef subsetDef}.\n@param destProduct the destination product\n@param subsetDef   the definition of the subset, may be <code>null</code>\n@return true, if the geo-coding could be transferred."},
    {"getSceneRasterWidth", (PyCFunction) BeamPyProduct_getSceneRasterWidth, METH_VARARGS, "Returns the scene width in pixels for this data product.\n@return the scene width in pixels for this data product."},
    {"getSceneRasterHeight", (PyCFunction) BeamPyProduct_getSceneRasterHeight, METH_VARARGS, "Returns the scene height in pixels for this data product.\n@return the scene height in pixels for this data product."},
    {"getStartTime", (PyCFunction) BeamPyProduct_getStartTime, METH_VARARGS, "Gets the (sensing) start time associated with the first raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the first raster data line.\nFor Level-3 products, this could be the start time of first input product\ncontributing data.\n@return the sensing start time, can be null e.g. for non-swath products"},
    {"setStartTime", (PyCFunction) BeamPyProduct_setStartTime, METH_VARARGS, "Sets the (sensing) start time of this product.\n\nFor Level-1/2 products this is\nthe data-take time associated with the first raster data line.\nFor Level-3 products, this could be the start time of first input product\ncontributing data.\n@param startTime the sensing start time, can be null"},
    {"getEndTime", (PyCFunction) BeamPyProduct_getEndTime, METH_VARARGS, "Gets the (sensing) stop time associated with the last raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the last raster data line.\nFor Level-3 products, this could be the end time of last input product\ncontributing data.\n@return the stop time , can be null e.g. for non-swath products"},
    {"setEndTime", (PyCFunction) BeamPyProduct_setEndTime, METH_VARARGS, "Sets the (sensing) stop time associated with the first raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the last raster data line.\nFor Level-3 products, this could be the end time of last input product\ncontributing data.\n@param endTime the sensing stop time, can be null"},
    {"getMetadataRoot", (PyCFunction) BeamPyProduct_getMetadataRoot, METH_VARARGS, "Gets the root element of the associated metadata.\n@return the metadata root element"},
    {"getBandGroup", (PyCFunction) BeamPyProduct_getBandGroup, METH_VARARGS, "Gets the band group of this product.\n@return The group of all bands."},
    {"getTiePointGridGroup", (PyCFunction) BeamPyProduct_getTiePointGridGroup, METH_VARARGS, "Gets the tie-point grid group of this product.\n@return The group of all tie-point grids."},
    {"addTiePointGrid", (PyCFunction) BeamPyProduct_addTiePointGrid, METH_VARARGS, "Adds the given tie-point grid to this product.\n@param tiePointGrid the tie-point grid to added, ignored if <code>null</code>"},
    {"removeTiePointGrid", (PyCFunction) BeamPyProduct_removeTiePointGrid, METH_VARARGS, "Removes the tie-point grid from this product.\n@param tiePointGrid the tie-point grid to be removed, ignored if <code>null</code>\n@return <code>true</code> if node could be removed"},
    {"getNumTiePointGrids", (PyCFunction) BeamPyProduct_getNumTiePointGrids, METH_VARARGS, "Returns the number of tie-point grids contained in this product\n@return the number of tie-point grids"},
    {"getTiePointGridAt", (PyCFunction) BeamPyProduct_getTiePointGridAt, METH_VARARGS, "Returns the tie-point grid at the given index.\n@param index the tie-point grid index\n@return the tie-point grid at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getTiePointGridNames", (PyCFunction) BeamPyProduct_getTiePointGridNames, METH_VARARGS, "Returns a string array containing the names of the tie-point grids contained in this product\n@return a string array containing the names of the tie-point grids contained in this product. If this product has\nno tie-point grids a zero-length-array is returned."},
    {"getTiePointGrids", (PyCFunction) BeamPyProduct_getTiePointGrids, METH_VARARGS, "Returns an array of tie-point grids contained in this product\n@return an array of tie-point grids contained in this product. If this product has no  tie-point grids a\nzero-length-array is returned."},
    {"getTiePointGrid", (PyCFunction) BeamPyProduct_getTiePointGrid, METH_VARARGS, "Returns the tie-point grid with the given name.\n@param name the tie-point grid name\n@return the tie-point grid with the given name or <code>null</code> if a tie-point grid with the given name is\nnot contained in this product."},
    {"containsTiePointGrid", (PyCFunction) BeamPyProduct_containsTiePointGrid, METH_VARARGS, "Tests if a tie-point grid with the given name is contained in this product.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a tie-point grid with the given name is contained in this product,\n<code>false</code> otherwise"},
    {"addBand", (PyCFunction) BeamPyProduct_addBand, METH_VARARGS, "Adds the given band to this product.\n@param band the band to added, must not be <code>null</code>"},
    {"addNewBand", (PyCFunction) BeamPyProduct_addNewBand, METH_VARARGS, "Creates a new band with the given name and data type and adds it to this product and returns it.\n@param bandName the new band's name\n@param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\nconstants\n@return the new band which has just been added"},
    {"addComputedBand", (PyCFunction) BeamPyProduct_addComputedBand, METH_VARARGS, "Creates a new band with the given name and adds it to this product and returns it.\nThe new band's data type is {@code float} and it's samples are computed from the given band maths expression.\n@param bandName   the new band's name\n@param expression the band maths expression\n@return the new band which has just been added"},
    {"removeBand", (PyCFunction) BeamPyProduct_removeBand, METH_VARARGS, "Removes the given band from this product.\n@param band the band to be removed, ignored if <code>null</code>\n@return {@code true} if removed succesfully, otherwise {@code false}"},
    {"getNumBands", (PyCFunction) BeamPyProduct_getNumBands, METH_VARARGS, "@return the number of bands contained in this product."},
    {"getBandAt", (PyCFunction) BeamPyProduct_getBandAt, METH_VARARGS, "Returns the band at the given index.\n@param index the band index\n@return the band at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getBandNames", (PyCFunction) BeamPyProduct_getBandNames, METH_VARARGS, "Returns a string array containing the names of the bands contained in this product\n@return a string array containing the names of the bands contained in this product. If this product has no bands\na zero-length-array is returned."},
    {"getBands", (PyCFunction) BeamPyProduct_getBands, METH_VARARGS, "Returns an array of bands contained in this product\n@return an array of bands contained in this product. If this product has no bands a zero-length-array is\nreturned."},
    {"getBand", (PyCFunction) BeamPyProduct_getBand, METH_VARARGS, "Returns the band with the given name.\n@param name the band name\n@return the band with the given name or <code>null</code> if a band with the given name is not contained in this\nproduct.\n@throws IllegalArgumentException if the given name is <code>null</code> or empty."},
    {"getBandIndex", (PyCFunction) BeamPyProduct_getBandIndex, METH_VARARGS, "Returns the index for the band with the given name.\n@param name the band name\n@return the band index or <code>-1</code> if a band with the given name is not contained in this product.\n@throws IllegalArgumentException if the given name is <code>null</code> or empty."},
    {"containsBand", (PyCFunction) BeamPyProduct_containsBand, METH_VARARGS, "Tests if a band with the given name is contained in this product.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a band with the given name is contained in this product, <code>false</code>\notherwise\n@throws IllegalArgumentException if the given name is <code>null</code> or empty."},
    {"containsRasterDataNode", (PyCFunction) BeamPyProduct_containsRasterDataNode, METH_VARARGS, "Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or\ntie-point grids.\n@param name the name, must not be <code>null</code>\n@return <code>true</code> if a raster data node with the given name is contained in this product,\n<code>false</code> otherwise"},
    {"getRasterDataNode", (PyCFunction) BeamPyProduct_getRasterDataNode, METH_VARARGS, "Gets the raster data node with the given name. The method first searches for bands with the given name, then for\ntie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.\n@param name the name, must not be <code>null</code>\n@return the raster data node with the given name or <code>null</code> if a raster data node with the given name\nis not contained in this product."},
    {"getMaskGroup", (PyCFunction) BeamPyProduct_getMaskGroup, METH_VARARGS, ""},
    {"getVectorDataGroup", (PyCFunction) BeamPyProduct_getVectorDataGroup, METH_VARARGS, ""},
    {"getFlagCodingGroup", (PyCFunction) BeamPyProduct_getFlagCodingGroup, METH_VARARGS, ""},
    {"getIndexCodingGroup", (PyCFunction) BeamPyProduct_getIndexCodingGroup, METH_VARARGS, ""},
    {"containsPixel", (PyCFunction) BeamPyProduct_containsPixel, METH_VARARGS, "Tests if the given pixel position is within the product pixel bounds.\n@param x the x coordinate of the pixel position\n@param y the y coordinate of the pixel position\n@return true, if so\n@see #containsPixel(PixelPos)"},
    {"getGcpGroup", (PyCFunction) BeamPyProduct_getGcpGroup, METH_VARARGS, "Gets the group of ground-control points (GCPs).\nNote that this method will create the group, if none exists already.\n@return the GCP group."},
    {"getPinGroup", (PyCFunction) BeamPyProduct_getPinGroup, METH_VARARGS, "Gets the group of pins.\nNote that this method will create the group, if none exists already.\n@return the pin group."},
    {"isCompatibleProduct", (PyCFunction) BeamPyProduct_isCompatibleProduct, METH_VARARGS, "Checks whether or not the given product is compatible with this product.\n@param product the product to compare with\n@param eps     the maximum lat/lon error in degree\n@return <code>false</code> if the scene dimensions or geocoding are different, <code>true</code> otherwise."},
    {"parseExpression", (PyCFunction) BeamPyProduct_parseExpression, METH_VARARGS, "Parses a mathematical expression given as a text string.\n@param expression a expression given as a text string, e.g. \"radiance_4 / (1.0 + radiance_11)\".\n@return a term parsed from the given expression string\n@throws ParseException if the expression could not successfully be parsed"},
    {"acceptVisitor", (PyCFunction) BeamPyProduct_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag\ncodings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.\n@param visitor the visitor, must not be <code>null</code>"},
    {"addProductNodeListener", (PyCFunction) BeamPyProduct_addProductNodeListener, METH_VARARGS, "Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each\ntime a node in this product changes.\n@param listener the listener to be added\n@return boolean if listener was added or not"},
    {"removeProductNodeListener", (PyCFunction) BeamPyProduct_removeProductNodeListener, METH_VARARGS, "Removes a <code>ProductNodeListener</code> from this product.\n@param listener the listener to be removed."},
    {"getProductNodeListeners", (PyCFunction) BeamPyProduct_getProductNodeListeners, METH_VARARGS, ""},
    {"getRefNo", (PyCFunction) BeamPyProduct_getRefNo, METH_VARARGS, "@return The reference number of this product."},
    {"setRefNo", (PyCFunction) BeamPyProduct_setRefNo, METH_VARARGS, "Sets the reference number.\n@param refNo the reference number to set must be in the range 1 .. Integer.MAX_VALUE\n@throws IllegalArgumentException if the refNo is out of range\n@throws IllegalStateException"},
    {"resetRefNo", (PyCFunction) BeamPyProduct_resetRefNo, METH_VARARGS, ""},
    {"getProductManager", (PyCFunction) BeamPyProduct_getProductManager, METH_VARARGS, "Returns the product manager for this product.\n@return this product's manager, can be <code>null</code>"},
    {"createBandArithmeticParser", (PyCFunction) BeamPyProduct_createBandArithmeticParser, METH_VARARGS, "Creates a parser for band arithmetic expressions.\nThe parser created will use a namespace comprising all tie-point grids, bands and flags of this product.\n@return a parser for band arithmetic expressions for this product, never null"},
    {"createBandArithmeticDefaultNamespace", (PyCFunction) BeamPyProduct_createBandArithmeticDefaultNamespace, METH_VARARGS, "Creates a namespace to be used by parsers for band arithmetic expressions.\nThe namespace created comprises all tie-point grids, bands and flags of this product.\n@return a namespace, never null"},
    {"createSubset", (PyCFunction) BeamPyProduct_createSubset, METH_VARARGS, "Creates a subset of this product. The returned product represents a true spatial and spectral subset of this\nproduct, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the\ndescription from this product was used.\n@param subsetDef the product subset definition\n@param name      the name for the new product\n@param desc      the description for the new product\n@return the product subset, or <code>null</code> if the product/subset combination is not valid\n@throws IOException if an I/O error occurs"},
    {"createFlippedProduct", (PyCFunction) BeamPyProduct_createFlippedProduct, METH_VARARGS, "Creates flipped raster-data version of this product.\n@param flipType the flip type, see <code>{@link ProductFlipper}</code>\n@param name     the name for the new product\n@param desc     the description for the new product\n@return the product subset, or <code>null</code> if the product/subset combination is not valid\n@throws IOException if an I/O error occurs"},
    {"setModified", (PyCFunction) BeamPyProduct_setModified, METH_VARARGS, ""},
    {"getQuicklookBandName", (PyCFunction) BeamPyProduct_getQuicklookBandName, METH_VARARGS, "Gets the name of the band suitable for quicklook generation.\n@return the name of the quicklook band, or null if none has been defined"},
    {"setQuicklookBandName", (PyCFunction) BeamPyProduct_setQuicklookBandName, METH_VARARGS, "Sets the name of the band suitable for quicklook generation.\n@param quicklookBandName the name of the quicklook band, or null"},
    {"createPixelInfoString", (PyCFunction) BeamPyProduct_createPixelInfoString, METH_VARARGS, "Creates a string containing all available information at the given pixel position. The string returned is a line\nseparated text with each line containing a key/value pair.\n@param pixelX the pixel X co-ordinate\n@param pixelY the pixel Y co-ordinate\n@return the info string at the given position"},
    {"getRemovedChildNodes", (PyCFunction) BeamPyProduct_getRemovedChildNodes, METH_VARARGS, "@return All removed child nodes. Array may be empty."},
    {"canBeOrthorectified", (PyCFunction) BeamPyProduct_canBeOrthorectified, METH_VARARGS, "Checks whether or not this product can be ortorectified.\n@return true if {@link Band#canBeOrthorectified()} returns true for all bands, false otherwise"},
    {"getPreferredTileSize", (PyCFunction) BeamPyProduct_getPreferredTileSize, METH_VARARGS, "Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\ncreated for a {@link RasterDataNode} of this product.\n@return the preferred tile size, may be <code>null</null> if not specified\n@see RasterDataNode#getSourceImage()\n@see RasterDataNode# setSourceImage (java.awt.image.RenderedImage)"},
    {"setPreferredTileSize", (PyCFunction) BeamPyProduct_setPreferredTileSize, METH_VARARGS, "Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\ncreated for a {@link RasterDataNode} of this product.\n@param tileWidth  the preferred tile width\n@param tileHeight the preferred tile height\n@see #setPreferredTileSize(java.awt.Dimension)"},
    {"getAllFlagNames", (PyCFunction) BeamPyProduct_getAllFlagNames, METH_VARARGS, "Returns the names of all flags of all flag datasets contained this product.\n\nA flag name contains the dataset (a band of this product) and the actual flag name as defined in the\nflag-coding associated with the dataset. The general format for the flag name strings returned is therefore\n<code>\"<i>dataset</i>.<i>flag_name</i>\"</code>.\n\nThe method is used to find out which flags a product has in order to use them in bit-mask expressions.\n@return the array of all flag names. If this product does not support flags, an empty array is returned, but\nnever <code>null</code>.\n@see #parseExpression(String)"},
    {"getAutoGrouping", (PyCFunction) BeamPyProduct_getAutoGrouping, METH_VARARGS, "Gets the auto-grouping applicable to product nodes contained in this product.\n@return The auto-grouping or {@code null}."},
    {"setAutoGrouping", (PyCFunction) BeamPyProduct_setAutoGrouping, METH_VARARGS, "Sets the auto-grouping applicable to product nodes contained in this product.\nA given {@code pattern} parameter is a textual representation of the auto-grouping.\nThe syntax for the pattern is:\n<pre>\npattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | \"\" (empty string)\ngroupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}\ngroupName  :=  any non-empty string without characters ':' and '/'\n</pre>\nAn example for {@code pattern} applicable to Envisat AATSR data is\n<pre>\nnadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward\n</pre>\n@param pattern The auto-grouping pattern."},
    {"addComputedMask", (PyCFunction) BeamPyProduct_addComputedMask, METH_VARARGS, "Creates a new mask using a band arithmetic expression\nand adds it to this product and returns it.\n@param maskName     the new mask's name\n@param expression   the band arithmetic expression\n@param description  the mask's description\n@param color        the display color\n@param transparency the display transparency\n@return the new mask which has just been added"},
    {"addBitmaskDef", (PyCFunction) BeamPyProduct_addBitmaskDef, METH_VARARGS, "Adds the given bitmask definition to this product.\n@param bitmaskDef the bitmask definition to added, ignored if <code>null</code>\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getBitmaskDefNames", (PyCFunction) BeamPyProduct_getBitmaskDefNames, METH_VARARGS, "Returns a string array containing the names of the bitmask definitions contained in this product.\n@return a string array containing the names of the bitmask definitions contained in this product. If this product\nhas no bitmask definitions a zero-length-array is returned.\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getBitmaskDef", (PyCFunction) BeamPyProduct_getBitmaskDef, METH_VARARGS, "Returns the bitmask definition with the given name.\n@param name the bitmask definition name\n@return the bitmask definition with the given name or <code>null</code> if a bitmask definition with the given\nname is not contained in this product.\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getValidMask", (PyCFunction) BeamPyProduct_getValidMask, METH_VARARGS, "Gets a valid-mask for the given ID.\n@param id the ID\n@return a cached valid mask for the given ID or null\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"setValidMask", (PyCFunction) BeamPyProduct_setValidMask, METH_VARARGS, "Sets a valid-mask for the given ID.\n@param id        the ID\n@param validMask the pixel mask\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"createValidMask2", (PyCFunction) BeamPyProduct_createValidMask2, METH_VARARGS, "Creates a bit-packed valid-mask for all pixels of the scene covered by this product.\nThe given expression is considered to be boolean, if it evaluates to <code>true</code>\nthe related bit in the mask is set.\n@param expression the boolean expression, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\n@param pm         a progress monitor\n@return a bit-packed mask for all pixels of the scene, never null\n@throws IOException if an I/O error occurs\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"createValidMask1", (PyCFunction) BeamPyProduct_createValidMask1, METH_VARARGS, "Creates a bit-packed mask for all pixels of the scene covered by this product.\nThe given term is considered to be boolean, if it evaluates to <code>true</code>\nthe related bit in the mask is set.\n@param term the boolean term, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\n@param pm   a progress monitor\n@return a bit-packed mask for all pixels of the scene, never null\n@throws IOException if an I/O error occurs\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"readBitmask2", (PyCFunction) BeamPyProduct_readBitmask2, METH_VARARGS, "Creates a bit-mask by evaluating the given bit-mask term.\n The method first creates an evaluation context for the given bit-mask term and the specified region and then\nevaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\nthe resulting bitmask - is stored in the given boolean array buffer <code>bitmask</code> in the same order as\npixels appear in the given region. The buffer must at least have a length equal to <code>width * height</code>\nelements.\n\n If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\nloaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n\n The {@link #parseExpression(String)} method can be used to create a bit-mask\nterm from a textual bit-mask expression.\n\n@param offsetX     the X-offset of the spatial subset in pixel co-ordinates\n@param offsetY     the Y-offset of the spatial subset in pixel co-ordinates\n@param width       the width of the spatial subset in pixel co-ordinates\n@param height      the height of the spatial subset in pixel co-ordinates\n@param bitmaskTerm a bit-mask term, as returned by the {@link #parseExpression(String)} method\n@param bitmask     a buffer used to hold the results of the bit-mask evaluations for each pixel in the given\nspatial subset\n@param pm          a monitor to inform the user about progress\n@throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"readBitmask1", (PyCFunction) BeamPyProduct_readBitmask1, METH_VARARGS, "Creates a bit-mask by evaluating the given bit-mask term.\n\n The method first creates an evaluation context for the given bit-mask term and the specified region and then\nevaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\nthe resulting bitmask - is stored in the given boolean array buffer <code>bitmask</code> in the same order as\npixels appear in the given region. The buffer must at least have a length equal to <code>width * height</code>\nelements.\n\n If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\nloaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n\n The {@link #parseExpression(String)} method can be used to create a bit-mask\nterm from a textual bit-mask expression.\n@param offsetX     the X-offset of the spatial subset in pixel co-ordinates\n@param offsetY     the Y-offset of the spatial subset in pixel co-ordinates\n@param width       the width of the spatial subset in pixel co-ordinates\n@param height      the height of the spatial subset in pixel co-ordinates\n@param bitmaskTerm a bit-mask term, as returned by the {@link #parseExpression(String)}\nmethod\n@param bitmask     a byte buffer used to hold the results of the bit-mask evaluations for each pixel in the given\nspatial subset\n@param trueValue   the byte value to be set if the bitmask-term evauates to <code>true</code>\n@param falseValue  the byte value to be set if the bitmask-term evauates to <code>false</code>\n@throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getOwner", (PyCFunction) BeamPyProduct_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyProduct_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyProduct_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyProduct_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyProduct_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyProduct_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyProduct_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyProduct_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyProduct_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getDisplayName", (PyCFunction) BeamPyProduct_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyProduct_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyProduct_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyProduct_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyProduct_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Product_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Product",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "<code>Product</code> instances are an in-memory representation of a remote sensing data product. The product is more\nan abstract hull containing references to the data of the product or readers to retrieve the data on demant. The\nproduct itself does not hold the remote sensing data. Data products can contain multiple geophysical parameters\nstored as bands and can also have multiple metadata attributes. Also, a <code>Product</code> can contain any number\nof <code>TiePointGrids</code> holding the tie point data.\n\nEvery product can also have a product reader and writer assigned to it. The reader represents the data source from\nwhich a product was created, whereas the writer represents the data sink. Both, the source and the sink must not\nnecessarily store data in the same format. Furthermore, it is not mandatory for a product to have both of them.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Product_Methods,         /* tp_methods */
    Product_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Point2D_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Point2D_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Point2D_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Point2D",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Point2D_Methods,         /* tp_methods */
    Point2D_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductVisitor_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductVisitor_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductVisitor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductVisitor",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A visitor for a product and all other product nodes. This interface is part of the <i>visitor pattern</i> used to\nvisit all nodes of a data product. Implementations of this interface can be passed to the <code>acceptVisitor</code>\nmethod of an <code>Product</code> (or any other <code>ProductNode</code>).\n@see Product#acceptVisitor(ProductVisitor)\n@see ProductNode#acceptVisitor(ProductVisitor)",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductVisitor_Methods,         /* tp_methods */
    ProductVisitor_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Scaling_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Scaling_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Scaling_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Scaling",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The scaling method used for geophysical value transformation in a {@link Band}.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Scaling_Methods,         /* tp_methods */
    Scaling_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef WritableNamespace_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef WritableNamespace_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject WritableNamespace_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "WritableNamespace",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    WritableNamespace_Methods,         /* tp_methods */
    WritableNamespace_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Set_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Set_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Set_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Set",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Set_Methods,         /* tp_methods */
    Set_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MultiLevelImage_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MultiLevelImage_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MultiLevelImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MultiLevelImage",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MultiLevelImage_Methods,         /* tp_methods */
    MultiLevelImage_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ROI_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ROI_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ROI_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ROI",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ROI_Methods,         /* tp_methods */
    ROI_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef RenderingHints_Key_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef RenderingHints_Key_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderingHints_Key_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RenderingHints_Key",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderingHints_Key_Methods,         /* tp_methods */
    RenderingHints_Key_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Collection_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Collection_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Collection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Collection",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Collection_Methods,         /* tp_methods */
    Collection_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductManager_Listener_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductManager_Listener_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductManager_Listener_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductManager_Listener",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A listener for the product manager.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductManager_Listener_Methods,         /* tp_methods */
    ProductManager_Listener_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef GeoTIFFMetadata_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef GeoTIFFMetadata_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoTIFFMetadata_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "GeoTIFFMetadata",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoTIFFMetadata_Methods,         /* tp_methods */
    GeoTIFFMetadata_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ColorPaletteDef_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ColorPaletteDef_Methods[] = 
{
    {"newColorPaletteDefFromRange", (PyCFunction) BeamPyColorPaletteDef_newColorPaletteDefFromRange, METH_VARARGS | METH_STATIC, ""},
    {"newColorPaletteDefFromPoints", (PyCFunction) BeamPyColorPaletteDef_newColorPaletteDefFromPoints, METH_VARARGS | METH_STATIC, ""},
    {"isDiscrete", (PyCFunction) BeamPyColorPaletteDef_isDiscrete, METH_VARARGS, ""},
    {"setDiscrete", (PyCFunction) BeamPyColorPaletteDef_setDiscrete, METH_VARARGS, ""},
    {"getNumColors", (PyCFunction) BeamPyColorPaletteDef_getNumColors, METH_VARARGS, ""},
    {"setNumColors", (PyCFunction) BeamPyColorPaletteDef_setNumColors, METH_VARARGS, ""},
    {"getNumPoints", (PyCFunction) BeamPyColorPaletteDef_getNumPoints, METH_VARARGS, ""},
    {"setNumPoints", (PyCFunction) BeamPyColorPaletteDef_setNumPoints, METH_VARARGS, ""},
    {"isAutoDistribute", (PyCFunction) BeamPyColorPaletteDef_isAutoDistribute, METH_VARARGS, ""},
    {"setAutoDistribute", (PyCFunction) BeamPyColorPaletteDef_setAutoDistribute, METH_VARARGS, ""},
    {"getPointAt", (PyCFunction) BeamPyColorPaletteDef_getPointAt, METH_VARARGS, ""},
    {"getFirstPoint", (PyCFunction) BeamPyColorPaletteDef_getFirstPoint, METH_VARARGS, ""},
    {"getLastPoint", (PyCFunction) BeamPyColorPaletteDef_getLastPoint, METH_VARARGS, ""},
    {"getMinDisplaySample", (PyCFunction) BeamPyColorPaletteDef_getMinDisplaySample, METH_VARARGS, ""},
    {"getMaxDisplaySample", (PyCFunction) BeamPyColorPaletteDef_getMaxDisplaySample, METH_VARARGS, ""},
    {"insertPointAfter", (PyCFunction) BeamPyColorPaletteDef_insertPointAfter, METH_VARARGS, ""},
    {"createPointAfter", (PyCFunction) BeamPyColorPaletteDef_createPointAfter, METH_VARARGS, "creates a new point between the point at the given index\n@param index   the index\n@param scaling the scaling\n@return true, if a point has been inserted"},
    {"getCenterColor", (PyCFunction) BeamPyColorPaletteDef_getCenterColor, METH_VARARGS | METH_STATIC, "Creates the center color between the given two colors.\n@param c1 1st color\n@param c2 2nd color\n@return the center color"},
    {"removePointAt", (PyCFunction) BeamPyColorPaletteDef_removePointAt, METH_VARARGS, ""},
    {"addPoint", (PyCFunction) BeamPyColorPaletteDef_addPoint, METH_VARARGS, ""},
    {"getPoints", (PyCFunction) BeamPyColorPaletteDef_getPoints, METH_VARARGS, ""},
    {"setPoints", (PyCFunction) BeamPyColorPaletteDef_setPoints, METH_VARARGS, ""},
    {"getIterator", (PyCFunction) BeamPyColorPaletteDef_getIterator, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyColorPaletteDef_clone, METH_VARARGS, ""},
    {"createDeepCopy", (PyCFunction) BeamPyColorPaletteDef_createDeepCopy, METH_VARARGS, ""},
    {"loadColorPaletteDef", (PyCFunction) BeamPyColorPaletteDef_loadColorPaletteDef, METH_VARARGS | METH_STATIC, "Loads a color palette definition from the given file\n@param file the file\n@return the color palette definition, never null\n@throws IOException if an I/O error occurs"},
    {"storeColorPaletteDef", (PyCFunction) BeamPyColorPaletteDef_storeColorPaletteDef, METH_VARARGS | METH_STATIC, "Stores this color palette definition in the given file\n@param colorPaletteDef thje color palette definition\n@param file            the file\n@throws IOException if an I/O error occurs"},
    {"dispose", (PyCFunction) BeamPyColorPaletteDef_dispose, METH_VARARGS, "Releases all of the resources used by this color palette definition and all of its owned children. Its primary\nuse is to allow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"getColors", (PyCFunction) BeamPyColorPaletteDef_getColors, METH_VARARGS, ""},
    {"createColorPalette", (PyCFunction) BeamPyColorPaletteDef_createColorPalette, METH_VARARGS, ""},
    {"computeColor", (PyCFunction) BeamPyColorPaletteDef_computeColor, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ColorPaletteDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ColorPaletteDef",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ColorPaletteDef</code> class represents a curve that is used to transform the sample values of a\ngeo-physical band into color palette indexes.\n\n This special implemnentation of a gradation curve also provides separate color values for each of the tie points\ncontained in the curve. This allows a better image interpretation because certain colors correspond to certain sample\nvalues even if the curve points are used to create color gradient palettes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ColorPaletteDef_Methods,         /* tp_methods */
    ColorPaletteDef_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MapInfo_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MapInfo_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MapInfo",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>MapInfo</code> class holds information required to bring the cartographic map co-ordinate system to a\nraster co-ordinate system and back.\n\n@deprecated since BEAM 4.7, use geotools and {@link CrsGeoCoding} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapInfo_Methods,         /* tp_methods */
    MapInfo_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ImageInfo_Members[] = {
//     {"NO_COLOR", 0, 0, READONLY, NULL}
//     {"HISTOGRAM_MATCHING_OFF", 0, 0, READONLY, NULL}
//     {"HISTOGRAM_MATCHING_EQUALIZE", 0, 0, READONLY, NULL}
//     {"HISTOGRAM_MATCHING_NORMALIZE", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ImageInfo_Methods[] = 
{
    {"newImageInfoPalette", (PyCFunction) BeamPyImageInfo_newImageInfoPalette, METH_VARARGS | METH_STATIC, "Constructs a new image information instance.\n@param colorPaletteDef the color palette definition"},
    {"newImageInfoRGB", (PyCFunction) BeamPyImageInfo_newImageInfoRGB, METH_VARARGS | METH_STATIC, "Constructs a new RGB image information instance.\n@param rgbChannelDef the RGB channel definition"},
    {"getColorPaletteDef", (PyCFunction) BeamPyImageInfo_getColorPaletteDef, METH_VARARGS, "Gets the color palette definition as used for images created from single bands.\n@return The color palette definition. Can be {@code null}.\nIn this case {@link #getRgbChannelDef()} is non-null."},
    {"getRgbChannelDef", (PyCFunction) BeamPyImageInfo_getRgbChannelDef, METH_VARARGS, "Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.\n@return The RGB(A) channel definition.\nCan be {@code null}. In this case {@link #getColorPaletteDef()} is non-null."},
    {"getNoDataColor", (PyCFunction) BeamPyImageInfo_getNoDataColor, METH_VARARGS, ""},
    {"setNoDataColor", (PyCFunction) BeamPyImageInfo_setNoDataColor, METH_VARARGS, ""},
    {"setHistogramMatching", (PyCFunction) BeamPyImageInfo_setHistogramMatching, METH_VARARGS, ""},
    {"isLogScaled", (PyCFunction) BeamPyImageInfo_isLogScaled, METH_VARARGS, ""},
    {"setLogScaled", (PyCFunction) BeamPyImageInfo_setLogScaled, METH_VARARGS, ""},
    {"getColors", (PyCFunction) BeamPyImageInfo_getColors, METH_VARARGS, ""},
    {"getColorComponentCount", (PyCFunction) BeamPyImageInfo_getColorComponentCount, METH_VARARGS, "Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.\n@return {@code 3} for RGB images, {@code 4} for RGB images with an alpha channel (transparency)"},
    {"createIndexColorModel", (PyCFunction) BeamPyImageInfo_createIndexColorModel, METH_VARARGS, ""},
    {"createComponentColorModel", (PyCFunction) BeamPyImageInfo_createComponentColorModel, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyImageInfo_clone, METH_VARARGS, "Creates and returns a copy of this object.\n@return a copy of this object"},
    {"createDeepCopy", (PyCFunction) BeamPyImageInfo_createDeepCopy, METH_VARARGS, "Creates and returns a \"deep\" copy of this object. The method simply returns the value of\n{@link #clone()}.\n@return a copy of this object"},
    {"dispose", (PyCFunction) BeamPyImageInfo_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"setColors", (PyCFunction) BeamPyImageInfo_setColors, METH_VARARGS, "Sets the colours of the colour palette of this image info.\n@param colors the new colours"},
    {"setColorPaletteDef", (PyCFunction) BeamPyImageInfo_setColorPaletteDef, METH_VARARGS, "Transfers the colour palette into this image info.\n@param colorPaletteDef another colour palette\n@param minSample       the minium allowed sample value in the new colour palette\n@param maxSample       the maximum allowed sample value in the new colour palette\n@param autoDistribute  if true, points are distributed between minSample/maxSample."},
    {"getHistogramMatching", (PyCFunction) BeamPyImageInfo_getHistogramMatching, METH_VARARGS | METH_STATIC, "Converts a string to a histogram matching.\n@param mode the histogram matching string\n@return the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\"."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ImageInfo",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "This class contains information about how a product's raster data node is displayed as an image.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInfo_Methods,         /* tp_methods */
    ImageInfo_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef Histogram_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef Histogram_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Histogram_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "Histogram",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Instances of the <code>Histogram</code> class store histogram data.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Histogram_Methods,         /* tp_methods */
    Histogram_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef String_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef String_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject String_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "String",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    String_Methods,         /* tp_methods */
    String_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef BufferedImage_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef BufferedImage_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BufferedImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "BufferedImage",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BufferedImage_Methods,         /* tp_methods */
    BufferedImage_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef RGBChannelDef_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef RGBChannelDef_Methods[] = 
{
    {"newRGBChannelDef", (PyCFunction) BeamPyRGBChannelDef_newRGBChannelDef, METH_VARARGS | METH_STATIC, ""},
    {"getSourceName", (PyCFunction) BeamPyRGBChannelDef_getSourceName, METH_VARARGS, ""},
    {"setSourceName", (PyCFunction) BeamPyRGBChannelDef_setSourceName, METH_VARARGS, ""},
    {"getSourceNames", (PyCFunction) BeamPyRGBChannelDef_getSourceNames, METH_VARARGS, ""},
    {"setSourceNames", (PyCFunction) BeamPyRGBChannelDef_setSourceNames, METH_VARARGS, ""},
    {"isAlphaUsed", (PyCFunction) BeamPyRGBChannelDef_isAlphaUsed, METH_VARARGS, ""},
    {"isGammaUsed", (PyCFunction) BeamPyRGBChannelDef_isGammaUsed, METH_VARARGS, ""},
    {"getGamma", (PyCFunction) BeamPyRGBChannelDef_getGamma, METH_VARARGS, ""},
    {"setGamma", (PyCFunction) BeamPyRGBChannelDef_setGamma, METH_VARARGS, ""},
    {"getMinDisplaySample", (PyCFunction) BeamPyRGBChannelDef_getMinDisplaySample, METH_VARARGS, ""},
    {"setMinDisplaySample", (PyCFunction) BeamPyRGBChannelDef_setMinDisplaySample, METH_VARARGS, ""},
    {"getMaxDisplaySample", (PyCFunction) BeamPyRGBChannelDef_getMaxDisplaySample, METH_VARARGS, ""},
    {"setMaxDisplaySample", (PyCFunction) BeamPyRGBChannelDef_setMaxDisplaySample, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyRGBChannelDef_clone, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RGBChannelDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RGBChannelDef",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RGBChannelDef_Methods,         /* tp_methods */
    RGBChannelDef_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef TiePointGrid_Members[] = {
//     {"PROPERTY_NAME_IMAGE_INFO", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_LOG_10_SCALED", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_ROI_DEFINITION", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SCALING_FACTOR", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SCALING_OFFSET", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NO_DATA_VALUE", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NO_DATA_VALUE_USED", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_VALID_PIXEL_EXPRESSION", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_GEOCODING", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_STX", 0, 0, READONLY, NULL}
//     {"NO_DATA_TEXT", 0, 0, READONLY, NULL}
//     {"INVALID_POS_TEXT", 0, 0, READONLY, NULL}
//     {"IO_ERROR_TEXT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DATA", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_READ_ONLY", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SYNTHETIC", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_UNIT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef TiePointGrid_Methods[] = 
{
    {"newTiePointGrid1", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid1, METH_VARARGS | METH_STATIC, "Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n@param name         the name of the new object\n@param gridWidth    the width of the tie-point grid in pixels\n@param gridHeight   the height of the tie-point grid in pixels\n@param offsetX      the X co-ordinate of the first (upper-left) tie-point in pixels\n@param offsetY      the Y co-ordinate of the first (upper-left) tie-point in pixels\n@param subSamplingX the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param subSamplingY the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param tiePoints    the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>"},
    {"newTiePointGrid2", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid2, METH_VARARGS | METH_STATIC, "Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n@param name          the name of the new object\n@param gridWidth     the width of the tie-point grid in pixels\n@param gridHeight    the height of the tie-point grid in pixels\n@param offsetX       the X co-ordinate of the first (upper-left) tie-point in pixels\n@param offsetY       the Y co-ordinate of the first (upper-left) tie-point in pixels\n@param subSamplingX  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param subSamplingY  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param tiePoints     the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n@param discontinuity the discontinuity mode, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180}\n{@link #DISCONT_AT_360}"},
    {"newTiePointGrid3", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid3, METH_VARARGS | METH_STATIC, "Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n@param name           the name of the new object\n@param gridWidth      the width of the tie-point grid in pixels\n@param gridHeight     the height of the tie-point grid in pixels\n@param offsetX        the X co-ordinate of the first (upper-left) tie-point in pixels\n@param offsetY        the Y co-ordinate of the first (upper-left) tie-point in pixels\n@param subSamplingX   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param subSamplingY   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\n@param tiePoints      the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n@param containsAngles if true, the {@link #getDiscontinuity() angular discontinuity} is derived from the provided tie-point data values"},
    {"getDiscontinuity2", (PyCFunction) BeamPyTiePointGrid_getDiscontinuity2, METH_VARARGS | METH_STATIC, "Determines the angular discontinuity of the given tie point values.\n@return the angular discontinuity, will always be either {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"getDiscontinuity1", (PyCFunction) BeamPyTiePointGrid_getDiscontinuity1, METH_VARARGS, "Gets the angular discontinuity.\n@return the angular discontinuity, will always be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"setDiscontinuity", (PyCFunction) BeamPyTiePointGrid_setDiscontinuity, METH_VARARGS, "Sets the angular discontinuity.\n@param discontinuity angular discontinuity, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"isFloatingPointType", (PyCFunction) BeamPyTiePointGrid_isFloatingPointType, METH_VARARGS, "Returns <code>true</code>\n@return true"},
    {"getGeophysicalDataType", (PyCFunction) BeamPyTiePointGrid_getGeophysicalDataType, METH_VARARGS, "Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the\n<code>ProductData.TYPE_XXX</code> constants.\n@return the geophysical data type\n@see ProductData"},
    {"getSceneRasterData", (PyCFunction) BeamPyTiePointGrid_getSceneRasterData, METH_VARARGS, "Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. \n\nIn opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n<code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store\nthe scene's pixels.\n@return raster data covering the pixels for a complete scene\n@see #getRasterData\n@see #getRasterWidth\n@see #getRasterHeight\n@see #getSceneRasterWidth\n@see #getSceneRasterHeight"},
    {"getSceneRasterWidth", (PyCFunction) BeamPyTiePointGrid_getSceneRasterWidth, METH_VARARGS, "Returns the width in pixels of the scene represented by this tie-point grid. The value returned is\n<code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>\n@return the scene width in pixels"},
    {"getSceneRasterHeight", (PyCFunction) BeamPyTiePointGrid_getSceneRasterHeight, METH_VARARGS, "Returns the height in pixels of the scene represented by this tie-point grid. The value returned is\n<code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>\n@return the scene height in pixels"},
    {"getOffsetX", (PyCFunction) BeamPyTiePointGrid_getOffsetX, METH_VARARGS, "Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels."},
    {"getOffsetY", (PyCFunction) BeamPyTiePointGrid_getOffsetY, METH_VARARGS, "Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels."},
    {"getSubSamplingX", (PyCFunction) BeamPyTiePointGrid_getSubSamplingX, METH_VARARGS, "Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this\ntie-pint grid belongs to.\n@return the sub-sampling in X-direction, never less than one."},
    {"getSubSamplingY", (PyCFunction) BeamPyTiePointGrid_getSubSamplingY, METH_VARARGS, "Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this\ntie-pint grid belongs to.\n@return the sub-sampling in Y-direction, never less than one."},
    {"getTiePoints", (PyCFunction) BeamPyTiePointGrid_getTiePoints, METH_VARARGS, "Gets the data array holding this band's pixel samples.\n@return the data array for this band, or <code>null</code> if no data has been loaded\n@see ProductData#getElems"},
    {"getPixelInt", (PyCFunction) BeamPyTiePointGrid_getPixelInt, METH_VARARGS, "Gets the interpolated sample for the pixel located at (x,y) as an integer value. \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n@param x The X co-ordinate of the pixel location\n@param y The Y co-ordinate of the pixel location\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"dispose", (PyCFunction) BeamPyTiePointGrid_dispose, METH_VARARGS, ""},
    {"getPixelFloat2", (PyCFunction) BeamPyTiePointGrid_getPixelFloat2, METH_VARARGS, "Computes the interpolated sample for the pixel located at (x,y). \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"getPixelFloat1", (PyCFunction) BeamPyTiePointGrid_getPixelFloat1, METH_VARARGS, "Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"getPixelDouble", (PyCFunction) BeamPyTiePointGrid_getPixelDouble, METH_VARARGS, "Gets the interpolated sample for the pixel located at (x,y) as a double value. \n\nIf the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"setPixelInt", (PyCFunction) BeamPyTiePointGrid_setPixelInt, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixelFloat", (PyCFunction) BeamPyTiePointGrid_setPixelFloat, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixelDouble", (PyCFunction) BeamPyTiePointGrid_setPixelDouble, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"getPixels6", (PyCFunction) BeamPyTiePointGrid_getPixels6, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given\narray is <code>null</code> a new one was created and returned.\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the integer array to be filled with data\n@param pm     a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"getPixels4", (PyCFunction) BeamPyTiePointGrid_getPixels4, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product width and height as float array. If the given\narray is <code>null</code> a new one is created and returned.\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the float array to be filled with data\n@param pm     a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"getPixels2", (PyCFunction) BeamPyTiePointGrid_getPixels2, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\narray is <code>null</code> a new one was created and returned.\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the double array to be filled with data\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"setPixels3", (PyCFunction) BeamPyTiePointGrid_setPixels3, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixels2", (PyCFunction) BeamPyTiePointGrid_setPixels2, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixels1", (PyCFunction) BeamPyTiePointGrid_setPixels1, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"readPixels6", (PyCFunction) BeamPyTiePointGrid_readPixels6, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\narray is <code>null</code> a new one was created and returned.\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the integer array to be filled with data\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"readPixels4", (PyCFunction) BeamPyTiePointGrid_readPixels4, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\narray is <code>null</code> a new one was created and returned. *\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the float array to be filled with data\n@param pm     a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"readPixels2", (PyCFunction) BeamPyTiePointGrid_readPixels2, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\narray is <code>null</code> a new one was created and returned.\n@param x      the x coordinate of the array to be read\n@param y      the y coordinate of the array to be read\n@param w      the width of the array to be read\n@param h      the height of the array to be read\n@param pixels the double array to be filled with data\n@param pm     a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>."},
    {"writePixels6", (PyCFunction) BeamPyTiePointGrid_writePixels6, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"writePixels4", (PyCFunction) BeamPyTiePointGrid_writePixels4, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"writePixels2", (PyCFunction) BeamPyTiePointGrid_writePixels2, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"readRasterData2", (PyCFunction) BeamPyTiePointGrid_readRasterData2, METH_VARARGS, "Reads raster data from this dataset into the user-supplied raster data buffer. \n\nThis method always directly (re-)reads this band's data from its associated data source into the given data\nbuffer.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n@param offsetY    the Y-offset in the raster co-ordinates where reading starts\n@param width      the width of the raster data buffer\n@param height     the height of the raster data buffer\n@param rasterData a raster data buffer receiving the pixels to be read\n@param pm         a monitor to inform the user about progress\n@throws java.io.IOException      if an I/O error occurs\n@throws IllegalArgumentException if the raster is null\n@throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\nwhich this product raster belongs to, has no associated product reader\n@see ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)"},
    {"readRasterDataFully2", (PyCFunction) BeamPyTiePointGrid_readRasterDataFully2, METH_VARARGS, "{@inheritDoc}"},
    {"writeRasterData2", (PyCFunction) BeamPyTiePointGrid_writeRasterData2, METH_VARARGS, "{@inheritDoc}"},
    {"writeRasterDataFully2", (PyCFunction) BeamPyTiePointGrid_writeRasterDataFully2, METH_VARARGS, "{@inheritDoc}"},
    {"acceptVisitor", (PyCFunction) BeamPyTiePointGrid_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor. \n\nThe method simply calls <code>visitor.visit(this)</code>.\n@param visitor the visitor"},
    {"cloneTiePointGrid", (PyCFunction) BeamPyTiePointGrid_cloneTiePointGrid, METH_VARARGS, ""},
    {"createZenithFromElevationAngleTiePointGrid", (PyCFunction) BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid, METH_VARARGS | METH_STATIC, ""},
    {"createSubset", (PyCFunction) BeamPyTiePointGrid_createSubset, METH_VARARGS | METH_STATIC, ""},
    {"getRasterWidth", (PyCFunction) BeamPyTiePointGrid_getRasterWidth, METH_VARARGS, "Returns the width of the raster used by this product raster.\n@return the width of the raster"},
    {"getRasterHeight", (PyCFunction) BeamPyTiePointGrid_getRasterHeight, METH_VARARGS, "Returns the height of the raster used by this product raster.\n@return the height of the raster"},
    {"setModified", (PyCFunction) BeamPyTiePointGrid_setModified, METH_VARARGS, ""},
    {"getGeoCoding", (PyCFunction) BeamPyTiePointGrid_getGeoCoding, METH_VARARGS, "Returns the geo-coding of this {@link RasterDataNode}.\n@return the geo-coding"},
    {"setGeoCoding", (PyCFunction) BeamPyTiePointGrid_setGeoCoding, METH_VARARGS, "Sets the geo-coding for this {@link RasterDataNode}.\nAlso sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_GEOCODING}.\n@param geoCoding the new geo-coding\n@see Product#setGeoCoding(GeoCoding)"},
    {"getPointing", (PyCFunction) BeamPyTiePointGrid_getPointing, METH_VARARGS, "Gets a {@link Pointing} if one is available for this raster.\nThe methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\nsince the last creation of this raster's {@link Pointing} instance.\n@return the pointing object, or null if a pointing is not available"},
    {"canBeOrthorectified", (PyCFunction) BeamPyTiePointGrid_canBeOrthorectified, METH_VARARGS, "Tests if this raster data node can be orthorectified.\n@return true, if so"},
    {"getScalingFactor", (PyCFunction) BeamPyTiePointGrid_getScalingFactor, METH_VARARGS, "Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n<code>1.0</code> (no factor).\n@return the scaling factor\n@see #isScalingApplied()"},
    {"setScalingFactor", (PyCFunction) BeamPyTiePointGrid_setScalingFactor, METH_VARARGS, "Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n@param scalingFactor the scaling factor\n@see #isScalingApplied()"},
    {"getScalingOffset", (PyCFunction) BeamPyTiePointGrid_getScalingOffset, METH_VARARGS, "Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n<code>0.0</code> (no offset).\n@return the scaling offset\n@see #isScalingApplied()"},
    {"setScalingOffset", (PyCFunction) BeamPyTiePointGrid_setScalingOffset, METH_VARARGS, "Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n@param scalingOffset the scaling offset\n@see #isScalingApplied()"},
    {"isLog10Scaled", (PyCFunction) BeamPyTiePointGrid_isLog10Scaled, METH_VARARGS, "Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n<code>false</code>.\n@return whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"setLog10Scaled", (PyCFunction) BeamPyTiePointGrid_setLog10Scaled, METH_VARARGS, "Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data.\n@param log10Scaled whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"isScalingApplied", (PyCFunction) BeamPyTiePointGrid_isScalingApplied, METH_VARARGS, "Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\npixel values. The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n{@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n{@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n<code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n{@link #setPixelFloat(int, int, float)}.\n@return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n@see #getScalingOffset\n@see #getScalingFactor\n@see #isLog10Scaled"},
    {"isValidMaskProperty", (PyCFunction) BeamPyTiePointGrid_isValidMaskProperty, METH_VARARGS | METH_STATIC, "Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n@param propertyName the  name to test\n@return {@code true}, if so."},
    {"isNoDataValueSet", (PyCFunction) BeamPyTiePointGrid_isNoDataValueSet, METH_VARARGS, "Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n{@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n@return true, if so\n@see #isNoDataValueUsed()\n@see #setNoDataValue(double)"},
    {"clearNoDataValue", (PyCFunction) BeamPyTiePointGrid_clearNoDataValue, METH_VARARGS, "Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>."},
    {"isNoDataValueUsed", (PyCFunction) BeamPyTiePointGrid_isNoDataValueUsed, METH_VARARGS, "Tests whether or not the no-data value is used.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return true, if so\n@see #setNoDataValueUsed(boolean)\n@see #isNoDataValueSet()"},
    {"setNoDataValueUsed", (PyCFunction) BeamPyTiePointGrid_setNoDataValueUsed, METH_VARARGS, "Sets whether or not the no-data value is used.\nIf the no-data value is enabled and the no-data value has not been set so far,\na default no-data value it is set with a value of to zero.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n@param noDataValueUsed true, if so\n@see #isNoDataValueUsed()"},
    {"getNoDataValue", (PyCFunction) BeamPyTiePointGrid_getNoDataValue, METH_VARARGS, "Gets the no-data value as a primitive <code>double</code>.\nNote that the value returned is NOT necessarily the same as the value returned by\n{@link #getGeophysicalNoDataValue()} because no scaling is applied.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nThe method returns <code>0.0</code>, if no no-data value has been specified so far.\n@return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n@see #setNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"setNoDataValue", (PyCFunction) BeamPyTiePointGrid_setNoDataValue, METH_VARARGS, "Sets the no-data value as a primitive <code>double</code>.\nNote that the given value is related to the \"raw\", un-scaled raster data.\nIn order to set the geophysical, scaled no-data value use the method\n{@link #setGeophysicalNoDataValue(double)}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n@see #getNoDataValue()\n@see #isNoDataValueSet()"},
    {"getGeophysicalNoDataValue", (PyCFunction) BeamPyTiePointGrid_getGeophysicalNoDataValue, METH_VARARGS, "Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return the geophysical no-data value\n@see #setGeophysicalNoDataValue(double)"},
    {"setGeophysicalNoDataValue", (PyCFunction) BeamPyTiePointGrid_setGeophysicalNoDataValue, METH_VARARGS, "Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n@param noDataValue the new geophysical no-data value\n@see #setGeophysicalNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"getValidPixelExpression", (PyCFunction) BeamPyTiePointGrid_getValidPixelExpression, METH_VARARGS, "Gets the expression that is used to determine whether a pixel is valid or not.\nFor more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return the valid mask expression."},
    {"setValidPixelExpression", (PyCFunction) BeamPyTiePointGrid_setValidPixelExpression, METH_VARARGS, "Sets the expression that is used to determine whether a pixel is valid or not.\nThe valid-pixel expression is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n@param validPixelExpression the valid mask expression, can be null"},
    {"isValidMaskUsed", (PyCFunction) BeamPyTiePointGrid_isValidMaskUsed, METH_VARARGS, "Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\ntrue if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\nThe data-mask is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\n@return true, if so"},
    {"resetValidMask", (PyCFunction) BeamPyTiePointGrid_resetValidMask, METH_VARARGS, "Resets the valid mask of this raster.\nThe mask will be lazily regenerated when requested the next time."},
    {"getValidMaskExpression", (PyCFunction) BeamPyTiePointGrid_getValidMaskExpression, METH_VARARGS, "Gets the expression used for the computation of the mask which identifies valid pixel values.\nIt recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n{@link #getValidPixelExpression() validPixelExpression} properties, if any.\nThe method returns {@code null},  if none of these properties are set.\n@return The expression used for the computation of the mask which identifies valid pixel values,\nor {@code null}.\n@see #getValidPixelExpression()\n@see #getNoDataValue()"},
    {"updateExpression", (PyCFunction) BeamPyTiePointGrid_updateExpression, METH_VARARGS, "{@inheritDoc}"},
    {"hasRasterData", (PyCFunction) BeamPyTiePointGrid_hasRasterData, METH_VARARGS, "Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\nfalse.\n@return true, if so.\n@deprecated since BEAM 4.11. No replacement."},
    {"getRasterData", (PyCFunction) BeamPyTiePointGrid_getRasterData, METH_VARARGS, "Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\n<code>null</code>.\n@return the raster data for this band, or <code>null</code> if data has not been loaded\n@deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\nmethod variants to retrieve or read raster data."},
    {"setRasterData", (PyCFunction) BeamPyTiePointGrid_setRasterData, METH_VARARGS, "Sets the raster data of this dataset.\n\n Note that this method does not copy data at all. If the supplied raster data is compatible with this product\nraster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\ndataset's data!\n@param rasterData the raster data for this dataset\n@see #getRasterData()\n@deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"loadRasterData1", (PyCFunction) BeamPyTiePointGrid_loadRasterData1, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. No replacement."},
    {"loadRasterData2", (PyCFunction) BeamPyTiePointGrid_loadRasterData2, METH_VARARGS, "Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,\n<code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should\nalways return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>\nelements (samples).\n\nThe default implementation of this method does nothing.\n@param pm a monitor to inform the user about progress\n@throws IOException if an I/O error occurs\n@see #unloadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"unloadRasterData", (PyCFunction) BeamPyTiePointGrid_unloadRasterData, METH_VARARGS, "Un-loads the raster data for this <code>RasterDataNode</code>.\n\nIt is up to the implementation whether after this method has been called successfully, the\n<code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.\n\nThe default implementation of this method does nothing.\n@see #loadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"isPixelValid2", (PyCFunction) BeamPyTiePointGrid_isPixelValid2, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\n\n<i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\na synchronised block was used due to problem with the JAI ROI class that has been used in\nthe former implementation.</i>\n@param x the X co-ordinate of the pixel location\n@param y the Y co-ordinate of the pixel location\n@return <code>true</code> if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getSampleInt", (PyCFunction) BeamPyTiePointGrid_getSampleInt, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n\n<i>Note: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n@param x pixel X coordinate\n@param y pixel Y coordinate\n@return The geo-physical sample value."},
    {"getSampleFloat", (PyCFunction) BeamPyTiePointGrid_getSampleFloat, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n\n<i>Note: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n@param x pixel X coordinate\n@param y pixel Y coordinate\n@return The geo-physical sample value."},
    {"isPixelValid1", (PyCFunction) BeamPyTiePointGrid_isPixelValid1, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\n@param pixelIndex the linear pixel index in the range 0 to width * height - 1\n@return <code>true</code> if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"isPixelValid3", (PyCFunction) BeamPyTiePointGrid_isPixelValid3, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nThe method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,\nand secondly, if the pixel is within the ROI (if any).\n@param x   the X co-ordinate of the pixel location\n@param y   the Y co-ordinate of the pixel location\n@param roi the ROI, if null the method returns {@link #isPixelValid(int, int)}\n@return <code>true</code> if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getPixels5", (PyCFunction) BeamPyTiePointGrid_getPixels5, METH_VARARGS, "@see #getPixels(int, int, int, int, int[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixels3", (PyCFunction) BeamPyTiePointGrid_getPixels3, METH_VARARGS, "@see #getPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixels1", (PyCFunction) BeamPyTiePointGrid_getPixels1, METH_VARARGS, "@see #getPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixels5", (PyCFunction) BeamPyTiePointGrid_readPixels5, METH_VARARGS, "@see #readPixels(int, int, int, int, int[], ProgressMonitor)"},
    {"readPixels3", (PyCFunction) BeamPyTiePointGrid_readPixels3, METH_VARARGS, "@see #readPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixels1", (PyCFunction) BeamPyTiePointGrid_readPixels1, METH_VARARGS, "@see #readPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writePixels5", (PyCFunction) BeamPyTiePointGrid_writePixels5, METH_VARARGS, "@see #writePixels(int, int, int, int, int[], ProgressMonitor)"},
    {"writePixels3", (PyCFunction) BeamPyTiePointGrid_writePixels3, METH_VARARGS, "@see #writePixels(int, int, int, int, float[], ProgressMonitor)"},
    {"writePixels1", (PyCFunction) BeamPyTiePointGrid_writePixels1, METH_VARARGS, "@see #writePixels(int, int, int, int, double[], ProgressMonitor)"},
    {"readValidMask", (PyCFunction) BeamPyTiePointGrid_readValidMask, METH_VARARGS, ""},
    {"readRasterDataFully1", (PyCFunction) BeamPyTiePointGrid_readRasterDataFully1, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #readRasterDataFully(ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readRasterData1", (PyCFunction) BeamPyTiePointGrid_readRasterData1, METH_VARARGS, "Reads raster data from the node's associated data source into the given data\nbuffer.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n@param offsetY    the Y-offset in the raster co-ordinates where reading starts\n@param width      the width of the raster data buffer\n@param height     the height of the raster data buffer\n@param rasterData a raster data buffer receiving the pixels to be read\n@throws java.io.IOException      if an I/O error occurs\n@throws IllegalArgumentException if the raster is null\n@throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\nwhich this product raster belongs to, has no associated product reader\n@see ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writeRasterDataFully1", (PyCFunction) BeamPyTiePointGrid_writeRasterDataFully1, METH_VARARGS, ""},
    {"writeRasterData1", (PyCFunction) BeamPyTiePointGrid_writeRasterData1, METH_VARARGS, "@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\nreadPixels()} method variants to set or write raster data."},
    {"createCompatibleRasterData1", (PyCFunction) BeamPyTiePointGrid_createCompatibleRasterData1, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n@return raster data compatible with this product raster\n@see #createCompatibleSceneRasterData"},
    {"createCompatibleSceneRasterData", (PyCFunction) BeamPyTiePointGrid_createCompatibleSceneRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n@return raster data compatible with this product raster\n@see #createCompatibleRasterData"},
    {"createCompatibleRasterData2", (PyCFunction) BeamPyTiePointGrid_createCompatibleRasterData2, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>width*height</code> elements of a compatible data type.\n@param width  the width of the raster data to be created\n@param height the height of the raster data to be created\n@return raster data compatible with this product raster\n@see #createCompatibleRasterData\n@see #createCompatibleSceneRasterData"},
    {"isCompatibleRasterData", (PyCFunction) BeamPyTiePointGrid_isCompatibleRasterData, METH_VARARGS, "Tests whether the given parameters specify a compatible raster or not.\n@param rasterData the raster data\n@param w          the raster width\n@param h          the raster height\n@return {@code true} if so\n@deprecated since BEAM 4.11. No replacement."},
    {"checkCompatibleRasterData", (PyCFunction) BeamPyTiePointGrid_checkCompatibleRasterData, METH_VARARGS, "Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n@param rasterData the raster data\n@param w          the raster width\n@param h          the raster height\n@deprecated since BEAM 4.11. No replacement."},
    {"hasIntPixels", (PyCFunction) BeamPyTiePointGrid_hasIntPixels, METH_VARARGS, "Determines whether this raster data node contains integer samples.\n@return true if this raster data node contains integer samples."},
    {"createTransectProfileData", (PyCFunction) BeamPyTiePointGrid_createTransectProfileData, METH_VARARGS, "Creates a transect profile for the given shape (-outline).\n@param shape the shape\n@return the profile data\n@throws IOException if an I/O error occurs"},
    {"getImageInfo1", (PyCFunction) BeamPyTiePointGrid_getImageInfo1, METH_VARARGS, "Gets the image information for image display.\n@return the image info or null"},
    {"setImageInfo", (PyCFunction) BeamPyTiePointGrid_setImageInfo, METH_VARARGS, "Sets the image information for image display.\n@param imageInfo the image info, can be null"},
    {"fireImageInfoChanged", (PyCFunction) BeamPyTiePointGrid_fireImageInfoChanged, METH_VARARGS, "Notifies listeners that the image (display) information has changed."},
    {"getImageInfo2", (PyCFunction) BeamPyTiePointGrid_getImageInfo2, METH_VARARGS, "Returns the image information for this raster data node.\n\nThe method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.\n@param pm A progress monitor.\n@return A valid image information instance.\n@see #getImageInfo(double[], ProgressMonitor)"},
    {"getImageInfo3", (PyCFunction) BeamPyTiePointGrid_getImageInfo3, METH_VARARGS, "Gets the image creation information.\n\nIf no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is\ncalled with the given parameters passed to this method.\n@param histoSkipAreas Only used, if new image info is created (see <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code>\nmethod).\n@param pm             A progress monitor.\n@return The image creation information."},
    {"createDefaultImageInfo1", (PyCFunction) BeamPyTiePointGrid_createDefaultImageInfo1, METH_VARARGS, "Creates a default image information instance.\n\nAn <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\nthe entire area is skipped.\n@param pm             a monitor to inform the user about progress\n@return a valid image information instance, never <code>null</code>."},
    {"createDefaultImageInfo2", (PyCFunction) BeamPyTiePointGrid_createDefaultImageInfo2, METH_VARARGS, "Creates an instance of a default image information.\n\nAn <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\nthe entire area is skipped.\n@param histogram      the histogram to create the image information.\n@return a valid image information instance, never <code>null</code>."},
    {"getOverlayMaskGroup", (PyCFunction) BeamPyTiePointGrid_getOverlayMaskGroup, METH_VARARGS, "@return The overlay mask group."},
    {"createColorIndexedImage", (PyCFunction) BeamPyTiePointGrid_createColorIndexedImage, METH_VARARGS, "Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\nnull)</code>.\n@param pm a monitor to inform the user about progress\n@return a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createRgbImage", (PyCFunction) BeamPyTiePointGrid_createRgbImage, METH_VARARGS, "Creates an RGB image for this raster data node.\n@param pm a monitor to inform the user about progress\n@return a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"quantizeRasterData1", (PyCFunction) BeamPyTiePointGrid_quantizeRasterData1, METH_VARARGS, ""},
    {"quantizeRasterData2", (PyCFunction) BeamPyTiePointGrid_quantizeRasterData2, METH_VARARGS, ""},
    {"createPixelValidator", (PyCFunction) BeamPyTiePointGrid_createPixelValidator, METH_VARARGS, "Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n@param lineOffset the absolute line offset, zero based\n@param roi        an optional ROI\n@return a new validator instance, never null\n@throws IOException if an I/O error occurs"},
    {"scale", (PyCFunction) BeamPyTiePointGrid_scale, METH_VARARGS, "Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n<code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\nscaling.\n@param v the input value\n@return the scaled value"},
    {"scaleInverse", (PyCFunction) BeamPyTiePointGrid_scaleInverse, METH_VARARGS, "Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n<code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\nscaling.\n@param v the input value\n@return the scaled value"},
    {"getPixelString", (PyCFunction) BeamPyTiePointGrid_getPixelString, METH_VARARGS, "Returns the pixel located at (x,y) as a string value.\n@param x the X co-ordinate of the pixel location\n@param y the Y co-ordinate of the pixel location\n@return the pixel value at (x,y) as string or an error message text"},
    {"isSourceImageSet", (PyCFunction) BeamPyTiePointGrid_isSourceImageSet, METH_VARARGS, "Returns whether the source image is set on this {@code RasterDataNode}.\n@return whether the source image is set.\n@see #getSourceImage()\n@see #setSourceImage(java.awt.image.RenderedImage)\n@see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n@see #createSourceImage()"},
    {"getSourceImage", (PyCFunction) BeamPyTiePointGrid_getSourceImage, METH_VARARGS, "Gets the source image associated with this {@code RasterDataNode}.\n@return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\nthe method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n@see #createSourceImage()\n@see #isSourceImageSet()"},
    {"setSourceImage2", (PyCFunction) BeamPyTiePointGrid_setSourceImage2, METH_VARARGS, "Sets the source image associated with this {@code RasterDataNode}.\n@param sourceImage The source image.\nCan be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}."},
    {"setSourceImage1", (PyCFunction) BeamPyTiePointGrid_setSourceImage1, METH_VARARGS, "Sets the source image associated with this {@code RasterDataNode}.\n@param sourceImage The source image.\nCan be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}."},
    {"isGeophysicalImageSet", (PyCFunction) BeamPyTiePointGrid_isGeophysicalImageSet, METH_VARARGS, "Returns whether the geophysical image is set on this {@code RasterDataNode}.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\n@return whether the geophysical image is set."},
    {"getGeophysicalImage", (PyCFunction) BeamPyTiePointGrid_getGeophysicalImage, METH_VARARGS, "@return The geophysical source image."},
    {"isValidMaskImageSet", (PyCFunction) BeamPyTiePointGrid_isValidMaskImageSet, METH_VARARGS, "Returns wether the valid mask image is set on this {@code RasterDataNode}.\n@return Wether the source image is set."},
    {"getValidMaskImage", (PyCFunction) BeamPyTiePointGrid_getValidMaskImage, METH_VARARGS, "Gets the valid-mask image associated with this {@code RasterDataNode}.\n@return The rendered image."},
    {"isStxSet", (PyCFunction) BeamPyTiePointGrid_isStxSet, METH_VARARGS, ""},
    {"getStx1", (PyCFunction) BeamPyTiePointGrid_getStx1, METH_VARARGS, "Gets the statistics. If statistcs are not yet available,\nthe method will compute (possibly inaccurate) statistics and return those.\n\nIf accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\nshall be used instead.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\n@return The statistics.\n@see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n@see #setStx(Stx)"},
    {"getStx2", (PyCFunction) BeamPyTiePointGrid_getStx2, METH_VARARGS, "Gets the statistics.\nIf the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.\nThis method belongs to preliminary API and may be removed or changed in the future.\n@param accurate If true, accurate statistics are computed.\n@param pm       A progress monitor which is used to compute the new statistics, if required.\n@return The statistics."},
    {"setStx", (PyCFunction) BeamPyTiePointGrid_setStx, METH_VARARGS, "Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\nare really related to this {@code RasterDataNode}'s raster data.\nThe method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\nThis method belongs to preliminary API and may be removed or changed in the future.\n@param stx The statistics."},
    {"getValidShape", (PyCFunction) BeamPyTiePointGrid_getValidShape, METH_VARARGS, "Gets the shape of the area where this raster data contains valid samples.\nThe method returns <code>null</code>, if the entire raster contains valid samples.\n@return The shape of the area where the raster data has samples, can be {@code null}."},
    {"getRoiMaskGroup", (PyCFunction) BeamPyTiePointGrid_getRoiMaskGroup, METH_VARARGS, "@return The roi mask group.\n@deprecated since BEAM 4.10 (no replacement)"},
    {"getDataType", (PyCFunction) BeamPyTiePointGrid_getDataType, METH_VARARGS, "Gets the data type of this data node.\n@return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants"},
    {"getNumDataElems", (PyCFunction) BeamPyTiePointGrid_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyTiePointGrid_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyTiePointGrid_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyTiePointGrid_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyTiePointGrid_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyTiePointGrid_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyTiePointGrid_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyTiePointGrid_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyTiePointGrid_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyTiePointGrid_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyTiePointGrid_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyTiePointGrid_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyTiePointGrid_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"getRawStorageSize2", (PyCFunction) BeamPyTiePointGrid_getRawStorageSize2, METH_VARARGS, "Gets the estimated size in bytes of this product node.\n@param subsetDef if not <code>null</code> the subset may limit the size returned\n@return the size in bytes."},
    {"createCompatibleProductData", (PyCFunction) BeamPyTiePointGrid_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>numElems</code> elements of a compatible data type.\n@param numElems the number of elements, must not be less than one\n@return product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyTiePointGrid_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyTiePointGrid_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyTiePointGrid_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyTiePointGrid_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyTiePointGrid_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyTiePointGrid_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"toString", (PyCFunction) BeamPyTiePointGrid_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyTiePointGrid_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyTiePointGrid_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyTiePointGrid_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyTiePointGrid_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyTiePointGrid_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyTiePointGrid_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"getRawStorageSize1", (PyCFunction) BeamPyTiePointGrid_getRawStorageSize1, METH_VARARGS, "Gets an estimated, raw storage size in bytes of this product node.\n@return the size in bytes."},
    {"fireProductNodeChanged1", (PyCFunction) BeamPyTiePointGrid_fireProductNodeChanged1, METH_VARARGS, ""},
    {"fireProductNodeChanged2", (PyCFunction) BeamPyTiePointGrid_fireProductNodeChanged2, METH_VARARGS, ""},
    {"removeFromFile", (PyCFunction) BeamPyTiePointGrid_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyTiePointGrid_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject TiePointGrid_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "TiePointGrid",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A tie-point grid contains the data for geophysical parameter in remote sensing data products. Tie-point grid are\ntwo-dimensional images which hold their pixel values (samples) in a <code>float</code> array. \n\nUsually, tie-point grids are a sub-sampling of a data product's scene resolution.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    TiePointGrid_Methods,         /* tp_methods */
    TiePointGrid_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef SimpleFeature_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef SimpleFeature_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SimpleFeature_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "SimpleFeature",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SimpleFeature_Methods,         /* tp_methods */
    SimpleFeature_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductSubsetDef_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductSubsetDef_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductSubsetDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductSubsetDef",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The <code>ProductSubsetDef</code> class describes a subset or portion of a remote sensing data product.\n\n Subsets can be spatial or spectral or both. A spatial subset is given through a rectangular region in pixels. The\nspectral subset as a list of band (or channel) names.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductSubsetDef_Methods,         /* tp_methods */
    ProductSubsetDef_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProductWriter_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProductWriter_Methods[] = 
{
    {"getWriterPlugIn", (PyCFunction) BeamPyProductWriter_getWriterPlugIn, METH_VARARGS, "Returns the plug-in which created this product writer.\n@return the product writer plug-in, should never be <code>null</code>"},
    {"getOutput", (PyCFunction) BeamPyProductWriter_getOutput, METH_VARARGS, "Retrives the current output destination object. Thie return value might be <code>null</code> if the\n<code>setOutput</code> has not been called so far.\n@return the output"},
    {"writeProductNodes", (PyCFunction) BeamPyProductWriter_writeProductNodes, METH_VARARGS, "Writes the in-memory representation of a data product.\n\n Whether the band data - the actual pixel values - is written out immediately or later when pixels are\nflushed, is up to the implementation.\n@param product the in-memory representation of the data product\n@param output  an object representing a valid output for this writer, might be a <code>ImageInputStream</code> or\nother <code>Object</code> to use for future decoding.\n@throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is not one of the\nsupported output sources.\n@throws IOException              if an I/O error occurs"},
    {"writeBandRasterData", (PyCFunction) BeamPyProductWriter_writeBandRasterData, METH_VARARGS, "Writes raster data from the given in-memory source buffer into the data sink specified by the given source band\nand region.\n\n<h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample\nvalues given in the source buffer. The method does not modify the pixel data of the given source band at all.\n\n<h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>\nand <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data\nand <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be\n<code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in\nline-by-line order, so the raster X co-ordinate varies faster than the Y.\n\n<h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,\n<code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the\nsource band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates\nsince product writers do not support spectral or spatial subsets.\n@param sourceBand    the source band which identifies the data sink to which to write the sample values\n@param sourceOffsetX the X-offset in the band's raster co-ordinates\n@param sourceOffsetY the Y-offset in the band's raster co-ordinates\n@param sourceWidth   the width of region to be written given in the band's raster co-ordinates\n@param sourceHeight  the height of region to be written given in the band's raster co-ordinates\n@param sourceBuffer  the source buffer which provides the sample values to be written\n@param pm            a monitor to inform the user about progress\n@throws IOException              if an I/O error occurs\n@throws IllegalArgumentException if the number of elements source buffer not equals <code>sourceWidth *\nsourceHeight</code> or the source region is out of the band's raster\n@see Band#getRasterWidth()\n@see Band#getRasterHeight()"},
    {"flush", (PyCFunction) BeamPyProductWriter_flush, METH_VARARGS, "Writes all data in memory to the data sink(s) associated with this writer.\n@throws IOException if an I/O error occurs"},
    {"close", (PyCFunction) BeamPyProductWriter_close, METH_VARARGS, "Closes all output streams currently open. A concrete implementation should call <code>flush</code> before\nperforming the actual close-operation.\n@throws IOException if an I/O error occurs"},
    {"shouldWrite", (PyCFunction) BeamPyProductWriter_shouldWrite, METH_VARARGS, "Returns wether the given product node is to be written.\n@param node the product node\n@return <code>true</code> if so"},
    {"isIncrementalMode", (PyCFunction) BeamPyProductWriter_isIncrementalMode, METH_VARARGS, "Returns whether this product writer writes only modified product nodes.\n@return <code>true</code> if so"},
    {"setIncrementalMode", (PyCFunction) BeamPyProductWriter_setIncrementalMode, METH_VARARGS, "Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress\nlistening.\n@param enabled enables or disables progress listening."},
    {"deleteOutput", (PyCFunction) BeamPyProductWriter_deleteOutput, METH_VARARGS, "Complete deletes the physical representation of the given product from the file system.\n@throws IOException if an I/O error occurs"},
    {"removeBand", (PyCFunction) BeamPyProductWriter_removeBand, METH_VARARGS, "Physically deletes a <code>Band</code> in a product writer's output.\n@param band The band to delete."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductWriter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProductWriter",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "An interface that supports writing a complete data product tree and single band rasters.\n@see ProductReader",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductWriter_Methods,         /* tp_methods */
    ProductWriter_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef MetadataAttribute_Members[] = {
//     {"PROPERTY_NAME_DATA", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_READ_ONLY", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_SYNTHETIC", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_UNIT", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_NAME", 0, 0, READONLY, NULL}
//     {"PROPERTY_NAME_DESCRIPTION", 0, 0, READONLY, NULL}
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef MetadataAttribute_Methods[] = 
{
    {"newMetadataAttribute", (PyCFunction) BeamPyMetadataAttribute_newMetadataAttribute, METH_VARARGS | METH_STATIC, ""},
    {"getParentElement", (PyCFunction) BeamPyMetadataAttribute_getParentElement, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyMetadataAttribute_equals, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyMetadataAttribute_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls <code>visitor.visit(this)</code>.\n@param visitor the visitor"},
    {"createDeepClone", (PyCFunction) BeamPyMetadataAttribute_createDeepClone, METH_VARARGS, ""},
    {"getDataType", (PyCFunction) BeamPyMetadataAttribute_getDataType, METH_VARARGS, "Gets the data type of this data node.\n@return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants"},
    {"isFloatingPointType", (PyCFunction) BeamPyMetadataAttribute_isFloatingPointType, METH_VARARGS, "Tests whether the data type of this node is a floating point type.\n@return true, if so"},
    {"getNumDataElems", (PyCFunction) BeamPyMetadataAttribute_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyMetadataAttribute_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyMetadataAttribute_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyMetadataAttribute_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyMetadataAttribute_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyMetadataAttribute_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyMetadataAttribute_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyMetadataAttribute_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyMetadataAttribute_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyMetadataAttribute_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyMetadataAttribute_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyMetadataAttribute_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyMetadataAttribute_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"dispose", (PyCFunction) BeamPyMetadataAttribute_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\nOverrides of this method should always call <code>super.dispose();</code> after disposing this instance."},
    {"createCompatibleProductData", (PyCFunction) BeamPyMetadataAttribute_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n<code>numElems</code> elements of a compatible data type.\n@param numElems the number of elements, must not be less than one\n@return product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyMetadataAttribute_getOwner, METH_VARARGS, "@return The owner node of this node."},
    {"getName", (PyCFunction) BeamPyMetadataAttribute_getName, METH_VARARGS, "@return This node's name."},
    {"setName", (PyCFunction) BeamPyMetadataAttribute_setName, METH_VARARGS, "Sets this product's name.\n@param name The name."},
    {"getDescription", (PyCFunction) BeamPyMetadataAttribute_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\n@return a description or <code>null</code>"},
    {"setDescription", (PyCFunction) BeamPyMetadataAttribute_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\n@param description a description, can be <code>null</code>"},
    {"isModified", (PyCFunction) BeamPyMetadataAttribute_isModified, METH_VARARGS, "Returns whether or not this node is modified.\n@return <code>true</code> if so"},
    {"setModified", (PyCFunction) BeamPyMetadataAttribute_setModified, METH_VARARGS, "Sets this node's modified flag.\n\nIf the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\ntrue.\n@param modified whether or not this node is beeing marked as modified.\n@see Product#fireNodeChanged"},
    {"toString", (PyCFunction) BeamPyMetadataAttribute_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyMetadataAttribute_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  <code>\\/:*?\"&lt;&gt;|</code>\n@param name the name to test\n@return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise"},
    {"getProduct", (PyCFunction) BeamPyMetadataAttribute_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\n@return the product, or <code>null</code> if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyMetadataAttribute_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\n@return the product reader, or <code>null</code> if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyMetadataAttribute_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\n@return the product writer, or <code>null</code> if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyMetadataAttribute_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\nproduct with the reference number <code>2</code>.\n@return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n<code>null</code>\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyMetadataAttribute_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n<code>2</code>.\n@return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n<code>null</code> if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyMetadataAttribute_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\n@param oldExternalName The old node name.\n@param newExternalName The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyMetadataAttribute_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\n@param productWriter the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyMetadataAttribute_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MetadataAttribute_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MetadataAttribute",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A <code>MetadataAttribute</code> is part of a <code>{@link MetadataElement}</code> and represents a key/value pair.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MetadataAttribute_Methods,         /* tp_methods */
    MetadataAttribute_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ProgressMonitor_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ProgressMonitor_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProgressMonitor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ProgressMonitor",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProgressMonitor_Methods,         /* tp_methods */
    ProgressMonitor_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef VectorDataNode_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef VectorDataNode_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject VectorDataNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "VectorDataNode",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A container which allows to store vector data in the BEAM product model.\n\nThis is a preliminary API under construction for BEAM 4.7. Not intended for public use.\n@see Product#getVectorDataGroup()",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    VectorDataNode_Methods,         /* tp_methods */
    VectorDataNode_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef GeneralPath_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef GeneralPath_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeneralPath_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "GeneralPath",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeneralPath_Methods,         /* tp_methods */
    GeneralPath_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef ImageInputStream_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef ImageInputStream_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInputStream_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "ImageInputStream",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInputStream_Methods,         /* tp_methods */
    ImageInputStream_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMemberDef RenderingHints_Members[] = {
    {NULL, 0, 0, 0, NULL} /*Sentinel*/
};

static PyMethodDef RenderingHints_Methods[] = 
{
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderingHints_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RenderingHints",               /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderingHints_Methods,         /* tp_methods */
    RenderingHints_Members,         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};


int beampy_registerJObjectSubtypes(PyObject* module)
{
    // Register Shape:
    Shape_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Shape_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Shape_Type);
    PyModule_AddObject(module, "Shape", (PyObject*) &Shape_Type);

    // Register MapTransform:
    MapTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapTransform_Type);
    PyModule_AddObject(module, "MapTransform", (PyObject*) &MapTransform_Type);

    // Register ImageGeometry:
    ImageGeometry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageGeometry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageGeometry_Type);
    PyModule_AddObject(module, "ImageGeometry", (PyObject*) &ImageGeometry_Type);

    // Register Parser:
    Parser_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Parser_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Parser_Type);
    PyModule_AddObject(module, "Parser", (PyObject*) &Parser_Type);

    // Register GeoCoding:
    GeoCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoCoding_Type);
    PyModule_AddObject(module, "GeoCoding", (PyObject*) &GeoCoding_Type);

    // Register ProductData:
    ProductData_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductData_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductData_Type);
    PyModule_AddObject(module, "ProductData", (PyObject*) &ProductData_Type);

    // Register AffineTransform:
    AffineTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&AffineTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&AffineTransform_Type);
    PyModule_AddObject(module, "AffineTransform", (PyObject*) &AffineTransform_Type);

    // Register Mask:
    Mask_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Mask_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Mask_Type);
    PyModule_AddObject(module, "Mask", (PyObject*) &Mask_Type);

    // Register Double:
    Double_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Double_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Double_Type);
    PyModule_AddObject(module, "Double", (PyObject*) &Double_Type);

    // Register GPF:
    GPF_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GPF_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GPF_Type);
    PyModule_AddObject(module, "GPF", (PyObject*) &GPF_Type);

    // Register IndexCoding:
    IndexCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexCoding_Type);
    PyModule_AddObject(module, "IndexCoding", (PyObject*) &IndexCoding_Type);

    // Register Term:
    Term_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Term_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Term_Type);
    PyModule_AddObject(module, "Term", (PyObject*) &Term_Type);

    // Register RasterDataNode:
    RasterDataNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RasterDataNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RasterDataNode_Type);
    PyModule_AddObject(module, "RasterDataNode", (PyObject*) &RasterDataNode_Type);

    // Register Class:
    Class_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Class_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Class_Type);
    PyModule_AddObject(module, "Class", (PyObject*) &Class_Type);

    // Register Product_AutoGrouping:
    Product_AutoGrouping_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Product_AutoGrouping_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Product_AutoGrouping_Type);
    PyModule_AddObject(module, "Product_AutoGrouping", (PyObject*) &Product_AutoGrouping_Type);

    // Register PixelPos:
    PixelPos_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PixelPos_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PixelPos_Type);
    PyModule_AddObject(module, "PixelPos", (PyObject*) &PixelPos_Type);

    // Register BitRaster:
    BitRaster_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BitRaster_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BitRaster_Type);
    PyModule_AddObject(module, "BitRaster", (PyObject*) &BitRaster_Type);

    // Register ImageOutputStream:
    ImageOutputStream_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageOutputStream_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageOutputStream_Type);
    PyModule_AddObject(module, "ImageOutputStream", (PyObject*) &ImageOutputStream_Type);

    // Register Stx:
    Stx_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Stx_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Stx_Type);
    PyModule_AddObject(module, "Stx", (PyObject*) &Stx_Type);

    // Register Rectangle:
    Rectangle_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Rectangle_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Rectangle_Type);
    PyModule_AddObject(module, "Rectangle", (PyObject*) &Rectangle_Type);

    // Register Dimension:
    Dimension_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Dimension_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Dimension_Type);
    PyModule_AddObject(module, "Dimension", (PyObject*) &Dimension_Type);

    // Register ProductIO:
    ProductIO_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductIO_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductIO_Type);
    PyModule_AddObject(module, "ProductIO", (PyObject*) &ProductIO_Type);

    // Register ProductNode:
    ProductNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNode_Type);
    PyModule_AddObject(module, "ProductNode", (PyObject*) &ProductNode_Type);

    // Register AngularDirection:
    AngularDirection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&AngularDirection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&AngularDirection_Type);
    PyModule_AddObject(module, "AngularDirection", (PyObject*) &AngularDirection_Type);

    // Register SimpleFeatureType:
    SimpleFeatureType_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SimpleFeatureType_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SimpleFeatureType_Type);
    PyModule_AddObject(module, "SimpleFeatureType", (PyObject*) &SimpleFeatureType_Type);

    // Register SampleCoding:
    SampleCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SampleCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SampleCoding_Type);
    PyModule_AddObject(module, "SampleCoding", (PyObject*) &SampleCoding_Type);

    // Register Object:
    Object_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Object_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Object_Type);
    PyModule_AddObject(module, "Object", (PyObject*) &Object_Type);

    // Register ProductReader:
    ProductReader_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductReader_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductReader_Type);
    PyModule_AddObject(module, "ProductReader", (PyObject*) &ProductReader_Type);

    // Register ProductReaderPlugIn:
    ProductReaderPlugIn_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductReaderPlugIn_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductReaderPlugIn_Type);
    PyModule_AddObject(module, "ProductReaderPlugIn", (PyObject*) &ProductReaderPlugIn_Type);

    // Register Integer:
    Integer_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Integer_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Integer_Type);
    PyModule_AddObject(module, "Integer", (PyObject*) &Integer_Type);

    // Register ProductData_UTC:
    ProductData_UTC_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductData_UTC_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductData_UTC_Type);
    PyModule_AddObject(module, "ProductData_UTC", (PyObject*) &ProductData_UTC_Type);

    // Register Band:
    Band_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Band_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Band_Type);
    PyModule_AddObject(module, "Band", (PyObject*) &Band_Type);

    // Register ColorPaletteDef_Point:
    ColorPaletteDef_Point_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ColorPaletteDef_Point_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ColorPaletteDef_Point_Type);
    PyModule_AddObject(module, "ColorPaletteDef_Point", (PyObject*) &ColorPaletteDef_Point_Type);

    // Register RenderedImage:
    RenderedImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderedImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderedImage_Type);
    PyModule_AddObject(module, "RenderedImage", (PyObject*) &RenderedImage_Type);

    // Register Placemark:
    Placemark_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Placemark_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Placemark_Type);
    PyModule_AddObject(module, "Placemark", (PyObject*) &Placemark_Type);

    // Register IndexValidator:
    IndexValidator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexValidator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexValidator_Type);
    PyModule_AddObject(module, "IndexValidator", (PyObject*) &IndexValidator_Type);

    // Register Area:
    Area_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Area_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Area_Type);
    PyModule_AddObject(module, "Area", (PyObject*) &Area_Type);

    // Register ComponentColorModel:
    ComponentColorModel_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ComponentColorModel_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ComponentColorModel_Type);
    PyModule_AddObject(module, "ComponentColorModel", (PyObject*) &ComponentColorModel_Type);

    // Register Iterator:
    Iterator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Iterator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Iterator_Type);
    PyModule_AddObject(module, "Iterator", (PyObject*) &Iterator_Type);

    // Register MathTransform:
    MathTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MathTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MathTransform_Type);
    PyModule_AddObject(module, "MathTransform", (PyObject*) &MathTransform_Type);

    // Register CoordinateReferenceSystem:
    CoordinateReferenceSystem_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&CoordinateReferenceSystem_Type) < 0) {
        return 0;
    }
    Py_INCREF(&CoordinateReferenceSystem_Type);
    PyModule_AddObject(module, "CoordinateReferenceSystem", (PyObject*) &CoordinateReferenceSystem_Type);

    // Register ProductWriterPlugIn:
    ProductWriterPlugIn_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductWriterPlugIn_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductWriterPlugIn_Type);
    PyModule_AddObject(module, "ProductWriterPlugIn", (PyObject*) &ProductWriterPlugIn_Type);

    // Register File:
    File_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&File_Type) < 0) {
        return 0;
    }
    Py_INCREF(&File_Type);
    PyModule_AddObject(module, "File", (PyObject*) &File_Type);

    // Register GeoPos:
    GeoPos_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoPos_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoPos_Type);
    PyModule_AddObject(module, "GeoPos", (PyObject*) &GeoPos_Type);

    // Register ProductNodeGroup:
    ProductNodeGroup_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNodeGroup_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNodeGroup_Type);
    PyModule_AddObject(module, "ProductNodeGroup", (PyObject*) &ProductNodeGroup_Type);

    // Register MapProjection:
    MapProjection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapProjection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapProjection_Type);
    PyModule_AddObject(module, "MapProjection", (PyObject*) &MapProjection_Type);

    // Register ProductManager:
    ProductManager_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductManager_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductManager_Type);
    PyModule_AddObject(module, "ProductManager", (PyObject*) &ProductManager_Type);

    // Register FlagCoding:
    FlagCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&FlagCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&FlagCoding_Type);
    PyModule_AddObject(module, "FlagCoding", (PyObject*) &FlagCoding_Type);

    // Register IndexColorModel:
    IndexColorModel_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexColorModel_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexColorModel_Type);
    PyModule_AddObject(module, "IndexColorModel", (PyObject*) &IndexColorModel_Type);

    // Register Operator:
    Operator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Operator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Operator_Type);
    PyModule_AddObject(module, "Operator", (PyObject*) &Operator_Type);

    // Register OperatorSpiRegistry:
    OperatorSpiRegistry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&OperatorSpiRegistry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&OperatorSpiRegistry_Type);
    PyModule_AddObject(module, "OperatorSpiRegistry", (PyObject*) &OperatorSpiRegistry_Type);

    // Register ImageInfo_HistogramMatching:
    ImageInfo_HistogramMatching_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInfo_HistogramMatching_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInfo_HistogramMatching_Type);
    PyModule_AddObject(module, "ImageInfo_HistogramMatching", (PyObject*) &ImageInfo_HistogramMatching_Type);

    // Register BitmaskDef:
    BitmaskDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BitmaskDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BitmaskDef_Type);
    PyModule_AddObject(module, "BitmaskDef", (PyObject*) &BitmaskDef_Type);

    // Register ProductNodeListener:
    ProductNodeListener_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNodeListener_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNodeListener_Type);
    PyModule_AddObject(module, "ProductNodeListener", (PyObject*) &ProductNodeListener_Type);

    // Register ProductUtils:
    ProductUtils_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductUtils_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductUtils_Type);
    PyModule_AddObject(module, "ProductUtils", (PyObject*) &ProductUtils_Type);

    // Register Map:
    Map_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Map_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Map_Type);
    PyModule_AddObject(module, "Map", (PyObject*) &Map_Type);

    // Register MetadataElement:
    MetadataElement_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MetadataElement_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MetadataElement_Type);
    PyModule_AddObject(module, "MetadataElement", (PyObject*) &MetadataElement_Type);

    // Register Datum:
    Datum_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Datum_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Datum_Type);
    PyModule_AddObject(module, "Datum", (PyObject*) &Datum_Type);

    // Register Pointing:
    Pointing_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Pointing_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Pointing_Type);
    PyModule_AddObject(module, "Pointing", (PyObject*) &Pointing_Type);

    // Register Color:
    Color_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Color_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Color_Type);
    PyModule_AddObject(module, "Color", (PyObject*) &Color_Type);

    // Register PlacemarkDescriptor:
    PlacemarkDescriptor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PlacemarkDescriptor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PlacemarkDescriptor_Type);
    PyModule_AddObject(module, "PlacemarkDescriptor", (PyObject*) &PlacemarkDescriptor_Type);

    // Register PointingFactory:
    PointingFactory_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PointingFactory_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PointingFactory_Type);
    PyModule_AddObject(module, "PointingFactory", (PyObject*) &PointingFactory_Type);

    // Register TransectProfileData:
    TransectProfileData_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&TransectProfileData_Type) < 0) {
        return 0;
    }
    Py_INCREF(&TransectProfileData_Type);
    PyModule_AddObject(module, "TransectProfileData", (PyObject*) &TransectProfileData_Type);

    // Register PlacemarkGroup:
    PlacemarkGroup_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PlacemarkGroup_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PlacemarkGroup_Type);
    PyModule_AddObject(module, "PlacemarkGroup", (PyObject*) &PlacemarkGroup_Type);

    // Register Product:
    Product_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Product_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Product_Type);
    PyModule_AddObject(module, "Product", (PyObject*) &Product_Type);

    // Register Point2D:
    Point2D_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Point2D_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Point2D_Type);
    PyModule_AddObject(module, "Point2D", (PyObject*) &Point2D_Type);

    // Register ProductVisitor:
    ProductVisitor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductVisitor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductVisitor_Type);
    PyModule_AddObject(module, "ProductVisitor", (PyObject*) &ProductVisitor_Type);

    // Register Scaling:
    Scaling_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Scaling_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Scaling_Type);
    PyModule_AddObject(module, "Scaling", (PyObject*) &Scaling_Type);

    // Register WritableNamespace:
    WritableNamespace_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&WritableNamespace_Type) < 0) {
        return 0;
    }
    Py_INCREF(&WritableNamespace_Type);
    PyModule_AddObject(module, "WritableNamespace", (PyObject*) &WritableNamespace_Type);

    // Register Set:
    Set_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Set_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Set_Type);
    PyModule_AddObject(module, "Set", (PyObject*) &Set_Type);

    // Register MultiLevelImage:
    MultiLevelImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MultiLevelImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MultiLevelImage_Type);
    PyModule_AddObject(module, "MultiLevelImage", (PyObject*) &MultiLevelImage_Type);

    // Register ROI:
    ROI_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ROI_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ROI_Type);
    PyModule_AddObject(module, "ROI", (PyObject*) &ROI_Type);

    // Register RenderingHints_Key:
    RenderingHints_Key_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderingHints_Key_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderingHints_Key_Type);
    PyModule_AddObject(module, "RenderingHints_Key", (PyObject*) &RenderingHints_Key_Type);

    // Register Collection:
    Collection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Collection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Collection_Type);
    PyModule_AddObject(module, "Collection", (PyObject*) &Collection_Type);

    // Register ProductManager_Listener:
    ProductManager_Listener_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductManager_Listener_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductManager_Listener_Type);
    PyModule_AddObject(module, "ProductManager_Listener", (PyObject*) &ProductManager_Listener_Type);

    // Register GeoTIFFMetadata:
    GeoTIFFMetadata_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoTIFFMetadata_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoTIFFMetadata_Type);
    PyModule_AddObject(module, "GeoTIFFMetadata", (PyObject*) &GeoTIFFMetadata_Type);

    // Register ColorPaletteDef:
    ColorPaletteDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ColorPaletteDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ColorPaletteDef_Type);
    PyModule_AddObject(module, "ColorPaletteDef", (PyObject*) &ColorPaletteDef_Type);

    // Register MapInfo:
    MapInfo_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapInfo_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapInfo_Type);
    PyModule_AddObject(module, "MapInfo", (PyObject*) &MapInfo_Type);

    // Register ImageInfo:
    ImageInfo_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInfo_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInfo_Type);
    PyModule_AddObject(module, "ImageInfo", (PyObject*) &ImageInfo_Type);

    // Register Histogram:
    Histogram_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Histogram_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Histogram_Type);
    PyModule_AddObject(module, "Histogram", (PyObject*) &Histogram_Type);

    // Register String:
    String_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&String_Type) < 0) {
        return 0;
    }
    Py_INCREF(&String_Type);
    PyModule_AddObject(module, "String", (PyObject*) &String_Type);

    // Register BufferedImage:
    BufferedImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BufferedImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BufferedImage_Type);
    PyModule_AddObject(module, "BufferedImage", (PyObject*) &BufferedImage_Type);

    // Register RGBChannelDef:
    RGBChannelDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RGBChannelDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RGBChannelDef_Type);
    PyModule_AddObject(module, "RGBChannelDef", (PyObject*) &RGBChannelDef_Type);

    // Register TiePointGrid:
    TiePointGrid_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&TiePointGrid_Type) < 0) {
        return 0;
    }
    Py_INCREF(&TiePointGrid_Type);
    PyModule_AddObject(module, "TiePointGrid", (PyObject*) &TiePointGrid_Type);

    // Register SimpleFeature:
    SimpleFeature_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SimpleFeature_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SimpleFeature_Type);
    PyModule_AddObject(module, "SimpleFeature", (PyObject*) &SimpleFeature_Type);

    // Register ProductSubsetDef:
    ProductSubsetDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductSubsetDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductSubsetDef_Type);
    PyModule_AddObject(module, "ProductSubsetDef", (PyObject*) &ProductSubsetDef_Type);

    // Register ProductWriter:
    ProductWriter_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductWriter_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductWriter_Type);
    PyModule_AddObject(module, "ProductWriter", (PyObject*) &ProductWriter_Type);

    // Register MetadataAttribute:
    MetadataAttribute_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MetadataAttribute_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MetadataAttribute_Type);
    PyModule_AddObject(module, "MetadataAttribute", (PyObject*) &MetadataAttribute_Type);

    // Register ProgressMonitor:
    ProgressMonitor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProgressMonitor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProgressMonitor_Type);
    PyModule_AddObject(module, "ProgressMonitor", (PyObject*) &ProgressMonitor_Type);

    // Register VectorDataNode:
    VectorDataNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&VectorDataNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&VectorDataNode_Type);
    PyModule_AddObject(module, "VectorDataNode", (PyObject*) &VectorDataNode_Type);

    // Register GeneralPath:
    GeneralPath_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeneralPath_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeneralPath_Type);
    PyModule_AddObject(module, "GeneralPath", (PyObject*) &GeneralPath_Type);

    // Register ImageInputStream:
    ImageInputStream_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInputStream_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInputStream_Type);
    PyModule_AddObject(module, "ImageInputStream", (PyObject*) &ImageInputStream_Type);

    // Register RenderingHints:
    RenderingHints_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderingHints_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderingHints_Type);
    PyModule_AddObject(module, "RenderingHints", (PyObject*) &RenderingHints_Type);

    return 1;
}

// <<<<<<<< Begin include from PyCModuleGenerator-stub-pymodule.c

/**
 * The BEAM/Python API module definition structure.
 * The variable 'BeamPy_Methods' is defined in the generated file 'beampy_module.c'.
 */
static struct PyModuleDef BeamPy_Module =
{
   PyModuleDef_HEAD_INIT,
   "beampy",           /* Name of the Python module */
   "BEAM Python API",  /* Module documentation */
   -1,                 /* Size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
   BeamPy_Functions    /* Structure containing global beampy-functions */
};

int beampy_registerJObjectSubtypes(PyObject* module);


/**
 * Called by the Python interpreter once immediately after the shared lib _beampy.pyk has been loaded.
 */
PyMODINIT_FUNC PyInit_beampy()
{
    PyObject* module;

    fprintf(stdout, "beampy: enter PyInit_beampy()\n");

    /////////////////////////////////////////////////////////////////////////
    // Create BeamPy_Module

    module = PyModule_Create(&BeamPy_Module);
    if (module == NULL) {
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Define exception type BeamPy_Error ('beampy.error')

    BeamPy_Error = PyErr_NewException("beampy.BeamError", NULL, NULL);
    Py_INCREF(BeamPy_Error);
    PyModule_AddObject(module, "error", BeamPy_Error);

    /////////////////////////////////////////////////////////////////////////
    // Register CArray_Type

    if (PyType_Ready(&CArray_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&CArray_Type);
    PyModule_AddObject(module, "CArray", (PyObject*) &CArray_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register JObject_Type ('JObject')
    //
    if (PyType_Ready(&JObject_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&JObject_Type);
    PyModule_AddObject(module, "JObject", (PyObject*) &JObject_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register JObjectArray_Type ('JObjectArray')
    //
    JObjectArray_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&JObject_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&JObjectArray_Type);
    PyModule_AddObject(module, "JObjectArray", (PyObject*) &JObjectArray_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register BEAM JObject Sub-types
    //
    if (!beampy_registerJObjectSubtypes(module)) {
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Create JVM

    if (!beam_createJvmWithDefaults()) {
        PyErr_SetString(BeamPy_Error, "Failed to create Java VM");
        return NULL;
    }

    fprintf(stdout, "beampy: exit PyInit_beampy()\n");

    return module;
}

// >>>>>>>> End include from PyCModuleGenerator-stub-pymodule.c

// <<<<<<<< Begin include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.c

JavaVM* jvm = NULL;
JNIEnv* jenv = NULL;

/* Shared library callbacks (called if this module's code is linked into a shared library and loaded by a Java VM) */

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved)
{
    fprintf(stdout, "beampy: JNI_OnLoad() called\n");
    jvm = vm;
    (*jvm)->GetEnv(vm, &jenv, JNI_VERSION_1_6);
    return JNI_VERSION_1_6;
}

JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved)
{
    fprintf(stdout, "beampy: JNI_OnUnload() called\n");
    jvm = NULL;
    jenv = NULL;
}

/* Java VM functions that must be used if this module is used in stand-alone mode (= not loaded as shared library by a Java VM) */

boolean beam_isJvmCreated()
{
    return jvm != NULL;
}

boolean beam_createJvm(const char* option_strings[], int option_count)
{
    JavaVMInitArgs vm_args; 
    JavaVMOption* options;
    int res;

    if (jvm != NULL) {
        return JNI_TRUE;
    }

    fprintf(stdout, "beampy: creating Java VM using %d options\n", option_count);

    options = (JavaVMOption*) calloc(option_count, sizeof (JavaVMOption));
    {
        int i;
        for (i = 0; i < option_count; i++) {
            options[i].optionString = (char*) option_strings[i];
            fprintf(stdout, "beampy: option(%d) = \"%s\"\n", i, options[i].optionString);
        }
    }

    vm_args.version = JNI_VERSION_1_6;
    vm_args.options = options;
    vm_args.nOptions = option_count;
    vm_args.ignoreUnrecognized = 0;
    res = JNI_CreateJavaVM(&jvm, (void**) &jenv, &vm_args);

    free(options);

    if (res != 0) {
        fprintf(stderr, "beampy: JNI_CreateJavaVM failed with exit code %d\n", res);
        return JNI_FALSE;
    } else {
        fprintf(stdout, "beampy: Java VM successfully created\n");
    }

    return JNI_TRUE;
}

boolean beam_destroyJvm()
{
    jint res;

    if (jvm == NULL) {
        return JNI_TRUE;
    }
    
    res = (*jvm)->DestroyJavaVM(jvm);
    if (res != 0) {
        fprintf(stderr, "beampy: DestroyJavaVM failed with exit code %d\n", res);
        return JNI_FALSE;
    }

    jvm = NULL;
    jenv = NULL;
    return JNI_TRUE;
}

#ifdef WIN32
#define OS_FILESEP "\\"
#define OS_PATHSEP ";"
#else
#define OS_FILESEP "/"
#define OS_PATHSEP ":"
#endif

void beam_createJvmClassPathOptionHandler(const char* parent_dir, const char* file_name, int is_dir, void* user_data)
{
    char** class_path = (char**) user_data;

    if (strcmp(file_name, ".") == 0 || strcmp(file_name, "..") == 0) {
        return;
    }

    if (*class_path == NULL) {
        Util_appendString(class_path, "-Djava.class.path=");
    } else {
        Util_appendString(class_path, OS_PATHSEP);
    }

    Util_appendString(class_path, parent_dir);
    Util_appendString(class_path, OS_FILESEP);
    Util_appendString(class_path, file_name);
}

char* beam_createJvmClassPathOption()
{
    const char* beam_home;
    char* path;
    char* class_path;

    beam_home = getenv("BEAM_HOME");
    if (beam_home == NULL) {
        fprintf(stderr, "beampy: missing environment variable 'BEAM_HOME'\n");
        fprintf(stderr, "beampy: please make sure 'BEAM_HOME' points to a valid BEAM installation directory\n");
        return NULL;
    }

    class_path = NULL;

    path = NULL;
    Util_appendString(&path, beam_home);
    Util_appendString(&path, OS_FILESEP);
    Util_appendString(&path, "lib");
    Util_listDir(path, beam_createJvmClassPathOptionHandler, &class_path);
    free(path);

    path = NULL;
    Util_appendString(&path, beam_home);
    Util_appendString(&path, OS_FILESEP);
    Util_appendString(&path, "modules");
    Util_listDir(path, beam_createJvmClassPathOptionHandler, &class_path);
    free(path);

    return class_path;
}

#undef OS_FILESEP
#undef OS_PATHSEP

boolean beam_createJvmWithDefaults()
{
    const char* jvm_options[5];
    char* class_path_option;
    boolean result;

    class_path_option = beam_createJvmClassPathOption();
    if (class_path_option == NULL) {
        const char* beam_home = getenv("BEAM_HOME");
        fprintf(stderr, "beampy: failed to construct Java classpath\n");
        if (beam_home != NULL) {
            fprintf(stderr, "beampy: please make sure 'BEAM_HOME' points to a valid BEAM installation directory\n");
            fprintf(stderr, "beampy: currently BEAM_HOME = %s\n", beam_home);
        }
        return JNI_FALSE;
    }

    fprintf(stdout, "beampy: %s\n", class_path_option);

    jvm_options[0] = class_path_option;
    /*jvm_options[1] = "-Djava.library.path=c:\\mylibs";*/
    jvm_options[1] = "-Djava.awt.headless=true";
    jvm_options[2] = "-Xms128M";
    jvm_options[3] = "-Xmx512M";
    jvm_options[4] = "-verbose:jni";

    result = beam_createJvm(jvm_options, 5);

    free(class_path_option);

    return result;
}



jclass beam_findJvmClass(const char* classResourceName)
{
    jclass c = (*jenv)->FindClass(jenv, classResourceName);
    if (c == NULL) {
        fprintf(stderr, "beampy: Java class not found: %s\n", classResourceName);
    }
    return c;
}


// todo - the following functions actually belong in another module because they expect String and Object typedefs to be present

String String_newString(const char* chars)
{
    jstring str = (*jenv)->NewStringUTF(jenv, chars);
    return (*jenv)->NewGlobalRef(jenv, str);
}

void Object_delete(Object object)
{
    if (object != NULL) {
        (*jenv)->DeleteGlobalRef(jenv, object);
    }
}

// >>>>>>>> End include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.c

int beam_initApi()
{
    static int exitCode = -1;
    if (exitCode >= 0) {
        return exitCode;
    }

    if (!beam_isJvmCreated() && !beam_createJvmWithDefaults()) {
        exitCode = 1;
        return exitCode;
    }

    classBoolean = beam_findJvmClass("java/lang/Boolean");
    if (classBoolean == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Boolean\n");
        exitCode = 1000;
        return exitCode;
    }

    classByte = beam_findJvmClass("java/lang/Byte");
    if (classByte == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Byte\n");
        exitCode = 1001;
        return exitCode;
    }

    classCharacter = beam_findJvmClass("java/lang/Character");
    if (classCharacter == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Character\n");
        exitCode = 1002;
        return exitCode;
    }

    classShort = beam_findJvmClass("java/lang/Short");
    if (classShort == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Short\n");
        exitCode = 1003;
        return exitCode;
    }

    classInteger = beam_findJvmClass("java/lang/Integer");
    if (classInteger == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Integer\n");
        exitCode = 1004;
        return exitCode;
    }

    classLong = beam_findJvmClass("java/lang/Long");
    if (classLong == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Long\n");
        exitCode = 1005;
        return exitCode;
    }

    classFloat = beam_findJvmClass("java/lang/Float");
    if (classFloat == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Float\n");
        exitCode = 1006;
        return exitCode;
    }

    classDouble = beam_findJvmClass("java/lang/Double");
    if (classDouble == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Double\n");
        exitCode = 1007;
        return exitCode;
    }

    classString = beam_findJvmClass("java/lang/String");
    if (classString == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/String\n");
        exitCode = 1008;
        return exitCode;
    }

    classHashMap = beam_findJvmClass("java/util/HashMap");
    if (classHashMap == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/HashMap\n");
        exitCode = 1009;
        return exitCode;
    }

    classHashSet = beam_findJvmClass("java/util/HashSet");
    if (classHashSet == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/HashSet\n");
        exitCode = 1010;
        return exitCode;
    }

    classArrayList = beam_findJvmClass("java/util/ArrayList");
    if (classArrayList == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/ArrayList\n");
        exitCode = 1011;
        return exitCode;
    }

    classGeoCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/GeoCoding");
    if (classGeoCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/GeoCoding\n");
        exitCode = 2000;
        return exitCode;
    }

    classProductWriter = beam_findJvmClass("org/esa/beam/framework/dataio/ProductWriter");
    if (classProductWriter == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductWriter\n");
        exitCode = 2001;
        return exitCode;
    }

    classGPF = beam_findJvmClass("org/esa/beam/framework/gpf/GPF");
    if (classGPF == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/gpf/GPF\n");
        exitCode = 2002;
        return exitCode;
    }

    classIndexCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/IndexCoding");
    if (classIndexCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/IndexCoding\n");
        exitCode = 2003;
        return exitCode;
    }

    classPixelPos = beam_findJvmClass("org/esa/beam/framework/datamodel/PixelPos");
    if (classPixelPos == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/PixelPos\n");
        exitCode = 2004;
        return exitCode;
    }

    classProductIO = beam_findJvmClass("org/esa/beam/framework/dataio/ProductIO");
    if (classProductIO == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductIO\n");
        exitCode = 2005;
        return exitCode;
    }

    classPlacemark = beam_findJvmClass("org/esa/beam/framework/datamodel/Placemark");
    if (classPlacemark == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Placemark\n");
        exitCode = 2006;
        return exitCode;
    }

    classMetadataElement = beam_findJvmClass("org/esa/beam/framework/datamodel/MetadataElement");
    if (classMetadataElement == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/MetadataElement\n");
        exitCode = 2007;
        return exitCode;
    }

    classProduct = beam_findJvmClass("org/esa/beam/framework/datamodel/Product");
    if (classProduct == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Product\n");
        exitCode = 2008;
        return exitCode;
    }

    classColorPaletteDef = beam_findJvmClass("org/esa/beam/framework/datamodel/ColorPaletteDef");
    if (classColorPaletteDef == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ColorPaletteDef\n");
        exitCode = 2009;
        return exitCode;
    }

    classImageInfo = beam_findJvmClass("org/esa/beam/framework/datamodel/ImageInfo");
    if (classImageInfo == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ImageInfo\n");
        exitCode = 2010;
        return exitCode;
    }

    classProductManager = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductManager");
    if (classProductManager == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductManager\n");
        exitCode = 2011;
        return exitCode;
    }

    classImageGeometry = beam_findJvmClass("org/esa/beam/framework/datamodel/ImageGeometry");
    if (classImageGeometry == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ImageGeometry\n");
        exitCode = 2012;
        return exitCode;
    }

    classBand = beam_findJvmClass("org/esa/beam/framework/datamodel/Band");
    if (classBand == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Band\n");
        exitCode = 2013;
        return exitCode;
    }

    classPlacemarkGroup = beam_findJvmClass("org/esa/beam/framework/datamodel/PlacemarkGroup");
    if (classPlacemarkGroup == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/PlacemarkGroup\n");
        exitCode = 2014;
        return exitCode;
    }

    classTiePointGrid = beam_findJvmClass("org/esa/beam/framework/datamodel/TiePointGrid");
    if (classTiePointGrid == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/TiePointGrid\n");
        exitCode = 2015;
        return exitCode;
    }

    classAngularDirection = beam_findJvmClass("org/esa/beam/framework/datamodel/AngularDirection");
    if (classAngularDirection == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/AngularDirection\n");
        exitCode = 2016;
        return exitCode;
    }

    classFlagCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/FlagCoding");
    if (classFlagCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/FlagCoding\n");
        exitCode = 2017;
        return exitCode;
    }

    classMap = beam_findJvmClass("java/util/Map");
    if (classMap == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/Map\n");
        exitCode = 2018;
        return exitCode;
    }

    classProductReader = beam_findJvmClass("org/esa/beam/framework/dataio/ProductReader");
    if (classProductReader == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductReader\n");
        exitCode = 2019;
        return exitCode;
    }

    classRGBChannelDef = beam_findJvmClass("org/esa/beam/framework/datamodel/RGBChannelDef");
    if (classRGBChannelDef == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/RGBChannelDef\n");
        exitCode = 2020;
        return exitCode;
    }

    classProductData = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductData");
    if (classProductData == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductData\n");
        exitCode = 2021;
        return exitCode;
    }

    classGeoPos = beam_findJvmClass("org/esa/beam/framework/datamodel/GeoPos");
    if (classGeoPos == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/GeoPos\n");
        exitCode = 2022;
        return exitCode;
    }

    classProductNodeGroup = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductNodeGroup");
    if (classProductNodeGroup == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductNodeGroup\n");
        exitCode = 2023;
        return exitCode;
    }

    classProductUtils = beam_findJvmClass("org/esa/beam/util/ProductUtils");
    if (classProductUtils == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/util/ProductUtils\n");
        exitCode = 2024;
        return exitCode;
    }

    classMetadataAttribute = beam_findJvmClass("org/esa/beam/framework/datamodel/MetadataAttribute");
    if (classMetadataAttribute == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/MetadataAttribute\n");
        exitCode = 2025;
        return exitCode;
    }

    exitCode = 0;
    return exitCode;
}


PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "isCrossingMeridianAt180", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_isCrossingMeridianAt180", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "canGetPixelPos", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_canGetPixelPos", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "canGetGeoPos", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_canGetGeoPos", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getPixelPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/PixelPos;)Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyGeoCoding_getPixelPos", &_thisPyObj, &geoPosPyObj, &pixelPosPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, classPixelPos, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, geoPosJObj, pixelPosJObj);
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;)Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyGeoCoding_getGeoPos", &_thisPyObj, &pixelPosPyObj, &geoPosPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, classPixelPos, &ok);
    if (!ok) {
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelPosJObj, geoPosJObj);
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getDatum", "()Lorg/esa/beam/framework/dataop/maptransf/Datum;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_getDatum", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Datum_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getImageCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_getImageCRS", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getMapCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_getMapCRS", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_getGeoCRS", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getImageToMapTransform", "()Lorg/opengis/referencing/operation/MathTransform;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoCoding_getImageToMapTransform", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MathTransform_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "getWriterPlugIn", "()Lorg/esa/beam/framework/dataio/ProductWriterPlugIn;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_getWriterPlugIn", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriterPlugIn_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "getOutput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_getOutput", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "writeProductNodes", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductWriter_writeProductNodes", &_thisPyObj, &productPyObj, &outputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* sourceBandPyObj = NULL;
    jobject sourceBandJObj = NULL;
    jint sourceOffsetX = (jint) 0;
    jint sourceOffsetY = (jint) 0;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    PyObject* sourceBufferPyObj = NULL;
    jobject sourceBufferJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "writeBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiiiiOO:BeamPyProductWriter_writeBandRasterData", &_thisPyObj, &sourceBandPyObj, &sourceOffsetX, &sourceOffsetY, &sourceWidth, &sourceHeight, &sourceBufferPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    sourceBandJObj = BPy_ToJObjectT(sourceBandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    sourceBufferJObj = BPy_ToJObjectT(sourceBufferPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceBandJObj, sourceOffsetX, sourceOffsetY, sourceWidth, sourceHeight, sourceBufferJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "flush", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_flush", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "close", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_close", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "shouldWrite", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductWriter_shouldWrite", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "isIncrementalMode", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_isIncrementalMode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean enabled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "setIncrementalMode", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyProductWriter_setIncrementalMode", &_thisPyObj, &enabled)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, enabled);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "deleteOutput", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductWriter_deleteOutput", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductWriter_removeBand", &_thisPyObj, &bandPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductWriter);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    bandJObj = BPy_ToJObjectT(bandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:BeamPyGPF_createProductWithoutSourceProducts", &operatorName, &parametersPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyGPF_createProductFromSourceProduct", &operatorName, &parametersPyObj, &sourceProductPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;[Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyGPF_createProductFromSourceProducts", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    sourceProductsJObj = BPy_ToJObjectArrayT(sourceProductsPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyGPF_createProductFromNamedSourceProducts", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* renderingHintsPyObj = NULL;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProductNS", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsOOO:BeamPyGPF_createProductNS", &_thisPyObj, &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGPF);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    renderingHintsJObj = BPy_ToJObjectT(renderingHintsPyObj, classRenderingHints, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* renderingHintsPyObj = NULL;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createOperator", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/gpf/Operator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsOOO:BeamPyGPF_createOperator", &_thisPyObj, &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGPF);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = BPy_ToJObjectT(parametersPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    renderingHintsJObj = BPy_ToJObjectT(renderingHintsPyObj, classRenderingHints, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    _resultPyObj = BPy_FromJObject(&Operator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "getOperatorSpiRegistry", "()Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGPF_getOperatorSpiRegistry", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGPF);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&OperatorSpiRegistry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* spiRegistryPyObj = NULL;
    jobject spiRegistryJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "setOperatorSpiRegistry", "(Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyGPF_setOperatorSpiRegistry", &_thisPyObj, &spiRegistryPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGPF);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    spiRegistryJObj = BPy_ToJObjectT(spiRegistryPyObj, classOperatorSpiRegistry, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spiRegistryJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "getDefaultInstance", "()Lorg/esa/beam/framework/gpf/GPF;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method);
    _resultPyObj = BPy_FromJObject(&GPF_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* defaultInstancePyObj = NULL;
    jobject defaultInstanceJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "setDefaultInstance", "(Lorg/esa/beam/framework/gpf/GPF;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGPF_setDefaultInstance", &defaultInstancePyObj)) {
        return NULL;
    }
    defaultInstanceJObj = BPy_ToJObjectT(defaultInstancePyObj, classGPF, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classGPF, _method, defaultInstanceJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    jboolean incremental = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/io/File;Ljava/lang/String;ZLcom/bc/ceres/core/ProgressMonitor;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOsbO:BeamPyGPF_writeProduct", &productPyObj, &filePyObj, &formatName, &incremental, &pmPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    fileJObj = BPy_ToJObjectT(filePyObj, classFile, &ok);
    if (!ok) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classGPF, _method, productJObj, fileJObj, formatNameJObj, incremental, pmJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyIndexCoding_newIndexCoding", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classIndexCoding, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndex", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_getIndex", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getIndexNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addIndex", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osis:BeamPyIndexCoding_addIndex", &_thisPyObj, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexValue", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_getIndexValue", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_addElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_addAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osis:BeamPyIndexCoding_addSample", &_thisPyObj, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getSampleCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyIndexCoding_getSampleName", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyIndexCoding_getSampleValue", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getElementGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getParentElement", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyIndexCoding_addElementAt", &_thisPyObj, &elementPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_removeElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getNumElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyIndexCoding_getElementAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getElementNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_getElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_containsElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_getElementIndex", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_removeAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getNumAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyIndexCoding_getAttributeAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getAttributeNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_getAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_containsAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_getAttributeIndex", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyIndexCoding_getAttributeDouble", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyIndexCoding_getAttributeUTC", &_thisPyObj, &name, &defaultValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyIndexCoding_getAttributeInt", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyIndexCoding_setAttributeInt", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyIndexCoding_setAttributeDouble", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyIndexCoding_setAttributeUTC", &_thisPyObj, &name, &valuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = BPy_ToJObjectT(valuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyIndexCoding_getAttributeString", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyIndexCoding_setAttributeString", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyIndexCoding_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_createDeepClone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyIndexCoding_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyIndexCoding_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classIndexCoding, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyIndexCoding_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyIndexCoding_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyIndexCoding_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classIndexCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classPixelPos, _method);
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:BeamPyPixelPos_newPixelPos2", &x, &y)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classPixelPos, _method, x, y);
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_isValid", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_setInvalid", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "getX", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_getX", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "getY", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_getY", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Odd:BeamPyPixelPos_setLocation1", &_thisPyObj, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat arg0 = (jfloat) 0;
    jfloat arg1 = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Off:BeamPyPixelPos_setLocation2", &_thisPyObj, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(Ljava/awt/geom/Point2D;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPixelPos_setLocation3", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classPoint2D, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0JObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:BeamPyPixelPos_distanceSq2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classPixelPos, _method, arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:BeamPyPixelPos_distance2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classPixelPos, _method, arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DD)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Odd:BeamPyPixelPos_distanceSq1", &_thisPyObj, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPixelPos_distanceSq3", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classPoint2D, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DD)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Odd:BeamPyPixelPos_distance1", &_thisPyObj, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPixelPos_distance3", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classPoint2D, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_clone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPixelPos_hashCode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPixelPos_equals", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPixelPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReader", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductReader", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductWriterExtensions", "(Ljava/lang/String;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductWriterExtensions", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductWriter", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductWriter;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductWriter", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "readProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_readProduct", &filePath)) {
        return NULL;
    }
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, filePathJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForFile", "(Ljava/io/File;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductIO_getProductReaderForFile", &filePyObj)) {
        return NULL;
    }
    fileJObj = BPy_ToJObjectT(filePyObj, classFile, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, fileJObj);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForInput", "(Ljava/lang/Object;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductIO_getProductReaderForInput", &inputPyObj)) {
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, inputJObj);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Ljava/lang/String;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyProductIO_writeProduct", &productPyObj, &filePath, &formatName)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    (*jenv)->CallStaticVoidMethod(jenv, classProductIO, _method, productJObj, filePathJObj, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* descriptorPyObj = NULL;
    jobject descriptorJObj = NULL;
    PyObject* featurePyObj = NULL;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "<init>", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Lorg/opengis/feature/simple/SimpleFeature;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_newPlacemark", &descriptorPyObj, &featurePyObj)) {
        return NULL;
    }
    descriptorJObj = BPy_ToJObjectT(descriptorPyObj, classPlacemarkDescriptor, &ok);
    if (!ok) {
        return NULL;
    }
    featureJObj = BPy_ToJObjectT(featurePyObj, classSimpleFeature, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classPlacemark, _method, descriptorJObj, featureJObj);
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* descriptorPyObj = NULL;
    jobject descriptorJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPointPlacemark", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/GeoCoding;)Lorg/esa/beam/framework/datamodel/Placemark;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsssOOO:BeamPyPlacemark_createPointPlacemark", &descriptorPyObj, &name, &label, &text, &pixelPosPyObj, &geoPosPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    descriptorJObj = BPy_ToJObjectT(descriptorPyObj, classPlacemarkDescriptor, &ok);
    if (!ok) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, classPixelPos, &ok);
    if (!ok) {
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method, descriptorJObj, nameJObj, labelJObj, textJObj, pixelPosJObj, geoPosJObj, geoCodingJObj);
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDescriptor", "()Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getDescriptor", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&PlacemarkDescriptor_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getFeature", "()Lorg/opengis/feature/simple/SimpleFeature;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getFeature", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&SimpleFeature_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getAttributeValue", "(Ljava/lang/String;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_getAttributeValue", &_thisPyObj, &attributeName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, attributeNameJObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    PyObject* attributeValuePyObj = NULL;
    jobject attributeValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setAttributeValue", "(Ljava/lang/String;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyPlacemark_setAttributeValue", &_thisPyObj, &attributeName, &attributeValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    attributeValueJObj = BPy_ToJObjectT(attributeValuePyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeNameJObj, attributeValueJObj);
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setLabel", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_setLabel", &_thisPyObj, &label)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, labelJObj);
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getLabel", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getLabel", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setText", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_setText", &_thisPyObj, &text)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, textJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getText", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getText", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* styleCss = NULL;
    jstring styleCssJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setStyleCss", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_setStyleCss", &_thisPyObj, &styleCss)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    styleCssJObj =(*jenv)->NewStringUTF(jenv, styleCss);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, styleCssJObj);
    (*jenv)->DeleteLocalRef(jenv, styleCssJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getStyleCss", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getStyleCss", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getPixelPos", "()Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getPixelPos", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setPixelPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_setPixelPos", &_thisPyObj, &pixelPosPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, classPixelPos, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pixelPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getGeoPos", "()Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getGeoPos", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_setGeoPos", &_thisPyObj, &geoPosPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "updatePositions", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_updatePositions", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPinFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createGcpFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createGeometryFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPointFeatureType", "(Ljava/lang/String;)Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemark_createPointFeatureType", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemark_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyPlacemark_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemark_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classPlacemark, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemark_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyPlacemark_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemark_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemark);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataElement_newMetadataElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classMetadataElement, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getElementGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getParentElement", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_addElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyMetadataElement_addElementAt", &_thisPyObj, &elementPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_removeElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getNumElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyMetadataElement_getElementAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getElementNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_getElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_containsElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_getElementIndex", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_addAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_removeAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getNumAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyMetadataElement_getAttributeAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getAttributeNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_getAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_containsAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_getAttributeIndex", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyMetadataElement_getAttributeDouble", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyMetadataElement_getAttributeUTC", &_thisPyObj, &name, &defaultValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyMetadataElement_getAttributeInt", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyMetadataElement_setAttributeInt", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyMetadataElement_setAttributeDouble", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyMetadataElement_setAttributeUTC", &_thisPyObj, &name, &valuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = BPy_ToJObjectT(valuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyMetadataElement_getAttributeString", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyMetadataElement_setAttributeString", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyMetadataElement_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_createDeepClone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataElement_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataElement_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classMetadataElement, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataElement_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyMetadataElement_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataElement_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataElement);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint sceneRasterWidth = (jint) 0;
    jint sceneRasterHeight = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "<init>", "(Ljava/lang/String;Ljava/lang/String;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ssii:BeamPyProduct_newProduct", &name, &type, &sceneRasterWidth, &sceneRasterHeight)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _resultJObj = (*jenv)->NewObject(jenv, classProduct, _method, nameJObj, typeJObj, sceneRasterWidth, sceneRasterHeight);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getFileLocation", "()Ljava/io/File;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getFileLocation", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&File_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* fileLocationPyObj = NULL;
    jobject fileLocationJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setFileLocation", "(Ljava/io/File;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setFileLocation", &_thisPyObj, &fileLocationPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    fileLocationJObj = BPy_ToJObjectT(fileLocationPyObj, classFile, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, fileLocationJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductType", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    jstring productTypeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductType", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_setProductType", &_thisPyObj, &productType)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    productTypeJObj =(*jenv)->NewStringUTF(jenv, productType);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productTypeJObj);
    (*jenv)->DeleteLocalRef(jenv, productTypeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* readerPyObj = NULL;
    jobject readerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductReader", "(Lorg/esa/beam/framework/dataio/ProductReader;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setProductReader", &_thisPyObj, &readerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    readerJObj = BPy_ToJObjectT(readerPyObj, classProductReader, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* writerPyObj = NULL;
    jobject writerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductWriter", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setProductWriter", &_thisPyObj, &writerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    writerJObj = BPy_ToJObjectT(writerPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, writerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "writeHeader", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_writeHeader", &_thisPyObj, &outputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeProductReader", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_closeProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeProductWriter", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_closeProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeIO", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_closeIO", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPointingFactory", "()Lorg/esa/beam/framework/datamodel/PointingFactory;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getPointingFactory", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&PointingFactory_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pointingFactoryPyObj = NULL;
    jobject pointingFactoryJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setPointingFactory", "(Lorg/esa/beam/framework/datamodel/PointingFactory;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setPointingFactory", &_thisPyObj, &pointingFactoryPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    pointingFactoryJObj = BPy_ToJObjectT(pointingFactoryPyObj, classPointingFactory, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointingFactoryJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setGeoCoding", &_thisPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getGeoCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isUsingSingleGeoCoding", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_isUsingSingleGeoCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* destProductPyObj = NULL;
    jobject destProductJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "transferGeoCodingTo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProduct_transferGeoCodingTo", &_thisPyObj, &destProductPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    destProductJObj = BPy_ToJObjectT(destProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, destProductJObj, subsetDefJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getSceneRasterWidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getSceneRasterHeight", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getStartTime", "()Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getStartTime", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* startTimePyObj = NULL;
    jobject startTimeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setStartTime", "(Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setStartTime", &_thisPyObj, &startTimePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    startTimeJObj = BPy_ToJObjectT(startTimePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startTimeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getEndTime", "()Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getEndTime", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* endTimePyObj = NULL;
    jobject endTimeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setEndTime", "(Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_setEndTime", &_thisPyObj, &endTimePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    endTimeJObj = BPy_ToJObjectT(endTimePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, endTimeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getMetadataRoot", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getMetadataRoot", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getBandGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getTiePointGridGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* tiePointGridPyObj = NULL;
    jobject tiePointGridJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_addTiePointGrid", &_thisPyObj, &tiePointGridPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    tiePointGridJObj = BPy_ToJObjectT(tiePointGridPyObj, classTiePointGrid, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* tiePointGridPyObj = NULL;
    jobject tiePointGridJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_removeTiePointGrid", &_thisPyObj, &tiePointGridPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    tiePointGridJObj = BPy_ToJObjectT(tiePointGridPyObj, classTiePointGrid, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getNumTiePointGrids", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getNumTiePointGrids", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridAt", "(I)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProduct_getTiePointGridAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getTiePointGridNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGrids", "()[Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getTiePointGrids", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGrid", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getTiePointGrid", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsTiePointGrid", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_containsTiePointGrid", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_addBand", &_thisPyObj, &bandPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bandJObj = BPy_ToJObjectT(bandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    jint dataType = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyProduct_addNewBand", &_thisPyObj, &bandName, &dataType)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, dataType);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyProduct_addComputedBand", &_thisPyObj, &bandName, &expression)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, expressionJObj);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_removeBand", &_thisPyObj, &bandPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bandJObj = BPy_ToJObjectT(bandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, bandJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getNumBands", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getNumBands", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandAt", "(I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProduct_getBandAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getBandNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBands", "()[Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getBands", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBand", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getBand", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandIndex", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getBandIndex", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsBand", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_containsBand", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsRasterDataNode", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_containsRasterDataNode", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRasterDataNode", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/RasterDataNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getRasterDataNode", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&RasterDataNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getMaskGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getVectorDataGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getVectorDataGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getFlagCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getFlagCodingGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getIndexCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getIndexCodingGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsPixel", "(FF)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Off:BeamPyProduct_containsPixel", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGcpGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getGcpGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&PlacemarkGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPinGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getPinGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&PlacemarkGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jfloat eps = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isCompatibleProduct", "(Lorg/esa/beam/framework/datamodel/Product;F)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOf:BeamPyProduct_isCompatibleProduct", &_thisPyObj, &productPyObj, &eps)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj, eps);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "parseExpression", "(Ljava/lang/String;)Lcom/bc/jexp/Term;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_parseExpression", &_thisPyObj, &expression)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj);
    _resultPyObj = BPy_FromJObject(&Term_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_addProductNodeListener", &_thisPyObj, &listenerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    listenerJObj = BPy_ToJObjectT(listenerPyObj, classProductNodeListener, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_removeProductNodeListener", &_thisPyObj, &listenerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    listenerJObj = BPy_ToJObjectT(listenerPyObj, classProductNodeListener, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, listenerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductNodeListeners", "()[Lorg/esa/beam/framework/datamodel/ProductNodeListener;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductNodeListeners", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRefNo", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getRefNo", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setRefNo", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProduct_setRefNo", &_thisPyObj, &refNo)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, refNo);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "resetRefNo", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_resetRefNo", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductManager", "()Lorg/esa/beam/framework/datamodel/ProductManager;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductManager", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductManager_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticParser", "()Lcom/bc/jexp/Parser;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_createBandArithmeticParser", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Parser_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticDefaultNamespace", "()Lcom/bc/jexp/WritableNamespace;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_createBandArithmeticDefaultNamespace", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&WritableNamespace_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createSubset", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOss:BeamPyProduct_createSubset", &_thisPyObj, &subsetDefPyObj, &name, &desc)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, subsetDefJObj, nameJObj, descJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint flipType = (jint) 0;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createFlippedProduct", "(ILjava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiss:BeamPyProduct_createFlippedProduct", &_thisPyObj, &flipType, &name, &desc)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, flipType, nameJObj, descJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyProduct_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getQuicklookBandName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getQuicklookBandName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* quicklookBandName = NULL;
    jstring quicklookBandNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setQuicklookBandName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_setQuicklookBandName", &_thisPyObj, &quicklookBandName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    quicklookBandNameJObj =(*jenv)->NewStringUTF(jenv, quicklookBandName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, quicklookBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, quicklookBandNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createPixelInfoString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyProduct_createPixelInfoString", &_thisPyObj, &pixelX, &pixelY)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelX, pixelY);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRemovedChildNodes", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getRemovedChildNodes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_canBeOrthorectified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPreferredTileSize", "()Ljava/awt/Dimension;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getPreferredTileSize", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Dimension_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint tileWidth = (jint) 0;
    jint tileHeight = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setPreferredTileSize", "(II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyProduct_setPreferredTileSize", &_thisPyObj, &tileWidth, &tileHeight)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tileWidth, tileHeight);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getAllFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getAllFlagNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getAutoGrouping", "()Lorg/esa/beam/framework/datamodel/Product/AutoGrouping;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getAutoGrouping", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_AutoGrouping_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* pattern = NULL;
    jstring patternJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setAutoGrouping", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_setAutoGrouping", &_thisPyObj, &pattern)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    patternJObj =(*jenv)->NewStringUTF(jenv, pattern);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, patternJObj);
    (*jenv)->DeleteLocalRef(jenv, patternJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* maskName = NULL;
    jstring maskNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* colorPyObj = NULL;
    jobject colorJObj = NULL;
    jdouble transparency = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addMask", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/awt/Color;D)Lorg/esa/beam/framework/datamodel/Mask;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsssOd:BeamPyProduct_addComputedMask", &_thisPyObj, &maskName, &expression, &description, &colorPyObj, &transparency)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    maskNameJObj =(*jenv)->NewStringUTF(jenv, maskName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    colorJObj = BPy_ToJObjectT(colorPyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, maskNameJObj, expressionJObj, descriptionJObj, colorJObj, transparency);
    _resultPyObj = BPy_FromJObject(&Mask_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, maskNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* bitmaskDefPyObj = NULL;
    jobject bitmaskDefJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBitmaskDef", "(Lorg/esa/beam/framework/datamodel/BitmaskDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_addBitmaskDef", &_thisPyObj, &bitmaskDefPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bitmaskDefJObj = BPy_ToJObjectT(bitmaskDefPyObj, classBitmaskDef, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bitmaskDefJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBitmaskDefNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getBitmaskDefNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBitmaskDef", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/BitmaskDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getBitmaskDef", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&BitmaskDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getValidMask", "(Ljava/lang/String;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_getValidMask", &_thisPyObj, &id)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, idJObj);
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* validMaskPyObj = NULL;
    jobject validMaskJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setValidMask", "(Ljava/lang/String;Lorg/esa/beam/util/BitRaster;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyProduct_setValidMask", &_thisPyObj, &id, &validMaskPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    validMaskJObj = BPy_ToJObjectT(validMaskPyObj, classBitRaster, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, idJObj, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Ljava/lang/String;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyProduct_createValidMask2", &_thisPyObj, &expression, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* termPyObj = NULL;
    jobject termJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Lcom/bc/jexp/Term;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProduct_createValidMask1", &_thisPyObj, &termPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    termJObj = BPy_ToJObjectT(termPyObj, classTerm, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, termJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* bitmaskTermPyObj = NULL;
    jobject bitmaskTermJObj = NULL;
    jboolean* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[ZLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOOO:BeamPyProduct_readBitmask2", &_thisPyObj, &offsetX, &offsetY, &width, &height, &bitmaskTermPyObj, &bitmaskPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bitmaskTermJObj = BPy_ToJObjectT(bitmaskTermPyObj, classTerm, &ok);
    if (!ok) {
        return NULL;
    }
    bitmaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jboolean*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = BPy_NewJBooleanArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, pmJObj);
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* bitmaskTermPyObj = NULL;
    jobject bitmaskTermJObj = NULL;
    jbyte* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    jbyte trueValue = (jbyte) 0;
    jbyte falseValue = (jbyte) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[BBBLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOObbO:BeamPyProduct_readBitmask1", &_thisPyObj, &offsetX, &offsetY, &width, &height, &bitmaskTermPyObj, &bitmaskPyObj, &trueValue, &falseValue, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    bitmaskTermJObj = BPy_ToJObjectT(bitmaskTermPyObj, classTerm, &ok);
    if (!ok) {
        return NULL;
    }
    bitmaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jbyte*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = BPy_NewJByteArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, trueValue, falseValue, pmJObj);
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProduct_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProduct_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProduct, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProduct_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyProduct_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProduct_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProduct);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:BeamPyColorPaletteDef_newColorPaletteDefFromRange", &minSample, &maxSample)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classColorPaletteDef, _method, minSample, maxSample);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    jint numColors = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_newColorPaletteDefFromPoints", &pointsPyObj, &numColors)) {
        return NULL;
    }
    pointsJObj = BPy_ToJObjectArrayT(pointsPyObj, classColorPaletteDef_Point, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classColorPaletteDef, _method, pointsJObj, numColors);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isDiscrete", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_isDiscrete", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean discrete = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setDiscrete", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyColorPaletteDef_setDiscrete", &_thisPyObj, &discrete)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discrete);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumColors", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getNumColors", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint numColors = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumColors", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_setNumColors", &_thisPyObj, &numColors)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numColors);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumPoints", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getNumPoints", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint numPoints = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumPoints", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_setNumPoints", &_thisPyObj, &numPoints)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numPoints);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isAutoDistribute", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_isAutoDistribute", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean autoDistribute = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setAutoDistribute", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyColorPaletteDef_setAutoDistribute", &_thisPyObj, &autoDistribute)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPointAt", "(I)Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_getPointAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getFirstPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getFirstPoint", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getLastPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getLastPoint", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMinDisplaySample", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getMinDisplaySample", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMaxDisplaySample", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getMaxDisplaySample", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* pointPyObj = NULL;
    jobject pointJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "insertPointAfter", "(ILorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyColorPaletteDef_insertPointAfter", &_thisPyObj, &index, &pointPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    pointJObj = BPy_ToJObjectT(pointPyObj, classColorPaletteDef_Point, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, pointJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createPointAfter", "(ILorg/esa/beam/framework/datamodel/Scaling;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyColorPaletteDef_createPointAfter", &_thisPyObj, &index, &scalingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    scalingJObj = BPy_ToJObjectT(scalingPyObj, classScaling, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index, scalingJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* c1PyObj = NULL;
    jobject c1JObj = NULL;
    PyObject* c2PyObj = NULL;
    jobject c2JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getCenterColor", "(Ljava/awt/Color;Ljava/awt/Color;)Ljava/awt/Color;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyColorPaletteDef_getCenterColor", &c1PyObj, &c2PyObj)) {
        return NULL;
    }
    c1JObj = BPy_ToJObjectT(c1PyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    c2JObj = BPy_ToJObjectT(c2PyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classColorPaletteDef, _method, c1JObj, c2JObj);
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "removePointAt", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_removePointAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pointPyObj = NULL;
    jobject pointJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "addPoint", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyColorPaletteDef_addPoint", &_thisPyObj, &pointPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    pointJObj = BPy_ToJObjectT(pointPyObj, classColorPaletteDef_Point, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPoints", "()[Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getPoints", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setPoints", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyColorPaletteDef_setPoints", &_thisPyObj, &pointsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    pointsJObj = BPy_ToJObjectArrayT(pointsPyObj, classColorPaletteDef_Point, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getIterator", "()Ljava/util/Iterator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getIterator", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Iterator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_clone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_createDeepCopy", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "loadColorPaletteDef", "(Ljava/io/File;)Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_loadColorPaletteDef", &filePyObj)) {
        return NULL;
    }
    fileJObj = BPy_ToJObjectT(filePyObj, classFile, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classColorPaletteDef, _method, fileJObj);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "storeColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;Ljava/io/File;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyColorPaletteDef_storeColorPaletteDef", &colorPaletteDefPyObj, &filePyObj)) {
        return NULL;
    }
    colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, classColorPaletteDef, &ok);
    if (!ok) {
        return NULL;
    }
    fileJObj = BPy_ToJObjectT(filePyObj, classFile, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classColorPaletteDef, _method, colorPaletteDefJObj, fileJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyColorPaletteDef_getColors", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createColorPalette", "(Lorg/esa/beam/framework/datamodel/Scaling;)[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyColorPaletteDef_createColorPalette", &_thisPyObj, &scalingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    scalingJObj = BPy_ToJObjectT(scalingPyObj, classScaling, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    jdouble sample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "computeColor", "(Lorg/esa/beam/framework/datamodel/Scaling;D)Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOd:BeamPyColorPaletteDef_computeColor", &_thisPyObj, &scalingPyObj, &sample)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classColorPaletteDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    scalingJObj = BPy_ToJObjectT(scalingPyObj, classScaling, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj, sample);
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_newImageInfoPalette", &colorPaletteDefPyObj)) {
        return NULL;
    }
    colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, classColorPaletteDef, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classImageInfo, _method, colorPaletteDefJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rgbChannelDefPyObj = NULL;
    jobject rgbChannelDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/RGBChannelDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_newImageInfoRGB", &rgbChannelDefPyObj)) {
        return NULL;
    }
    rgbChannelDefJObj = BPy_ToJObjectT(rgbChannelDefPyObj, classRGBChannelDef, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classImageInfo, _method, rgbChannelDefJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColorPaletteDef", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_getColorPaletteDef", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getRgbChannelDef", "()Lorg/esa/beam/framework/datamodel/RGBChannelDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_getRgbChannelDef", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&RGBChannelDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getNoDataColor", "()Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_getNoDataColor", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* noDataColorPyObj = NULL;
    jobject noDataColorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setNoDataColor", "(Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyImageInfo_setNoDataColor", &_thisPyObj, &noDataColorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    noDataColorJObj = BPy_ToJObjectT(noDataColorPyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataColorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* histogramMatchingPyObj = NULL;
    jobject histogramMatchingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setHistogramMatching", "(Lorg/esa/beam/framework/datamodel/ImageInfo/HistogramMatching;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyImageInfo_setHistogramMatching", &_thisPyObj, &histogramMatchingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    histogramMatchingJObj = BPy_ToJObjectT(histogramMatchingPyObj, classImageInfo_HistogramMatching, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, histogramMatchingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "isLogScaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_isLogScaled", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean logScaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setLogScaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyImageInfo_setLogScaled", &_thisPyObj, &logScaled)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, logScaled);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_getColors", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColorComponentCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_getColorComponentCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createIndexColorModel", "(Lorg/esa/beam/framework/datamodel/Scaling;)Ljava/awt/image/IndexColorModel;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyImageInfo_createIndexColorModel", &_thisPyObj, &scalingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    scalingJObj = BPy_ToJObjectT(scalingPyObj, classScaling, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    _resultPyObj = BPy_FromJObject(&IndexColorModel_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createComponentColorModel", "()Ljava/awt/image/ComponentColorModel;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_createComponentColorModel", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ComponentColorModel_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_clone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_createDeepCopy", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageInfo_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* colorsPyObj = NULL;
    jarray colorsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setColors", "([Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyImageInfo_setColors", &_thisPyObj, &colorsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    colorsJObj = BPy_ToJObjectArrayT(colorsPyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorsJObj);
    (*jenv)->DeleteLocalRef(jenv, colorsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    jboolean autoDistribute = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;DDZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOddb:BeamPyImageInfo_setColorPaletteDef", &_thisPyObj, &colorPaletteDefPyObj, &minSample, &maxSample, &autoDistribute)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageInfo);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, classColorPaletteDef, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorPaletteDefJObj, minSample, maxSample, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* mode = NULL;
    jstring modeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getHistogramMatching", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ImageInfo/HistogramMatching;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyImageInfo_getHistogramMatching", &mode)) {
        return NULL;
    }
    modeJObj =(*jenv)->NewStringUTF(jenv, mode);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageInfo, _method, modeJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_HistogramMatching_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, modeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classProductManager, _method);
    _resultPyObj = BPy_FromJObject(&ProductManager_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductManager_getProductCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductManager_getProduct", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductManager_getProductDisplayNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductManager_getProductNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProducts", "()[Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductManager_getProducts", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductManager_getProductByDisplayName", &_thisPyObj, &displayName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductByRefNo", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductManager_getProductByRefNo", &_thisPyObj, &refNo)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, refNo);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductManager_getProductByName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductIndex", "(Lorg/esa/beam/framework/datamodel/Product;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_getProductIndex", &_thisPyObj, &productPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, productJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "containsProduct", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductManager_containsProduct", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "contains", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_contains", &_thisPyObj, &productPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "addProduct", "(Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_addProduct", &_thisPyObj, &productPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeProduct", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_removeProduct", &_thisPyObj, &productPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeAllProducts", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductManager_removeAllProducts", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "addListener", "(Lorg/esa/beam/framework/datamodel/ProductManager/Listener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_addListener", &_thisPyObj, &listenerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    listenerJObj = BPy_ToJObjectT(listenerPyObj, classProductManager_Listener, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeListener", "(Lorg/esa/beam/framework/datamodel/ProductManager/Listener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductManager_removeListener", &_thisPyObj, &listenerPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductManager);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    listenerJObj = BPy_ToJObjectT(listenerPyObj, classProductManager_Listener, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* boundsPyObj = NULL;
    jobject boundsJObj = NULL;
    PyObject* mapCrsPyObj = NULL;
    jobject mapCrsJObj = NULL;
    PyObject* image2mapPyObj = NULL;
    jobject image2mapJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "<init>", "(Ljava/awt/Rectangle;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/awt/geom/AffineTransform;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyImageGeometry_newImageGeometry", &boundsPyObj, &mapCrsPyObj, &image2mapPyObj)) {
        return NULL;
    }
    boundsJObj = BPy_ToJObjectT(boundsPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapCrsJObj = BPy_ToJObjectT(mapCrsPyObj, classCoordinateReferenceSystem, &ok);
    if (!ok) {
        return NULL;
    }
    image2mapJObj = BPy_ToJObjectT(image2mapPyObj, classAffineTransform, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classImageGeometry, _method, boundsJObj, mapCrsJObj, image2mapJObj);
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getImage2MapTransform", "()Ljava/awt/geom/AffineTransform;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageGeometry_getImage2MapTransform", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageGeometry);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&AffineTransform_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getImageRect", "()Ljava/awt/Rectangle;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageGeometry_getImageRect", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageGeometry);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getMapCrs", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageGeometry_getMapCrs", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageGeometry);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "changeYAxisDirection", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyImageGeometry_changeYAxisDirection", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classImageGeometry);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    jdouble referencePixelX = (jdouble) 0;
    jdouble referencePixelY = (jdouble) 0;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateEastingNorthing", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DDDD)Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdddd:BeamPyImageGeometry_calculateEastingNorthing", &sourceProductPyObj, &targetCrsPyObj, &referencePixelX, &referencePixelY, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, classCoordinateReferenceSystem, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, referencePixelX, referencePixelY, pixelSizeX, pixelSizeY);
    _resultPyObj = BPy_FromJObject(&Point2D_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateProductSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DD)Ljava/awt/Rectangle;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdd:BeamPyImageGeometry_calculateProductSize", &sourceProductPyObj, &targetCrsPyObj, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, classCoordinateReferenceSystem, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, pixelSizeX, pixelSizeY);
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    PyObject* pixelSizeXPyObj = NULL;
    jobject pixelSizeXJObj = NULL;
    PyObject* pixelSizeYPyObj = NULL;
    jobject pixelSizeYJObj = NULL;
    PyObject* widthPyObj = NULL;
    jobject widthJObj = NULL;
    PyObject* heightPyObj = NULL;
    jobject heightJObj = NULL;
    PyObject* orientationPyObj = NULL;
    jobject orientationJObj = NULL;
    PyObject* eastingPyObj = NULL;
    jobject eastingJObj = NULL;
    PyObject* northingPyObj = NULL;
    jobject northingJObj = NULL;
    PyObject* referencePixelXPyObj = NULL;
    jobject referencePixelXJObj = NULL;
    PyObject* referencePixelYPyObj = NULL;
    jobject referencePixelYJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "createTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOOOOOOOOOO:BeamPyImageGeometry_createTargetGeometry", &sourceProductPyObj, &targetCrsPyObj, &pixelSizeXPyObj, &pixelSizeYPyObj, &widthPyObj, &heightPyObj, &orientationPyObj, &eastingPyObj, &northingPyObj, &referencePixelXPyObj, &referencePixelYPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, classCoordinateReferenceSystem, &ok);
    if (!ok) {
        return NULL;
    }
    pixelSizeXJObj = BPy_ToJObjectT(pixelSizeXPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    pixelSizeYJObj = BPy_ToJObjectT(pixelSizeYPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    widthJObj = BPy_ToJObjectT(widthPyObj, classInteger, &ok);
    if (!ok) {
        return NULL;
    }
    heightJObj = BPy_ToJObjectT(heightPyObj, classInteger, &ok);
    if (!ok) {
        return NULL;
    }
    orientationJObj = BPy_ToJObjectT(orientationPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    eastingJObj = BPy_ToJObjectT(eastingPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    northingJObj = BPy_ToJObjectT(northingPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    referencePixelXJObj = BPy_ToJObjectT(referencePixelXPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    referencePixelYJObj = BPy_ToJObjectT(referencePixelYPyObj, classDouble, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, pixelSizeXJObj, pixelSizeYJObj, widthJObj, heightJObj, orientationJObj, eastingJObj, northingJObj, referencePixelXJObj, referencePixelYJObj);
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* collocationProductPyObj = NULL;
    jobject collocationProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "createCollocationTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyImageGeometry_createCollocationTargetGeometry", &targetProductPyObj, &collocationProductPyObj)) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    collocationProductJObj = BPy_ToJObjectT(collocationProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, targetProductJObj, collocationProductJObj);
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint dataType = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "<init>", "(Ljava/lang/String;III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siii:BeamPyBand_newBand", &name, &dataType, &width, &height)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classBand, _method, nameJObj, dataType, width, height);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getFlagCoding", "()Lorg/esa/beam/framework/datamodel/FlagCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getFlagCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isFlagBand", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isFlagBand", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getIndexCoding", "()Lorg/esa/beam/framework/datamodel/IndexCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getIndexCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isIndexBand", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isIndexBand", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleCoding", "()Lorg/esa/beam/framework/datamodel/SampleCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSampleCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&SampleCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* sampleCodingPyObj = NULL;
    jobject sampleCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSampleCoding", "(Lorg/esa/beam/framework/datamodel/SampleCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setSampleCoding", &_thisPyObj, &sampleCodingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    sampleCodingJObj = BPy_ToJObjectT(sampleCodingPyObj, classSampleCoding, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sampleCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralBandIndex", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSpectralBandIndex", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint spectralBandIndex = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralBandIndex", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyBand_setSpectralBandIndex", &_thisPyObj, &spectralBandIndex)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandIndex);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralWavelength", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSpectralWavelength", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat spectralWavelength = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralWavelength", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Of:BeamPyBand_setSpectralWavelength", &_thisPyObj, &spectralWavelength)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralWavelength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralBandwidth", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSpectralBandwidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat spectralBandwidth = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralBandwidth", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Of:BeamPyBand_setSpectralBandwidth", &_thisPyObj, &spectralBandwidth)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandwidth);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSolarFlux", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSolarFlux", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat solarFlux = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSolarFlux", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Of:BeamPyBand_setSolarFlux", &_thisPyObj, &solarFlux)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, solarFlux);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getViewModeId", "(Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyBand_getViewModeId", &_thisPyObj, &bandName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* validMaskExpression = NULL;
    jstring validMaskExpressionJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    jint defaultProductIndex = (jint) 0;
    jboolean checkInvalids = (jboolean) 0;
    jboolean useInvalidValue = (jboolean) 0;
    jdouble noDataValue = (jdouble) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "computeBand", "(Ljava/lang/String;Ljava/lang/String;[Lorg/esa/beam/framework/datamodel/Product;IZZDLcom/bc/ceres/core/ProgressMonitor;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OssOibbdO:BeamPyBand_computeBand", &_thisPyObj, &expression, &validMaskExpression, &sourceProductsPyObj, &defaultProductIndex, &checkInvalids, &useInvalidValue, &noDataValue, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    validMaskExpressionJObj =(*jenv)->NewStringUTF(jenv, validMaskExpression);
    sourceProductsJObj = BPy_ToJObjectArrayT(sourceProductsPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, expressionJObj, validMaskExpressionJObj, sourceProductsJObj, defaultProductIndex, checkInvalids, useInvalidValue, noDataValue, pmJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validMaskExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSceneRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getPixelInt", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getPixelFloat", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getPixelDouble", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:BeamPyBand_setPixelInt", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiif:BeamPyBand_setPixelFloat", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiid:BeamPyBand_setPixelDouble", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_setPixelsInt", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_setPixelsFloat", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_setPixelsDouble", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "ensureRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_ensureRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_unloadRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSceneRasterWidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSceneRasterHeight", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getRasterWidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getRasterHeight", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyBand_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getGeoCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setGeoCoding", &_thisPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getPointing", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Pointing_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_canBeOrthorectified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isFloatingPointType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getGeophysicalDataType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getScalingFactor", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_setScalingFactor", &_thisPyObj, &scalingFactor)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getScalingOffset", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_setScalingOffset", &_thisPyObj, &scalingOffset)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isLog10Scaled", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyBand_setLog10Scaled", &_thisPyObj, &log10Scaled)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isScalingApplied", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyBand_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classBand, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isNoDataValueSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_clearNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isNoDataValueUsed", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyBand_setNoDataValueUsed", &_thisPyObj, &noDataValueUsed)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_setNoDataValue", &_thisPyObj, &noDataValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getGeophysicalNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_setGeophysicalNoDataValue", &_thisPyObj, &noDataValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getValidPixelExpression", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyBand_setValidPixelExpression", &_thisPyObj, &validPixelExpression)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isValidMaskUsed", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_resetValidMask", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getValidMaskExpression", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyBand_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_hasRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setRasterData", &_thisPyObj, &rasterDataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_loadRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_isPixelValid", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getSampleInt", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getSampleFloat", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_getPixelsInt", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_getPixelsFloat", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_getPixelsDouble", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_readPixelsInt", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "i", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJIntArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJIntArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_readPixelsFloat", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "f", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJFloatArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJFloatArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_readPixelsDouble", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "d", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJDoubleArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJDoubleArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_writePixelsInt", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_writePixelsFloat", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_writePixelsDouble", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_readValidMask", &_thisPyObj, &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    validMaskPyObj = BPy_ToPrimitiveArrayBufferWritable(validMaskPyObj, &validMaskBuf, "b", w*h);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = BPy_NewJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    if (validMaskData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, validMaskJObj)) {
        _resultPyObj = BPy_CopyJBooleanArrayToBuffer((jarray) validMaskJObj, validMaskData, validMaskLength, validMaskPyObj);
    } else {
        _resultPyObj = BPy_FromJBooleanArray((jarray) validMaskJObj);
    }
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_writeRasterDataFully", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyBand_writeRasterData", &_thisPyObj, &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_createCompatibleRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_createCompatibleSceneRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_createCompatibleRasterDataForRect", &_thisPyObj, &width, &height)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOii:BeamPyBand_isCompatibleRasterData", &_thisPyObj, &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOii:BeamPyBand_checkCompatibleRasterData", &_thisPyObj, &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_hasIntPixels", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_createTransectProfileData", &_thisPyObj, &shapePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    shapeJObj = BPy_ToJObjectT(shapePyObj, classShape, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    _resultPyObj = BPy_FromJObject(&TransectProfileData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getImageInfo", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setImageInfo", &_thisPyObj, &imageInfoPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, classImageInfo, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_fireImageInfoChanged", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* histogramPyObj = NULL;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyBand_createDefaultImageInfo", &_thisPyObj, &histoSkipAreasPyObj, &histogramPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    histogramJObj = BPy_ToJObjectT(histogramPyObj, classHistogram, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getOverlayMaskGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_createColorIndexedImage", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_createRgbImage", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyBand_createPixelValidator", &_thisPyObj, &lineOffset, &roiPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    roiJObj = BPy_ToJObjectT(roiPyObj, classROI, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    _resultPyObj = BPy_FromJObject(&IndexValidator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "scale", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_scale", &_thisPyObj, &v)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyBand_scaleInverse", &_thisPyObj, &v)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyBand_getPixelString", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isSourceImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getSourceImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isGeophysicalImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getGeophysicalImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isValidMaskImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getValidMaskImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isStxSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getStx", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* stxPyObj = NULL;
    jobject stxJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setStx", &_thisPyObj, &stxPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    stxJObj = BPy_ToJObjectT(stxPyObj, classStx, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getValidShape", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Shape_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getRoiMaskGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getDataType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getNumDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyBand_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setData", &_thisPyObj, &dataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    dataJObj = BPy_ToJObjectT(dataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_setDataElems", &_thisPyObj, &elemsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    elemsJObj = BPy_ToJObjectT(elemsPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getDataElemSize", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyBand_setReadOnly", &_thisPyObj, &readOnly)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isReadOnly", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyBand_setUnit", &_thisPyObj, &unit)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getUnit", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isSynthetic", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyBand_setSynthetic", &_thisPyObj, &synthetic)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_fireProductNodeDataChanged", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyBand_createCompatibleProductData", &_thisPyObj, &numElems)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyBand_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyBand_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyBand_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classBand, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyBand_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyBand_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classBand);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getVectorDataNode", "()Lorg/esa/beam/framework/datamodel/VectorDataNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getVectorDataNode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&VectorDataNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* featurePyObj = NULL;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getPlacemark", "(Lorg/opengis/feature/simple/SimpleFeature;)Lorg/esa/beam/framework/datamodel/Placemark;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_getPlacemark", &_thisPyObj, &featurePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    featureJObj = BPy_ToJObjectT(featurePyObj, classSimpleFeature, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, featureJObj);
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_add3", &_thisPyObj, &placemarkPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    placemarkJObj = BPy_ToJObjectT(placemarkPyObj, classPlacemark, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/Placemark;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyPlacemarkGroup_add1", &_thisPyObj, &index, &placemarkPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    placemarkJObj = BPy_ToJObjectT(placemarkPyObj, classPlacemark, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, placemarkJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_remove1", &_thisPyObj, &placemarkPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    placemarkJObj = BPy_ToJObjectT(placemarkPyObj, classPlacemark, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_isTakingOverNodeOwnership", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getNodeCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyPlacemarkGroup_get1", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getNodeDisplayNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getNodeNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_toArray1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arrayPyObj = NULL;
    jarray arrayJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "([Lorg/esa/beam/framework/datamodel/ProductNode;)[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_toArray2", &_thisPyObj, &arrayPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    arrayJObj = BPy_ToJObjectArrayT(arrayPyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arrayJObj);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, arrayJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_indexOf1", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_indexOf2", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_getByDisplayName", &_thisPyObj, &displayName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_get2", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_contains1", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_contains2", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_add4", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyPlacemarkGroup_add2", &_thisPyObj, &index, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_remove2", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_removeAll", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_clearRemovedList", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getRemovedNodes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_getRawStorageSize2", &_thisPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyPlacemarkGroup_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyPlacemarkGroup_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemarkGroup_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classPlacemarkGroup, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyPlacemarkGroup_getRawStorageSize1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyPlacemarkGroup_fireProductNodeChanged1", &_thisPyObj, &propertyName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    PyObject* oldValuePyObj = NULL;
    jobject oldValueJObj = NULL;
    PyObject* newValuePyObj = NULL;
    jobject newValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsOO:BeamPyPlacemarkGroup_fireProductNodeChanged2", &_thisPyObj, &propertyName, &oldValuePyObj, &newValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    oldValueJObj = BPy_ToJObjectT(oldValuePyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    newValueJObj = BPy_ToJObjectT(newValuePyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyPlacemarkGroup_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classPlacemarkGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffO:BeamPyTiePointGrid_newTiePointGrid1", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint discontinuity = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FI)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOi:BeamPyTiePointGrid_newTiePointGrid2", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &discontinuity)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, discontinuity);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jboolean containsAngles = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOb:BeamPyTiePointGrid_newTiePointGrid3", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &containsAngles)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, containsAngles);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "([F)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDiscontinuity2", &tiePointsPyObj)) {
        return NULL;
    }
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classTiePointGrid, _method, tiePointsJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDiscontinuity1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint discontinuity = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDiscontinuity", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyTiePointGrid_setDiscontinuity", &_thisPyObj, &discontinuity)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discontinuity);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isFloatingPointType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getGeophysicalDataType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSceneRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSceneRasterWidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSceneRasterHeight", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetX", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getOffsetX", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetY", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getOffsetY", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingX", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSubSamplingX", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingY", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSubSamplingY", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getTiePoints", "()[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getTiePoints", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getPixelInt", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getPixelFloat2", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(FF)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Off:BeamPyTiePointGrid_getPixelFloat1", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getPixelDouble", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:BeamPyTiePointGrid_setPixelInt", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiif:BeamPyTiePointGrid_setPixelFloat", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiid:BeamPyTiePointGrid_setPixelDouble", &_thisPyObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_getPixels6", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_getPixels4", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_getPixels2", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_setPixels3", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_setPixels2", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_setPixels1", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_readPixels6", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_readPixels4", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_readPixels2", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_writePixels6", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_writePixels4", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_writePixels2", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_readRasterData2", &_thisPyObj, &offsetX, &offsetY, &width, &height, &rasterDataPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_readRasterDataFully2", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:BeamPyTiePointGrid_writeRasterData2", &_thisPyObj, &offsetX, &offsetY, &width, &height, &rasterDataPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_writeRasterDataFully2", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "cloneTiePointGrid", "()Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_cloneTiePointGrid", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* elevationAngleGridPyObj = NULL;
    jobject elevationAngleGridJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createZenithFromElevationAngleTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid", &elevationAngleGridPyObj)) {
        return NULL;
    }
    elevationAngleGridJObj = BPy_ToJObjectT(elevationAngleGridPyObj, classTiePointGrid, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classTiePointGrid, _method, elevationAngleGridJObj);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceTiePointGridPyObj = NULL;
    jobject sourceTiePointGridJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createSubset", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_createSubset", &sourceTiePointGridPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    sourceTiePointGridJObj = BPy_ToJObjectT(sourceTiePointGridPyObj, classTiePointGrid, &ok);
    if (!ok) {
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classTiePointGrid, _method, sourceTiePointGridJObj, subsetDefJObj);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getRasterWidth", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getRasterHeight", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyTiePointGrid_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getGeoCoding", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setGeoCoding", &_thisPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getPointing", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Pointing_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_canBeOrthorectified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getScalingFactor", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_setScalingFactor", &_thisPyObj, &scalingFactor)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getScalingOffset", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_setScalingOffset", &_thisPyObj, &scalingOffset)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isLog10Scaled", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyTiePointGrid_setLog10Scaled", &_thisPyObj, &log10Scaled)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isScalingApplied", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyTiePointGrid_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classTiePointGrid, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isNoDataValueSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_clearNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isNoDataValueUsed", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyTiePointGrid_setNoDataValueUsed", &_thisPyObj, &noDataValueUsed)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_setNoDataValue", &_thisPyObj, &noDataValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getGeophysicalNoDataValue", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_setGeophysicalNoDataValue", &_thisPyObj, &noDataValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getValidPixelExpression", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyTiePointGrid_setValidPixelExpression", &_thisPyObj, &validPixelExpression)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isValidMaskUsed", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_resetValidMask", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getValidMaskExpression", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyTiePointGrid_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_hasRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setRasterData", &_thisPyObj, &rasterDataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_loadRasterData1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_loadRasterData2", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_unloadRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_isPixelValid2", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getSampleInt", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getSampleFloat", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint pixelIndex = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyTiePointGrid_isPixelValid1", &_thisPyObj, &pixelIndex)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, pixelIndex);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(IILjavax/media/jai/ROI;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiO:BeamPyTiePointGrid_isPixelValid3", &_thisPyObj, &x, &y, &roiPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    roiJObj = BPy_ToJObjectT(roiPyObj, classROI, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y, roiJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_getPixels5", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_getPixels3", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_getPixels1", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_readPixels5", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_readPixels3", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_readPixels1", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_writePixels5", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_writePixels3", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_writePixels1", &_thisPyObj, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_readValidMask", &_thisPyObj, &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    validMaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(validMaskPyObj, &validMaskBuf, "b", -1);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = BPy_NewJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    _resultPyObj = BPy_FromJBooleanArray((jarray) _resultJObj);
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_readRasterDataFully1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_readRasterData1", &_thisPyObj, &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_writeRasterDataFully1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiO:BeamPyTiePointGrid_writeRasterData1", &_thisPyObj, &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_createCompatibleRasterData1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_createCompatibleSceneRasterData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_createCompatibleRasterData2", &_thisPyObj, &width, &height)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOii:BeamPyTiePointGrid_isCompatibleRasterData", &_thisPyObj, &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOii:BeamPyTiePointGrid_checkCompatibleRasterData", &_thisPyObj, &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_hasIntPixels", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_createTransectProfileData", &_thisPyObj, &shapePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    shapeJObj = BPy_ToJObjectT(shapePyObj, classShape, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    _resultPyObj = BPy_FromJObject(&TransectProfileData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getImageInfo1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setImageInfo", &_thisPyObj, &imageInfoPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, classImageInfo, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_fireImageInfoChanged", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "(Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_getImageInfo2", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyTiePointGrid_getImageInfo3", &_thisPyObj, &histoSkipAreasPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyTiePointGrid_createDefaultImageInfo1", &_thisPyObj, &histoSkipAreasPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* histogramPyObj = NULL;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyTiePointGrid_createDefaultImageInfo2", &_thisPyObj, &histoSkipAreasPyObj, &histogramPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    histogramJObj = BPy_ToJObjectT(histogramPyObj, classHistogram, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getOverlayMaskGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_createColorIndexedImage", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_createRgbImage", &_thisPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDDLcom/bc/ceres/core/ProgressMonitor;)[B", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OdddO:BeamPyTiePointGrid_quantizeRasterData1", &_thisPyObj, &newMin, &newMax, &gamma, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, pmJObj);
    _resultPyObj = BPy_FromJByteArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    jbyte* samplesData = NULL;
    int samplesLength = 0;
    PyObject* samplesPyObj = NULL;
    Py_buffer samplesBuf;
    jarray samplesJObj = NULL;
    jint offset = (jint) 0;
    jint stride = (jint) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDD[BIILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OdddOiiO:BeamPyTiePointGrid_quantizeRasterData2", &_thisPyObj, &newMin, &newMax, &gamma, &samplesPyObj, &offset, &stride, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    samplesPyObj = BPy_ToPrimitiveArrayBufferReadOnly(samplesPyObj, &samplesBuf, "b", -1);
    if (samplesPyObj == NULL) {
        return NULL;
    }
    samplesData = (jbyte*) samplesBuf.buf;
    samplesLength = samplesBuf.len / samplesBuf.itemsize;
    samplesJObj = BPy_NewJByteArrayFromBuffer(samplesData, samplesLength);
    if (samplesJObj == NULL) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, samplesJObj, offset, stride, pmJObj);
    PyBuffer_Release(&samplesBuf);
    (*jenv)->DeleteLocalRef(jenv, samplesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyTiePointGrid_createPixelValidator", &_thisPyObj, &lineOffset, &roiPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    roiJObj = BPy_ToJObjectT(roiPyObj, classROI, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    _resultPyObj = BPy_FromJObject(&IndexValidator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "scale", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_scale", &_thisPyObj, &v)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyTiePointGrid_scaleInverse", &_thisPyObj, &v)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyTiePointGrid_getPixelString", &_thisPyObj, &x, &y)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isSourceImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getSourceImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* sourceImagePyObj = NULL;
    jobject sourceImageJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Ljava/awt/image/RenderedImage;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setSourceImage2", &_thisPyObj, &sourceImagePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    sourceImageJObj = BPy_ToJObjectT(sourceImagePyObj, classRenderedImage, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* sourceImagePyObj = NULL;
    jobject sourceImageJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Lcom/bc/ceres/glevel/MultiLevelImage;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setSourceImage1", &_thisPyObj, &sourceImagePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    sourceImageJObj = BPy_ToJObjectT(sourceImagePyObj, classMultiLevelImage, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isGeophysicalImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getGeophysicalImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isValidMaskImageSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getValidMaskImage", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isStxSet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getStx1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean accurate = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "(ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ObO:BeamPyTiePointGrid_getStx2", &_thisPyObj, &accurate, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, accurate, pmJObj);
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* stxPyObj = NULL;
    jobject stxJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setStx", &_thisPyObj, &stxPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    stxJObj = BPy_ToJObjectT(stxPyObj, classStx, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getValidShape", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Shape_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getRoiMaskGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDataType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getNumDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setData", &_thisPyObj, &dataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    dataJObj = BPy_ToJObjectT(dataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_setDataElems", &_thisPyObj, &elemsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    elemsJObj = BPy_ToJObjectT(elemsPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDataElemSize", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyTiePointGrid_setReadOnly", &_thisPyObj, &readOnly)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isReadOnly", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyTiePointGrid_setUnit", &_thisPyObj, &unit)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getUnit", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isSynthetic", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyTiePointGrid_setSynthetic", &_thisPyObj, &synthetic)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_fireProductNodeDataChanged", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_getRawStorageSize2", &_thisPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyTiePointGrid_createCompatibleProductData", &_thisPyObj, &numElems)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyTiePointGrid_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyTiePointGrid_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyTiePointGrid_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classTiePointGrid, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getRawStorageSize1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyTiePointGrid_fireProductNodeChanged1", &_thisPyObj, &propertyName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    PyObject* oldValuePyObj = NULL;
    jobject oldValueJObj = NULL;
    PyObject* newValuePyObj = NULL;
    jobject newValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsOO:BeamPyTiePointGrid_fireProductNodeChanged2", &_thisPyObj, &propertyName, &oldValuePyObj, &newValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    oldValueJObj = BPy_ToJObjectT(oldValuePyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    newValueJObj = BPy_ToJObjectT(newValuePyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyTiePointGrid_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classTiePointGrid);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jdouble azimuth = (jdouble) 0;
    jdouble zenith = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:BeamPyAngularDirection_newAngularDirection", &azimuth, &zenith)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classAngularDirection, _method, azimuth, zenith);
    _resultPyObj = BPy_FromJObject(&AngularDirection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* objPyObj = NULL;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyAngularDirection_equals", &_thisPyObj, &objPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classAngularDirection);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'AngularDirection' (Java object reference)");
        return NULL;
    }
    objJObj = BPy_ToJObjectT(objPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyAngularDirection_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classAngularDirection);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'AngularDirection' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyFlagCoding_newFlagCoding", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classFlagCoding, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlag", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_getFlag", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getFlagNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint flagMask = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addFlag", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osis:BeamPyFlagCoding_addFlag", &_thisPyObj, &name, &flagMask, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, flagMask, descriptionJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagMask", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_getFlagMask", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_addElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_addAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osis:BeamPyFlagCoding_addSample", &_thisPyObj, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getSampleCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyFlagCoding_getSampleName", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyFlagCoding_getSampleValue", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getElementGroup", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getParentElement", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyFlagCoding_addElementAt", &_thisPyObj, &elementPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_removeElement", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getNumElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyFlagCoding_getElementAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getElementNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getElements", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_getElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_containsElement", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_getElementIndex", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_removeAttribute", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getNumAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyFlagCoding_getAttributeAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getAttributeNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getAttributes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_getAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_containsAttribute", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_getAttributeIndex", &_thisPyObj, &attributePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    attributeJObj = BPy_ToJObjectT(attributePyObj, classMetadataAttribute, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyFlagCoding_getAttributeDouble", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyFlagCoding_getAttributeUTC", &_thisPyObj, &name, &defaultValuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyFlagCoding_getAttributeInt", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osi:BeamPyFlagCoding_setAttributeInt", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Osd:BeamPyFlagCoding_setAttributeDouble", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsO:BeamPyFlagCoding_setAttributeUTC", &_thisPyObj, &name, &valuePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = BPy_ToJObjectT(valuePyObj, classProductData_UTC, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyFlagCoding_getAttributeString", &_thisPyObj, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyFlagCoding_setAttributeString", &_thisPyObj, &name, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyFlagCoding_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_createDeepClone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyFlagCoding_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyFlagCoding_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classFlagCoding, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyFlagCoding_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyFlagCoding_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyFlagCoding_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classFlagCoding);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_size(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "size", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_size", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMap_isEmpty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "isEmpty", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_isEmpty", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_containsKey(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "containsKey", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_containsKey", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_containsValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "containsValue", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_containsValue", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_get(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_get", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_put(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* arg1PyObj = NULL;
    jobject arg1JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyMap_put", &_thisPyObj, &arg0PyObj, &arg1PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    arg1JObj = BPy_ToJObjectT(arg1PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj, arg1JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_remove(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "remove", "(Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_remove", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_putAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "putAll", "(Ljava/util/Map;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_putAll", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0JObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMap_clear(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "clear", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_clear", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMap_keySet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "keySet", "()Ljava/util/Set;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_keySet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Set_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_values(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "values", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_values", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_entrySet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "entrySet", "()Ljava/util/Set;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_entrySet", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Set_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMap_equals", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMap, "java.util.Map", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMap_hashCode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMap);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getReaderPlugIn", "()Lorg/esa/beam/framework/dataio/ProductReaderPlugIn;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductReader_getReaderPlugIn", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReaderPlugIn_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getInput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductReader_getInput", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getSubsetDef", "()Lorg/esa/beam/framework/dataio/ProductSubsetDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductReader_getSubsetDef", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductSubsetDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "readProductNodes", "(Ljava/lang/Object;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductReader_readProductNodes", &_thisPyObj, &inputPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, classProductSubsetDef, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, inputJObj, subsetDefJObj);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* destBandPyObj = NULL;
    jobject destBandJObj = NULL;
    jint destOffsetX = (jint) 0;
    jint destOffsetY = (jint) 0;
    jint destWidth = (jint) 0;
    jint destHeight = (jint) 0;
    PyObject* destBufferPyObj = NULL;
    jobject destBufferJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "readBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiiiiOO:BeamPyProductReader_readBandRasterData", &_thisPyObj, &destBandPyObj, &destOffsetX, &destOffsetY, &destWidth, &destHeight, &destBufferPyObj, &pmPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    destBandJObj = BPy_ToJObjectT(destBandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    destBufferJObj = BPy_ToJObjectT(destBufferPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, destBandJObj, destOffsetX, destOffsetY, destWidth, destHeight, destBufferJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "close", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductReader_close", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductReader);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classRGBChannelDef, _method);
    _resultPyObj = BPy_FromJObject(&RGBChannelDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyRGBChannelDef_getSourceName", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* sourceName = NULL;
    jstring sourceNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceName", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ois:BeamPyRGBChannelDef_setSourceName", &_thisPyObj, &index, &sourceName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    sourceNameJObj =(*jenv)->NewStringUTF(jenv, sourceName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, sourceNameJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyRGBChannelDef_getSourceNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* bandNamesPyObj = NULL;
    jarray bandNamesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyRGBChannelDef_setSourceNames", &_thisPyObj, &bandNamesPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    bandNamesJObj = BPy_ToJStringArray(bandNamesPyObj, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandNamesJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNamesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "isAlphaUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyRGBChannelDef_isAlphaUsed", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "isGammaUsed", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyRGBChannelDef_isGammaUsed", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getGamma", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyRGBChannelDef_getGamma", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble gamma = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setGamma", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oid:BeamPyRGBChannelDef_setGamma", &_thisPyObj, &index, &gamma)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, gamma);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMinDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyRGBChannelDef_getMinDisplaySample", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble min = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMinDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oid:BeamPyRGBChannelDef_setMinDisplaySample", &_thisPyObj, &index, &min)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, min);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMaxDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyRGBChannelDef_getMaxDisplaySample", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble max = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMaxDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oid:BeamPyRGBChannelDef_setMaxDisplaySample", &_thisPyObj, &index, &max)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, max);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyRGBChannelDef_clone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classRGBChannelDef);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_createInstance1", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:BeamPyProductData_createInstance2", &type, &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type, numElems);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(ILjava/lang/Object;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:BeamPyProductData_createInstance3", &type, &dataPyObj)) {
        return NULL;
    }
    dataJObj = BPy_ToJObjectT(dataPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type, dataJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance5", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance1", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance10", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance3", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance8", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance2", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jlong* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([J)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance9", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "l", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jlong*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJLongArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* strData = NULL;
    jstring strDataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductData_createInstance4", &strData)) {
        return NULL;
    }
    strDataJObj =(*jenv)->NewStringUTF(jenv, strData);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, strDataJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, strDataJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jfloat* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([F)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance7", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "f", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jfloat*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJFloatArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jdouble* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([D)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance6", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "d", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jdouble*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJDoubleArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getType1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "(I)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_getElemSize2", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductData, _method, type);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemSize1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "(I)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_getTypeString2", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getType", "(Ljava/lang/String;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductData_getType2", &type)) {
        return NULL;
    }
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductData, _method, typeJObj);
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getTypeString1", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isInt", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_isInt", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isSigned", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_isSigned", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isUnsigned", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_isUnsigned", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isUIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isUIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isFloatingPointType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isFloatingPointType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isScalar", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_isScalar", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getNumElems", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getNumElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemInt", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemInt", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemUInt", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemUInt", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemFloat", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemFloat", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemDouble", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemDouble", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemBoolean", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElemBoolean", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemIntAt", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemIntAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemUIntAt", "(I)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemUIntAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemFloatAt", "(I)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemFloatAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemDoubleAt", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemDoubleAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemStringAt", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemStringAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemBooleanAt", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_getElemBooleanAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemInt", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductData_setElemInt", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong value = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemUInt", "(J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OL:BeamPyProductData_setElemUInt", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat value = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemFloat", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Of:BeamPyProductData_setElemFloat", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemDouble", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyProductData_setElemDouble", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemString", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductData_setElemString", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean value = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemBoolean", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyProductData_setElemBoolean", &_thisPyObj, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemIntAt", "(II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyProductData_setElemIntAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong value = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemUIntAt", "(IJ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiL:BeamPyProductData_setElemUIntAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat value = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemFloatAt", "(IF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oif:BeamPyProductData_setElemFloatAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemDoubleAt", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oid:BeamPyProductData_setElemDoubleAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemStringAt", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ois:BeamPyProductData_setElemStringAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean value = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemBooleanAt", "(IZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oib:BeamPyProductData_setElemBooleanAt", &_thisPyObj, &index, &value)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_getElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductData_setElems", &_thisPyObj, &dataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    dataJObj = BPy_ToJObjectT(dataPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(Ljavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductData_readFrom4", &_thisPyObj, &inputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classImageInputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(ILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyProductData_readFrom3", &_thisPyObj, &pos, &inputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classImageInputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiO:BeamPyProductData_readFrom1", &_thisPyObj, &startPos, &numElems, &inputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classImageInputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    jlong inputPos = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiOL:BeamPyProductData_readFrom2", &_thisPyObj, &startPos, &numElems, &inputPyObj, &inputPos)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    inputJObj = BPy_ToJObjectT(inputPyObj, classImageInputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj, inputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(Ljavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductData_writeTo4", &_thisPyObj, &outputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classImageOutputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(ILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyProductData_writeTo3", &_thisPyObj, &pos, &outputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classImageOutputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiO:BeamPyProductData_writeTo1", &_thisPyObj, &startPos, &numElems, &outputPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classImageOutputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    jlong outputPos = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiOL:BeamPyProductData_writeTo2", &_thisPyObj, &startPos, &numElems, &outputPyObj, &outputPos)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    outputJObj = BPy_ToJObjectT(outputPyObj, classImageOutputStream, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj, outputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_hashCode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* otherPyObj = NULL;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductData_equals", &_thisPyObj, &otherPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    otherJObj = BPy_ToJObjectT(otherPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* otherPyObj = NULL;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "equalElems", "(Lorg/esa/beam/framework/datamodel/ProductData;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductData_equalElems", &_thisPyObj, &otherPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    otherJObj = BPy_ToJObjectT(otherPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductData);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:BeamPyGeoPos_newGeoPos", &lat, &lon)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classGeoPos, _method, lat, lon);
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLat", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_getLat", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLon", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_getLon", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Off:BeamPyGeoPos_setLocation", &_thisPyObj, &lat, &lon)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, lat, lon);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_isValid", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* aPyObj = NULL;
    jarray aJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "areValid", "([Lorg/esa/beam/framework/datamodel/GeoPos;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_areValid", &aPyObj)) {
        return NULL;
    }
    aJObj = BPy_ToJObjectArrayT(aPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classGeoPos, _method, aJObj);
    (*jenv)->DeleteLocalRef(jenv, aJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_setInvalid", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* objPyObj = NULL;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyGeoPos_equals", &_thisPyObj, &objPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    objJObj = BPy_ToJObjectT(objPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_hashCode", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "normalize", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_normalize", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    jfloat lon = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "normalizeLon", "(F)F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:BeamPyGeoPos_normalizeLon", &lon)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticFloatMethod(jenv, classGeoPos, _method, lon);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLatString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_getLatString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLonString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_getLonString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classGeoPos);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductNodeGroup_newProductNodeGroup", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classProductNodeGroup, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_isTakingOverNodeOwnership", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getNodeCount", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductNodeGroup_getAt", &_thisPyObj, &index)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getNodeDisplayNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getNodeNames", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_indexOfName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_indexOf", &_thisPyObj, &elementPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    elementJObj = BPy_ToJObjectT(elementPyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_getByDisplayName", &_thisPyObj, &displayName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_get", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_containsName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_contains", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_add", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiO:BeamPyProductNodeGroup_addAt", &_thisPyObj, &index, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_remove", &_thisPyObj, &nodePyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nodeJObj = BPy_ToJObjectT(nodePyObj, classProductNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_removeAll", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_clearRemovedList", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getRemovedNodes", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyProductNodeGroup_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyProductNodeGroup_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyProductNodeGroup_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductNodeGroup_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductNodeGroup, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductNodeGroup_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductNodeGroup_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classProductNodeGroup);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classProductUtils, _method);
    _resultPyObj = BPy_FromJObject(&ProductUtils_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    jboolean assignMissingImageInfos = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createImageInfo", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ObO:BeamPyProductUtils_createImageInfo", &rastersPyObj, &assignMissingImageInfos, &pmPyObj)) {
        return NULL;
    }
    rastersJObj = BPy_ToJObjectArrayT(rastersPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rastersJObj, assignMissingImageInfos, pmJObj);
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRgbImage", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/ImageInfo;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductUtils_createRgbImage", &rastersPyObj, &imageInfoPyObj, &pmPyObj)) {
        return NULL;
    }
    rastersJObj = BPy_ToJObjectArrayT(rastersPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, classImageInfo, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rastersJObj, imageInfoJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rasterDataNodePyObj = NULL;
    jobject rasterDataNodeJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createColorIndexedImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_createColorIndexedImage", &rasterDataNodePyObj, &pmPyObj)) {
        return NULL;
    }
    rasterDataNodeJObj = BPy_ToJObjectT(rasterDataNodePyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterDataNodeJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapProjectionPyObj = NULL;
    jobject mapProjectionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductUtils_createSuitableMapInfo1", &productPyObj, &rectPyObj, &mapProjectionPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapProjectionJObj = BPy_ToJObjectT(mapProjectionPyObj, classMapProjection, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapProjectionJObj);
    _resultPyObj = BPy_FromJObject(&MapInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* mapProjectionPyObj = NULL;
    jobject mapProjectionJObj = NULL;
    jdouble orientation = (jdouble) 0;
    jdouble noDataValue = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;DD)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdd:BeamPyProductUtils_createSuitableMapInfo2", &productPyObj, &mapProjectionPyObj, &orientation, &noDataValue)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    mapProjectionJObj = BPy_ToJObjectT(mapProjectionPyObj, classMapProjection, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, mapProjectionJObj, orientation, noDataValue);
    _resultPyObj = BPy_FromJObject(&MapInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getOutputRasterSize", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;DD)Ljava/awt/Dimension;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOOdd:BeamPyProductUtils_getOutputRasterSize", &productPyObj, &rectPyObj, &mapTransformPyObj, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, classMapTransform, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapTransformJObj, pixelSizeX, pixelSizeY);
    _resultPyObj = BPy_FromJObject(&Dimension_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductUtils_createMapEnvelope2", &productPyObj, &rectPyObj, &mapTransformPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, classMapTransform, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapTransformJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiO:BeamPyProductUtils_createMapEnvelope1", &productPyObj, &rectPyObj, &step, &mapTransformPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, classMapTransform, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, mapTransformJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* boundaryPyObj = NULL;
    jarray boundaryJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getMinMax", "([Ljava/awt/geom/Point2D;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getMinMax", &boundaryPyObj)) {
        return NULL;
    }
    boundaryJObj = BPy_ToJObjectArrayT(boundaryPyObj, classPoint2D, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, boundaryJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, boundaryJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiO:BeamPyProductUtils_createMapBoundary", &productPyObj, &rectPyObj, &step, &mapTransformPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, classMapTransform, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, mapTransformJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductUtils_createGeoBoundary1", &productPyObj, &step)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyProductUtils_createGeoBoundary2", &productPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    regionJObj = BPy_ToJObjectT(regionPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:BeamPyProductUtils_createGeoBoundary3", &productPyObj, &regionPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    regionJObj = BPy_ToJObjectT(regionPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step, usePixelCenter);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyProductUtils_createGeoBoundary4", &rasterPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    rasterJObj = BPy_ToJObjectT(rasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    regionJObj = BPy_ToJObjectT(regionPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, regionJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_createGeoBoundaryPaths1", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyProductUtils_createGeoBoundaryPaths2", &productPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    regionJObj = BPy_ToJObjectT(regionPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:BeamPyProductUtils_createGeoBoundaryPaths3", &productPyObj, &regionPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    regionJObj = BPy_ToJObjectT(regionPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step, usePixelCenter);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyProductUtils_createPixelBoundary1", &productPyObj, &rectPyObj, &step)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:BeamPyProductUtils_createPixelBoundary2", &productPyObj, &rectPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, usePixelCenter);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:BeamPyProductUtils_createPixelBoundary3", &rasterPyObj, &rectPyObj, &step)) {
        return NULL;
    }
    rasterJObj = BPy_ToJObjectT(rasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, rectJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyProductUtils_createRectBoundary1", &rectPyObj, &step)) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rectJObj, step);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oib:BeamPyProductUtils_createRectBoundary2", &rectPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    rectJObj = BPy_ToJObjectT(rectPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rectJObj, step, usePixelCenter);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagCodings", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyFlagCodings", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    sourceJObj = BPy_ToJObjectT(sourcePyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetJObj = BPy_ToJObjectT(targetPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceFlagCodingPyObj = NULL;
    jobject sourceFlagCodingJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagCoding", "(Lorg/esa/beam/framework/datamodel/FlagCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/FlagCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyFlagCoding", &sourceFlagCodingPyObj, &targetPyObj)) {
        return NULL;
    }
    sourceFlagCodingJObj = BPy_ToJObjectT(sourceFlagCodingPyObj, classFlagCoding, &ok);
    if (!ok) {
        return NULL;
    }
    targetJObj = BPy_ToJObjectT(targetPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceFlagCodingJObj, targetJObj);
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceIndexCodingPyObj = NULL;
    jobject sourceIndexCodingJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyIndexCoding", "(Lorg/esa/beam/framework/datamodel/IndexCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/IndexCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyIndexCoding", &sourceIndexCodingPyObj, &targetPyObj)) {
        return NULL;
    }
    sourceIndexCodingJObj = BPy_ToJObjectT(sourceIndexCodingPyObj, classIndexCoding, &ok);
    if (!ok) {
        return NULL;
    }
    targetJObj = BPy_ToJObjectT(targetPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceIndexCodingJObj, targetJObj);
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyOverlayMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyOverlayMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyRoiMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyRoiMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOb:BeamPyProductUtils_copyFlagBands2", &sourceProductPyObj, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, copySourceImage);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyFlagBands1", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* gridName = NULL;
    jstring gridNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyTiePointGrid", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyProductUtils_copyTiePointGrid", &gridName, &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    gridNameJObj =(*jenv)->NewStringUTF(jenv, gridName);
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, gridNameJObj, sourceProductJObj, targetProductJObj);
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, gridNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOOb:BeamPyProductUtils_copyBand4", &sourceBandName, &sourceProductPyObj, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj, copySourceImage);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOsOb:BeamPyProductUtils_copyBand2", &sourceBandName, &sourceProductPyObj, &targetBandName, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj, copySourceImage);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceRasterPyObj = NULL;
    jobject sourceRasterJObj = NULL;
    PyObject* targetRasterPyObj = NULL;
    jobject targetRasterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyRasterDataNodeProperties", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/RasterDataNode;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyRasterDataNodeProperties", &sourceRasterPyObj, &targetRasterPyObj)) {
        return NULL;
    }
    sourceRasterJObj = BPy_ToJObjectT(sourceRasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    targetRasterJObj = BPy_ToJObjectT(targetRasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceRasterJObj, targetRasterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyProductUtils_copyBand3", &sourceBandName, &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOsO:BeamPyProductUtils_copyBand1", &sourceBandName, &sourceProductPyObj, &targetBandName, &targetProductPyObj)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj);
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceBandPyObj = NULL;
    jobject sourceBandJObj = NULL;
    PyObject* targetBandPyObj = NULL;
    jobject targetBandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copySpectralBandProperties", "(Lorg/esa/beam/framework/datamodel/Band;Lorg/esa/beam/framework/datamodel/Band;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copySpectralBandProperties", &sourceBandPyObj, &targetBandPyObj)) {
        return NULL;
    }
    sourceBandJObj = BPy_ToJObjectT(sourceBandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    targetBandJObj = BPy_ToJObjectT(targetBandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceBandJObj, targetBandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyGeoCoding", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyGeoCoding", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyTiePointGrids", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyTiePointGrids", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyVectorData", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyVectorData", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_canGetPixelPos1", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductUtils, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_canGetPixelPos2", &rasterPyObj)) {
        return NULL;
    }
    rasterJObj = BPy_ToJObjectT(rasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductUtils, _method, rasterJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* raster1PyObj = NULL;
    jobject raster1JObj = NULL;
    jfloat sampleMin1 = (jfloat) 0;
    jfloat sampleMax1 = (jfloat) 0;
    PyObject* raster2PyObj = NULL;
    jobject raster2JObj = NULL;
    jfloat sampleMin2 = (jfloat) 0;
    jfloat sampleMax2 = (jfloat) 0;
    PyObject* roiMaskPyObj = NULL;
    jobject roiMaskJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* backgroundPyObj = NULL;
    jobject backgroundJObj = NULL;
    PyObject* imagePyObj = NULL;
    jobject imageJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createDensityPlotImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/Mask;IILjava/awt/Color;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OffOffOiiOOO:BeamPyProductUtils_createDensityPlotImage", &raster1PyObj, &sampleMin1, &sampleMax1, &raster2PyObj, &sampleMin2, &sampleMax2, &roiMaskPyObj, &width, &height, &backgroundPyObj, &imagePyObj, &pmPyObj)) {
        return NULL;
    }
    raster1JObj = BPy_ToJObjectT(raster1PyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    raster2JObj = BPy_ToJObjectT(raster2PyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    roiMaskJObj = BPy_ToJObjectT(roiMaskPyObj, classMask, &ok);
    if (!ok) {
        return NULL;
    }
    backgroundJObj = BPy_ToJObjectT(backgroundPyObj, classColor, &ok);
    if (!ok) {
        return NULL;
    }
    imageJObj = BPy_ToJObjectT(imagePyObj, classBufferedImage, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, raster1JObj, sampleMin1, sampleMax1, raster2JObj, sampleMin2, sampleMax2, roiMaskJObj, width, height, backgroundJObj, imageJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* overlayBImPyObj = NULL;
    jobject overlayBImJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "overlayMasks", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:BeamPyProductUtils_overlayMasks", &rasterPyObj, &overlayBImPyObj, &pmPyObj)) {
        return NULL;
    }
    rasterJObj = BPy_ToJObjectT(rasterPyObj, classRasterDataNode, &ok);
    if (!ok) {
        return NULL;
    }
    overlayBImJObj = BPy_ToJObjectT(overlayBImPyObj, classBufferedImage, &ok);
    if (!ok) {
        return NULL;
    }
    pmJObj = BPy_ToJObjectT(pmPyObj, classProgressMonitor, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, overlayBImJObj, pmJObj);
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getCenterGeoPos", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getCenterGeoPos", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_normalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon_old", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_normalizeGeoPolygon_old", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_denormalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_denormalizeGeoPos", &geoPosPyObj)) {
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos_old", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_denormalizeGeoPos_old", &geoPosPyObj)) {
        return NULL;
    }
    geoPosJObj = BPy_ToJObjectT(geoPosPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getRotationDirection", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getRotationDirection", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getAngleSum", "([Lorg/esa/beam/framework/datamodel/GeoPos;)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getAngleSum", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, classGeoPos, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* geoPathPyObj = NULL;
    jobject geoPathJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "convertToPixelPath", "(Ljava/awt/geom/GeneralPath;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_convertToPixelPath", &geoPathPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    geoPathJObj = BPy_ToJObjectT(geoPathPyObj, classGeneralPath, &ok);
    if (!ok) {
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, geoPathJObj, geoCodingJObj);
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "convertToGeoPath", "(Ljava/awt/Shape;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_convertToGeoPath", &shapePyObj, &geoCodingPyObj)) {
        return NULL;
    }
    shapeJObj = BPy_ToJObjectT(shapePyObj, classShape, &ok);
    if (!ok) {
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, shapeJObj, geoCodingJObj);
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyMetadata2", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    sourceJObj = BPy_ToJObjectT(sourcePyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetJObj = BPy_ToJObjectT(targetPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/MetadataElement;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyMetadata1", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    sourceJObj = BPy_ToJObjectT(sourcePyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    targetJObj = BPy_ToJObjectT(targetPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyPreferredTileSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_copyPreferredTileSize", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_createGeoTIFFMetadata2", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = BPy_FromJObject(&GeoTIFFMetadata_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/GeoCoding;II)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:BeamPyProductUtils_createGeoTIFFMetadata1", &geoCodingPyObj, &width, &height)) {
        return NULL;
    }
    geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, geoCodingJObj, width, height);
    _resultPyObj = BPy_FromJObject(&GeoTIFFMetadata_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* negativeAreaPyObj = NULL;
    jobject negativeAreaJObj = NULL;
    jdouble deltaX = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "areaToPath", "(Ljava/awt/geom/Area;D)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyProductUtils_areaToPath", &negativeAreaPyObj, &deltaX)) {
        return NULL;
    }
    negativeAreaJObj = BPy_ToJObjectT(negativeAreaPyObj, classArea, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, negativeAreaJObj, deltaX);
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* elemPyObj = NULL;
    jobject elemJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "addElementToHistory", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyProductUtils_addElementToHistory", &productPyObj, &elemPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    elemJObj = BPy_ToJObjectT(elemPyObj, classMetadataElement, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, productJObj, elemJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "removeInvalidExpressions", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_removeInvalidExpressions", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "findSuitableQuicklookBandName", "(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_findSuitableQuicklookBandName", &productPyObj)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceGeoCodingPyObj = NULL;
    jobject sourceGeoCodingJObj = NULL;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    PyObject* destGeoCodingPyObj = NULL;
    jobject destGeoCodingJObj = NULL;
    PyObject* destAreaPyObj = NULL;
    jobject destAreaJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "computeSourcePixelCoordinates", "(Lorg/esa/beam/framework/datamodel/GeoCoding;IILorg/esa/beam/framework/datamodel/GeoCoding;Ljava/awt/Rectangle;)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiOO:BeamPyProductUtils_computeSourcePixelCoordinates", &sourceGeoCodingPyObj, &sourceWidth, &sourceHeight, &destGeoCodingPyObj, &destAreaPyObj)) {
        return NULL;
    }
    sourceGeoCodingJObj = BPy_ToJObjectT(sourceGeoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    destGeoCodingJObj = BPy_ToJObjectT(destGeoCodingPyObj, classGeoCoding, &ok);
    if (!ok) {
        return NULL;
    }
    destAreaJObj = BPy_ToJObjectT(destAreaPyObj, classRectangle, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceGeoCodingJObj, sourceWidth, sourceHeight, destGeoCodingJObj, destAreaJObj);
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* pixelPositionsPyObj = NULL;
    jarray pixelPositionsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "computeMinMaxY", "([Lorg/esa/beam/framework/datamodel/PixelPos;)[F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_computeMinMaxY", &pixelPositionsPyObj)) {
        return NULL;
    }
    pixelPositionsJObj = BPy_ToJObjectArrayT(pixelPositionsPyObj, classPixelPos, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, pixelPositionsJObj);
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pixelPositionsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* addedRasterDataNodesPyObj = NULL;
    jobject addedRasterDataNodesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;DLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdO:BeamPyProductUtils_copyBandsForGeomTransform1", &sourceProductPyObj, &targetProductPyObj, &defaultNoDataValue, &addedRasterDataNodesPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    addedRasterDataNodesJObj = BPy_ToJObjectT(addedRasterDataNodesPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, defaultNoDataValue, addedRasterDataNodesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean includeTiePointGrids = (jboolean) 0;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* targetToSourceMapPyObj = NULL;
    jobject targetToSourceMapJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;ZDLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OObdO:BeamPyProductUtils_copyBandsForGeomTransform2", &sourceProductPyObj, &targetProductPyObj, &includeTiePointGrids, &defaultNoDataValue, &targetToSourceMapPyObj)) {
        return NULL;
    }
    sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetProductJObj = BPy_ToJObjectT(targetProductPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    targetToSourceMapJObj = BPy_ToJObjectT(targetToSourceMapPyObj, classMap, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, includeTiePointGrids, defaultNoDataValue, targetToSourceMapJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jdouble y = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getScanLineTime", "(Lorg/esa/beam/framework/datamodel/Product;D)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:BeamPyProductUtils_getScanLineTime", &productPyObj, &y)) {
        return NULL;
    }
    productJObj = BPy_ToJObjectT(productPyObj, classProduct, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, y);
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleDouble", "(Lorg/esa/beam/framework/datamodel/Band;III)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:BeamPyProductUtils_getGeophysicalSampleDouble", &bandPyObj, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    bandJObj = BPy_ToJObjectT(bandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classProductUtils, _method, bandJObj, pixelX, pixelY, level);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleLong", "(Lorg/esa/beam/framework/datamodel/Band;III)J", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:BeamPyProductUtils_getGeophysicalSampleLong", &bandPyObj, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    bandJObj = BPy_ToJObjectT(bandPyObj, classBand, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallStaticLongMethod(jenv, classProductUtils, _method, bandJObj, pixelX, pixelY, level);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "<init>", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData;Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOb:BeamPyMetadataAttribute_newMetadataAttribute", &name, &dataPyObj, &readOnly)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    dataJObj = BPy_ToJObjectT(dataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classMetadataAttribute, _method, nameJObj, dataJObj, readOnly);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getParentElement", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* objectPyObj = NULL;
    jobject objectJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_equals", &_thisPyObj, &objectPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    objectJObj = BPy_ToJObjectT(objectPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objectJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_acceptVisitor", &_thisPyObj, &visitorPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    visitorJObj = BPy_ToJObjectT(visitorPyObj, classProductVisitor, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_createDeepClone", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getDataType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_isFloatingPointType", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getNumDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_setData", &_thisPyObj, &dataPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    dataJObj = BPy_ToJObjectT(dataPyObj, classProductData, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getData", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_setDataElems", &_thisPyObj, &elemsPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    elemsJObj = BPy_ToJObjectT(elemsPyObj, classObject, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getDataElems", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getDataElemSize", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyMetadataAttribute_setReadOnly", &_thisPyObj, &readOnly)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_isReadOnly", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataAttribute_setUnit", &_thisPyObj, &unit)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getUnit", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_isSynthetic", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyMetadataAttribute_setSynthetic", &_thisPyObj, &synthetic)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_fireProductNodeDataChanged", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_dispose", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyMetadataAttribute_createCompatibleProductData", &_thisPyObj, &numElems)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getOwner", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataAttribute_setName", &_thisPyObj, &name)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getDescription", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Os:BeamPyMetadataAttribute_setDescription", &_thisPyObj, &description)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_isModified", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob:BeamPyMetadataAttribute_setModified", &_thisPyObj, &modified)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_toString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataAttribute_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classMetadataAttribute, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getProduct", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getProductReader", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getProductWriter", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getDisplayName", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyMetadataAttribute_getProductRefString", &_thisPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:BeamPyMetadataAttribute_updateExpression", &_thisPyObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_removeFromFile", &_thisPyObj, &productWriterPyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    productWriterJObj = BPy_ToJObjectT(productWriterPyObj, classProductWriter, &ok);
    if (!ok) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jboolean ok = 1;
    
    PyObject* _thisPyObj = NULL;
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:BeamPyMetadataAttribute_getExtension", &_thisPyObj, &arg0PyObj)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(_thisPyObj, classMetadataAttribute);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    arg0JObj = BPy_ToJObjectT(arg0PyObj, classClass, &ok);
    if (!ok) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}



/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * This code has been generated using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */

// <<<<<<<< Begin include from PyCModuleGenerator-stub-init.c
// #include "beam_capi.h"
#include "beampy.h"

#include <Python.h>
#include "structmember.h"
#include <jni.h>

#include "../beam_util.h"

static PyObject* BeamPy_Error;

/* Extra global functions for beampy. These will also go into the module definition. */
PyObject* BeamPyObject_delete(PyObject* self, PyObject* args);
PyObject* BeamPyString_newString(PyObject* self, PyObject* args);


jarray beampy_newJBooleanArray(const jboolean* data, jint length);
jarray beampy_newJByteArray(const jbyte* data, jint length);
jarray beampy_newJCharArray(const jchar* data, jint length);
jarray beampy_newJShortArray(const jshort* data, jint length);
jarray beampy_newJIntArray(const jint* data, jint length);
jarray beampy_newJLongArray(const jlong* data, jint length);
jarray beampy_newJFloatArray(const jfloat* data, jint length);
jarray beampy_newJDoubleArray(const jdouble* data, jint length);

// experimental
// PyObject* BeamPyMap_newHashMap(PyObject* self, PyObject* args);
// >>>>>>>> End include from PyCModuleGenerator-stub-init.c

/* Wrapped API classes */
typedef void* GeoCoding;
typedef void* ProductWriter;
typedef void* GPF;
typedef void* IndexCoding;
typedef void* PixelPos;
typedef void* ProductIO;
typedef void* Placemark;
typedef void* MetadataElement;
typedef void* Product;
typedef void* ColorPaletteDef;
typedef void* ImageInfo;
typedef void* ProductManager;
typedef void* ImageGeometry;
typedef void* Band;
typedef void* PlacemarkGroup;
typedef void* TiePointGrid;
typedef void* AngularDirection;
typedef void* FlagCoding;
typedef void* ProductReader;
typedef void* RGBChannelDef;
typedef void* ProductData;
typedef void* GeoPos;
typedef void* ProductNodeGroup;
typedef void* ProductUtils;
typedef void* MetadataAttribute;


/* Non-API classes used in the API */
typedef void* String;
typedef void* ProgressMonitor;
typedef void* MultiLevelImage;
typedef void* Parser;
typedef void* Term;
typedef void* WritableNamespace;
typedef void* Color;
typedef void* Dimension;
typedef void* Rectangle;
typedef void* RenderingHints;
typedef void* RenderingHints_Key;
typedef void* Shape;
typedef void* AffineTransform;
typedef void* Area;
typedef void* GeneralPath;
typedef void* Point2D;
typedef void* Rectangle2D;
typedef void* BufferedImage;
typedef void* ComponentColorModel;
typedef void* IndexColorModel;
typedef void* RenderedImage;
typedef void* File;
typedef void* Class;
typedef void* Double;
typedef void* Integer;
typedef void* Object;
typedef void* Collection;
typedef void* Iterator;
typedef void* Map;
typedef void* ImageInputStream;
typedef void* ImageOutputStream;
typedef void* ROI;
typedef void* ProductReaderPlugIn;
typedef void* ProductSubsetDef;
typedef void* ProductWriterPlugIn;
typedef void* BitmaskDef;
typedef void* ColorPaletteDef_Point;
typedef void* ImageInfo_HistogramMatching;
typedef void* Mask;
typedef void* PlacemarkDescriptor;
typedef void* Pointing;
typedef void* PointingFactory;
typedef void* Product_AutoGrouping;
typedef void* ProductData_UTC;
typedef void* ProductManager_Listener;
typedef void* ProductNode;
typedef void* ProductNodeListener;
typedef void* ProductVisitor;
typedef void* RasterDataNode;
typedef void* SampleCoding;
typedef void* Scaling;
typedef void* Stx;
typedef void* TransectProfileData;
typedef void* VectorDataNode;
typedef void* Datum;
typedef void* MapInfo;
typedef void* MapProjection;
typedef void* MapTransform;
typedef void* Operator;
typedef void* OperatorSpiRegistry;
typedef void* BitRaster;
typedef void* GeoTIFFMetadata;
typedef void* Histogram;
typedef void* IndexValidator;
typedef void* SimpleFeature;
typedef void* SimpleFeatureType;
typedef void* CoordinateReferenceSystem;
typedef void* MathTransform;

// <<<<<<<< Begin include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.h
/*
 * Java VM functions that must be used if this module is used in stand-alone
 * mode (= not loaded as shared library by a Java VM).
 */
boolean beam_isJvmCreated();
boolean beam_createJvm(const char* option_strings[], int option_count);
boolean beam_createJvmWithDefaults();
boolean beam_destroyJvm();

String String_newString(const char* chars);
void Object_delete(Object object);
// >>>>>>>> End include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.h

PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGroups(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumResolutionsMax(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setNumResolutionsMax(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createValidRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_toString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args);
PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scale(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getClosestGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args);

static PyMethodDef BeamPy_Methods[] = {
    {"GeoCoding_isCrossingMeridianAt180", BeamPyGeoCoding_isCrossingMeridianAt180, METH_VARARGS, " Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.\n\n @return <code>true</code>, if so\n\n@param this The GeoCoding object."},
    {"GeoCoding_canGetPixelPos", BeamPyGeoCoding_canGetPixelPos, METH_VARARGS, " Checks whether or not this geo-coding can determine the pixel position from a geodetic position.\n\n @return <code>true</code>, if so\n\n@param this The GeoCoding object."},
    {"GeoCoding_canGetGeoPos", BeamPyGeoCoding_canGetGeoPos, METH_VARARGS, " Checks whether or not this geo-coding can determine the geodetic position from a pixel position.\n\n @return <code>true</code>, if so\n\n@param this The GeoCoding object."},
    {"GeoCoding_getPixelPos", BeamPyGeoCoding_getPixelPos, METH_VARARGS, " Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.\n\n \n@param this The GeoCoding object.\n@param geoPos   the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\n @param pixelPos an instance of <code>Point</code> to be used as retun value. If this parameter is\n                 <code>null</code>, the method creates a new instance which it then returns.\n @return the pixel co-ordinates as x/y\n"},
    {"GeoCoding_getGeoPos", BeamPyGeoCoding_getGeoPos, METH_VARARGS, " Returns the latitude and longitude value for a given pixel co-ordinate.\n\n \n@param this The GeoCoding object.\n@param pixelPos the pixel's co-ordinates given as x,y\n @param geoPos   an instance of <code>GeoPos</code> to be used as retun value. If this parameter is\n                 <code>null</code>, the method creates a new instance which it then returns.\n @return the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\n"},
    {"GeoCoding_getDatum", BeamPyGeoCoding_getDatum, METH_VARARGS, " Gets the datum, the reference point or surface against which {@link GeoPos} measurements are made.\n\n @return the datum\n @deprecated use the datum of the associated {@link #getMapCRS() map CRS}.\n\n@param this The GeoCoding object."},
    {"GeoCoding_dispose", BeamPyGeoCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getImageCRS", BeamPyGeoCoding_getImageCRS, METH_VARARGS, " @return The image coordinate reference system (CRS). It is usually derived from the base CRS by including\n         a linear or non-linear transformation from base (geodetic) coordinates to image coordinates.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getMapCRS", BeamPyGeoCoding_getMapCRS, METH_VARARGS, " @return The map coordinate reference system (CRS). It may be either a geographical CRS (nominal case is\n         \"WGS-84\") or a derived projected CRS, e.g. \"UTM 32 - North\".\n\n@param this The GeoCoding object."},
    {"GeoCoding_getGeoCRS", BeamPyGeoCoding_getGeoCRS, METH_VARARGS, " @return The geographical coordinate reference system (CRS). It may be either \"WGS-84\" (nominal case) or\n         any other geographical CRS.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getImageToMapTransform", BeamPyGeoCoding_getImageToMapTransform, METH_VARARGS, " @return The math transformation used to convert image coordinates to map coordinates.\n\n@param this The GeoCoding object."},
    {"ProductWriter_getWriterPlugIn", BeamPyProductWriter_getWriterPlugIn, METH_VARARGS, " Returns the plug-in which created this product writer.\n\n @return the product writer plug-in, should never be <code>null</code>\n\n@param this The ProductWriter object."},
    {"ProductWriter_getOutput", BeamPyProductWriter_getOutput, METH_VARARGS, " Retrives the current output destination object. Thie return value might be <code>null</code> if the\n <code>setOutput</code> has not been called so far.\n\n @return the output\n\n@param this The ProductWriter object."},
    {"ProductWriter_writeProductNodes", BeamPyProductWriter_writeProductNodes, METH_VARARGS, " Writes the in-memory representation of a data product.\n <p/>\n <p> Whether the band data - the actual pixel values - is written out immediately or later when pixels are\n flushed, is up to the implementation.\n\n \n@param this The ProductWriter object.\n@param product the in-memory representation of the data product\n @param output  an object representing a valid output for this writer, might be a <code>ImageInputStream</code> or\n                other <code>Object</code> to use for future decoding.\n\n @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is not one of the\n                                  supported output sources.\n @throws IOException              if an I/O error occurs\n"},
    {"ProductWriter_writeBandRasterData", BeamPyProductWriter_writeBandRasterData, METH_VARARGS, " Writes raster data from the given in-memory source buffer into the data sink specified by the given source band\n and region.\n <p/>\n <h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample\n values given in the source buffer. The method does not modify the pixel data of the given source band at all.\n <p/>\n <h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>\n and <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data\n and <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be\n <code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in\n line-by-line order, so the raster X co-ordinate varies faster than the Y.\n <p/>\n <h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,\n <code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the\n source band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates\n since product writers do not support spectral or spatial subsets.\n\n \n@param this The ProductWriter object.\n@param sourceBand    the source band which identifies the data sink to which to write the sample values\n @param sourceOffsetX the X-offset in the band's raster co-ordinates\n @param sourceOffsetY the Y-offset in the band's raster co-ordinates\n @param sourceWidth   the width of region to be written given in the band's raster co-ordinates\n @param sourceHeight  the height of region to be written given in the band's raster co-ordinates\n @param sourceBuffer  the source buffer which provides the sample values to be written\n @param pm            a monitor to inform the user about progress\n\n @throws IOException              if an I/O error occurs\n @throws IllegalArgumentException if the number of elements source buffer not equals <code>sourceWidth *\n                                  sourceHeight</code> or the source region is out of the band's raster\n @see org.esa.beam.framework.datamodel.Band#getRasterWidth()\n @see org.esa.beam.framework.datamodel.Band#getRasterHeight()\n"},
    {"ProductWriter_flush", BeamPyProductWriter_flush, METH_VARARGS, " Writes all data in memory to the data sink(s) associated with this writer.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_close", BeamPyProductWriter_close, METH_VARARGS, " Closes all output streams currently open. A concrete implementation should call <code>flush</code> before\n performing the actual close-operation.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_shouldWrite", BeamPyProductWriter_shouldWrite, METH_VARARGS, " Returns wether the given product node is to be written.\n\n \n@param this The ProductWriter object.\n@param node the product node\n\n @return <code>true</code> if so\n"},
    {"ProductWriter_isIncrementalMode", BeamPyProductWriter_isIncrementalMode, METH_VARARGS, " Returns whether this product writer writes only modified product nodes.\n\n @return <code>true</code> if so\n\n@param this The ProductWriter object."},
    {"ProductWriter_setIncrementalMode", BeamPyProductWriter_setIncrementalMode, METH_VARARGS, " Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress\n listening.\n\n \n@param this The ProductWriter object.\n@param enabled enables or disables progress listening.\n"},
    {"ProductWriter_deleteOutput", BeamPyProductWriter_deleteOutput, METH_VARARGS, " Complete deletes the physical representation of the given product from the file system.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_removeBand", BeamPyProductWriter_removeBand, METH_VARARGS, " Physically deletes a <code>Band</code> in a product writer's output.\n\n \n@param this The ProductWriter object.\n@param band The band to delete.\n"},
    {"GPF_createProductWithoutSourceProducts", BeamPyGPF_createProductWithoutSourceProducts, METH_VARARGS, " Creates a product by using the operator specified by the given name.\n The resulting product can be used as input product for a further call to {@code createProduct()}.\n By concatenating multiple calls it is possible to set up a processing graph.\n\n @param operatorName the name of the operator to use.\n @param parameters   the named parameters needed by the operator.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n"},
    {"GPF_createProductFromSourceProduct", BeamPyGPF_createProductFromSourceProduct, METH_VARARGS, " Creates a product by using the operator specified by the given name.\n The resulting product can be used as input product for a further call to {@code createProduct()}.\n By concatenating multiple calls it is possible to set up a processing graph.\n\n @param operatorName  the name of the operator to use.\n @param parameters    the named parameters needed by the operator.\n @param sourceProduct a source product.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n"},
    {"GPF_createProductFromSourceProducts", BeamPyGPF_createProductFromSourceProducts, METH_VARARGS, " Creates a product by using the operator specified by the given name.\n The resulting product can be used as input product for a further call to {@code createProduct()}.\n By concatenating multiple calls it is possible to set up a processing graph.\n\n @param operatorName   the name of the operator to use.\n @param parameters     the named parameters needed by the operator.\n @param sourceProducts the source products.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n"},
    {"GPF_createProductFromNamedSourceProducts", BeamPyGPF_createProductFromNamedSourceProducts, METH_VARARGS, " Creates a product by using the operator specified by the given name.\n The resulting product can be used as input product for a further call to {@code createProduct()}.\n By concatenating multiple calls it is possible to set up a processing graph.\n\n @param operatorName   the name of the operator to use.\n @param parameters     the named parameters needed by the operator.\n @param sourceProducts the map of named source products.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n"},
    {"GPF_createProductNS", BeamPyGPF_createProductNS, METH_VARARGS, " Creates a product by using the operator specified by the given name.\n The resulting product can be used as input product for a further call to {@code createProduct()}.\n By concatenating multiple calls it is possible to set up a processing graph.\n <p>All static {@code createProduct} methods delegate to this non-static (= NS) version.\n It can be overriden by clients in order to alter product creation behaviour of the static\n {@code createProduct} methods of the current GPF instance.</p>\n\n \n@param this The GPF object.\n@param operatorName   the name of the operator to use.\n @param parameters     the named parameters needed by the operator.\n @param sourceProducts the map of named source products.\n @param renderingHints the rendering hints, may be {@code null}.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n"},
    {"GPF_createOperator", BeamPyGPF_createOperator, METH_VARARGS, " Creates an operator instance by using the given operator (alias) name.\n\n \n@param this The GPF object.\n@param operatorName   the name of the operator to use.\n @param parameters     the named parameters needed by the operator.\n @param sourceProducts the map of named source products.\n @param renderingHints the rendering hints, may be {@code null}.\n\n @return the product created by the operator.\n\n @throws OperatorException if the product could not be created.\n @since BEAM 4.9\n"},
    {"GPF_getOperatorSpiRegistry", BeamPyGPF_getOperatorSpiRegistry, METH_VARARGS, " Gets the registry for operator SPIs.\n\n @return the registry for operator SPIs.\n\n@param this The GPF object."},
    {"GPF_setOperatorSpiRegistry", BeamPyGPF_setOperatorSpiRegistry, METH_VARARGS, " Sets the registry for operator SPIs.\n\n \n@param this The GPF object.\n@param spiRegistry the registry for operator SPIs.\n"},
    {"GPF_getDefaultInstance", BeamPyGPF_getDefaultInstance, METH_VARARGS, " Gets the default GPF instance.\n\n @return the singelton instance.\n"},
    {"GPF_setDefaultInstance", BeamPyGPF_setDefaultInstance, METH_VARARGS, " Sets the default GPF instance.\n\n @param defaultInstance the GPF default instance.\n"},
    {"GPF_writeProduct", BeamPyGPF_writeProduct, METH_VARARGS, " Writes a product with the specified format to the given file.\n\n @param product     the product\n @param file        the product file\n @param formatName  the name of a supported product format, e.g. \"HDF5\". If <code>null</code>, the default format\n                    \"BEAM-DIMAP\" will be used\n @param incremental switch the product writer in incremental mode or not.\n @param pm          a monitor to inform the user about progress\n"},
    {"IndexCoding_newIndexCoding", BeamPyIndexCoding_newIndexCoding, METH_VARARGS, " Constructs a new index coding object with the given name.\n\n @param name the name\n"},
    {"IndexCoding_getIndex", BeamPyIndexCoding_getIndex, METH_VARARGS, " Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to\n getPropertyValue(String).\n\n \n@param this The IndexCoding object.\n@param name the flag name\n @return a metadata attribute wich is the representation of the flag with the given name\n"},
    {"IndexCoding_getIndexNames", BeamPyIndexCoding_getIndexNames, METH_VARARGS, " Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.\n\n @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned\n\n@param this The IndexCoding object."},
    {"IndexCoding_addIndex", BeamPyIndexCoding_addIndex, METH_VARARGS, " Adds a new index definition to this flags coding.\n\n \n@param this The IndexCoding object.\n@param name        the index name\n @param value       the index value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded index. \n"},
    {"IndexCoding_getIndexValue", BeamPyIndexCoding_getIndexValue, METH_VARARGS, " Returns the flag mask value for the specified flag name.\n\n \n@param this The IndexCoding object.\n@param name the flag name\n @return flagMask the flag's bit mask as a 32 bit integer\n @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist\n"},
    {"IndexCoding_acceptVisitor", BeamPyIndexCoding_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The IndexCoding object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"IndexCoding_addElement", BeamPyIndexCoding_addElement, METH_VARARGS, " Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\n because flag codings do not support inner elements.\n\n \n@param this The IndexCoding object.\n@param element the element to be added, always ignored\n"},
    {"IndexCoding_addAttribute", BeamPyIndexCoding_addAttribute, METH_VARARGS, " Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n\n \n@param this The IndexCoding object.\n@param attribute the attribute to be added\n @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value\n"},
    {"IndexCoding_addSample", BeamPyIndexCoding_addSample, METH_VARARGS, " Adds a new coding value to this sample coding.\n\n \n@param this The IndexCoding object.\n@param name        the coding name\n @param value       the value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded sample.\n"},
    {"IndexCoding_getSampleCount", BeamPyIndexCoding_getSampleCount, METH_VARARGS, " Gets the number of coded sample values.\n\n @return the number of coded sample values\n\n@param this The IndexCoding object."},
    {"IndexCoding_getSampleName", BeamPyIndexCoding_getSampleName, METH_VARARGS, " Gets the sample name at the specified attribute index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index.\n @return the sample name.\n"},
    {"IndexCoding_getSampleValue", BeamPyIndexCoding_getSampleValue, METH_VARARGS, " Gets the sample value at the specified attribute index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index.\n @return the sample value.\n"},
    {"IndexCoding_getElementGroup", BeamPyIndexCoding_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n\n @return The child element group, may be null.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getParentElement", BeamPyIndexCoding_getParentElement, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_addElementAt", BeamPyIndexCoding_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The IndexCoding object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"IndexCoding_removeElement", BeamPyIndexCoding_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The IndexCoding object.\n@param element the element to be removed, ignored if <code>null</code>\n\n @return true, if so\n"},
    {"IndexCoding_getNumElements", BeamPyIndexCoding_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElementAt", BeamPyIndexCoding_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The IndexCoding object.\n@param index the element index\n\n @return the element at the given index\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"IndexCoding_getElementNames", BeamPyIndexCoding_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElements", BeamPyIndexCoding_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElement", BeamPyIndexCoding_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The IndexCoding object.\n@param name the element name\n\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"IndexCoding_containsElement", BeamPyIndexCoding_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The IndexCoding object.\n@param name the name, must not be <code>null</code>\n\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"IndexCoding_getElementIndex", BeamPyIndexCoding_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n\n \n@param this The IndexCoding object.\n@param element The element .\n\n @return The element's index, or -1.\n\n @since BEAM 4.7\n"},
    {"IndexCoding_removeAttribute", BeamPyIndexCoding_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The IndexCoding object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n\n @return <code>true</code> if it was removed\n"},
    {"IndexCoding_getNumAttributes", BeamPyIndexCoding_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttributeAt", BeamPyIndexCoding_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index\n\n @return the attribute, or <code>null</code> if this node does not contain attributes\n\n @throws IndexOutOfBoundsException\n"},
    {"IndexCoding_getAttributeNames", BeamPyIndexCoding_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttributes", BeamPyIndexCoding_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttribute", BeamPyIndexCoding_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The IndexCoding object.\n@param name the attribute name\n\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"IndexCoding_containsAttribute", BeamPyIndexCoding_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The IndexCoding object.\n@param name the attribute name\n\n @return <code>true</code> if so\n"},
    {"IndexCoding_getAttributeIndex", BeamPyIndexCoding_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n\n \n@param this The IndexCoding object.\n@param attribute The attribute.\n\n @return The attribute's index, or -1.\n\n @since BEAM 4.7\n"},
    {"IndexCoding_getAttributeDouble", BeamPyIndexCoding_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as double.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"IndexCoding_getAttributeUTC", BeamPyIndexCoding_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as UTC.\n"},
    {"IndexCoding_getAttributeInt", BeamPyIndexCoding_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"IndexCoding_setAttributeInt", BeamPyIndexCoding_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setAttributeDouble", BeamPyIndexCoding_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setAttributeUTC", BeamPyIndexCoding_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_getAttributeString", BeamPyIndexCoding_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n"},
    {"IndexCoding_setAttributeString", BeamPyIndexCoding_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setModified", BeamPyIndexCoding_setModified, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_createDeepClone", BeamPyIndexCoding_createDeepClone, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_dispose", BeamPyIndexCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getOwner", BeamPyIndexCoding_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getName", BeamPyIndexCoding_getName, METH_VARARGS, " @return This node's name.\n\n@param this The IndexCoding object."},
    {"IndexCoding_setName", BeamPyIndexCoding_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The IndexCoding object.\n@param name The name.\n"},
    {"IndexCoding_getDescription", BeamPyIndexCoding_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The IndexCoding object."},
    {"IndexCoding_setDescription", BeamPyIndexCoding_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The IndexCoding object.\n@param description a description, can be <code>null</code>\n"},
    {"IndexCoding_isModified", BeamPyIndexCoding_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The IndexCoding object."},
    {"IndexCoding_toString", BeamPyIndexCoding_toString, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_isValidNodeName", BeamPyIndexCoding_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"IndexCoding_getProduct", BeamPyIndexCoding_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductReader", BeamPyIndexCoding_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductWriter", BeamPyIndexCoding_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The IndexCoding object."},
    {"IndexCoding_getDisplayName", BeamPyIndexCoding_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductRefString", BeamPyIndexCoding_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The IndexCoding object."},
    {"IndexCoding_updateExpression", BeamPyIndexCoding_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The IndexCoding object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"IndexCoding_removeFromFile", BeamPyIndexCoding_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The IndexCoding object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"IndexCoding_getExtension", BeamPyIndexCoding_getExtension, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"PixelPos_newPixelPos1", BeamPyPixelPos_newPixelPos1, METH_VARARGS, " Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0).\n"},
    {"PixelPos_newPixelPos2", BeamPyPixelPos_newPixelPos2, METH_VARARGS, " Constructs and initializes a <code>PixelPos</code> with the specified coordinate.\n\n @param x the x component of the coordinate\n @param y the y component of the coordinate\n"},
    {"PixelPos_isValid", BeamPyPixelPos_isValid, METH_VARARGS, " Tests whether or not this pixel position is valid.\n\n @return true, if so\n\n@param this The PixelPos object."},
    {"PixelPos_setInvalid", BeamPyPixelPos_setInvalid, METH_VARARGS, " Sets this pixel position so that is becomes invalid.\n\n@param this The PixelPos object."},
    {"PixelPos_getX", BeamPyPixelPos_getX, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_getY", BeamPyPixelPos_getY, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation1", BeamPyPixelPos_setLocation1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation2", BeamPyPixelPos_setLocation2, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_toString", BeamPyPixelPos_toString, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation3", BeamPyPixelPos_setLocation3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distanceSq2", BeamPyPixelPos_distanceSq2, METH_VARARGS, ""},
    {"PixelPos_distance2", BeamPyPixelPos_distance2, METH_VARARGS, ""},
    {"PixelPos_distanceSq1", BeamPyPixelPos_distanceSq1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distanceSq3", BeamPyPixelPos_distanceSq3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distance1", BeamPyPixelPos_distance1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distance3", BeamPyPixelPos_distance3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_clone", BeamPyPixelPos_clone, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_hashCode", BeamPyPixelPos_hashCode, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_equals", BeamPyPixelPos_equals, METH_VARARGS, "\n@param this The PixelPos object."},
    {"ProductIO_getProductReader", BeamPyProductIO_getProductReader, METH_VARARGS, " Gets a product reader for the given format name.\n\n @param formatName the product format name\n\n @return a suitable product reader or <code>null</code> if none was found\n"},
    {"ProductIO_getProductWriterExtensions", BeamPyProductIO_getProductWriterExtensions, METH_VARARGS, " Gets an array of writer product file extensions for the given format name.\n\n @param formatName the format name\n\n @return an array of extensions or null if the format does not exist\n"},
    {"ProductIO_getProductWriter", BeamPyProductIO_getProductWriter, METH_VARARGS, " Gets a product writer for the given format name.\n\n @param formatName the product format name\n\n @return a suitable product writer or <code>null</code> if none was found\n"},
    {"ProductIO_readProduct", BeamPyProductIO_readProduct, METH_VARARGS, " Reads the data product specified by the given file path.\n <p>The product returned will be associated with the reader appropriate for the given\n file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>\n <p>The method does not automatically read band data, thus\n {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null\n for all bands in the product returned by this method.</p>\n\n @param filePath the data product file path\n\n @return a data model as an in-memory representation of the given product file or <code>null</code> if no\n         appropriate reader was found for the given product file\n\n @throws IOException if an I/O error occurs\n @see #readProduct(File)\n"},
    {"ProductIO_getProductReaderForFile", BeamPyProductIO_getProductReaderForFile, METH_VARARGS, " Returns a product reader instance for the given file if any registered product reader can decode the given file.\n\n @param file the file to decode.\n\n @return a product reader for the given file or <code>null</code> if the file cannot be decoded.\n\n @deprecated Since BEAM 4.10. Use {@link #getProductReaderForInput(Object)} instead.\n"},
    {"ProductIO_getProductReaderForInput", BeamPyProductIO_getProductReaderForInput, METH_VARARGS, " Tries to find a product reader instance suitable for the given input.\n The method returns {@code null}, if no\n registered product reader can handle the given {@code input} value.\n <p/>\n The {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or\n {@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.\n\n @param input the input object.\n\n @return a product reader for the given {@code input} or {@code null} if no registered reader can handle\n         the it.\n\n @see ProductReaderPlugIn#getDecodeQualification(Object)\n @see ProductReader#readProductNodes(Object, ProductSubsetDef)\n"},
    {"ProductIO_writeProduct", BeamPyProductIO_writeProduct, METH_VARARGS, " Writes a product with the specified format to the given file path.\n <p>The method also writes all band data to the file. Therefore the band data must either\n <ld>\n <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>\n <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>\n </ld>.\n\n @param product    the product, must not be <code>null</code>\n @param filePath   the file path\n @param formatName the name of a supported product format, e.g. \"HDF5\". If <code>null</code>, the default format\n                   \"BEAM-DIMAP\" will be used\n\n @throws IOException if an IOException occurs\n"},
    {"Placemark_newPlacemark", BeamPyPlacemark_newPlacemark, METH_VARARGS, " Constructor.\n\n @param descriptor The placemark descriptor that created this placemark.\n @param feature    The wrapped feature.\n"},
    {"Placemark_createPointPlacemark", BeamPyPlacemark_createPointPlacemark, METH_VARARGS, " Creates a point placemark.\n\n @param descriptor The placemark descriptor that created this placemark.\n @param name       The placemark's name.\n @param label      The placemark's label. May be {@code null}.\n @param text       The placemark's (XHTML) text. May be {@code null}.\n @param pixelPos   The placemark's pixel position. May be {@code null}, if {@code geoPos} is given.\n @param geoPos     The placemark's pixel position. May be {@code null}, if {@code pixelPos} is given.\n @param geoCoding  The placemark's geo-coding. Used to compute {@code pixelPos} from {@code geoPos}, if {@code pixelPos} is {@code null}.\n @return A new point placemark.\n"},
    {"Placemark_getDescriptor", BeamPyPlacemark_getDescriptor, METH_VARARGS, " @return The placemark descriptor that created this placemark.\n @since BEAM 4.10\n\n@param this The Placemark object."},
    {"Placemark_getFeature", BeamPyPlacemark_getFeature, METH_VARARGS, " @return The wrapped {@link SimpleFeature} underlying this placemark.\n @since BEAM 4.7\n\n@param this The Placemark object."},
    {"Placemark_getAttributeValue", BeamPyPlacemark_getAttributeValue, METH_VARARGS, " Gets the attribute value of the underlying feature.\n\n \n@param this The Placemark object.\n@param attributeName The feature's attribute name.\n @return The feature's attribute value, may be {@code null}.\n"},
    {"Placemark_setAttributeValue", BeamPyPlacemark_setAttributeValue, METH_VARARGS, " Sets the attribute value of the underlying feature.\n\n \n@param this The Placemark object.\n@param attributeName  The feature's attribute name.\n @param attributeValue The feature's attribute value, may be {@code null}.\n"},
    {"Placemark_setLabel", BeamPyPlacemark_setLabel, METH_VARARGS, " Sets this placemark's label.\n\n \n@param this The Placemark object.\n@param label the label, if {@code null} an empty label is set.\n"},
    {"Placemark_getLabel", BeamPyPlacemark_getLabel, METH_VARARGS, " @return This placemark's label, cannot be {@code null}.\n\n@param this The Placemark object."},
    {"Placemark_setText", BeamPyPlacemark_setText, METH_VARARGS, " Sets this placemark's (XHTML) text.\n\n \n@param this The Placemark object.\n@param text The text, if {@code null} an empty text is set.\n"},
    {"Placemark_getText", BeamPyPlacemark_getText, METH_VARARGS, " @return This placemark's (XHTML) text, cannot be {@code null}.\n\n@param this The Placemark object."},
    {"Placemark_setStyleCss", BeamPyPlacemark_setStyleCss, METH_VARARGS, " Sets this placemark's CSS style.\n\n \n@param this The Placemark object.\n@param styleCss The text, if {@code null} an empty text is set.\n @since BEAM 4.10\n"},
    {"Placemark_getStyleCss", BeamPyPlacemark_getStyleCss, METH_VARARGS, " @return This placemark's CSS style, cannot be {@code null}.\n @since BEAM 4.10\n\n@param this The Placemark object."},
    {"Placemark_acceptVisitor", BeamPyPlacemark_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n\n \n@param this The Placemark object.\n@param visitor the visitor\n"},
    {"Placemark_getPixelPos", BeamPyPlacemark_getPixelPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_setPixelPos", BeamPyPlacemark_setPixelPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_getGeoPos", BeamPyPlacemark_getGeoPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_setGeoPos", BeamPyPlacemark_setGeoPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_updatePositions", BeamPyPlacemark_updatePositions, METH_VARARGS, " Updates pixel and geo position according to the current geometry (model coordinates).\n\n@param this The Placemark object."},
    {"Placemark_createPinFeatureType", BeamPyPlacemark_createPinFeatureType, METH_VARARGS, ""},
    {"Placemark_createGcpFeatureType", BeamPyPlacemark_createGcpFeatureType, METH_VARARGS, ""},
    {"Placemark_createGeometryFeatureType", BeamPyPlacemark_createGeometryFeatureType, METH_VARARGS, ""},
    {"Placemark_createPointFeatureType", BeamPyPlacemark_createPointFeatureType, METH_VARARGS, ""},
    {"Placemark_getOwner", BeamPyPlacemark_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Placemark object."},
    {"Placemark_getName", BeamPyPlacemark_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Placemark object."},
    {"Placemark_setName", BeamPyPlacemark_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Placemark object.\n@param name The name.\n"},
    {"Placemark_getDescription", BeamPyPlacemark_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Placemark object."},
    {"Placemark_setDescription", BeamPyPlacemark_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Placemark object.\n@param description a description, can be <code>null</code>\n"},
    {"Placemark_isModified", BeamPyPlacemark_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Placemark object."},
    {"Placemark_setModified", BeamPyPlacemark_setModified, METH_VARARGS, " Sets this node's modified flag.\n <p/>\n If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\n true.\n\n \n@param this The Placemark object.\n@param modified whether or not this node is beeing marked as modified.\n @see org.esa.beam.framework.datamodel.Product#fireNodeChanged\n"},
    {"Placemark_toString", BeamPyPlacemark_toString, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_dispose", BeamPyPlacemark_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The Placemark object."},
    {"Placemark_isValidNodeName", BeamPyPlacemark_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Placemark_getProduct", BeamPyPlacemark_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Placemark object."},
    {"Placemark_getProductReader", BeamPyPlacemark_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The Placemark object."},
    {"Placemark_getProductWriter", BeamPyPlacemark_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The Placemark object."},
    {"Placemark_getDisplayName", BeamPyPlacemark_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Placemark object."},
    {"Placemark_getProductRefString", BeamPyPlacemark_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Placemark object."},
    {"Placemark_updateExpression", BeamPyPlacemark_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The Placemark object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"Placemark_removeFromFile", BeamPyPlacemark_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The Placemark object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"Placemark_getExtension", BeamPyPlacemark_getExtension, METH_VARARGS, "\n@param this The Placemark object."},
    {"MetadataElement_newMetadataElement", BeamPyMetadataElement_newMetadataElement, METH_VARARGS, " Constructs a new metadata element.\n\n @param name the element name\n"},
    {"MetadataElement_getElementGroup", BeamPyMetadataElement_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n\n @return The child element group, may be null.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getParentElement", BeamPyMetadataElement_getParentElement, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_addElement", BeamPyMetadataElement_addElement, METH_VARARGS, " Adds the given element to this element.\n\n \n@param this The MetadataElement object.\n@param element the element to added, ignored if <code>null</code>\n"},
    {"MetadataElement_addElementAt", BeamPyMetadataElement_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The MetadataElement object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"MetadataElement_removeElement", BeamPyMetadataElement_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The MetadataElement object.\n@param element the element to be removed, ignored if <code>null</code>\n\n @return true, if so\n"},
    {"MetadataElement_getNumElements", BeamPyMetadataElement_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElementAt", BeamPyMetadataElement_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The MetadataElement object.\n@param index the element index\n\n @return the element at the given index\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"MetadataElement_getElementNames", BeamPyMetadataElement_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElements", BeamPyMetadataElement_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElement", BeamPyMetadataElement_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The MetadataElement object.\n@param name the element name\n\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"MetadataElement_containsElement", BeamPyMetadataElement_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The MetadataElement object.\n@param name the name, must not be <code>null</code>\n\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"MetadataElement_getElementIndex", BeamPyMetadataElement_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n\n \n@param this The MetadataElement object.\n@param element The element .\n\n @return The element's index, or -1.\n\n @since BEAM 4.7\n"},
    {"MetadataElement_addAttribute", BeamPyMetadataElement_addAttribute, METH_VARARGS, " Adds an attribute to this node.\n\n \n@param this The MetadataElement object.\n@param attribute the attribute to be added, <code>null</code> is ignored\n"},
    {"MetadataElement_removeAttribute", BeamPyMetadataElement_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The MetadataElement object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n\n @return <code>true</code> if it was removed\n"},
    {"MetadataElement_getNumAttributes", BeamPyMetadataElement_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttributeAt", BeamPyMetadataElement_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The MetadataElement object.\n@param index the attribute index\n\n @return the attribute, or <code>null</code> if this node does not contain attributes\n\n @throws IndexOutOfBoundsException\n"},
    {"MetadataElement_getAttributeNames", BeamPyMetadataElement_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttributes", BeamPyMetadataElement_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttribute", BeamPyMetadataElement_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The MetadataElement object.\n@param name the attribute name\n\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"MetadataElement_containsAttribute", BeamPyMetadataElement_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The MetadataElement object.\n@param name the attribute name\n\n @return <code>true</code> if so\n"},
    {"MetadataElement_getAttributeIndex", BeamPyMetadataElement_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n\n \n@param this The MetadataElement object.\n@param attribute The attribute.\n\n @return The attribute's index, or -1.\n\n @since BEAM 4.7\n"},
    {"MetadataElement_getAttributeDouble", BeamPyMetadataElement_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as double.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"MetadataElement_getAttributeUTC", BeamPyMetadataElement_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as UTC.\n"},
    {"MetadataElement_getAttributeInt", BeamPyMetadataElement_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"MetadataElement_setAttributeInt", BeamPyMetadataElement_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setAttributeDouble", BeamPyMetadataElement_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setAttributeUTC", BeamPyMetadataElement_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_getAttributeString", BeamPyMetadataElement_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n"},
    {"MetadataElement_setAttributeString", BeamPyMetadataElement_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setModified", BeamPyMetadataElement_setModified, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_acceptVisitor", BeamPyMetadataElement_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then\n visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.\n\n \n@param this The MetadataElement object.\n@param visitor the visitor\n"},
    {"MetadataElement_createDeepClone", BeamPyMetadataElement_createDeepClone, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_dispose", BeamPyMetadataElement_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getOwner", BeamPyMetadataElement_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getName", BeamPyMetadataElement_getName, METH_VARARGS, " @return This node's name.\n\n@param this The MetadataElement object."},
    {"MetadataElement_setName", BeamPyMetadataElement_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The MetadataElement object.\n@param name The name.\n"},
    {"MetadataElement_getDescription", BeamPyMetadataElement_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The MetadataElement object."},
    {"MetadataElement_setDescription", BeamPyMetadataElement_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The MetadataElement object.\n@param description a description, can be <code>null</code>\n"},
    {"MetadataElement_isModified", BeamPyMetadataElement_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The MetadataElement object."},
    {"MetadataElement_toString", BeamPyMetadataElement_toString, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_isValidNodeName", BeamPyMetadataElement_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"MetadataElement_getProduct", BeamPyMetadataElement_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductReader", BeamPyMetadataElement_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductWriter", BeamPyMetadataElement_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The MetadataElement object."},
    {"MetadataElement_getDisplayName", BeamPyMetadataElement_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductRefString", BeamPyMetadataElement_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The MetadataElement object."},
    {"MetadataElement_updateExpression", BeamPyMetadataElement_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The MetadataElement object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"MetadataElement_removeFromFile", BeamPyMetadataElement_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The MetadataElement object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"MetadataElement_getExtension", BeamPyMetadataElement_getExtension, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"Product_newProduct", BeamPyProduct_newProduct, METH_VARARGS, " Creates a new product without any reader (in-memory product)\n\n @param name              the product name\n @param type              the product type\n @param sceneRasterWidth  the scene width in pixels for this data product\n @param sceneRasterHeight the scene height in pixels for this data product\n"},
    {"Product_getFileLocation", BeamPyProduct_getFileLocation, METH_VARARGS, " Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no\n disk location (pure virtual memory product)\n\n @return the file location, may be <code>null</code>\n\n@param this The Product object."},
    {"Product_setFileLocation", BeamPyProduct_setFileLocation, METH_VARARGS, " Sets the file location for this product.\n\n \n@param this The Product object.\n@param fileLocation the file location, may be <code>null</code>\n"},
    {"Product_getProductType", BeamPyProduct_getProductType, METH_VARARGS, " Gets the product type string.\n\n @return the product type string\n\n@param this The Product object."},
    {"Product_setProductType", BeamPyProduct_setProductType, METH_VARARGS, " Sets the product type of this product.\n\n \n@param this The Product object.\n@param productType the product type.\n"},
    {"Product_setProductReader", BeamPyProduct_setProductReader, METH_VARARGS, " Sets the product reader which will be used to create this product in-memory represention from an external source\n and which will be used to (re-)load band rasters.\n\n \n@param this The Product object.\n@param reader the product reader.\n @throws IllegalArgumentException if the given reader is null.\n"},
    {"Product_getProductReader", BeamPyProduct_getProductReader, METH_VARARGS, " Returns the reader which was used to create this product in-memory represention from an external source and which\n will be used to (re-)load band rasters.\n\n @return the product reader, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_setProductWriter", BeamPyProduct_setProductWriter, METH_VARARGS, " Sets the writer which will be used to write modifications of this product's in-memory represention to an external\n destination.\n\n \n@param this The Product object.\n@param writer the product writer, can be <code>null</code>\n"},
    {"Product_getProductWriter", BeamPyProduct_getProductWriter, METH_VARARGS, " Returns the writer which will be used to write modifications of this product's in-memory represention to an\n external destination.\n\n @return the product writer, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_writeHeader", BeamPyProduct_writeHeader, METH_VARARGS, " <p>Writes the header of a data product.<p/>\n\n \n@param this The Product object.\n@param output an object representing a valid output for this writer, might be a <code>ImageOutputStream</code>\n               or a <code>File</code> or other <code>Object</code> to use for future decoding.\n @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is none of the\n                                  supported output types.\n @throws IOException              if an I/O error occurs\n"},
    {"Product_closeProductReader", BeamPyProduct_closeProductReader, METH_VARARGS, " Closes and clears this product's reader (if any).\n\n @throws IOException if an I/O error occurs\n @see #closeIO\n\n@param this The Product object."},
    {"Product_closeProductWriter", BeamPyProduct_closeProductWriter, METH_VARARGS, " Closes and clears this product's writer (if any).\n\n @throws IOException if an I/O error occurs\n @see #closeIO\n\n@param this The Product object."},
    {"Product_closeIO", BeamPyProduct_closeIO, METH_VARARGS, " Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and\n <code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but\n should be called if the product instance is no longer in use.\n\n @throws IOException if an I/O error occurs\n @see #closeProductReader\n @see #closeProductWriter\n @see #dispose\n\n@param this The Product object."},
    {"Product_dispose", BeamPyProduct_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n </p>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n </p>\n <p>This implementation also calls the <code>closeIO</code> in order to release all open I/O resources.\n\n@param this The Product object."},
    {"Product_getPointingFactory", BeamPyProduct_getPointingFactory, METH_VARARGS, " Gets the pointing factory associated with this data product.\n\n @return the pointing factory or null, if none\n\n@param this The Product object."},
    {"Product_setPointingFactory", BeamPyProduct_setPointingFactory, METH_VARARGS, " Sets the pointing factory for this data product.\n\n \n@param this The Product object.\n@param pointingFactory the pointing factory\n"},
    {"Product_setGeoCoding", BeamPyProduct_setGeoCoding, METH_VARARGS, " Geo-codes this data product.\n\n \n@param this The Product object.\n@param geoCoding the geo-coding, if <code>null</code> geo-coding is removed\n @throws IllegalArgumentException <br>- if the given <code>GeoCoding</code> is a <code>TiePointGeoCoding</code>\n                                  and <code>latGrid</code> or <code>lonGrid</code> are not instances of tie point\n                                  grids in this product. <br>- if the given <code>GeoCoding</code> is a\n                                  <code>MapGeoCoding</code> and its <code>MapInfo</code> is <code>null</code>\n                                  <br>- if the given <code>GeoCoding</code> is a <code>MapGeoCoding</code> and the\n                                  <code>sceneWith</code> or <code>sceneHeight</code> of its <code>MapInfo</code>\n                                  is not equal to this products <code>sceneRasterWidth</code> or\n                                  <code>sceneRasterHeight</code>\n"},
    {"Product_getGeoCoding", BeamPyProduct_getGeoCoding, METH_VARARGS, " Returns the geo-coding used for this data product.\n\n @return the geo-coding, can be <code>null</code> if this product is not geo-coded.\n\n@param this The Product object."},
    {"Product_isUsingSingleGeoCoding", BeamPyProduct_isUsingSingleGeoCoding, METH_VARARGS, " Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing\n the band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.\n If this product does not have a geo-coding, the method returns false.\n\n @return true, if so\n\n@param this The Product object."},
    {"Product_transferGeoCodingTo", BeamPyProduct_transferGeoCodingTo, METH_VARARGS, " Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to\n the given {@link ProductSubsetDef subsetDef}.\n\n \n@param this The Product object.\n@param destProduct the destination product\n @param subsetDef   the definition of the subset, may be <code>null</code>\n @return true, if the geo-coding could be transferred.\n"},
    {"Product_getSceneRasterWidth", BeamPyProduct_getSceneRasterWidth, METH_VARARGS, " Returns the scene width in pixels for this data product.\n\n @return the scene width in pixels for this data product.\n\n@param this The Product object."},
    {"Product_getSceneRasterHeight", BeamPyProduct_getSceneRasterHeight, METH_VARARGS, " Returns the scene height in pixels for this data product.\n\n @return the scene height in pixels for this data product.\n\n@param this The Product object."},
    {"Product_getStartTime", BeamPyProduct_getStartTime, METH_VARARGS, " Gets the (sensing) start time associated with the first raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the first raster data line.\n For Level-3 products, this could be the start time of first input product\n contributing data.</p>\n\n @return the sensing start time, can be null e.g. for non-swath products\n\n@param this The Product object."},
    {"Product_setStartTime", BeamPyProduct_setStartTime, METH_VARARGS, " Sets the (sensing) start time of this product.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the first raster data line.\n For Level-3 products, this could be the start time of first input product\n contributing data.</p>\n\n \n@param this The Product object.\n@param startTime the sensing start time, can be null\n"},
    {"Product_getEndTime", BeamPyProduct_getEndTime, METH_VARARGS, " Gets the (sensing) stop time associated with the last raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the last raster data line.\n For Level-3 products, this could be the end time of last input product\n contributing data.</p>\n\n @return the stop time , can be null e.g. for non-swath products\n\n@param this The Product object."},
    {"Product_setEndTime", BeamPyProduct_setEndTime, METH_VARARGS, " Sets the (sensing) stop time associated with the first raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the last raster data line.\n For Level-3 products, this could be the end time of last input product\n contributing data.</p>\n\n \n@param this The Product object.\n@param endTime the sensing stop time, can be null\n"},
    {"Product_getMetadataRoot", BeamPyProduct_getMetadataRoot, METH_VARARGS, " Gets the root element of the associated metadata.\n\n @return the metadata root element\n\n@param this The Product object."},
    {"Product_getGroups", BeamPyProduct_getGroups, METH_VARARGS, " @return The group which contains all other product node groups.\n @since BEAM 5.0\n\n@param this The Product object."},
    {"Product_getGroup", BeamPyProduct_getGroup, METH_VARARGS, " \n@param this The Product object.\n@param name The group name.\n @return The group with the given name, or {@code null} if no such group exists.\n @since BEAM 5.0\n"},
    {"Product_getTiePointGridGroup", BeamPyProduct_getTiePointGridGroup, METH_VARARGS, " Gets the tie-point grid group of this product.\n\n @return The group of all tie-point grids.\n @since BEAM 4.7\n\n@param this The Product object."},
    {"Product_addTiePointGrid", BeamPyProduct_addTiePointGrid, METH_VARARGS, " Adds the given tie-point grid to this product.\n\n \n@param this The Product object.\n@param tiePointGrid the tie-point grid to added, ignored if <code>null</code>\n"},
    {"Product_removeTiePointGrid", BeamPyProduct_removeTiePointGrid, METH_VARARGS, " Removes the tie-point grid from this product.\n\n \n@param this The Product object.\n@param tiePointGrid the tie-point grid to be removed, ignored if <code>null</code>\n @return <code>true</code> if node could be removed\n"},
    {"Product_getNumTiePointGrids", BeamPyProduct_getNumTiePointGrids, METH_VARARGS, " Returns the number of tie-point grids contained in this product\n\n @return the number of tie-point grids\n\n@param this The Product object."},
    {"Product_getTiePointGridAt", BeamPyProduct_getTiePointGridAt, METH_VARARGS, " Returns the tie-point grid at the given index.\n\n \n@param this The Product object.\n@param index the tie-point grid index\n @return the tie-point grid at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"Product_getTiePointGridNames", BeamPyProduct_getTiePointGridNames, METH_VARARGS, " Returns a string array containing the names of the tie-point grids contained in this product\n\n @return a string array containing the names of the tie-point grids contained in this product. If this product has\n         no tie-point grids a zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getTiePointGrids", BeamPyProduct_getTiePointGrids, METH_VARARGS, " Returns an array of tie-point grids contained in this product\n\n @return an array of tie-point grids contained in this product. If this product has no  tie-point grids a\n         zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getTiePointGrid", BeamPyProduct_getTiePointGrid, METH_VARARGS, " Returns the tie-point grid with the given name.\n\n \n@param this The Product object.\n@param name the tie-point grid name\n @return the tie-point grid with the given name or <code>null</code> if a tie-point grid with the given name is\n         not contained in this product.\n"},
    {"Product_containsTiePointGrid", BeamPyProduct_containsTiePointGrid, METH_VARARGS, " Tests if a tie-point grid with the given name is contained in this product.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a tie-point grid with the given name is contained in this product,\n         <code>false</code> otherwise\n"},
    {"Product_getBandGroup", BeamPyProduct_getBandGroup, METH_VARARGS, " Gets the band group of this product.\n\n @return The group of all bands.\n @since BEAM 4.7\n\n@param this The Product object."},
    {"Product_addBand", BeamPyProduct_addBand, METH_VARARGS, " Adds the given band to this product.\n\n \n@param this The Product object.\n@param band the band to added, must not be <code>null</code>\n"},
    {"Product_addNewBand", BeamPyProduct_addNewBand, METH_VARARGS, " Creates a new band with the given name and data type and adds it to this product and returns it.\n\n \n@param this The Product object.\n@param bandName the new band's name\n @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\n                 constants\n @return the new band which has just been added\n"},
    {"Product_addComputedBand", BeamPyProduct_addComputedBand, METH_VARARGS, " Creates a new band with the given name and adds it to this product and returns it.\n The new band's data type is {@code float} and it's samples are computed from the given band maths expression.\n\n \n@param this The Product object.\n@param bandName   the new band's name\n @param expression the band maths expression\n @return the new band which has just been added\n @since BEAM 4.9\n"},
    {"Product_removeBand", BeamPyProduct_removeBand, METH_VARARGS, " Removes the given band from this product.\n\n \n@param this The Product object.\n@param band the band to be removed, ignored if <code>null</code>\n @return {@code true} if removed succesfully, otherwise {@code false}\n"},
    {"Product_getNumBands", BeamPyProduct_getNumBands, METH_VARARGS, " @return the number of bands contained in this product.\n\n@param this The Product object."},
    {"Product_getBandAt", BeamPyProduct_getBandAt, METH_VARARGS, " Returns the band at the given index.\n\n \n@param this The Product object.\n@param index the band index\n @return the band at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"Product_getBandNames", BeamPyProduct_getBandNames, METH_VARARGS, " Returns a string array containing the names of the bands contained in this product\n\n @return a string array containing the names of the bands contained in this product. If this product has no bands\n         a zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getBands", BeamPyProduct_getBands, METH_VARARGS, " Returns an array of bands contained in this product\n\n @return an array of bands contained in this product. If this product has no bands a zero-length-array is\n         returned.\n\n@param this The Product object."},
    {"Product_getBand", BeamPyProduct_getBand, METH_VARARGS, " Returns the band with the given name.\n\n \n@param this The Product object.\n@param name the band name\n @return the band with the given name or <code>null</code> if a band with the given name is not contained in this\n         product.\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_getBandIndex", BeamPyProduct_getBandIndex, METH_VARARGS, " Returns the index for the band with the given name.\n\n \n@param this The Product object.\n@param name the band name\n @return the band index or <code>-1</code> if a band with the given name is not contained in this product.\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_containsBand", BeamPyProduct_containsBand, METH_VARARGS, " Tests if a band with the given name is contained in this product.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a band with the given name is contained in this product, <code>false</code>\n         otherwise\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_containsRasterDataNode", BeamPyProduct_containsRasterDataNode, METH_VARARGS, " Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or\n tie-point grids.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a raster data node with the given name is contained in this product,\n         <code>false</code> otherwise\n"},
    {"Product_getRasterDataNode", BeamPyProduct_getRasterDataNode, METH_VARARGS, " Gets the raster data node with the given name. The method first searches for bands with the given name, then for\n tie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return the raster data node with the given name or <code>null</code> if a raster data node with the given name\n         is not contained in this product.\n"},
    {"Product_getMaskGroup", BeamPyProduct_getMaskGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getVectorDataGroup", BeamPyProduct_getVectorDataGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getFlagCodingGroup", BeamPyProduct_getFlagCodingGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getIndexCodingGroup", BeamPyProduct_getIndexCodingGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_containsPixel", BeamPyProduct_containsPixel, METH_VARARGS, " Tests if the given pixel position is within the product pixel bounds.\n\n \n@param this The Product object.\n@param x the x coordinate of the pixel position\n @param y the y coordinate of the pixel position\n @return true, if so\n @see #containsPixel(PixelPos)\n"},
    {"Product_getGcpGroup", BeamPyProduct_getGcpGroup, METH_VARARGS, " Gets the group of ground-control points (GCPs).\n Note that this method will create the group, if none exists already.\n\n @return the GCP group.\n\n@param this The Product object."},
    {"Product_getPinGroup", BeamPyProduct_getPinGroup, METH_VARARGS, " Gets the group of pins.\n Note that this method will create the group, if none exists already.\n\n @return the pin group.\n\n@param this The Product object."},
    {"Product_getNumResolutionsMax", BeamPyProduct_getNumResolutionsMax, METH_VARARGS, " @return The maximum number of resolution levels common to all band images.\n         If less than or equal to zero, the  number of resolution levels is considered to be unknown.\n @since BEAM 5.0\n\n@param this The Product object."},
    {"Product_setNumResolutionsMax", BeamPyProduct_setNumResolutionsMax, METH_VARARGS, " \n@param this The Product object.\n@param numResolutionsMax The maximum number of resolution levels common to all band images.\n                          If less than or equal to zero, the  number of resolution levels is considered to be unknown.\n @since BEAM 5.0\n"},
    {"Product_isCompatibleProduct", BeamPyProduct_isCompatibleProduct, METH_VARARGS, " Checks whether or not the given product is compatible with this product.\n\n \n@param this The Product object.\n@param product the product to compare with\n @param eps     the maximum lat/lon error in degree\n @return <code>false</code> if the scene dimensions or geocoding are different, <code>true</code> otherwise.\n"},
    {"Product_parseExpression", BeamPyProduct_parseExpression, METH_VARARGS, " Parses a mathematical expression given as a text string.\n\n \n@param this The Product object.\n@param expression a expression given as a text string, e.g. \"radiance_4 / (1.0 + radiance_11)\".\n @return a term parsed from the given expression string\n @throws ParseException if the expression could not successfully be parsed\n"},
    {"Product_acceptVisitor", BeamPyProduct_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag\n codings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.\n\n \n@param this The Product object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"Product_addProductNodeListener", BeamPyProduct_addProductNodeListener, METH_VARARGS, " Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each\n time a node in this product changes.\n\n \n@param this The Product object.\n@param listener the listener to be added\n @return boolean if listener was added or not\n"},
    {"Product_removeProductNodeListener", BeamPyProduct_removeProductNodeListener, METH_VARARGS, " Removes a <code>ProductNodeListener</code> from this product.\n\n \n@param this The Product object.\n@param listener the listener to be removed.\n"},
    {"Product_getProductNodeListeners", BeamPyProduct_getProductNodeListeners, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getRefNo", BeamPyProduct_getRefNo, METH_VARARGS, " @return The reference number of this product.\n\n@param this The Product object."},
    {"Product_setRefNo", BeamPyProduct_setRefNo, METH_VARARGS, " Sets the reference number.\n\n \n@param this The Product object.\n@param refNo the reference number to set must be in the range 1 .. Integer.MAX_VALUE\n @throws IllegalArgumentException if the refNo is out of range\n @throws IllegalStateException\n"},
    {"Product_resetRefNo", BeamPyProduct_resetRefNo, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getProductManager", BeamPyProduct_getProductManager, METH_VARARGS, " Returns the product manager for this product.\n\n @return this product's manager, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_createBandArithmeticParser", BeamPyProduct_createBandArithmeticParser, METH_VARARGS, " Creates a parser for band arithmetic expressions.\n The parser created will use a namespace comprising all tie-point grids, bands and flags of this product.\n\n @return a parser for band arithmetic expressions for this product, never null\n\n@param this The Product object."},
    {"Product_createBandArithmeticDefaultNamespace", BeamPyProduct_createBandArithmeticDefaultNamespace, METH_VARARGS, " Creates a namespace to be used by parsers for band arithmetic expressions.\n The namespace created comprises all tie-point grids, bands and flags of this product.\n\n @return a namespace, never null\n\n@param this The Product object."},
    {"Product_createSubset", BeamPyProduct_createSubset, METH_VARARGS, " Creates a subset of this product. The returned product represents a true spatial and spectral subset of this\n product, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the\n description from this product was used.\n\n \n@param this The Product object.\n@param subsetDef the product subset definition\n @param name      the name for the new product\n @param desc      the description for the new product\n @return the product subset, or <code>null</code> if the product/subset combination is not valid\n @throws IOException if an I/O error occurs\n"},
    {"Product_createFlippedProduct", BeamPyProduct_createFlippedProduct, METH_VARARGS, " Creates flipped raster-data version of this product.\n\n \n@param this The Product object.\n@param flipType the flip type, see <code>{@link org.esa.beam.framework.dataio.ProductFlipper}</code>\n @param name     the name for the new product\n @param desc     the description for the new product\n @return the product subset, or <code>null</code> if the product/subset combination is not valid\n @throws IOException if an I/O error occurs\n"},
    {"Product_setModified", BeamPyProduct_setModified, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getQuicklookBandName", BeamPyProduct_getQuicklookBandName, METH_VARARGS, " Gets the name of the band suitable for quicklook generation.\n\n @return the name of the quicklook band, or null if none has been defined\n\n@param this The Product object."},
    {"Product_setQuicklookBandName", BeamPyProduct_setQuicklookBandName, METH_VARARGS, " Sets the name of the band suitable for quicklook generation.\n\n \n@param this The Product object.\n@param quicklookBandName the name of the quicklook band, or null\n"},
    {"Product_createPixelInfoString", BeamPyProduct_createPixelInfoString, METH_VARARGS, " Creates a string containing all available information at the given pixel position. The string returned is a line\n separated text with each line containing a key/value pair.\n\n \n@param this The Product object.\n@param pixelX the pixel X co-ordinate\n @param pixelY the pixel Y co-ordinate\n @return the info string at the given position\n"},
    {"Product_getRemovedChildNodes", BeamPyProduct_getRemovedChildNodes, METH_VARARGS, " @return All removed child nodes. Array may be empty.\n\n@param this The Product object."},
    {"Product_canBeOrthorectified", BeamPyProduct_canBeOrthorectified, METH_VARARGS, " Checks whether or not this product can be ortorectified.\n\n @return true if {@link Band#canBeOrthorectified()} returns true for all bands, false otherwise\n\n@param this The Product object."},
    {"Product_getPreferredTileSize", BeamPyProduct_getPreferredTileSize, METH_VARARGS, " Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\n created for a {@link RasterDataNode} of this product.\n\n @return the preferred tile size, may be <code>null</null> if not specified\n @see RasterDataNode#getSourceImage()\n @see RasterDataNode# setSourceImage (java.awt.image.RenderedImage)\n\n@param this The Product object."},
    {"Product_setPreferredTileSize", BeamPyProduct_setPreferredTileSize, METH_VARARGS, " Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\n created for a {@link RasterDataNode} of this product.\n\n \n@param this The Product object.\n@param tileWidth  the preferred tile width\n @param tileHeight the preferred tile height\n @see #setPreferredTileSize(java.awt.Dimension)\n"},
    {"Product_getAllFlagNames", BeamPyProduct_getAllFlagNames, METH_VARARGS, " Returns the names of all flags of all flag datasets contained this product.\n <p/>\n <p>A flag name contains the dataset (a band of this product) and the actual flag name as defined in the\n flag-coding associated with the dataset. The general format for the flag name strings returned is therefore\n <code>\"<i>dataset</i>.<i>flag_name</i>\"</code>.\n </p>\n <p>The method is used to find out which flags a product has in order to use them in bit-mask expressions.\n\n @return the array of all flag names. If this product does not support flags, an empty array is returned, but\n         never <code>null</code>.\n @see #parseExpression(String)\n\n@param this The Product object."},
    {"Product_getAutoGrouping", BeamPyProduct_getAutoGrouping, METH_VARARGS, " Gets the auto-grouping applicable to product nodes contained in this product.\n\n @return The auto-grouping or {@code null}.\n @since BEAM 4.8\n\n@param this The Product object."},
    {"Product_setAutoGrouping", BeamPyProduct_setAutoGrouping, METH_VARARGS, " Sets the auto-grouping applicable to product nodes contained in this product.\n A given {@code pattern} parameter is a textual representation of the auto-grouping.\n The syntax for the pattern is:\n <pre>\n pattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | \"\" (empty string)\n groupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}\n groupName  :=  any non-empty string without characters ':' and '/'\n </pre>\n An example for {@code pattern} applicable to Envisat AATSR data is\n <pre>\n nadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward\n </pre>\n\n \n@param this The Product object.\n@param pattern The auto-grouping pattern.\n @since BEAM 4.8\n"},
    {"Product_addComputedMask", BeamPyProduct_addComputedMask, METH_VARARGS, " Creates a new mask using a band arithmetic expression\n and adds it to this product and returns it.\n\n \n@param this The Product object.\n@param maskName     the new mask's name\n @param expression   the band arithmetic expression\n @param description  the mask's description\n @param color        the display color\n @param transparency the display transparency\n @return the new mask which has just been added\n @since BEAM 4.10\n"},
    {"Product_addBitmaskDef", BeamPyProduct_addBitmaskDef, METH_VARARGS, " Adds the given bitmask definition to this product.\n\n \n@param this The Product object.\n@param bitmaskDef the bitmask definition to added, ignored if <code>null</code>\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_getBitmaskDefNames", BeamPyProduct_getBitmaskDefNames, METH_VARARGS, " Returns a string array containing the names of the bitmask definitions contained in this product.\n\n @return a string array containing the names of the bitmask definitions contained in this product. If this product\n         has no bitmask definitions a zero-length-array is returned.\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n\n@param this The Product object."},
    {"Product_getBitmaskDef", BeamPyProduct_getBitmaskDef, METH_VARARGS, " Returns the bitmask definition with the given name.\n\n \n@param this The Product object.\n@param name the bitmask definition name\n @return the bitmask definition with the given name or <code>null</code> if a bitmask definition with the given\n         name is not contained in this product.\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_getValidMask", BeamPyProduct_getValidMask, METH_VARARGS, " Gets a valid-mask for the given ID.\n\n \n@param this The Product object.\n@param id the ID\n @return a cached valid mask for the given ID or null\n @see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_setValidMask", BeamPyProduct_setValidMask, METH_VARARGS, " Sets a valid-mask for the given ID.\n\n \n@param this The Product object.\n@param id        the ID\n @param validMask the pixel mask\n @see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_createValidMask2", BeamPyProduct_createValidMask2, METH_VARARGS, " Creates a bit-packed valid-mask for all pixels of the scene covered by this product.\n The given expression is considered to be boolean, if it evaluates to <code>true</code>\n the related bit in the mask is set.\n\n \n@param this The Product object.\n@param expression the boolean expression, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\n @param pm         a progress monitor\n @return a bit-packed mask for all pixels of the scene, never null\n @throws IOException if an I/O error occurs\n @see #parseExpression(String)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_createValidMask1", BeamPyProduct_createValidMask1, METH_VARARGS, " Creates a bit-packed mask for all pixels of the scene covered by this product.\n The given term is considered to be boolean, if it evaluates to <code>true</code>\n the related bit in the mask is set.\n\n \n@param this The Product object.\n@param term the boolean term, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\n @param pm   a progress monitor\n @return a bit-packed mask for all pixels of the scene, never null\n @throws IOException if an I/O error occurs\n @see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_readBitmask2", BeamPyProduct_readBitmask2, METH_VARARGS, " Creates a bit-mask by evaluating the given bit-mask term.\n <p> The method first creates an evaluation context for the given bit-mask term and the specified region and then\n evaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\n the resulting bitmask - is stored in the given boolean array buffer <code>bitmask</code> in the same order as\n pixels appear in the given region. The buffer must at least have a length equal to <code>width * height</code>\n elements.\n </p>\n <p> If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\n loaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n </p>\n <p> The {@link #parseExpression(String)} method can be used to create a bit-mask\n term from a textual bit-mask expression.\n </p>\n\n \n@param this The Product object.\n@param offsetX     the X-offset of the spatial subset in pixel co-ordinates\n @param offsetY     the Y-offset of the spatial subset in pixel co-ordinates\n @param width       the width of the spatial subset in pixel co-ordinates\n @param height      the height of the spatial subset in pixel co-ordinates\n @param bitmaskTerm a bit-mask term, as returned by the {@link #parseExpression(String)} method\n @param bitmask     a buffer used to hold the results of the bit-mask evaluations for each pixel in the given\n                    spatial subset\n @param pm          a monitor to inform the user about progress\n @throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n @see #parseExpression(String)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_readBitmask1", BeamPyProduct_readBitmask1, METH_VARARGS, " Creates a bit-mask by evaluating the given bit-mask term.\n <p/>\n <p> The method first creates an evaluation context for the given bit-mask term and the specified region and then\n evaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\n the resulting bitmask - is stored in the given boolean array buffer <code>bitmask</code> in the same order as\n pixels appear in the given region. The buffer must at least have a length equal to <code>width * height</code>\n elements.\n </p>\n <p> If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\n loaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n </p>\n <p> The {@link #parseExpression(String)} method can be used to create a bit-mask\n term from a textual bit-mask expression.\n\n \n@param this The Product object.\n@param offsetX     the X-offset of the spatial subset in pixel co-ordinates\n @param offsetY     the Y-offset of the spatial subset in pixel co-ordinates\n @param width       the width of the spatial subset in pixel co-ordinates\n @param height      the height of the spatial subset in pixel co-ordinates\n @param bitmaskTerm a bit-mask term, as returned by the {@link #parseExpression(String)}\n                    method\n @param bitmask     a byte buffer used to hold the results of the bit-mask evaluations for each pixel in the given\n                    spatial subset\n @param trueValue   the byte value to be set if the bitmask-term evauates to <code>true</code>\n @param falseValue  the byte value to be set if the bitmask-term evauates to <code>false</code>\n @throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n @see #parseExpression(String)\n @deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead\n"},
    {"Product_getOwner", BeamPyProduct_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Product object."},
    {"Product_getName", BeamPyProduct_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Product object."},
    {"Product_setName", BeamPyProduct_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Product object.\n@param name The name.\n"},
    {"Product_getDescription", BeamPyProduct_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Product object."},
    {"Product_setDescription", BeamPyProduct_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Product object.\n@param description a description, can be <code>null</code>\n"},
    {"Product_isModified", BeamPyProduct_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Product object."},
    {"Product_toString", BeamPyProduct_toString, METH_VARARGS, "\n@param this The Product object."},
    {"Product_isValidNodeName", BeamPyProduct_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Product_getProduct", BeamPyProduct_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Product object."},
    {"Product_getDisplayName", BeamPyProduct_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Product object."},
    {"Product_getProductRefString", BeamPyProduct_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Product object."},
    {"Product_updateExpression", BeamPyProduct_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The Product object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"Product_removeFromFile", BeamPyProduct_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The Product object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"Product_getExtension", BeamPyProduct_getExtension, METH_VARARGS, "\n@param this The Product object."},
    {"ColorPaletteDef_newColorPaletteDefFromRange", BeamPyColorPaletteDef_newColorPaletteDefFromRange, METH_VARARGS, ""},
    {"ColorPaletteDef_newColorPaletteDefFromPoints", BeamPyColorPaletteDef_newColorPaletteDefFromPoints, METH_VARARGS, ""},
    {"ColorPaletteDef_isDiscrete", BeamPyColorPaletteDef_isDiscrete, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setDiscrete", BeamPyColorPaletteDef_setDiscrete, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getNumColors", BeamPyColorPaletteDef_getNumColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setNumColors", BeamPyColorPaletteDef_setNumColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getNumPoints", BeamPyColorPaletteDef_getNumPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setNumPoints", BeamPyColorPaletteDef_setNumPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_isAutoDistribute", BeamPyColorPaletteDef_isAutoDistribute, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setAutoDistribute", BeamPyColorPaletteDef_setAutoDistribute, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getPointAt", BeamPyColorPaletteDef_getPointAt, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getFirstPoint", BeamPyColorPaletteDef_getFirstPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getLastPoint", BeamPyColorPaletteDef_getLastPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getMinDisplaySample", BeamPyColorPaletteDef_getMinDisplaySample, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getMaxDisplaySample", BeamPyColorPaletteDef_getMaxDisplaySample, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_insertPointAfter", BeamPyColorPaletteDef_insertPointAfter, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createPointAfter", BeamPyColorPaletteDef_createPointAfter, METH_VARARGS, " creates a new point between the point at the given index\n\n \n@param this The ColorPaletteDef object.\n@param index   the index\n @param scaling the scaling\n\n @return true, if a point has been inserted\n"},
    {"ColorPaletteDef_getCenterColor", BeamPyColorPaletteDef_getCenterColor, METH_VARARGS, " Creates the center color between the given two colors.\n\n @param c1 1st color\n @param c2 2nd color\n\n @return the center color\n"},
    {"ColorPaletteDef_removePointAt", BeamPyColorPaletteDef_removePointAt, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_addPoint", BeamPyColorPaletteDef_addPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getPoints", BeamPyColorPaletteDef_getPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setPoints", BeamPyColorPaletteDef_setPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getIterator", BeamPyColorPaletteDef_getIterator, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_clone", BeamPyColorPaletteDef_clone, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createDeepCopy", BeamPyColorPaletteDef_createDeepCopy, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_loadColorPaletteDef", BeamPyColorPaletteDef_loadColorPaletteDef, METH_VARARGS, " Loads a color palette definition from the given file\n\n @param file the file\n\n @return the color palette definition, never null\n\n @throws IOException if an I/O error occurs\n"},
    {"ColorPaletteDef_storeColorPaletteDef", BeamPyColorPaletteDef_storeColorPaletteDef, METH_VARARGS, " Stores this color palette definition in the given file\n\n @param colorPaletteDef thje color palette definition\n @param file            the file\n\n @throws IOException if an I/O error occurs\n"},
    {"ColorPaletteDef_dispose", BeamPyColorPaletteDef_dispose, METH_VARARGS, " Releases all of the resources used by this color palette definition and all of its owned children. Its primary\n use is to allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getColors", BeamPyColorPaletteDef_getColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createColorPalette", BeamPyColorPaletteDef_createColorPalette, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_computeColor", BeamPyColorPaletteDef_computeColor, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ImageInfo_newImageInfoPalette", BeamPyImageInfo_newImageInfoPalette, METH_VARARGS, " Constructs a new image information instance.\n\n @param colorPaletteDef the color palette definition\n"},
    {"ImageInfo_newImageInfoRGB", BeamPyImageInfo_newImageInfoRGB, METH_VARARGS, " Constructs a new RGB image information instance.\n\n @param rgbChannelDef the RGB channel definition\n"},
    {"ImageInfo_getColorPaletteDef", BeamPyImageInfo_getColorPaletteDef, METH_VARARGS, " Gets the color palette definition as used for images created from single bands.\n\n @return The color palette definition. Can be {@code null}.\n         In this case {@link #getRgbChannelDef()} is non-null.\n\n@param this The ImageInfo object."},
    {"ImageInfo_getRgbChannelDef", BeamPyImageInfo_getRgbChannelDef, METH_VARARGS, " Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.\n\n @return The RGB(A) channel definition.\n         Can be {@code null}. In this case {@link #getColorPaletteDef()} is non-null.\n\n@param this The ImageInfo object."},
    {"ImageInfo_getNoDataColor", BeamPyImageInfo_getNoDataColor, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setNoDataColor", BeamPyImageInfo_setNoDataColor, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setHistogramMatching", BeamPyImageInfo_setHistogramMatching, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_isLogScaled", BeamPyImageInfo_isLogScaled, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setLogScaled", BeamPyImageInfo_setLogScaled, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_getColors", BeamPyImageInfo_getColors, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_getColorComponentCount", BeamPyImageInfo_getColorComponentCount, METH_VARARGS, " Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.\n\n @return {@code 3} for RGB images, {@code 4} for RGB images with an alpha channel (transparency)\n\n@param this The ImageInfo object."},
    {"ImageInfo_createIndexColorModel", BeamPyImageInfo_createIndexColorModel, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_createComponentColorModel", BeamPyImageInfo_createComponentColorModel, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_clone", BeamPyImageInfo_clone, METH_VARARGS, " Creates and returns a copy of this object.\n\n @return a copy of this object\n\n@param this The ImageInfo object."},
    {"ImageInfo_createDeepCopy", BeamPyImageInfo_createDeepCopy, METH_VARARGS, " Creates and returns a \"deep\" copy of this object. The method simply returns the value of\n {@link #clone()}.\n\n @return a copy of this object\n\n@param this The ImageInfo object."},
    {"ImageInfo_dispose", BeamPyImageInfo_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The ImageInfo object."},
    {"ImageInfo_setColors", BeamPyImageInfo_setColors, METH_VARARGS, " Sets the colours of the colour palette of this image info.\n\n \n@param this The ImageInfo object.\n@param colors the new colours\n"},
    {"ImageInfo_setColorPaletteDef", BeamPyImageInfo_setColorPaletteDef, METH_VARARGS, " Transfers the colour palette into this image info.\n\n \n@param this The ImageInfo object.\n@param colorPaletteDef another colour palette\n @param minSample       the minium allowed sample value in the new colour palette\n @param maxSample       the maximum allowed sample value in the new colour palette\n @param autoDistribute  if true, points are distributed between minSample/maxSample.\n"},
    {"ImageInfo_getHistogramMatching", BeamPyImageInfo_getHistogramMatching, METH_VARARGS, " Converts a string to a histogram matching.\n\n @param mode the histogram matching string\n @return the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\".\n"},
    {"ProductManager_newProductManager", BeamPyProductManager_newProductManager, METH_VARARGS, " Constructs an product manager with an empty list of products.\n"},
    {"ProductManager_getProductCount", BeamPyProductManager_getProductCount, METH_VARARGS, " @return The number of products in this product manager.\n\n@param this The ProductManager object."},
    {"ProductManager_getProduct", BeamPyProductManager_getProduct, METH_VARARGS, " Gets the product at the given index.\n\n \n@param this The ProductManager object.\n@param index the index\n @return The product at the given index.\n"},
    {"ProductManager_getProductDisplayNames", BeamPyProductManager_getProductDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n @see ProductNode#getDisplayName()\n\n@param this The ProductManager object."},
    {"ProductManager_getProductNames", BeamPyProductManager_getProductNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The ProductManager object."},
    {"ProductManager_getProducts", BeamPyProductManager_getProducts, METH_VARARGS, " Returns an array of all products currently managed.\n\n @return an array containing the products, never <code>null</code>, but the array can have zero length\n\n@param this The ProductManager object."},
    {"ProductManager_getProductByDisplayName", BeamPyProductManager_getProductByDisplayName, METH_VARARGS, " \n@param this The ProductManager object.\n@param displayName The product's display name.\n @return The product with the given display name.\n"},
    {"ProductManager_getProductByRefNo", BeamPyProductManager_getProductByRefNo, METH_VARARGS, " \n@param this The ProductManager object.\n@param refNo The reference number.\n @return The product with the given reference number.\n"},
    {"ProductManager_getProductByName", BeamPyProductManager_getProductByName, METH_VARARGS, " \n@param this The ProductManager object.\n@param name The product name.\n @return The product with the given name.\n"},
    {"ProductManager_getProductIndex", BeamPyProductManager_getProductIndex, METH_VARARGS, "\n@param this The ProductManager object."},
    {"ProductManager_containsProduct", BeamPyProductManager_containsProduct, METH_VARARGS, " Tests whether a product with the given name is contained in this list.\n\n \n@param this The ProductManager object.\n@param name the product name\n @return true, if so\n"},
    {"ProductManager_contains", BeamPyProductManager_contains, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The ProductManager object.\n@param product The product.\n @return {@code true} if so.\n"},
    {"ProductManager_addProduct", BeamPyProductManager_addProduct, METH_VARARGS, " Adds the given product to this product manager if it does not already exists and sets it's reference number one\n biger than the greatest reference number in this product manager.\n\n \n@param this The ProductManager object.\n@param product the product to be added, ignored if <code>null</code>\n"},
    {"ProductManager_removeProduct", BeamPyProductManager_removeProduct, METH_VARARGS, " Removes the given product from this product manager if it exists.\n\n \n@param this The ProductManager object.\n@param product the product to be removed, ignored if <code>null</code>\n @return true, if the product was removed\n"},
    {"ProductManager_removeAllProducts", BeamPyProductManager_removeAllProducts, METH_VARARGS, " Removes all product from this list.\n\n@param this The ProductManager object."},
    {"ProductManager_addListener", BeamPyProductManager_addListener, METH_VARARGS, " Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is\n informed each time a product was added or removed.\n\n \n@param this The ProductManager object.\n@param listener the listener to be added.\n @return true if the listener was added, otherwise false.\n"},
    {"ProductManager_removeListener", BeamPyProductManager_removeListener, METH_VARARGS, " Removes a <code>ProductManagerListener</code> from this product manager.\n\n \n@param this The ProductManager object.\n@param listener The listener.\n @return true, if the listener was removed, otherwise false.\n"},
    {"ImageGeometry_newImageGeometry", BeamPyImageGeometry_newImageGeometry, METH_VARARGS, ""},
    {"ImageGeometry_getImage2MapTransform", BeamPyImageGeometry_getImage2MapTransform, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_getImageRect", BeamPyImageGeometry_getImageRect, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_getMapCrs", BeamPyImageGeometry_getMapCrs, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_changeYAxisDirection", BeamPyImageGeometry_changeYAxisDirection, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_calculateEastingNorthing", BeamPyImageGeometry_calculateEastingNorthing, METH_VARARGS, ""},
    {"ImageGeometry_calculateProductSize", BeamPyImageGeometry_calculateProductSize, METH_VARARGS, ""},
    {"ImageGeometry_createTargetGeometry", BeamPyImageGeometry_createTargetGeometry, METH_VARARGS, ""},
    {"ImageGeometry_createCollocationTargetGeometry", BeamPyImageGeometry_createCollocationTargetGeometry, METH_VARARGS, ""},
    {"ImageGeometry_createValidRect", BeamPyImageGeometry_createValidRect, METH_VARARGS, ""},
    {"Band_newBand", BeamPyBand_newBand, METH_VARARGS, " Constructs a new <code>Band</code>.\n\n @param name     the name of the new object\n @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\n                 constants, with the exception of <code>ProductData.TYPE_UINT32</code>\n @param width    the width of the raster in pixels\n @param height   the height of the raster in pixels\n"},
    {"Band_getFlagCoding", BeamPyBand_getFlagCoding, METH_VARARGS, " Gets the flag coding for this band.\n\n @return a non-null value if this band is a flag dataset, <code>null</code> otherwise\n\n@param this The Band object."},
    {"Band_isFlagBand", BeamPyBand_isFlagBand, METH_VARARGS, " Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_getIndexCoding", BeamPyBand_getIndexCoding, METH_VARARGS, " Gets the index coding for this band.\n\n @return a non-null value if this band is a flag dataset, <code>null</code> otherwise\n\n@param this The Band object."},
    {"Band_isIndexBand", BeamPyBand_isIndexBand, METH_VARARGS, " Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_getSampleCoding", BeamPyBand_getSampleCoding, METH_VARARGS, " Gets the sample coding.\n\n @return the sample coding, or {@value null} if not set.\n\n@param this The Band object."},
    {"Band_setSampleCoding", BeamPyBand_setSampleCoding, METH_VARARGS, " Sets the sample coding for this band.\n\n \n@param this The Band object.\n@param sampleCoding the sample coding\n @throws IllegalArgumentException if this band does not contain integer pixels\n"},
    {"Band_getSpectralBandIndex", BeamPyBand_getSpectralBandIndex, METH_VARARGS, " Gets the (zero-based) spectral band index.\n\n @return the (zero-based) spectral band index or <code>-1</code> if it is unknown\n\n@param this The Band object."},
    {"Band_setSpectralBandIndex", BeamPyBand_setSpectralBandIndex, METH_VARARGS, " Sets the (zero-based) spectral band index.\n\n \n@param this The Band object.\n@param spectralBandIndex the (zero-based) spectral band index or <code>-1</code> if it is unknown\n"},
    {"Band_getSpectralWavelength", BeamPyBand_getSpectralWavelength, METH_VARARGS, " Gets the spectral wavelength in <code>nm</code> (nanomater) units.\n\n @return the wave length in nanometers of this band, or zero if this is not a spectral band or the wave length is\n         not known.\n\n@param this The Band object."},
    {"Band_setSpectralWavelength", BeamPyBand_setSpectralWavelength, METH_VARARGS, " Sets the spectral wavelength in <code>nm</code> (nanomater) units.\n\n \n@param this The Band object.\n@param spectralWavelength the wavelength in nanometers of this band, or zero if this is not a spectral band or\n                           the wavelength is not known.\n"},
    {"Band_getSpectralBandwidth", BeamPyBand_getSpectralBandwidth, METH_VARARGS, " Gets the spectral bandwidth in <code>nm</code> (nanomater) units.\n\n @return the bandwidth in nanometers of this band, or zero if this is not a spectral band or the bandwidth is not\n         known.\n\n@param this The Band object."},
    {"Band_setSpectralBandwidth", BeamPyBand_setSpectralBandwidth, METH_VARARGS, " Sets the spectral bandwidth in <code>nm</code> (nanomater) units.\n\n \n@param this The Band object.\n@param spectralBandwidth the spectral bandwidth in nanometers of this band, or zero if this is not a spectral band\n                          or the spectral bandwidth is not known.\n"},
    {"Band_getSolarFlux", BeamPyBand_getSolarFlux, METH_VARARGS, " Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\n units for the wavelength of this band.\n\n @return the solar flux for the wavelength of this band, or zero if this is not a spectral band or the solar flux\n         is not known.\n\n@param this The Band object."},
    {"Band_setSolarFlux", BeamPyBand_setSolarFlux, METH_VARARGS, " Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\n units for the wavelength of this band.\n\n \n@param this The Band object.\n@param solarFlux the solar flux for the wavelength of this band, or zero if this is not a spectral band or the\n                  solar flux is not known.\n"},
    {"Band_acceptVisitor", BeamPyBand_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The Band object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"Band_toString", BeamPyBand_toString, METH_VARARGS, " Creates a string defining this band object.\n\n@param this The Band object."},
    {"Band_removeFromFile", BeamPyBand_removeFromFile, METH_VARARGS, "\n@param this The Band object."},
    {"Band_dispose", BeamPyBand_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The Band object."},
    {"Band_getViewModeId", BeamPyBand_getViewModeId, METH_VARARGS, "\n@param this The Band object."},
    {"Band_computeBand", BeamPyBand_computeBand, METH_VARARGS, " (Re-)Computes this band's data using the given arithmetic expression.\n\n \n@param this The Band object.\n@param expression          the arithmetic expression string, e.g. \"1 + log(radiance_5 / radiance_13)\"\n @param validMaskExpression the arithmetic expression identifying valid source pixels, e.g. \"radiance_5 > 0.0 && radiance_13 > 0.0\"\n @param sourceProducts      the list of source products possibly referenced in the expression\n @param defaultProductIndex the index of the product for which also symbols without the\n                            product prefix <code>$<i>ref-no</i></code> are registered in the namespace\n @param checkInvalids       if true, the method recognizes numerically invalid values (NaN, Infinity)\n @param useInvalidValue     if true, numerically invalid values (NaN, Infinity) are set to <code>invalidValue</code>,\n                            ignored if <code>checkInvalids = false</code>\n @param noDataValue         the value used in place of  numerically invalid values if <code>useInvalidValue =\n                            true</code>, ignored if  <code>checkInvalids = false</code>\n @param pm                  a monitor to inform the user about progress\n @return the number of invalid pixels, zero if  <code>checkInvalids = false</code>\n @throws IOException    if an I/O error occurs\n @throws ParseException if the expression syntax is invalid\n @deprecated Since BEAM 4.10. Use {@link VirtualBand} or {@link org.esa.beam.jai.VirtualBandOpImage}.\n"},
    {"Band_getSceneRasterData", BeamPyBand_getSceneRasterData, METH_VARARGS, " Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so\n far the method returns <code>null</code>.\n <p/>\n <p>In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the\n scene's pixels.\n\n @return raster data covering the pixels for a complete scene\n @see #getRasterData\n @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterWidth\n @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterHeight\n @deprecated since BEAM 4.11, use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_getPixelInt", BeamPyBand_getPixelInt, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as an integer value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n @deprecated since BEAM 4.11, use {@link #getSampleInt(int, int)} instead.\n"},
    {"Band_getPixelFloat", BeamPyBand_getPixelFloat, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as a float value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n @deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead.\n"},
    {"Band_getPixelDouble", BeamPyBand_getPixelDouble, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as a double value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n @deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead.\n"},
    {"Band_setPixelInt", BeamPyBand_setPixelInt, METH_VARARGS, " Sets the pixel at the given pixel co-ordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"Band_setPixelFloat", BeamPyBand_setPixelFloat, METH_VARARGS, " Sets the pixel at the given pixel coordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"Band_setPixelDouble", BeamPyBand_setPixelDouble, METH_VARARGS, " Sets the pixel value at the given pixel coordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"Band_setPixelsInt", BeamPyBand_setPixelsInt, METH_VARARGS, " Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of\n data at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels integer array to be written\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\n             method variants to set or write raster data.\n"},
    {"Band_setPixelsFloat", BeamPyBand_setPixelsFloat, METH_VARARGS, " Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data\n at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels float array to be written\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\n             method variants to set or write raster data.\n"},
    {"Band_setPixelsDouble", BeamPyBand_setPixelsDouble, METH_VARARGS, " Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data\n at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels double array to be written\n @throws NullPointerException if this band has no raster data\n @deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\n             method variants to set or write raster data.\n"},
    {"Band_ensureRasterData", BeamPyBand_ensureRasterData, METH_VARARGS, " Ensures that raster data exists\n\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The Band object."},
    {"Band_unloadRasterData", BeamPyBand_unloadRasterData, METH_VARARGS, " Un-loads the raster data for this band.\n <p/>\n <p>After this method has been called successfully, the <code>hasRasterData()</code> method returns\n <code>false</code> and <code>getRasterData()</code> returns <code>null</code>.\n <p/>\n\n @see #loadRasterData()\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The Band object."},
    {"Band_getSceneRasterWidth", BeamPyBand_getSceneRasterWidth, METH_VARARGS, " Returns the width in pixels of the scene represented by this product raster. By default, the method simply\n returns <code>getRasterWidth()</code>.\n\n @return the scene width in pixels\n\n@param this The Band object."},
    {"Band_getSceneRasterHeight", BeamPyBand_getSceneRasterHeight, METH_VARARGS, " Returns the height in pixels of the scene represented by this product raster. By default, the method simply\n returns <code>getRasterHeight()</code>.\n\n @return the scene height in pixels\n\n@param this The Band object."},
    {"Band_getRasterWidth", BeamPyBand_getRasterWidth, METH_VARARGS, " Returns the width of the raster used by this product raster.\n\n @return the width of the raster\n\n@param this The Band object."},
    {"Band_getRasterHeight", BeamPyBand_getRasterHeight, METH_VARARGS, " Returns the height of the raster used by this product raster.\n\n @return the height of the raster\n\n@param this The Band object."},
    {"Band_setModified", BeamPyBand_setModified, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getGeoCoding", BeamPyBand_getGeoCoding, METH_VARARGS, " Returns the geo-coding of this {@link RasterDataNode}.\n\n @return the geo-coding\n\n@param this The Band object."},
    {"Band_setGeoCoding", BeamPyBand_setGeoCoding, METH_VARARGS, " Sets the geo-coding for this {@link RasterDataNode}.\n Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_GEOCODING}.</p>\n\n \n@param this The Band object.\n@param geoCoding the new geo-coding\n @see Product#setGeoCoding(GeoCoding)\n"},
    {"Band_getPointing", BeamPyBand_getPointing, METH_VARARGS, " Gets a {@link Pointing} if one is available for this raster.\n The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\n since the last creation of this raster's {@link Pointing} instance.\n\n @return the pointing object, or null if a pointing is not available\n\n@param this The Band object."},
    {"Band_canBeOrthorectified", BeamPyBand_canBeOrthorectified, METH_VARARGS, " Tests if this raster data node can be orthorectified.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_isFloatingPointType", BeamPyBand_isFloatingPointType, METH_VARARGS, " Returns <code>true</code> if the pixel data contained in this band is \"naturally\" a floating point number type.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_getGeophysicalDataType", BeamPyBand_getGeophysicalDataType, METH_VARARGS, " Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the\n <code>ProductData.TYPE_XXX</code> constants.\n\n @return the geophysical data type\n @see ProductData\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_getScalingFactor", BeamPyBand_getScalingFactor, METH_VARARGS, " Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>1.0</code> (no factor).\n\n @return the scaling factor\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setScalingFactor", BeamPyBand_setScalingFactor, METH_VARARGS, " Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The Band object.\n@param scalingFactor the scaling factor\n @see #isScalingApplied()\n"},
    {"Band_getScalingOffset", BeamPyBand_getScalingOffset, METH_VARARGS, " Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>0.0</code> (no offset).\n\n @return the scaling offset\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setScalingOffset", BeamPyBand_setScalingOffset, METH_VARARGS, " Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The Band object.\n@param scalingOffset the scaling offset\n @see #isScalingApplied()\n"},
    {"Band_isLog10Scaled", BeamPyBand_isLog10Scaled, METH_VARARGS, " Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n <code>false</code>.\n\n @return whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setLog10Scaled", BeamPyBand_setLog10Scaled, METH_VARARGS, " Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data.\n\n \n@param this The Band object.\n@param log10Scaled whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n"},
    {"Band_isScalingApplied", BeamPyBand_isScalingApplied, METH_VARARGS, " Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\n pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n {@link #setPixelFloat(int, int, float)}.\n\n @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n @see #getScalingOffset\n @see #getScalingFactor\n @see #isLog10Scaled\n\n@param this The Band object."},
    {"Band_isValidMaskProperty", BeamPyBand_isValidMaskProperty, METH_VARARGS, " Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n\n @param propertyName the  name to test\n @return {@code true}, if so.\n @since BEAM 4.2\n"},
    {"Band_isNoDataValueSet", BeamPyBand_isNoDataValueSet, METH_VARARGS, " Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n\n @return true, if so\n @see #isNoDataValueUsed()\n @see #setNoDataValue(double)\n\n@param this The Band object."},
    {"Band_clearNoDataValue", BeamPyBand_clearNoDataValue, METH_VARARGS, " Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.\n\n@param this The Band object."},
    {"Band_isNoDataValueUsed", BeamPyBand_isNoDataValueUsed, METH_VARARGS, " Tests whether or not the no-data value is used.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n @see #setNoDataValueUsed(boolean)\n @see #isNoDataValueSet()\n\n@param this The Band object."},
    {"Band_setNoDataValueUsed", BeamPyBand_setNoDataValueUsed, METH_VARARGS, " Sets whether or not the no-data value is used.\n If the no-data value is enabled and the no-data value has not been set so far,\n a default no-data value it is set with a value of to zero.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n\n \n@param this The Band object.\n@param noDataValueUsed true, if so\n @see #isNoDataValueUsed()\n"},
    {"Band_getNoDataValue", BeamPyBand_getNoDataValue, METH_VARARGS, " Gets the no-data value as a primitive <code>double</code>.\n <p>Note that the value returned is NOT necessarily the same as the value returned by\n {@link #getGeophysicalNoDataValue()} because no scaling is applied.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.\n\n @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n @see #setNoDataValue(double)\n @see #isNoDataValueSet()\n\n@param this The Band object."},
    {"Band_setNoDataValue", BeamPyBand_setNoDataValue, METH_VARARGS, " Sets the no-data value as a primitive <code>double</code>.\n <p>Note that the given value is related to the \"raw\", un-scaled raster data.\n In order to set the geophysical, scaled no-data value use the method\n {@link #setGeophysicalNoDataValue(double)}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The Band object.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n @see #getNoDataValue()\n @see #isNoDataValueSet()\n"},
    {"Band_getGeophysicalNoDataValue", BeamPyBand_getGeophysicalNoDataValue, METH_VARARGS, " Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n\n@param this The Band object."},
    {"Band_setGeophysicalNoDataValue", BeamPyBand_setGeophysicalNoDataValue, METH_VARARGS, " Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The Band object.\n@param noDataValue the new geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n @see #isNoDataValueSet()\n"},
    {"Band_getValidPixelExpression", BeamPyBand_getValidPixelExpression, METH_VARARGS, " Gets the expression that is used to determine whether a pixel is valid or not.\n For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the valid mask expression.\n\n@param this The Band object."},
    {"Band_setValidPixelExpression", BeamPyBand_setValidPixelExpression, METH_VARARGS, " Sets the expression that is used to determine whether a pixel is valid or not.\n <p>The valid-pixel expression is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n\n \n@param this The Band object.\n@param validPixelExpression the valid mask expression, can be null\n"},
    {"Band_isValidMaskUsed", BeamPyBand_isValidMaskUsed, METH_VARARGS, " Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\n true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\n <p>The data-mask is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_resetValidMask", BeamPyBand_resetValidMask, METH_VARARGS, " Resets the valid mask of this raster.\n The mask will be lazily regenerated when requested the next time.\n\n@param this The Band object."},
    {"Band_getValidMaskExpression", BeamPyBand_getValidMaskExpression, METH_VARARGS, " Gets the expression used for the computation of the mask which identifies valid pixel values.\n It recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n {@link #getValidPixelExpression() validPixelExpression} properties, if any.\n The method returns {@code null},  if none of these properties are set.\n\n @return The expression used for the computation of the mask which identifies valid pixel values,\n         or {@code null}.\n @see #getValidPixelExpression()\n @see #getNoDataValue()\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_updateExpression", BeamPyBand_updateExpression, METH_VARARGS, " {@inheritDoc}\n\n@param this The Band object."},
    {"Band_hasRasterData", BeamPyBand_hasRasterData, METH_VARARGS, " Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\n false.\n\n @return true, if so.\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The Band object."},
    {"Band_getRasterData", BeamPyBand_getRasterData, METH_VARARGS, " Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\n <code>null</code>.\n\n @return the raster data for this band, or <code>null</code> if data has not been loaded\n @deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\n             method variants to retrieve or read raster data.\n\n@param this The Band object."},
    {"Band_setRasterData", BeamPyBand_setRasterData, METH_VARARGS, " Sets the raster data of this dataset.\n <p/>\n <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product\n raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\n dataset's data!\n\n \n@param this The Band object.\n@param rasterData the raster data for this dataset\n @see #getRasterData()\n @deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\n             method variants to set or write raster data.\n"},
    {"Band_loadRasterData", BeamPyBand_loadRasterData, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The Band object."},
    {"Band_isPixelValid", BeamPyBand_isPixelValid, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n <p/>\n <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\n a synchronised block was used due to problem with the JAI ROI class that has been used in\n the former implementation.</i>\n\n \n@param this The Band object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"Band_getSampleInt", BeamPyBand_getSampleInt, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The Band object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"Band_getSampleFloat", BeamPyBand_getSampleFloat, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The Band object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"Band_getPixelsInt", BeamPyBand_getPixelsInt, METH_VARARGS, " @see #getPixels(int, int, int, int, int[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_getPixelsFloat", BeamPyBand_getPixelsFloat, METH_VARARGS, " @see #getPixels(int, int, int, int, float[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_getPixelsDouble", BeamPyBand_getPixelsDouble, METH_VARARGS, " @see #getPixels(int, int, int, int, double[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_readPixelsInt", BeamPyBand_readPixelsInt, METH_VARARGS, " @see #readPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readPixelsFloat", BeamPyBand_readPixelsFloat, METH_VARARGS, " @see #readPixels(int, int, int, int, float[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_readPixelsDouble", BeamPyBand_readPixelsDouble, METH_VARARGS, " @see #readPixels(int, int, int, int, double[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The Band object."},
    {"Band_writePixelsInt", BeamPyBand_writePixelsInt, METH_VARARGS, " @see #writePixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_writePixelsFloat", BeamPyBand_writePixelsFloat, METH_VARARGS, " @see #writePixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_writePixelsDouble", BeamPyBand_writePixelsDouble, METH_VARARGS, " @see #writePixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readValidMask", BeamPyBand_readValidMask, METH_VARARGS, "\n@param this The Band object."},
    {"Band_writeRasterDataFully", BeamPyBand_writeRasterDataFully, METH_VARARGS, "\n@param this The Band object."},
    {"Band_writeRasterData", BeamPyBand_writeRasterData, METH_VARARGS, " @deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\n             readPixels()} method variants to set or write raster data.\n\n@param this The Band object."},
    {"Band_createCompatibleRasterData", BeamPyBand_createCompatibleRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleSceneRasterData\n\n@param this The Band object."},
    {"Band_createCompatibleSceneRasterData", BeamPyBand_createCompatibleSceneRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n\n@param this The Band object."},
    {"Band_createCompatibleRasterDataForRect", BeamPyBand_createCompatibleRasterDataForRect, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>width*height</code> elements of a compatible data type.\n\n \n@param this The Band object.\n@param width  the width of the raster data to be created\n @param height the height of the raster data to be created\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n @see #createCompatibleSceneRasterData\n"},
    {"Band_isCompatibleRasterData", BeamPyBand_isCompatibleRasterData, METH_VARARGS, " Tests whether the given parameters specify a compatible raster or not.\n\n \n@param this The Band object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @return {@code true} if so\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"Band_checkCompatibleRasterData", BeamPyBand_checkCompatibleRasterData, METH_VARARGS, " Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n\n \n@param this The Band object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"Band_hasIntPixels", BeamPyBand_hasIntPixels, METH_VARARGS, " Determines whether this raster data node contains integer samples.\n\n @return true if this raster data node contains integer samples.\n\n@param this The Band object."},
    {"Band_createTransectProfileData", BeamPyBand_createTransectProfileData, METH_VARARGS, " Creates a transect profile for the given shape (-outline).\n\n \n@param this The Band object.\n@param shape the shape\n @return the profile data\n @throws IOException if an I/O error occurs\n"},
    {"Band_getImageInfo", BeamPyBand_getImageInfo, METH_VARARGS, " Gets the image information for image display.\n\n @return the image info or null\n\n@param this The Band object."},
    {"Band_setImageInfo", BeamPyBand_setImageInfo, METH_VARARGS, " Sets the image information for image display.\n\n \n@param this The Band object.\n@param imageInfo the image info, can be null\n"},
    {"Band_fireImageInfoChanged", BeamPyBand_fireImageInfoChanged, METH_VARARGS, " Notifies listeners that the image (display) information has changed.\n\n @since BEAM 4.7\n\n@param this The Band object."},
    {"Band_createDefaultImageInfo", BeamPyBand_createDefaultImageInfo, METH_VARARGS, " Creates an instance of a default image information.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The Band object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param histogram      the histogram to create the image information.\n @return a valid image information instance, never <code>null</code>.\n"},
    {"Band_getOverlayMaskGroup", BeamPyBand_getOverlayMaskGroup, METH_VARARGS, " @return The overlay mask group.\n\n@param this The Band object."},
    {"Band_createColorIndexedImage", BeamPyBand_createColorIndexedImage, METH_VARARGS, " Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\n null)</code>.\n\n \n@param this The Band object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"Band_createRgbImage", BeamPyBand_createRgbImage, METH_VARARGS, " Creates an RGB image for this raster data node.\n\n \n@param this The Band object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"Band_createPixelValidator", BeamPyBand_createPixelValidator, METH_VARARGS, " Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n\n \n@param this The Band object.\n@param lineOffset the absolute line offset, zero based\n @param roi        an optional ROI\n @return a new validator instance, never null\n @throws IOException if an I/O error occurs\n"},
    {"Band_scale", BeamPyBand_scale, METH_VARARGS, " Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\n scaling.\n\n \n@param this The Band object.\n@param v the input value\n @return the scaled value\n"},
    {"Band_scaleInverse", BeamPyBand_scaleInverse, METH_VARARGS, " Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\n scaling.\n\n \n@param this The Band object.\n@param v the input value\n @return the scaled value\n"},
    {"Band_getPixelString", BeamPyBand_getPixelString, METH_VARARGS, " Returns the pixel located at (x,y) as a string value.\n\n \n@param this The Band object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return the pixel value at (x,y) as string or an error message text\n"},
    {"Band_isSourceImageSet", BeamPyBand_isSourceImageSet, METH_VARARGS, " Returns whether the source image is set on this {@code RasterDataNode}.\n\n @return whether the source image is set.\n @see #getSourceImage()\n @see #setSourceImage(java.awt.image.RenderedImage)\n @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n @see #createSourceImage()\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_getSourceImage", BeamPyBand_getSourceImage, METH_VARARGS, " Gets the source image associated with this {@code RasterDataNode}.\n\n @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\n         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n @see #createSourceImage()\n @see #isSourceImageSet()\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_isGeophysicalImageSet", BeamPyBand_isGeophysicalImageSet, METH_VARARGS, " Returns whether the geophysical image is set on this {@code RasterDataNode}.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return whether the geophysical image is set.\n @since BEAM 4.6\n\n@param this The Band object."},
    {"Band_getGeophysicalImage", BeamPyBand_getGeophysicalImage, METH_VARARGS, " @return The geophysical source image.\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_isValidMaskImageSet", BeamPyBand_isValidMaskImageSet, METH_VARARGS, " Returns wether the valid mask image is set on this {@code RasterDataNode}.\n\n @return Wether the source image is set.\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_getValidMaskImage", BeamPyBand_getValidMaskImage, METH_VARARGS, " Gets the valid-mask image associated with this {@code RasterDataNode}.\n\n @return The rendered image.\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_isStxSet", BeamPyBand_isStxSet, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getStx", BeamPyBand_getStx, METH_VARARGS, " Gets the statistics. If statistcs are not yet available,\n the method will compute (possibly inaccurate) statistics and return those.\n <p/>\n If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\n shall be used instead.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return The statistics.\n @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n @see #setStx(Stx)\n @since BEAM 4.2, revised in BEAM 4.5\n\n@param this The Band object."},
    {"Band_setStx", BeamPyBand_setStx, METH_VARARGS, " Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\n are really related to this {@code RasterDataNode}'s raster data.\n The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The Band object.\n@param stx The statistics.\n @since BEAM 4.2, revised in BEAM 4.5\n"},
    {"Band_getValidShape", BeamPyBand_getValidShape, METH_VARARGS, " Gets the shape of the area where this raster data contains valid samples.\n The method returns <code>null</code>, if the entire raster contains valid samples.\n\n @return The shape of the area where the raster data has samples, can be {@code null}.\n @since BEAM 4.7\n\n@param this The Band object."},
    {"Band_getRoiMaskGroup", BeamPyBand_getRoiMaskGroup, METH_VARARGS, " @return The roi mask group.\n @deprecated since BEAM 4.10 (no replacement)\n\n@param this The Band object."},
    {"Band_getDataType", BeamPyBand_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The Band object."},
    {"Band_getNumDataElems", BeamPyBand_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The Band object."},
    {"Band_setData", BeamPyBand_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The Band object."},
    {"Band_getData", BeamPyBand_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The Band object."},
    {"Band_setDataElems", BeamPyBand_setDataElems, METH_VARARGS, " Sets the data elements of this data node.\n @deprecated since 5.0\n @see ProductData#setElems(Object)\n\n@param this The Band object."},
    {"Band_getDataElems", BeamPyBand_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The Band object."},
    {"Band_getDataElemSize", BeamPyBand_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The Band object."},
    {"Band_setReadOnly", BeamPyBand_setReadOnly, METH_VARARGS, "\n@param this The Band object."},
    {"Band_isReadOnly", BeamPyBand_isReadOnly, METH_VARARGS, "\n@param this The Band object."},
    {"Band_setUnit", BeamPyBand_setUnit, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getUnit", BeamPyBand_getUnit, METH_VARARGS, "\n@param this The Band object."},
    {"Band_isSynthetic", BeamPyBand_isSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The Band object."},
    {"Band_setSynthetic", BeamPyBand_setSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The Band object."},
    {"Band_fireProductNodeDataChanged", BeamPyBand_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The Band object."},
    {"Band_createCompatibleProductData", BeamPyBand_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The Band object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"Band_getOwner", BeamPyBand_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Band object."},
    {"Band_getName", BeamPyBand_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Band object."},
    {"Band_setName", BeamPyBand_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Band object.\n@param name The name.\n"},
    {"Band_getDescription", BeamPyBand_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Band object."},
    {"Band_setDescription", BeamPyBand_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Band object.\n@param description a description, can be <code>null</code>\n"},
    {"Band_isModified", BeamPyBand_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_isValidNodeName", BeamPyBand_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Band_getProduct", BeamPyBand_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Band object."},
    {"Band_getProductReader", BeamPyBand_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The Band object."},
    {"Band_getProductWriter", BeamPyBand_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The Band object."},
    {"Band_getDisplayName", BeamPyBand_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Band object."},
    {"Band_getProductRefString", BeamPyBand_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Band object."},
    {"Band_getExtension", BeamPyBand_getExtension, METH_VARARGS, "\n@param this The Band object."},
    {"PlacemarkGroup_getVectorDataNode", BeamPyPlacemarkGroup_getVectorDataNode, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getPlacemark", BeamPyPlacemarkGroup_getPlacemark, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_add3", BeamPyPlacemarkGroup_add3, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_add1", BeamPyPlacemarkGroup_add1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_remove1", BeamPyPlacemarkGroup_remove1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_dispose", BeamPyPlacemarkGroup_dispose, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_isTakingOverNodeOwnership", BeamPyPlacemarkGroup_isTakingOverNodeOwnership, METH_VARARGS, " @return {@code true}, if child nodes will have this group as owner after adding.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getNodeCount", BeamPyPlacemarkGroup_getNodeCount, METH_VARARGS, " @return The number of product nodes in this product group.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_get1", BeamPyPlacemarkGroup_get1, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param index The node index.\n @return The product node at the given index.\n"},
    {"PlacemarkGroup_getNodeDisplayNames", BeamPyPlacemarkGroup_getNodeDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n @see ProductNode#getDisplayName()\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getNodeNames", BeamPyPlacemarkGroup_getNodeNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toArray1", BeamPyPlacemarkGroup_toArray1, METH_VARARGS, " Returns an array of all products currently managed.\n\n @return an array containing the products, never <code>null</code>, but the array can have zero length\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toArray2", BeamPyPlacemarkGroup_toArray2, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a\n              new array of the same runtime type is allocated for this purpose.\n @return an array containing the product nodes, never <code>null</code>, but the array can have zero length\n"},
    {"PlacemarkGroup_indexOf1", BeamPyPlacemarkGroup_indexOf1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_indexOf2", BeamPyPlacemarkGroup_indexOf2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getByDisplayName", BeamPyPlacemarkGroup_getByDisplayName, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param displayName the display name\n @return the product node with the given display name.\n"},
    {"PlacemarkGroup_get2", BeamPyPlacemarkGroup_get2, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param name the name\n @return the product node with the given name.\n"},
    {"PlacemarkGroup_contains1", BeamPyPlacemarkGroup_contains1, METH_VARARGS, " Tests whether a node with the given name is contained in this group.\n\n \n@param this The PlacemarkGroup object.\n@param name the name\n @return true, if so\n"},
    {"PlacemarkGroup_contains2", BeamPyPlacemarkGroup_contains2, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The PlacemarkGroup object.\n@param node the node\n @return true, if so\n"},
    {"PlacemarkGroup_add4", BeamPyPlacemarkGroup_add4, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The PlacemarkGroup object.\n@param node the node to be added, ignored if <code>null</code>\n @return true, if the node has been added\n"},
    {"PlacemarkGroup_add2", BeamPyPlacemarkGroup_add2, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The PlacemarkGroup object.\n@param index the index.\n @param node  the node to be added, ignored if <code>null</code>\n"},
    {"PlacemarkGroup_remove2", BeamPyPlacemarkGroup_remove2, METH_VARARGS, " Removes the given node from this group.\n\n \n@param this The PlacemarkGroup object.\n@param node the node to be removed\n @return true, if the node was removed\n"},
    {"PlacemarkGroup_removeAll", BeamPyPlacemarkGroup_removeAll, METH_VARARGS, " Removes all nodes from this group.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_clearRemovedList", BeamPyPlacemarkGroup_clearRemovedList, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRemovedNodes", BeamPyPlacemarkGroup_getRemovedNodes, METH_VARARGS, " Gets all removed node nodes.\n\n @return a collection of all removed node nodes.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRawStorageSize2", BeamPyPlacemarkGroup_getRawStorageSize2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setModified", BeamPyPlacemarkGroup_setModified, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_acceptVisitor", BeamPyPlacemarkGroup_acceptVisitor, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_updateExpression", BeamPyPlacemarkGroup_updateExpression, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getOwner", BeamPyPlacemarkGroup_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getName", BeamPyPlacemarkGroup_getName, METH_VARARGS, " @return This node's name.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setName", BeamPyPlacemarkGroup_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The PlacemarkGroup object.\n@param name The name.\n"},
    {"PlacemarkGroup_getDescription", BeamPyPlacemarkGroup_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setDescription", BeamPyPlacemarkGroup_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The PlacemarkGroup object.\n@param description a description, can be <code>null</code>\n"},
    {"PlacemarkGroup_isModified", BeamPyPlacemarkGroup_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toString", BeamPyPlacemarkGroup_toString, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_isValidNodeName", BeamPyPlacemarkGroup_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"PlacemarkGroup_getProduct", BeamPyPlacemarkGroup_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductReader", BeamPyPlacemarkGroup_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductWriter", BeamPyPlacemarkGroup_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getDisplayName", BeamPyPlacemarkGroup_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductRefString", BeamPyPlacemarkGroup_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRawStorageSize1", BeamPyPlacemarkGroup_getRawStorageSize1, METH_VARARGS, " Gets an estimated, raw storage size in bytes of this product node.\n\n @return the size in bytes.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_fireProductNodeChanged1", BeamPyPlacemarkGroup_fireProductNodeChanged1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_fireProductNodeChanged2", BeamPyPlacemarkGroup_fireProductNodeChanged2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_removeFromFile", BeamPyPlacemarkGroup_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The PlacemarkGroup object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"PlacemarkGroup_getExtension", BeamPyPlacemarkGroup_getExtension, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"TiePointGrid_newTiePointGrid1", BeamPyTiePointGrid_newTiePointGrid1, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name         the name of the new object\n @param gridWidth    the width of the tie-point grid in pixels\n @param gridHeight   the height of the tie-point grid in pixels\n @param offsetX      the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY      the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                     this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                     this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints    the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n"},
    {"TiePointGrid_newTiePointGrid2", BeamPyTiePointGrid_newTiePointGrid2, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name          the name of the new object\n @param gridWidth     the width of the tie-point grid in pixels\n @param gridHeight    the height of the tie-point grid in pixels\n @param offsetX       the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY       the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                      this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                      this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints     the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n @param discontinuity the discontinuity mode, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180}\n                      {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_newTiePointGrid3", BeamPyTiePointGrid_newTiePointGrid3, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name           the name of the new object\n @param gridWidth      the width of the tie-point grid in pixels\n @param gridHeight     the height of the tie-point grid in pixels\n @param offsetX        the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY        the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                       this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                       this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints      the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n @param containsAngles if true, the {@link #getDiscontinuity() angular discontinuity} is derived from the provided tie-point data values\n"},
    {"TiePointGrid_getDiscontinuity2", BeamPyTiePointGrid_getDiscontinuity2, METH_VARARGS, " Determines the angular discontinuity of the given tie point values.\n\n @return the angular discontinuity, will always be either {@link #DISCONT_AT_180} or\n         {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_getDiscontinuity1", BeamPyTiePointGrid_getDiscontinuity1, METH_VARARGS, " Gets the angular discontinuity.\n\n @return the angular discontinuity, will always be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n         {@link #DISCONT_AT_360}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setDiscontinuity", BeamPyTiePointGrid_setDiscontinuity, METH_VARARGS, " Sets the angular discontinuity.\n\n \n@param this The TiePointGrid object.\n@param discontinuity angular discontinuity, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n                      {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_isFloatingPointType", BeamPyTiePointGrid_isFloatingPointType, METH_VARARGS, " Returns <code>true</code>\n\n @return true\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeophysicalDataType", BeamPyTiePointGrid_getGeophysicalDataType, METH_VARARGS, " Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the\n <code>ProductData.TYPE_XXX</code> constants.\n\n @return the geophysical data type\n\n @see ProductData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterData", BeamPyTiePointGrid_getSceneRasterData, METH_VARARGS, " Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. <p/>\n <p/>\n In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store\n the scene's pixels.\n\n @return raster data covering the pixels for a complete scene\n\n @see #getRasterData\n @see #getRasterWidth\n @see #getRasterHeight\n @see #getSceneRasterWidth\n @see #getSceneRasterHeight\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterWidth", BeamPyTiePointGrid_getSceneRasterWidth, METH_VARARGS, " Returns the width in pixels of the scene represented by this tie-point grid. The value returned is\n <code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>\n\n @return the scene width in pixels\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterHeight", BeamPyTiePointGrid_getSceneRasterHeight, METH_VARARGS, " Returns the height in pixels of the scene represented by this tie-point grid. The value returned is\n <code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>\n\n @return the scene height in pixels\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getOffsetX", BeamPyTiePointGrid_getOffsetX, METH_VARARGS, " Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getOffsetY", BeamPyTiePointGrid_getOffsetY, METH_VARARGS, " Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSubSamplingX", BeamPyTiePointGrid_getSubSamplingX, METH_VARARGS, " Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this\n tie-pint grid belongs to.\n\n @return the sub-sampling in X-direction, never less than one.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSubSamplingY", BeamPyTiePointGrid_getSubSamplingY, METH_VARARGS, " Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this\n tie-pint grid belongs to.\n\n @return the sub-sampling in Y-direction, never less than one.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getTiePoints", BeamPyTiePointGrid_getTiePoints, METH_VARARGS, " Gets the data array holding this band's pixel samples.\n\n @return the data array for this band, or <code>null</code> if no data has been loaded\n\n @see ProductData#getElems\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixelInt", BeamPyTiePointGrid_getPixelInt, METH_VARARGS, " Gets the interpolated sample for the pixel located at (x,y) as an integer value. <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_dispose", BeamPyTiePointGrid_dispose, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixelFloat2", BeamPyTiePointGrid_getPixelFloat2, METH_VARARGS, " Computes the interpolated sample for the pixel located at (x,y). <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_getPixelFloat1", BeamPyTiePointGrid_getPixelFloat1, METH_VARARGS, " Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_getPixelDouble", BeamPyTiePointGrid_getPixelDouble, METH_VARARGS, " Gets the interpolated sample for the pixel located at (x,y) as a double value. <p/>\n <p/>\n If the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_setPixelInt", BeamPyTiePointGrid_setPixelInt, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixelFloat", BeamPyTiePointGrid_setPixelFloat, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixelDouble", BeamPyTiePointGrid_setPixelDouble, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels6", BeamPyTiePointGrid_getPixels6, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the integer array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_getPixels4", BeamPyTiePointGrid_getPixels4, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product width and height as float array. If the given\n array is <code>null</code> a new one is created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the float array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_getPixels2", BeamPyTiePointGrid_getPixels2, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the double array to be filled with data\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_setPixels3", BeamPyTiePointGrid_setPixels3, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixels2", BeamPyTiePointGrid_setPixels2, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixels1", BeamPyTiePointGrid_setPixels1, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels6", BeamPyTiePointGrid_readPixels6, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the integer array to be filled with data\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_readPixels4", BeamPyTiePointGrid_readPixels4, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\n array is <code>null</code> a new one was created and returned. *\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the float array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_readPixels2", BeamPyTiePointGrid_readPixels2, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the double array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_writePixels6", BeamPyTiePointGrid_writePixels6, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels4", BeamPyTiePointGrid_writePixels4, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels2", BeamPyTiePointGrid_writePixels2, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterData2", BeamPyTiePointGrid_readRasterData2, METH_VARARGS, " Reads raster data from this dataset into the user-supplied raster data buffer. <p/>\n <p/>\n This method always directly (re-)reads this band's data from its associated data source into the given data\n buffer.\n\n \n@param this The TiePointGrid object.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n @param offsetY    the Y-offset in the raster co-ordinates where reading starts\n @param width      the width of the raster data buffer\n @param height     the height of the raster data buffer\n @param rasterData a raster data buffer receiving the pixels to be read\n @param pm         a monitor to inform the user about progress\n\n @throws java.io.IOException      if an I/O error occurs\n @throws IllegalArgumentException if the raster is null\n @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\n                                  which this product raster belongs to, has no associated product reader\n @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor) \n"},
    {"TiePointGrid_readRasterDataFully2", BeamPyTiePointGrid_readRasterDataFully2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterData2", BeamPyTiePointGrid_writeRasterData2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterDataFully2", BeamPyTiePointGrid_writeRasterDataFully2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_acceptVisitor", BeamPyTiePointGrid_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor. <p/>\n <p/>\n The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The TiePointGrid object.\n@param visitor the visitor\n"},
    {"TiePointGrid_cloneTiePointGrid", BeamPyTiePointGrid_cloneTiePointGrid, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_createZenithFromElevationAngleTiePointGrid", BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid, METH_VARARGS, ""},
    {"TiePointGrid_createSubset", BeamPyTiePointGrid_createSubset, METH_VARARGS, ""},
    {"TiePointGrid_getRasterWidth", BeamPyTiePointGrid_getRasterWidth, METH_VARARGS, " Returns the width of the raster used by this product raster.\n\n @return the width of the raster\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRasterHeight", BeamPyTiePointGrid_getRasterHeight, METH_VARARGS, " Returns the height of the raster used by this product raster.\n\n @return the height of the raster\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setModified", BeamPyTiePointGrid_setModified, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeoCoding", BeamPyTiePointGrid_getGeoCoding, METH_VARARGS, " Returns the geo-coding of this {@link RasterDataNode}.\n\n @return the geo-coding\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setGeoCoding", BeamPyTiePointGrid_setGeoCoding, METH_VARARGS, " Sets the geo-coding for this {@link RasterDataNode}.\n Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_GEOCODING}.</p>\n\n \n@param this The TiePointGrid object.\n@param geoCoding the new geo-coding\n @see Product#setGeoCoding(GeoCoding)\n"},
    {"TiePointGrid_getPointing", BeamPyTiePointGrid_getPointing, METH_VARARGS, " Gets a {@link Pointing} if one is available for this raster.\n The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\n since the last creation of this raster's {@link Pointing} instance.\n\n @return the pointing object, or null if a pointing is not available\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_canBeOrthorectified", BeamPyTiePointGrid_canBeOrthorectified, METH_VARARGS, " Tests if this raster data node can be orthorectified.\n\n @return true, if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getScalingFactor", BeamPyTiePointGrid_getScalingFactor, METH_VARARGS, " Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>1.0</code> (no factor).\n\n @return the scaling factor\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setScalingFactor", BeamPyTiePointGrid_setScalingFactor, METH_VARARGS, " Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The TiePointGrid object.\n@param scalingFactor the scaling factor\n @see #isScalingApplied()\n"},
    {"TiePointGrid_getScalingOffset", BeamPyTiePointGrid_getScalingOffset, METH_VARARGS, " Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>0.0</code> (no offset).\n\n @return the scaling offset\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setScalingOffset", BeamPyTiePointGrid_setScalingOffset, METH_VARARGS, " Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The TiePointGrid object.\n@param scalingOffset the scaling offset\n @see #isScalingApplied()\n"},
    {"TiePointGrid_isLog10Scaled", BeamPyTiePointGrid_isLog10Scaled, METH_VARARGS, " Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n <code>false</code>.\n\n @return whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setLog10Scaled", BeamPyTiePointGrid_setLog10Scaled, METH_VARARGS, " Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data.\n\n \n@param this The TiePointGrid object.\n@param log10Scaled whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n"},
    {"TiePointGrid_isScalingApplied", BeamPyTiePointGrid_isScalingApplied, METH_VARARGS, " Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\n pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n {@link #setPixelFloat(int, int, float)}.\n\n @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n @see #getScalingOffset\n @see #getScalingFactor\n @see #isLog10Scaled\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidMaskProperty", BeamPyTiePointGrid_isValidMaskProperty, METH_VARARGS, " Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n\n @param propertyName the  name to test\n @return {@code true}, if so.\n @since BEAM 4.2\n"},
    {"TiePointGrid_isNoDataValueSet", BeamPyTiePointGrid_isNoDataValueSet, METH_VARARGS, " Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n\n @return true, if so\n @see #isNoDataValueUsed()\n @see #setNoDataValue(double)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_clearNoDataValue", BeamPyTiePointGrid_clearNoDataValue, METH_VARARGS, " Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isNoDataValueUsed", BeamPyTiePointGrid_isNoDataValueUsed, METH_VARARGS, " Tests whether or not the no-data value is used.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n @see #setNoDataValueUsed(boolean)\n @see #isNoDataValueSet()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setNoDataValueUsed", BeamPyTiePointGrid_setNoDataValueUsed, METH_VARARGS, " Sets whether or not the no-data value is used.\n If the no-data value is enabled and the no-data value has not been set so far,\n a default no-data value it is set with a value of to zero.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n\n \n@param this The TiePointGrid object.\n@param noDataValueUsed true, if so\n @see #isNoDataValueUsed()\n"},
    {"TiePointGrid_getNoDataValue", BeamPyTiePointGrid_getNoDataValue, METH_VARARGS, " Gets the no-data value as a primitive <code>double</code>.\n <p>Note that the value returned is NOT necessarily the same as the value returned by\n {@link #getGeophysicalNoDataValue()} because no scaling is applied.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.\n\n @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n @see #setNoDataValue(double)\n @see #isNoDataValueSet()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setNoDataValue", BeamPyTiePointGrid_setNoDataValue, METH_VARARGS, " Sets the no-data value as a primitive <code>double</code>.\n <p>Note that the given value is related to the \"raw\", un-scaled raster data.\n In order to set the geophysical, scaled no-data value use the method\n {@link #setGeophysicalNoDataValue(double)}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The TiePointGrid object.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n @see #getNoDataValue()\n @see #isNoDataValueSet()\n"},
    {"TiePointGrid_getGeophysicalNoDataValue", BeamPyTiePointGrid_getGeophysicalNoDataValue, METH_VARARGS, " Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setGeophysicalNoDataValue", BeamPyTiePointGrid_setGeophysicalNoDataValue, METH_VARARGS, " Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The TiePointGrid object.\n@param noDataValue the new geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n @see #isNoDataValueSet()\n"},
    {"TiePointGrid_getValidPixelExpression", BeamPyTiePointGrid_getValidPixelExpression, METH_VARARGS, " Gets the expression that is used to determine whether a pixel is valid or not.\n For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the valid mask expression.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setValidPixelExpression", BeamPyTiePointGrid_setValidPixelExpression, METH_VARARGS, " Sets the expression that is used to determine whether a pixel is valid or not.\n <p>The valid-pixel expression is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n\n \n@param this The TiePointGrid object.\n@param validPixelExpression the valid mask expression, can be null\n"},
    {"TiePointGrid_isValidMaskUsed", BeamPyTiePointGrid_isValidMaskUsed, METH_VARARGS, " Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\n true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\n <p>The data-mask is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_resetValidMask", BeamPyTiePointGrid_resetValidMask, METH_VARARGS, " Resets the valid mask of this raster.\n The mask will be lazily regenerated when requested the next time.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getValidMaskExpression", BeamPyTiePointGrid_getValidMaskExpression, METH_VARARGS, " Gets the expression used for the computation of the mask which identifies valid pixel values.\n It recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n {@link #getValidPixelExpression() validPixelExpression} properties, if any.\n The method returns {@code null},  if none of these properties are set.\n\n @return The expression used for the computation of the mask which identifies valid pixel values,\n         or {@code null}.\n @see #getValidPixelExpression()\n @see #getNoDataValue()\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_updateExpression", BeamPyTiePointGrid_updateExpression, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_hasRasterData", BeamPyTiePointGrid_hasRasterData, METH_VARARGS, " Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\n false.\n\n @return true, if so.\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRasterData", BeamPyTiePointGrid_getRasterData, METH_VARARGS, " Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\n <code>null</code>.\n\n @return the raster data for this band, or <code>null</code> if data has not been loaded\n @deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\n             method variants to retrieve or read raster data.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setRasterData", BeamPyTiePointGrid_setRasterData, METH_VARARGS, " Sets the raster data of this dataset.\n <p/>\n <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product\n raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\n dataset's data!\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data for this dataset\n @see #getRasterData()\n @deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\n             method variants to set or write raster data.\n"},
    {"TiePointGrid_loadRasterData1", BeamPyTiePointGrid_loadRasterData1, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_loadRasterData2", BeamPyTiePointGrid_loadRasterData2, METH_VARARGS, " Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,\n <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should\n always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>\n elements (samples).\n <p/>\n <p>The default implementation of this method does nothing.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @throws IOException if an I/O error occurs\n @see #unloadRasterData()\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"TiePointGrid_unloadRasterData", BeamPyTiePointGrid_unloadRasterData, METH_VARARGS, " Un-loads the raster data for this <code>RasterDataNode</code>.\n <p/>\n <p>It is up to the implementation whether after this method has been called successfully, the\n <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.\n <p/>\n <p>The default implementation of this method does nothing.\n\n @see #loadRasterData()\n @deprecated since BEAM 4.11. No replacement.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isPixelValid2", BeamPyTiePointGrid_isPixelValid2, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n <p/>\n <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\n a synchronised block was used due to problem with the JAI ROI class that has been used in\n the former implementation.</i>\n\n \n@param this The TiePointGrid object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"TiePointGrid_getSampleInt", BeamPyTiePointGrid_getSampleInt, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The TiePointGrid object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"TiePointGrid_getSampleFloat", BeamPyTiePointGrid_getSampleFloat, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The TiePointGrid object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"TiePointGrid_isPixelValid1", BeamPyTiePointGrid_isPixelValid1, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n\n \n@param this The TiePointGrid object.\n@param pixelIndex the linear pixel index in the range 0 to width * height - 1\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n @since 4.1\n"},
    {"TiePointGrid_isPixelValid3", BeamPyTiePointGrid_isPixelValid3, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,\n and secondly, if the pixel is within the ROI (if any).\n\n \n@param this The TiePointGrid object.\n@param x   the X co-ordinate of the pixel location\n @param y   the Y co-ordinate of the pixel location\n @param roi the ROI, if null the method returns {@link #isPixelValid(int, int)}\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"TiePointGrid_getPixels5", BeamPyTiePointGrid_getPixels5, METH_VARARGS, " @see #getPixels(int, int, int, int, int[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels3", BeamPyTiePointGrid_getPixels3, METH_VARARGS, " @see #getPixels(int, int, int, int, float[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels1", BeamPyTiePointGrid_getPixels1, METH_VARARGS, " @see #getPixels(int, int, int, int, double[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels5", BeamPyTiePointGrid_readPixels5, METH_VARARGS, " @see #readPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels3", BeamPyTiePointGrid_readPixels3, METH_VARARGS, " @see #readPixels(int, int, int, int, float[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels1", BeamPyTiePointGrid_readPixels1, METH_VARARGS, " @see #readPixels(int, int, int, int, double[], ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels5", BeamPyTiePointGrid_writePixels5, METH_VARARGS, " @see #writePixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels3", BeamPyTiePointGrid_writePixels3, METH_VARARGS, " @see #writePixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels1", BeamPyTiePointGrid_writePixels1, METH_VARARGS, " @see #writePixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readValidMask", BeamPyTiePointGrid_readValidMask, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterDataFully1", BeamPyTiePointGrid_readRasterDataFully1, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #readRasterDataFully(ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterData1", BeamPyTiePointGrid_readRasterData1, METH_VARARGS, " Reads raster data from the node's associated data source into the given data\n buffer.\n\n \n@param this The TiePointGrid object.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n @param offsetY    the Y-offset in the raster co-ordinates where reading starts\n @param width      the width of the raster data buffer\n @param height     the height of the raster data buffer\n @param rasterData a raster data buffer receiving the pixels to be read\n @throws java.io.IOException      if an I/O error occurs\n @throws IllegalArgumentException if the raster is null\n @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\n                                  which this product raster belongs to, has no associated product reader\n @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)\n @deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead.\n"},
    {"TiePointGrid_writeRasterDataFully1", BeamPyTiePointGrid_writeRasterDataFully1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterData1", BeamPyTiePointGrid_writeRasterData1, METH_VARARGS, " @deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\n             readPixels()} method variants to set or write raster data.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleRasterData1", BeamPyTiePointGrid_createCompatibleRasterData1, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleSceneRasterData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleSceneRasterData", BeamPyTiePointGrid_createCompatibleSceneRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleRasterData2", BeamPyTiePointGrid_createCompatibleRasterData2, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>width*height</code> elements of a compatible data type.\n\n \n@param this The TiePointGrid object.\n@param width  the width of the raster data to be created\n @param height the height of the raster data to be created\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n @see #createCompatibleSceneRasterData\n"},
    {"TiePointGrid_isCompatibleRasterData", BeamPyTiePointGrid_isCompatibleRasterData, METH_VARARGS, " Tests whether the given parameters specify a compatible raster or not.\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @return {@code true} if so\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"TiePointGrid_checkCompatibleRasterData", BeamPyTiePointGrid_checkCompatibleRasterData, METH_VARARGS, " Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @deprecated since BEAM 4.11. No replacement.\n"},
    {"TiePointGrid_hasIntPixels", BeamPyTiePointGrid_hasIntPixels, METH_VARARGS, " Determines whether this raster data node contains integer samples.\n\n @return true if this raster data node contains integer samples.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createTransectProfileData", BeamPyTiePointGrid_createTransectProfileData, METH_VARARGS, " Creates a transect profile for the given shape (-outline).\n\n \n@param this The TiePointGrid object.\n@param shape the shape\n @return the profile data\n @throws IOException if an I/O error occurs\n"},
    {"TiePointGrid_getImageInfo1", BeamPyTiePointGrid_getImageInfo1, METH_VARARGS, " Gets the image information for image display.\n\n @return the image info or null\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setImageInfo", BeamPyTiePointGrid_setImageInfo, METH_VARARGS, " Sets the image information for image display.\n\n \n@param this The TiePointGrid object.\n@param imageInfo the image info, can be null\n"},
    {"TiePointGrid_fireImageInfoChanged", BeamPyTiePointGrid_fireImageInfoChanged, METH_VARARGS, " Notifies listeners that the image (display) information has changed.\n\n @since BEAM 4.7\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getImageInfo2", BeamPyTiePointGrid_getImageInfo2, METH_VARARGS, " Returns the image information for this raster data node.\n <p/>\n <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.\n\n \n@param this The TiePointGrid object.\n@param pm A progress monitor.\n @return A valid image information instance.\n @see #getImageInfo(double[], ProgressMonitor)\n @since BEAM 4.2\n"},
    {"TiePointGrid_getImageInfo3", BeamPyTiePointGrid_getImageInfo3, METH_VARARGS, " Gets the image creation information.\n <p/>\n <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is\n called with the given parameters passed to this method.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas Only used, if new image info is created (see <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code>\n                       method).\n @param pm             A progress monitor.\n @return The image creation information.\n @since BEAM 4.2\n"},
    {"TiePointGrid_createDefaultImageInfo1", BeamPyTiePointGrid_createDefaultImageInfo1, METH_VARARGS, " Creates a default image information instance.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param pm             a monitor to inform the user about progress\n @return a valid image information instance, never <code>null</code>.\n"},
    {"TiePointGrid_createDefaultImageInfo2", BeamPyTiePointGrid_createDefaultImageInfo2, METH_VARARGS, " Creates an instance of a default image information.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param histogram      the histogram to create the image information.\n @return a valid image information instance, never <code>null</code>.\n"},
    {"TiePointGrid_getOverlayMaskGroup", BeamPyTiePointGrid_getOverlayMaskGroup, METH_VARARGS, " @return The overlay mask group.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createColorIndexedImage", BeamPyTiePointGrid_createColorIndexedImage, METH_VARARGS, " Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\n null)</code>.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"TiePointGrid_createRgbImage", BeamPyTiePointGrid_createRgbImage, METH_VARARGS, " Creates an RGB image for this raster data node.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"TiePointGrid_quantizeRasterData1", BeamPyTiePointGrid_quantizeRasterData1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_quantizeRasterData2", BeamPyTiePointGrid_quantizeRasterData2, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_createPixelValidator", BeamPyTiePointGrid_createPixelValidator, METH_VARARGS, " Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n\n \n@param this The TiePointGrid object.\n@param lineOffset the absolute line offset, zero based\n @param roi        an optional ROI\n @return a new validator instance, never null\n @throws IOException if an I/O error occurs\n"},
    {"TiePointGrid_scale", BeamPyTiePointGrid_scale, METH_VARARGS, " Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\n scaling.\n\n \n@param this The TiePointGrid object.\n@param v the input value\n @return the scaled value\n"},
    {"TiePointGrid_scaleInverse", BeamPyTiePointGrid_scaleInverse, METH_VARARGS, " Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\n scaling.\n\n \n@param this The TiePointGrid object.\n@param v the input value\n @return the scaled value\n"},
    {"TiePointGrid_getPixelString", BeamPyTiePointGrid_getPixelString, METH_VARARGS, " Returns the pixel located at (x,y) as a string value.\n\n \n@param this The TiePointGrid object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return the pixel value at (x,y) as string or an error message text\n"},
    {"TiePointGrid_isSourceImageSet", BeamPyTiePointGrid_isSourceImageSet, METH_VARARGS, " Returns whether the source image is set on this {@code RasterDataNode}.\n\n @return whether the source image is set.\n @see #getSourceImage()\n @see #setSourceImage(java.awt.image.RenderedImage)\n @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n @see #createSourceImage()\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSourceImage", BeamPyTiePointGrid_getSourceImage, METH_VARARGS, " Gets the source image associated with this {@code RasterDataNode}.\n\n @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\n         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n @see #createSourceImage()\n @see #isSourceImageSet()\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setSourceImage2", BeamPyTiePointGrid_setSourceImage2, METH_VARARGS, " Sets the source image associated with this {@code RasterDataNode}.\n\n \n@param this The TiePointGrid object.\n@param sourceImage The source image.\n                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\n @since BEAM 4.2\n"},
    {"TiePointGrid_setSourceImage1", BeamPyTiePointGrid_setSourceImage1, METH_VARARGS, " Sets the source image associated with this {@code RasterDataNode}.\n\n \n@param this The TiePointGrid object.\n@param sourceImage The source image.\n                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\n @since BEAM 4.6\n"},
    {"TiePointGrid_isGeophysicalImageSet", BeamPyTiePointGrid_isGeophysicalImageSet, METH_VARARGS, " Returns whether the geophysical image is set on this {@code RasterDataNode}.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return whether the geophysical image is set.\n @since BEAM 4.6\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeophysicalImage", BeamPyTiePointGrid_getGeophysicalImage, METH_VARARGS, " @return The geophysical source image.\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidMaskImageSet", BeamPyTiePointGrid_isValidMaskImageSet, METH_VARARGS, " Returns wether the valid mask image is set on this {@code RasterDataNode}.\n\n @return Wether the source image is set.\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getValidMaskImage", BeamPyTiePointGrid_getValidMaskImage, METH_VARARGS, " Gets the valid-mask image associated with this {@code RasterDataNode}.\n\n @return The rendered image.\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isStxSet", BeamPyTiePointGrid_isStxSet, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getStx1", BeamPyTiePointGrid_getStx1, METH_VARARGS, " Gets the statistics. If statistcs are not yet available,\n the method will compute (possibly inaccurate) statistics and return those.\n <p/>\n If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\n shall be used instead.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return The statistics.\n @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n @see #setStx(Stx)\n @since BEAM 4.2, revised in BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getStx2", BeamPyTiePointGrid_getStx2, METH_VARARGS, " Gets the statistics.\n If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The TiePointGrid object.\n@param accurate If true, accurate statistics are computed.\n @param pm       A progress monitor which is used to compute the new statistics, if required.\n @return The statistics.\n @since since BEAM 4.5\n"},
    {"TiePointGrid_setStx", BeamPyTiePointGrid_setStx, METH_VARARGS, " Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\n are really related to this {@code RasterDataNode}'s raster data.\n The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The TiePointGrid object.\n@param stx The statistics.\n @since BEAM 4.2, revised in BEAM 4.5\n"},
    {"TiePointGrid_getValidShape", BeamPyTiePointGrid_getValidShape, METH_VARARGS, " Gets the shape of the area where this raster data contains valid samples.\n The method returns <code>null</code>, if the entire raster contains valid samples.\n\n @return The shape of the area where the raster data has samples, can be {@code null}.\n @since BEAM 4.7\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRoiMaskGroup", BeamPyTiePointGrid_getRoiMaskGroup, METH_VARARGS, " @return The roi mask group.\n @deprecated since BEAM 4.10 (no replacement)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataType", BeamPyTiePointGrid_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getNumDataElems", BeamPyTiePointGrid_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setData", BeamPyTiePointGrid_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getData", BeamPyTiePointGrid_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setDataElems", BeamPyTiePointGrid_setDataElems, METH_VARARGS, " Sets the data elements of this data node.\n @deprecated since 5.0\n @see ProductData#setElems(Object)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataElems", BeamPyTiePointGrid_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataElemSize", BeamPyTiePointGrid_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setReadOnly", BeamPyTiePointGrid_setReadOnly, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_isReadOnly", BeamPyTiePointGrid_isReadOnly, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_setUnit", BeamPyTiePointGrid_setUnit, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getUnit", BeamPyTiePointGrid_getUnit, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_isSynthetic", BeamPyTiePointGrid_isSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setSynthetic", BeamPyTiePointGrid_setSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeDataChanged", BeamPyTiePointGrid_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRawStorageSize2", BeamPyTiePointGrid_getRawStorageSize2, METH_VARARGS, " Gets the estimated size in bytes of this product node.\n\n \n@param this The TiePointGrid object.\n@param subsetDef if not <code>null</code> the subset may limit the size returned\n @return the size in bytes.\n"},
    {"TiePointGrid_createCompatibleProductData", BeamPyTiePointGrid_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The TiePointGrid object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"TiePointGrid_getOwner", BeamPyTiePointGrid_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getName", BeamPyTiePointGrid_getName, METH_VARARGS, " @return This node's name.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setName", BeamPyTiePointGrid_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The TiePointGrid object.\n@param name The name.\n"},
    {"TiePointGrid_getDescription", BeamPyTiePointGrid_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setDescription", BeamPyTiePointGrid_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The TiePointGrid object.\n@param description a description, can be <code>null</code>\n"},
    {"TiePointGrid_isModified", BeamPyTiePointGrid_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_toString", BeamPyTiePointGrid_toString, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidNodeName", BeamPyTiePointGrid_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"TiePointGrid_getProduct", BeamPyTiePointGrid_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductReader", BeamPyTiePointGrid_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductWriter", BeamPyTiePointGrid_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDisplayName", BeamPyTiePointGrid_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductRefString", BeamPyTiePointGrid_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRawStorageSize1", BeamPyTiePointGrid_getRawStorageSize1, METH_VARARGS, " Gets an estimated, raw storage size in bytes of this product node.\n\n @return the size in bytes.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeChanged1", BeamPyTiePointGrid_fireProductNodeChanged1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeChanged2", BeamPyTiePointGrid_fireProductNodeChanged2, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_removeFromFile", BeamPyTiePointGrid_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The TiePointGrid object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"TiePointGrid_getExtension", BeamPyTiePointGrid_getExtension, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"AngularDirection_newAngularDirection", BeamPyAngularDirection_newAngularDirection, METH_VARARGS, ""},
    {"AngularDirection_equals", BeamPyAngularDirection_equals, METH_VARARGS, "\n@param this The AngularDirection object."},
    {"AngularDirection_toString", BeamPyAngularDirection_toString, METH_VARARGS, "\n@param this The AngularDirection object."},
    {"FlagCoding_newFlagCoding", BeamPyFlagCoding_newFlagCoding, METH_VARARGS, " Constructs a new flag coding object with the given name.\n\n @param name the name\n"},
    {"FlagCoding_getFlag", BeamPyFlagCoding_getFlag, METH_VARARGS, " Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to\n getPropertyValue(String).\n\n \n@param this The FlagCoding object.\n@param name the flag name\n @return a metadata attribute wich is the representation of the flag with the given name\n"},
    {"FlagCoding_getFlagNames", BeamPyFlagCoding_getFlagNames, METH_VARARGS, " Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.\n\n @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned\n\n@param this The FlagCoding object."},
    {"FlagCoding_addFlag", BeamPyFlagCoding_addFlag, METH_VARARGS, " Adds a new flag definition to this flags coding.\n\n \n@param this The FlagCoding object.\n@param name        the flag name\n @param flagMask    the flag's bit mask\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the flag.\n"},
    {"FlagCoding_getFlagMask", BeamPyFlagCoding_getFlagMask, METH_VARARGS, " Returns the flag mask value for the specified flag name.\n\n \n@param this The FlagCoding object.\n@param name the flag name\n @return flagMask the flag's bit mask as a 32 bit integer\n @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist\n"},
    {"FlagCoding_acceptVisitor", BeamPyFlagCoding_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The FlagCoding object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"FlagCoding_addElement", BeamPyFlagCoding_addElement, METH_VARARGS, " Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\n because flag codings do not support inner elements.\n\n \n@param this The FlagCoding object.\n@param element the element to be added, always ignored\n"},
    {"FlagCoding_addAttribute", BeamPyFlagCoding_addAttribute, METH_VARARGS, " Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n\n \n@param this The FlagCoding object.\n@param attribute the attribute to be added\n @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value\n"},
    {"FlagCoding_addSample", BeamPyFlagCoding_addSample, METH_VARARGS, " Adds a new coding value to this sample coding.\n\n \n@param this The FlagCoding object.\n@param name        the coding name\n @param value       the value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded sample.\n"},
    {"FlagCoding_getSampleCount", BeamPyFlagCoding_getSampleCount, METH_VARARGS, " Gets the number of coded sample values.\n\n @return the number of coded sample values\n\n@param this The FlagCoding object."},
    {"FlagCoding_getSampleName", BeamPyFlagCoding_getSampleName, METH_VARARGS, " Gets the sample name at the specified attribute index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index.\n @return the sample name.\n"},
    {"FlagCoding_getSampleValue", BeamPyFlagCoding_getSampleValue, METH_VARARGS, " Gets the sample value at the specified attribute index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index.\n @return the sample value.\n"},
    {"FlagCoding_getElementGroup", BeamPyFlagCoding_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n\n @return The child element group, may be null.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getParentElement", BeamPyFlagCoding_getParentElement, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_addElementAt", BeamPyFlagCoding_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The FlagCoding object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"FlagCoding_removeElement", BeamPyFlagCoding_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The FlagCoding object.\n@param element the element to be removed, ignored if <code>null</code>\n\n @return true, if so\n"},
    {"FlagCoding_getNumElements", BeamPyFlagCoding_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElementAt", BeamPyFlagCoding_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The FlagCoding object.\n@param index the element index\n\n @return the element at the given index\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"FlagCoding_getElementNames", BeamPyFlagCoding_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElements", BeamPyFlagCoding_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElement", BeamPyFlagCoding_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The FlagCoding object.\n@param name the element name\n\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"FlagCoding_containsElement", BeamPyFlagCoding_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The FlagCoding object.\n@param name the name, must not be <code>null</code>\n\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"FlagCoding_getElementIndex", BeamPyFlagCoding_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n\n \n@param this The FlagCoding object.\n@param element The element .\n\n @return The element's index, or -1.\n\n @since BEAM 4.7\n"},
    {"FlagCoding_removeAttribute", BeamPyFlagCoding_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The FlagCoding object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n\n @return <code>true</code> if it was removed\n"},
    {"FlagCoding_getNumAttributes", BeamPyFlagCoding_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttributeAt", BeamPyFlagCoding_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index\n\n @return the attribute, or <code>null</code> if this node does not contain attributes\n\n @throws IndexOutOfBoundsException\n"},
    {"FlagCoding_getAttributeNames", BeamPyFlagCoding_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttributes", BeamPyFlagCoding_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttribute", BeamPyFlagCoding_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The FlagCoding object.\n@param name the attribute name\n\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"FlagCoding_containsAttribute", BeamPyFlagCoding_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The FlagCoding object.\n@param name the attribute name\n\n @return <code>true</code> if so\n"},
    {"FlagCoding_getAttributeIndex", BeamPyFlagCoding_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n\n \n@param this The FlagCoding object.\n@param attribute The attribute.\n\n @return The attribute's index, or -1.\n\n @since BEAM 4.7\n"},
    {"FlagCoding_getAttributeDouble", BeamPyFlagCoding_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as double.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"FlagCoding_getAttributeUTC", BeamPyFlagCoding_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as UTC.\n"},
    {"FlagCoding_getAttributeInt", BeamPyFlagCoding_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"FlagCoding_setAttributeInt", BeamPyFlagCoding_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setAttributeDouble", BeamPyFlagCoding_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setAttributeUTC", BeamPyFlagCoding_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_getAttributeString", BeamPyFlagCoding_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n\n @return the attribute value as integer.\n"},
    {"FlagCoding_setAttributeString", BeamPyFlagCoding_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setModified", BeamPyFlagCoding_setModified, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_createDeepClone", BeamPyFlagCoding_createDeepClone, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_dispose", BeamPyFlagCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getOwner", BeamPyFlagCoding_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getName", BeamPyFlagCoding_getName, METH_VARARGS, " @return This node's name.\n\n@param this The FlagCoding object."},
    {"FlagCoding_setName", BeamPyFlagCoding_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The FlagCoding object.\n@param name The name.\n"},
    {"FlagCoding_getDescription", BeamPyFlagCoding_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The FlagCoding object."},
    {"FlagCoding_setDescription", BeamPyFlagCoding_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The FlagCoding object.\n@param description a description, can be <code>null</code>\n"},
    {"FlagCoding_isModified", BeamPyFlagCoding_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The FlagCoding object."},
    {"FlagCoding_toString", BeamPyFlagCoding_toString, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_isValidNodeName", BeamPyFlagCoding_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"FlagCoding_getProduct", BeamPyFlagCoding_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductReader", BeamPyFlagCoding_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductWriter", BeamPyFlagCoding_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The FlagCoding object."},
    {"FlagCoding_getDisplayName", BeamPyFlagCoding_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductRefString", BeamPyFlagCoding_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The FlagCoding object."},
    {"FlagCoding_updateExpression", BeamPyFlagCoding_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The FlagCoding object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"FlagCoding_removeFromFile", BeamPyFlagCoding_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The FlagCoding object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"FlagCoding_getExtension", BeamPyFlagCoding_getExtension, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"ProductReader_getReaderPlugIn", BeamPyProductReader_getReaderPlugIn, METH_VARARGS, " Returns the plug-in which created this product reader.\n\n @return the product reader plug-in, should never be <code>null</code>\n\n@param this The ProductReader object."},
    {"ProductReader_getInput", BeamPyProductReader_getInput, METH_VARARGS, " Retrives the current input destination object. Thie return value might be <code>null</code> if the\n <code>setInput</code> has not been called so far.\n\n@param this The ProductReader object."},
    {"ProductReader_getSubsetDef", BeamPyProductReader_getSubsetDef, METH_VARARGS, " Returns the subset information with which this a data product is read from its physical source.\n\n @return the subset information, can be <code>null</code>\n\n@param this The ProductReader object."},
    {"ProductReader_readProductNodes", BeamPyProductReader_readProductNodes, METH_VARARGS, " Reads a data product and returns a in-memory representation of it.\n <p/>\n <p> The given subset info can be used to specify spatial and spectral portions of the original proudct. If the\n subset is omitted, the complete product is read in.\n <p/>\n <p> Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,\n is up to the implementation.\n\n \n@param this The ProductReader object.\n@param input     an object representing a valid output for this product reader, might be a\n                  <code>ImageInputStream</code> or other <code>Object</code> to use for future decoding.\n @param subsetDef a spectral or spatial subset (or both) of the product. If <code>null</code>, the entire product\n                  is read in\n @throws IllegalArgumentException   if <code>input</code> is <code>null</code> or it's type is not one of the\n                                    supported input sources.\n @throws IOException                if an I/O error occurs\n @throws IllegalFileFormatException if the file format is illegal\n"},
    {"ProductReader_readBandRasterData", BeamPyProductReader_readBandRasterData, METH_VARARGS, " Reads raster data from the data source specified by the given destination band into the given in-memory buffer\n and region.\n <p/>\n <h3>Destination band</h3> The destination band is used to identify the data source from which this method\n transfers the sample values into the given destination buffer. The method does not modify the given destination\n band at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method\n should also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.\n <p/>\n <h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,\n <code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's\n raster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and\n sub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset\n and sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The\n destination region should always specify a sub-region of the band's scene raster.\n <p/>\n <h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given\n <code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are\n <b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *\n destHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies\n faster than the Y co-ordinate.\n\n \n@param this The ProductReader object.\n@param destBand    the destination band which identifies the data source from which to read the sample values\n @param destOffsetX the X-offset in the band's raster co-ordinates\n @param destOffsetY the Y-offset in the band's raster co-ordinates\n @param destWidth   the width of region to be read given in the band's raster co-ordinates\n @param destHeight  the height of region to be read given in the band's raster co-ordinates\n @param destBuffer  the destination buffer which receives the sample values to be read\n @throws IOException              if an I/O error occurs\n @throws IllegalArgumentException if the number of elements destination buffer not equals <code>destWidth *\n                                  destHeight</code> or the destination region is out of the band's scene raster\n @see org.esa.beam.framework.datamodel.Band#getSceneRasterWidth()\n @see org.esa.beam.framework.datamodel.Band#getSceneRasterHeight()\n"},
    {"ProductReader_close", BeamPyProductReader_close, METH_VARARGS, " Closes the access to all currently opened resources such as file input streams and all resources of this children\n directly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>close()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.close();</code> after disposing this instance.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductReader object."},
    {"RGBChannelDef_newRGBChannelDef", BeamPyRGBChannelDef_newRGBChannelDef, METH_VARARGS, ""},
    {"RGBChannelDef_getSourceName", BeamPyRGBChannelDef_getSourceName, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setSourceName", BeamPyRGBChannelDef_setSourceName, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getSourceNames", BeamPyRGBChannelDef_getSourceNames, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setSourceNames", BeamPyRGBChannelDef_setSourceNames, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_isAlphaUsed", BeamPyRGBChannelDef_isAlphaUsed, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_isGammaUsed", BeamPyRGBChannelDef_isGammaUsed, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getGamma", BeamPyRGBChannelDef_getGamma, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setGamma", BeamPyRGBChannelDef_setGamma, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getMinDisplaySample", BeamPyRGBChannelDef_getMinDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setMinDisplaySample", BeamPyRGBChannelDef_setMinDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getMaxDisplaySample", BeamPyRGBChannelDef_getMaxDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setMaxDisplaySample", BeamPyRGBChannelDef_setMaxDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_clone", BeamPyRGBChannelDef_clone, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"ProductData_createInstance1", BeamPyProductData_createInstance1, METH_VARARGS, " Factory method which creates a value instance of the given type and with exactly one element.\n\n @param type the value's type\n\n @return a new value instance, <code>null</code> if the given type is not known\n"},
    {"ProductData_createInstance2", BeamPyProductData_createInstance2, METH_VARARGS, " Factory method which creates a value instance of the given type and with the specified number of elements.\n\n @param type     the value's type\n @param numElems the number of elements, must be greater than zero if type is not {@link ProductData#TYPE_UTC}\n\n @return a new value instance, <code>null</code> if the given type is not known\n\n @throws IllegalArgumentException if one of the arguments is invalid\n"},
    {"ProductData_createInstance3", BeamPyProductData_createInstance3, METH_VARARGS, " Factory method which creates a value instance of the given type and with the specified number of elements.\n\n @param type the value's type\n @param data if <code>type</code> is <code>TYPE_ASCII</code> the <code>String</code>, otherwise the primitive array type corresponding to <code>type</code>\n\n @return a new value instance, <code>null</code> if the given type is not known\n\n @throws IllegalArgumentException if one of the arguments is invalid\n"},
    {"ProductData_createInstance5", BeamPyProductData_createInstance5, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance1", BeamPyProductData_createUnsignedInstance1, METH_VARARGS, ""},
    {"ProductData_createInstance10", BeamPyProductData_createInstance10, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance3", BeamPyProductData_createUnsignedInstance3, METH_VARARGS, ""},
    {"ProductData_createInstance8", BeamPyProductData_createInstance8, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance2", BeamPyProductData_createUnsignedInstance2, METH_VARARGS, ""},
    {"ProductData_createInstance9", BeamPyProductData_createInstance9, METH_VARARGS, ""},
    {"ProductData_createInstance4", BeamPyProductData_createInstance4, METH_VARARGS, ""},
    {"ProductData_createInstance7", BeamPyProductData_createInstance7, METH_VARARGS, ""},
    {"ProductData_createInstance6", BeamPyProductData_createInstance6, METH_VARARGS, ""},
    {"ProductData_getType1", BeamPyProductData_getType1, METH_VARARGS, " Returns this value's type ID.\n\n@param this The ProductData object."},
    {"ProductData_getElemSize2", BeamPyProductData_getElemSize2, METH_VARARGS, " Gets the element size of an element of the given type in bytes.\n\n @param type the element type\n\n @return the size of a single element in bytes.\n\n @throws IllegalArgumentException if the type is not supported.\n"},
    {"ProductData_getElemSize1", BeamPyProductData_getElemSize1, METH_VARARGS, " Gets the element size of an element of this product data in bytes.\n\n @return the size of a single element in bytes\n\n@param this The ProductData object."},
    {"ProductData_getTypeString2", BeamPyProductData_getTypeString2, METH_VARARGS, " Returns a textual representation of the given data type.\n\n @return a data type string, <code>null</code> if the type is unknown\n"},
    {"ProductData_getType2", BeamPyProductData_getType2, METH_VARARGS, " Returns a integer representation of the given data type string.\n\n @return a data type integer, <code>null</code> if the type is unknown\n"},
    {"ProductData_getTypeString1", BeamPyProductData_getTypeString1, METH_VARARGS, " Returns this value's data type String.\n\n@param this The ProductData object."},
    {"ProductData_isInt", BeamPyProductData_isInt, METH_VARARGS, " Tests whether this value has an integer.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isIntType", BeamPyProductData_isIntType, METH_VARARGS, " Tests whether the given value type is a signed or unsigned integer type.\n\n @return true, if so\n"},
    {"ProductData_isSigned", BeamPyProductData_isSigned, METH_VARARGS, " Tests whether the actual instance is an signed data type.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isUnsigned", BeamPyProductData_isUnsigned, METH_VARARGS, " Tests whether the actual instance is an unsigned data type.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isUIntType", BeamPyProductData_isUIntType, METH_VARARGS, " Tests whether the given value type is an unsigned integer type.\n\n @return true, if so\n"},
    {"ProductData_isFloatingPointType", BeamPyProductData_isFloatingPointType, METH_VARARGS, " Tests whether the given value type is a floating point type.\n\n @return true, if so\n"},
    {"ProductData_isScalar", BeamPyProductData_isScalar, METH_VARARGS, " Tests if this value is a scalar.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_getNumElems", BeamPyProductData_getNumElems, METH_VARARGS, " Returns the number of data elements this value has.\n\n@param this The ProductData object."},
    {"ProductData_getElemInt", BeamPyProductData_getElemInt, METH_VARARGS, " Returns the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply\n returns <code>getElemIntAt(0)</code>.\n\n @see #getElemIntAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemUInt", BeamPyProductData_getElemUInt, METH_VARARGS, " Returns the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this\n value is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.\n\n @see #getElemUIntAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemFloat", BeamPyProductData_getElemFloat, METH_VARARGS, " Returns the value as an <code>float</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemFloatAt(0)</code>.\n\n @see #getElemFloatAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemDouble", BeamPyProductData_getElemDouble, METH_VARARGS, " Returns the value as an <code>double</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemDoubleAt(0)</code>.\n\n @see #getElemDoubleAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemString", BeamPyProductData_getElemString, METH_VARARGS, " Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained\n in this value.\n\n @return a text representing this fields value, never <code>null</code>\n\n@param this The ProductData object."},
    {"ProductData_getElemBoolean", BeamPyProductData_getElemBoolean, METH_VARARGS, " Returns the value as an <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemBooleanAt(0)</code>.\n\n @see #getElemBooleanAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemIntAt", BeamPyProductData_getElemIntAt, METH_VARARGS, " Gets the value element with the given index as an <code>int</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemUIntAt", BeamPyProductData_getElemUIntAt, METH_VARARGS, " Gets the value element with the given index as a <code>long</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemFloatAt", BeamPyProductData_getElemFloatAt, METH_VARARGS, " Gets the value element with the given index as a <code>float</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemDoubleAt", BeamPyProductData_getElemDoubleAt, METH_VARARGS, " Gets the value element with the given index as a <code>double</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemStringAt", BeamPyProductData_getElemStringAt, METH_VARARGS, " Gets the value element with the given index as a <code>String</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemBooleanAt", BeamPyProductData_getElemBooleanAt, METH_VARARGS, " Gets the value element with the given index as a <code>boolean</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemInt", BeamPyProductData_setElemInt, METH_VARARGS, " Sets the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemInt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemIntAt(int index, int value)\n"},
    {"ProductData_setElemUInt", BeamPyProductData_setElemUInt, METH_VARARGS, " Sets the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this\n value is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemUIntAt(int index, long value)\n"},
    {"ProductData_setElemFloat", BeamPyProductData_setElemFloat, METH_VARARGS, " Sets the value as a <code>float</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemFloatAt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemFloatAt(int index, float value)\n"},
    {"ProductData_setElemDouble", BeamPyProductData_setElemDouble, METH_VARARGS, " Sets the value as a <code>double</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemDoubleAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemDoubleAt(int index, double value)\n"},
    {"ProductData_setElemString", BeamPyProductData_setElemString, METH_VARARGS, " Sets the value as a <code>String</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemStringAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemStringAt\n"},
    {"ProductData_setElemBoolean", BeamPyProductData_setElemBoolean, METH_VARARGS, " Sets the value as a <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemDoubleAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemBooleanAt(int index, boolean value)\n"},
    {"ProductData_setElemIntAt", BeamPyProductData_setElemIntAt, METH_VARARGS, " Sets the value at the specified index as an <code>int</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemUIntAt", BeamPyProductData_setElemUIntAt, METH_VARARGS, " Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemFloatAt", BeamPyProductData_setElemFloatAt, METH_VARARGS, " Sets the value at the specified index as a <code>float</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemDoubleAt", BeamPyProductData_setElemDoubleAt, METH_VARARGS, " Sets the value at the specified index as a <code>double</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemStringAt", BeamPyProductData_setElemStringAt, METH_VARARGS, " Sets the value at the specified index as a <code>String</code>.\n <p/>\n <p><i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemBooleanAt", BeamPyProductData_setElemBooleanAt, METH_VARARGS, " Sets the value at the specified index as a <code>boolean</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElems", BeamPyProductData_getElems, METH_VARARGS, " Returns the internal value. The actual type of the returned object should only be one of <ol>\n <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\n signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\n fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\n for signed 64-bit floating point fields</li> </ol>\n\n @return an array of one of the described types\n\n@param this The ProductData object."},
    {"ProductData_setElems", BeamPyProductData_setElems, METH_VARARGS, " Sets the internal value. The actual type of the given data object should only be one of <ol>\n <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\n signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\n fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\n for signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>\n\n \n@param this The ProductData object.\n@param data an array of one of the described types\n"},
    {"ProductData_readFrom4", BeamPyProductData_readFrom4, METH_VARARGS, " Reads all elements of this <code>ProductData</code> instance from to the given input stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position\n within the input stream.\n\n \n@param this The ProductData object.\n@param input a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom3", BeamPyProductData_readFrom3, METH_VARARGS, " Reads a single element of this <code>ProductData</code> instance from to the given output stream.\n <p/>\n <p> The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given\n output stream.<br> Reading starts at the current seek position within the output stream.\n\n \n@param this The ProductData object.\n@param pos   the destination position (zero-based)\n @param input a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom1", BeamPyProductData_readFrom1, METH_VARARGS, " Reads elements of this <code>ProductData</code> instance from the given output stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\n this <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek\n position of the input stream.\n\n \n@param this The ProductData object.\n@param startPos the destination start position (zero-based)\n @param numElems the number of elements to read\n @param input    a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom2", BeamPyProductData_readFrom2, METH_VARARGS, " Reads elements into this <code>ProductData</code> instance from the given input stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\n this <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>\n within the output stream. The method multiplies this position with the value returned by\n <code>getElemSize()</code> in order to find the correct stream offset in bytes.\n\n \n@param this The ProductData object.\n@param startPos the destination start position (zero-based)\n @param numElems the number of elements to read\n @param input    a seekable data input stream\n @param inputPos the (zero-based) position in the data output stream where reading starts\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo4", BeamPyProductData_writeTo4, METH_VARARGS, " Writes all elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position\n within the output stream.\n\n \n@param this The ProductData object.\n@param output a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo3", BeamPyProductData_writeTo3, METH_VARARGS, " Writes a single element of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given\n output stream.<br> Writing starts at the current seek position within the output stream.\n\n \n@param this The ProductData object.\n@param pos    the source position (zero-based)\n @param output a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo1", BeamPyProductData_writeTo1, METH_VARARGS, " Writes elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\n of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek\n position within the output stream.\n\n \n@param this The ProductData object.\n@param startPos the source start position (zero-based)\n @param numElems the number of elements to be written\n @param output   a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo2", BeamPyProductData_writeTo2, METH_VARARGS, " Writes elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\n of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at\n <code>outputPos</code> within the output stream. The method multiplies this position with the value returned by\n <code>getElemSize()</code> in order to find the correct stream offset in bytes.\n\n \n@param this The ProductData object.\n@param startPos  the source start position (zero-based)\n @param numElems  the number of elements to be written\n @param output    a seekable data output stream\n @param outputPos the position in the data output stream where writing starts\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_toString", BeamPyProductData_toString, METH_VARARGS, " Returns a string representation of this value which can be used for debugging purposes.\n\n@param this The ProductData object."},
    {"ProductData_hashCode", BeamPyProductData_hashCode, METH_VARARGS, " Returns {@link Object#hashCode()}.\n\n@param this The ProductData object."},
    {"ProductData_equals", BeamPyProductData_equals, METH_VARARGS, " Returns {@link Object#equals(Object)}.\n Use {@link #equalElems} in order to perform an element-wise comparision.\n\n@param this The ProductData object."},
    {"ProductData_equalElems", BeamPyProductData_equalElems, METH_VARARGS, " Tests whether this ProductData is equal to another one.\n Performs an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.\n Otherwise the method behaves like {@link Object#equals(Object)}.\n\n \n@param this The ProductData object.\n@param other the other one\n"},
    {"ProductData_dispose", BeamPyProductData_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\n@param this The ProductData object."},
    {"GeoPos_newGeoPos", BeamPyGeoPos_newGeoPos, METH_VARARGS, " Constructs a new geo-position with the given latitude and longitude values.\n\n @param lat the geographical latitude in decimal degree, valid range is -90 to +90\n @param lon the geographical longitude in decimal degree, valid range is -180 to +180\n"},
    {"GeoPos_getLat", BeamPyGeoPos_getLat, METH_VARARGS, " Gets the latitude value.\n\n @return the geographical latitude in decimal degree\n\n@param this The GeoPos object."},
    {"GeoPos_getLon", BeamPyGeoPos_getLon, METH_VARARGS, " Gets the longitude value.\n\n @return the geographical longitude in decimal degree\n\n@param this The GeoPos object."},
    {"GeoPos_setLocation", BeamPyGeoPos_setLocation, METH_VARARGS, " Sets the geographical location of this point.\n\n \n@param this The GeoPos object.\n@param lat the geographical latitude in decimal degree, valid range is -90 to +90\n @param lon the geographical longitude in decimal degree, valid range is -180 to +180\n"},
    {"GeoPos_isValid", BeamPyGeoPos_isValid, METH_VARARGS, " Tests whether or not this geo-position is valid.\n\n @return true, if so\n\n@param this The GeoPos object."},
    {"GeoPos_areValid", BeamPyGeoPos_areValid, METH_VARARGS, " Tests whether or not all given geo-positions are valid.\n\n @return true, if so\n"},
    {"GeoPos_setInvalid", BeamPyGeoPos_setInvalid, METH_VARARGS, " Sets the lat/lon fields so that {@link #isValid()} will return false.\n\n@param this The GeoPos object."},
    {"GeoPos_equals", BeamPyGeoPos_equals, METH_VARARGS, " Indicates whether some other object is \"equal to\" this one.\n\n \n@param this The GeoPos object.\n@param obj the reference object with which to compare.\n\n @return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.\n"},
    {"GeoPos_hashCode", BeamPyGeoPos_hashCode, METH_VARARGS, " Returns a hash code value for the object.\n\n @return a hash code value for this object.\n\n@param this The GeoPos object."},
    {"GeoPos_toString", BeamPyGeoPos_toString, METH_VARARGS, " Returns a string representation of the object. In general, the <code>toString</code> method returns a string that\n \"textually represents\" this object.\n\n @return a string representation of the object.\n\n@param this The GeoPos object."},
    {"GeoPos_normalize", BeamPyGeoPos_normalize, METH_VARARGS, " Normalizes this position so that its longitude is in the range -180 to +180 degree.\n\n@param this The GeoPos object."},
    {"GeoPos_normalizeLon", BeamPyGeoPos_normalizeLon, METH_VARARGS, " Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.\n Note that -180 will remain as is, although -180 is equivalent to +180 degrees.\n\n @param lon the longitude in degree\n\n @return the normalized longitude in the range\n"},
    {"GeoPos_getLatString", BeamPyGeoPos_getLatString, METH_VARARGS, " Returns a string representation of the latitude value.\n\n @return a string of the form DDD°[MM'[SS\"]] [N|S].\n\n@param this The GeoPos object."},
    {"GeoPos_getLonString", BeamPyGeoPos_getLonString, METH_VARARGS, " Returns a string representation of the latitude value.\n\n @return a string of the form DDD°[MM'[SS\"]] [W|E].\n\n@param this The GeoPos object."},
    {"ProductNodeGroup_newProductNodeGroup", BeamPyProductNodeGroup_newProductNodeGroup, METH_VARARGS, " Constructs a node group with no owner and which will not take ownership of added children.\n\n @param name The group name.\n @since BEAM 4.8\n"},
    {"ProductNodeGroup_isTakingOverNodeOwnership", BeamPyProductNodeGroup_isTakingOverNodeOwnership, METH_VARARGS, " @return {@code true}, if child nodes will have this group as owner after adding.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getNodeCount", BeamPyProductNodeGroup_getNodeCount, METH_VARARGS, " @return The number of product nodes in this product group.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getAt", BeamPyProductNodeGroup_getAt, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param index The node index.\n @return The product node at the given index.\n"},
    {"ProductNodeGroup_getNodeDisplayNames", BeamPyProductNodeGroup_getNodeDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n @see ProductNode#getDisplayName()\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getNodeNames", BeamPyProductNodeGroup_getNodeNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_indexOfName", BeamPyProductNodeGroup_indexOfName, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_indexOf", BeamPyProductNodeGroup_indexOf, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getByDisplayName", BeamPyProductNodeGroup_getByDisplayName, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param displayName the display name\n @return the product node with the given display name.\n"},
    {"ProductNodeGroup_get", BeamPyProductNodeGroup_get, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param name the name\n @return the product node with the given name.\n"},
    {"ProductNodeGroup_containsName", BeamPyProductNodeGroup_containsName, METH_VARARGS, " Tests whether a node with the given name is contained in this group.\n\n \n@param this The ProductNodeGroup object.\n@param name the name\n @return true, if so\n"},
    {"ProductNodeGroup_contains", BeamPyProductNodeGroup_contains, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The ProductNodeGroup object.\n@param node the node\n @return true, if so\n"},
    {"ProductNodeGroup_add", BeamPyProductNodeGroup_add, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The ProductNodeGroup object.\n@param node the node to be added, ignored if <code>null</code>\n @return true, if the node has been added\n"},
    {"ProductNodeGroup_addAt", BeamPyProductNodeGroup_addAt, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The ProductNodeGroup object.\n@param index the index.\n @param node  the node to be added, ignored if <code>null</code>\n"},
    {"ProductNodeGroup_remove", BeamPyProductNodeGroup_remove, METH_VARARGS, " Removes the given node from this group.\n\n \n@param this The ProductNodeGroup object.\n@param node the node to be removed\n @return true, if the node was removed\n"},
    {"ProductNodeGroup_removeAll", BeamPyProductNodeGroup_removeAll, METH_VARARGS, " Removes all nodes from this group.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_clearRemovedList", BeamPyProductNodeGroup_clearRemovedList, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getRemovedNodes", BeamPyProductNodeGroup_getRemovedNodes, METH_VARARGS, " Gets all removed node nodes.\n\n @return a collection of all removed node nodes.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setModified", BeamPyProductNodeGroup_setModified, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_acceptVisitor", BeamPyProductNodeGroup_acceptVisitor, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_dispose", BeamPyProductNodeGroup_dispose, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_updateExpression", BeamPyProductNodeGroup_updateExpression, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getOwner", BeamPyProductNodeGroup_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getName", BeamPyProductNodeGroup_getName, METH_VARARGS, " @return This node's name.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setName", BeamPyProductNodeGroup_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The ProductNodeGroup object.\n@param name The name.\n"},
    {"ProductNodeGroup_getDescription", BeamPyProductNodeGroup_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setDescription", BeamPyProductNodeGroup_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The ProductNodeGroup object.\n@param description a description, can be <code>null</code>\n"},
    {"ProductNodeGroup_isModified", BeamPyProductNodeGroup_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_toString", BeamPyProductNodeGroup_toString, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_isValidNodeName", BeamPyProductNodeGroup_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"ProductNodeGroup_getProduct", BeamPyProductNodeGroup_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductReader", BeamPyProductNodeGroup_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductWriter", BeamPyProductNodeGroup_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getDisplayName", BeamPyProductNodeGroup_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductRefString", BeamPyProductNodeGroup_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_removeFromFile", BeamPyProductNodeGroup_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The ProductNodeGroup object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"ProductNodeGroup_getExtension", BeamPyProductNodeGroup_getExtension, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductUtils_newProductUtils", BeamPyProductUtils_newProductUtils, METH_VARARGS, ""},
    {"ProductUtils_createImageInfo", BeamPyProductUtils_createImageInfo, METH_VARARGS, " Creates image creation information.\n\n @param rasters                 The raster data nodes.\n @param assignMissingImageInfos if {@code true}, it is ensured that to all {@code RasterDataNode}s a valid {@code ImageInfo} will be assigned.\n @param pm                      The progress monitor.\n\n @return image information\n\n @throws IOException if an I/O error occurs\n @since BEAM 4.2\n"},
    {"ProductUtils_createRgbImage", BeamPyProductUtils_createRgbImage, METH_VARARGS, " Creates a RGB image from the given array of <code>{@link RasterDataNode}</code>s.\n The given array <code>rasters</code> containing one or three raster data nodes. If three rasters are given\n RGB image is created, if only one raster is provided a gray scale image created.\n\n @param rasters   an array of one or three raster nodes.\n @param imageInfo the image info provides the information how to create the image\n @param pm        a monitor to inform the user about progress\n\n @return the created image\n\n @throws IOException if the given raster data is not loaded and reload causes an I/O error\n @see RasterDataNode#setImageInfo(org.esa.beam.framework.datamodel.ImageInfo)\n"},
    {"ProductUtils_createColorIndexedImage", BeamPyProductUtils_createColorIndexedImage, METH_VARARGS, " Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.\n <p/>\n <p>The method uses the given raster data node's image information (an instance of <code>{@link\n ImageInfo}</code>) to create the image.\n\n @param rasterDataNode the raster data node, must not be <code>null</code>\n @param pm             a monitor to inform the user about progress\n\n @return the color indexed image\n\n @throws IOException if the given raster data is not loaded and reload causes an I/O error\n @see org.esa.beam.framework.datamodel.RasterDataNode#getImageInfo()\n"},
    {"ProductUtils_createSuitableMapInfo1", BeamPyProductUtils_createSuitableMapInfo1, METH_VARARGS, " Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\n subset of the product's scene region for the given map projection. The position of the reference pixel will be\n the upper left pixel's center (0.5, 0.5).\n\n @param product       the product, must not be <code>null</code>\n @param rect          the rectangle in pixel coordinates of the product, if <code>null</code> the entire region is\n                      considered\n @param mapProjection the map projection, must not be <code>null</code>\n\n @return the map information instance\n"},
    {"ProductUtils_createSuitableMapInfo2", BeamPyProductUtils_createSuitableMapInfo2, METH_VARARGS, " Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\n subset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.\n\n @param product       the product, must not be <code>null</code>\n @param mapProjection the map projection, must not be <code>null</code>\n @param orientation   the orientation angle\n @param noDataValue   the no-data value to be used\n\n @return the map information instance\n"},
    {"ProductUtils_getOutputRasterSize", BeamPyProductUtils_getOutputRasterSize, METH_VARARGS, ""},
    {"ProductUtils_createMapEnvelope2", BeamPyProductUtils_createMapEnvelope2, METH_VARARGS, " Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)\n and the given map transfromation. The method delegates to {@link #createMapEnvelope(org.esa.beam.framework.datamodel.Product,\n java.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,\n step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene raster width and\n height.\n\n @param product      The product.\n @param rect         The rectangle in pixel coordinates.\n @param mapTransform The map transformation.\n\n @return The boundary in map coordinates for the given product.\n"},
    {"ProductUtils_createMapEnvelope1", BeamPyProductUtils_createMapEnvelope1, METH_VARARGS, " Creates the boundary in map coordinates for the given product, source rectangle (in product\n pixel coordinates) and the given map transfromation. The method delegates to\n {@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,\n step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene\n raster width and height.\n\n @param product      The product.\n @param rect         The rectangle in pixel coordinates.\n @param step         The step size in pixels.\n @param mapTransform The map transformation.\n\n @return The boundary in map coordinates for the given product.\n"},
    {"ProductUtils_getMinMax", BeamPyProductUtils_getMinMax, METH_VARARGS, ""},
    {"ProductUtils_createMapBoundary", BeamPyProductUtils_createMapBoundary, METH_VARARGS, ""},
    {"ProductUtils_createGeoBoundary1", BeamPyProductUtils_createGeoBoundary1, METH_VARARGS, " Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.\n\n @param product the input product, must not be null\n @param step    the step given in pixels\n\n @return an array of geographical coordinates\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n"},
    {"ProductUtils_createGeoBoundary2", BeamPyProductUtils_createGeoBoundary2, METH_VARARGS, " Creates the geographical boundary of the given region within the given product and returns it as a list of\n geographical coordinates.\n <p> This method delegates to {@link #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param product the input product, must not be null\n @param region  the region rectangle in product pixel coordinates, can be null for entire product\n @param step    the step given in pixels\n\n @return an array of geographical coordinates\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundary3", BeamPyProductUtils_createGeoBoundary3, METH_VARARGS, " Creates the geographical boundary of the given region within the given product and returns it as a list of\n geographical coordinates.\n\n @param product        the input product, must not be null\n @param region         the region rectangle in product pixel coordinates, can be null for entire product\n @param step           the step given in pixels\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n\n @return an array of geographical coordinates\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)\n"},
    {"ProductUtils_getClosestGeoPos", BeamPyProductUtils_getClosestGeoPos, METH_VARARGS, " Searches for a valid GeoPos by considering the vicinity of a {@link PixelPos}. It does not check\n the original pixel position, but uses it for determining which pixel positions to examine.\n\n @param gc      the GeoCoding, must not be null\n @param origPos the original pixel position, must not be null\n @param region  the rectangle which determines the valid pixel positions, must not be null\n @param step    determines the step size between pixels which is used in the search process. Small step\n                sizes will increase the accuracy, but need more computational time\n\n @return a {@link GeoPos}. This will be valid if the search was successful. If not, a {@link GeoPos} with\n         NaN-values for latitude and longitude will be returned.\n"},
    {"ProductUtils_createGeoBoundary4", BeamPyProductUtils_createGeoBoundary4, METH_VARARGS, " Creates the geographical boundary of the given region within the given raster and returns it as a list of\n geographical coordinates.\n\n @param raster the input raster, must not be null\n @param region the region rectangle in raster pixel coordinates, can be null for entire raster\n @param step   the step given in pixels\n\n @return an array of geographical coordinates\n\n @throws IllegalArgumentException if raster is null or if the raster has no {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths1", BeamPyProductUtils_createGeoBoundaryPaths1, METH_VARARGS, " Converts the geographic boundary entire product into one, two or three shape objects. If the product does not\n intersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created\n and returned in the order from west to east.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product the input product\n\n @return an array of shape objects\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths2", BeamPyProductUtils_createGeoBoundaryPaths2, METH_VARARGS, " Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\n the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\n shapes are created and returned in the order from west to east.\n <p/>\n This method delegates to {@link #createGeoBoundaryPaths(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}\n and the additional parameter <code>usePixelCenter</code> is <code>true</code>.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product the input product\n @param region  the region rectangle in product pixel coordinates, can be null for entire product\n @param step    the step given in pixels\n\n @return an array of shape objects\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths3", BeamPyProductUtils_createGeoBoundaryPaths3, METH_VARARGS, " Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\n the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\n shapes are created and returned in the order from west to east.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product        the input product\n @param region         the region rectangle in product pixel coordinates, can be null for entire product\n @param step           the step given in pixels\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the pathes\n\n @return an array of shape objects\n\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)\n"},
    {"ProductUtils_createPixelBoundary1", BeamPyProductUtils_createPixelBoundary1, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p> This method delegates to {@link #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param product the product\n @param rect    the source rectangle\n @param step    the mean distance from one pixel position to the other in the returned array\n\n @return the rectangular boundary\n"},
    {"ProductUtils_createPixelBoundary2", BeamPyProductUtils_createPixelBoundary2, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n\n @param product        the product\n @param rect           the source rectangle\n @param step           the mean distance from one pixel position to the other in the returned array\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n\n @return the rectangular boundary\n"},
    {"ProductUtils_createPixelBoundary3", BeamPyProductUtils_createPixelBoundary3, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a raster boundary expressed in geographical\n co-ordinates.\n\n @param raster the raster\n @param rect   the source rectangle\n @param step   the mean distance from one pixel position to the other in the returned array\n\n @return the rectangular boundary\n"},
    {"ProductUtils_createRectBoundary1", BeamPyProductUtils_createRectBoundary1, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p> This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param rect the source rectangle\n @param step the mean distance from one pixel position to the other in the returned array\n\n @return the rectangular boundary\n"},
    {"ProductUtils_createRectBoundary2", BeamPyProductUtils_createRectBoundary2, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p/>\n\n @param rect           the source rectangle\n @param step           the mean distance from one pixel position to the other in the returned array\n @param usePixelCenter <code>true</code> if the pixel center should be used\n\n @return the rectangular boundary\n"},
    {"ProductUtils_copyFlagCodings", BeamPyProductUtils_copyFlagCodings, METH_VARARGS, " Copies the flag codings from the source product to the target.\n\n @param source the source product\n @param target the target product\n"},
    {"ProductUtils_copyFlagCoding", BeamPyProductUtils_copyFlagCoding, METH_VARARGS, " Copies the given source flag coding to the target product.\n If it exists already, the method simply returns the existing instance.\n\n @param sourceFlagCoding the source flag coding\n @param target           the target product\n\n @return The flag coding.\n"},
    {"ProductUtils_copyIndexCoding", BeamPyProductUtils_copyIndexCoding, METH_VARARGS, " Copies the given source index coding to the target product\n If it exists already, the method simply returns the existing instance.\n\n @param sourceIndexCoding the source index coding\n @param target            the target product\n\n @return The index coding.\n"},
    {"ProductUtils_copyMasks", BeamPyProductUtils_copyMasks, METH_VARARGS, " Copies the {@link Mask}s from the source product to the target product.\n <p/>\n IMPORTANT NOTE: This method should only be used, if it is known that all masks\n in the source product will also be valid in the target product. This method does\n <em>not</em> copy overlay masks from the source bands to the target bands. Also\n note that a source mask is not copied to the target product, when there already\n is a mask in the target product with the same name as the source mask.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyOverlayMasks", BeamPyProductUtils_copyOverlayMasks, METH_VARARGS, " Copies the overlay {@link Mask}s from the source product's raster data nodes to\n the target product's raster data nodes.\n <p/>\n IMPORTANT NOTE: This method should only be used, if it is known that all masks\n in the source product will also be valid in the target product. This method does\n <em>not</em> copy overlay masks, which are not contained in the target product's\n mask group.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyRoiMasks", BeamPyProductUtils_copyRoiMasks, METH_VARARGS, " Copies the ROI {@link Mask}s from the source product's raster data nodes to\n the target product's raster data nodes.\n <p/>\n IMPORTANT NOTE: This method should only be used, if it is known that all masks\n in the source product will also be valid in the target product. This method does\n <em>not</em> copy ROI masks, which are not contained in the target product's\n mask group.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n\n @deprecated since BEAM 4.10 (no replacement)\n"},
    {"ProductUtils_copyFlagBands2", BeamPyProductUtils_copyFlagBands2, METH_VARARGS, " Copies all bands which contain a flagcoding from the source product to the target product.\n\n @param sourceProduct   the source product\n @param targetProduct   the target product\n @param copySourceImage whether the source image of the source band should be copied.\n\n @since BEAM 4.10\n"},
    {"ProductUtils_copyFlagBands1", BeamPyProductUtils_copyFlagBands1, METH_VARARGS, " Copies all bands which contain a flagcoding from the source product to the target product.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n\n @deprecated since BEAM 4.10, use {@link #copyFlagBands(Product, Product, boolean)} instead.\n"},
    {"ProductUtils_copyTiePointGrid", BeamPyProductUtils_copyTiePointGrid, METH_VARARGS, " Copies the named tie-point grid from the source product to the target product.\n\n @param gridName      the name of the tie-point grid to be copied.\n @param sourceProduct the source product\n @param targetProduct the target product\n\n @return the copied tie-point grid, or <code>null</code> if the sourceProduct does not contain a tie-point grid with the given name.\n"},
    {"ProductUtils_copyBand4", BeamPyProductUtils_copyBand4, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName  the name of the band to be copied.\n @param sourceProduct   the source product.\n @param targetProduct   the target product.\n @param copySourceImage whether the source image of the source band should be copied.\n\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n\n @since BEAM 4.10\n"},
    {"ProductUtils_copyBand2", BeamPyProductUtils_copyBand2, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName  the name of the band to be copied.\n @param sourceProduct   the source product.\n @param targetBandName  the name of the band copied.\n @param targetProduct   the target product.\n @param copySourceImage whether the source image of the source band should be copied.\n\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n\n @since BEAM 4.10\n"},
    {"ProductUtils_copyRasterDataNodeProperties", BeamPyProductUtils_copyRasterDataNodeProperties, METH_VARARGS, " Copies all properties from source band to the target band.\n\n @param sourceRaster the source band\n @param targetRaster the target band\n\n @see #copySpectralBandProperties(org.esa.beam.framework.datamodel.Band, org.esa.beam.framework.datamodel.Band)\n"},
    {"ProductUtils_copyBand3", BeamPyProductUtils_copyBand3, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName the name of the band to be copied.\n @param sourceProduct  the source product.\n @param targetProduct  the target product.\n\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n\n @deprecated since BEAM 4.10, use {@link #copyBand(String, Product, Product, boolean)} instead.\n"},
    {"ProductUtils_copyBand1", BeamPyProductUtils_copyBand1, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName the name of the band to be copied.\n @param sourceProduct  the source product.\n @param targetBandName the name of the band copied.\n @param targetProduct  the target product.\n\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n\n @deprecated since BEAM 4.10, use {@link #copyBand(String, Product, String, Product, boolean)} instead.\n"},
    {"ProductUtils_copySpectralBandProperties", BeamPyProductUtils_copySpectralBandProperties, METH_VARARGS, " Copies the spectral properties from source band to target band. These properties are:\n <ul>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandIndex() spectral band index},</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralWavelength() the central wavelength},</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandwidth() the spectral bandwidth} and</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSolarFlux() the solar spectral flux}.</li>\n </ul>\n\n @param sourceBand the source band\n @param targetBand the target band\n\n @see #copyRasterDataNodeProperties(org.esa.beam.framework.datamodel.RasterDataNode, org.esa.beam.framework.datamodel.RasterDataNode)\n"},
    {"ProductUtils_copyGeoCoding", BeamPyProductUtils_copyGeoCoding, METH_VARARGS, " Copies the geocoding from the source product to target product.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n\n @throws IllegalArgumentException if one of the params is <code>null</code>.\n"},
    {"ProductUtils_copyTiePointGrids", BeamPyProductUtils_copyTiePointGrids, METH_VARARGS, " Copies all tie point grids from one product to another.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyVectorData", BeamPyProductUtils_copyVectorData, METH_VARARGS, ""},
    {"ProductUtils_canGetPixelPos1", BeamPyProductUtils_canGetPixelPos1, METH_VARARGS, " Returns whether or not a product can return a pixel position from a given geographical position.\n\n @param product the product to be checked\n\n @return <code>true</code> if the given product can return a pixel position\n"},
    {"ProductUtils_canGetPixelPos2", BeamPyProductUtils_canGetPixelPos2, METH_VARARGS, " Returns whether or not a raster can return a pixel position from a given geographical position.\n\n @param raster the raster to be checked\n\n @return <code>true</code> if the given raster can return a pixel position\n"},
    {"ProductUtils_createDensityPlotImage", BeamPyProductUtils_createDensityPlotImage, METH_VARARGS, " Creates a density plot image from two raster data nodes.\n\n @param raster1    the first raster data node\n @param sampleMin1 the minimum sample value to be considered in the first raster\n @param sampleMax1 the maximum sample value to be considered in the first raster\n @param raster2    the second raster data node\n @param sampleMin2 the minimum sample value to be considered in the second raster\n @param sampleMax2 the maximum sample value to be considered in the second raster\n @param roiMask    an optional mask to be used as a ROI for the computation\n @param width      the width of the output image\n @param height     the height of the output image\n @param background the background color of the output image\n @param image      an image to be used as output image, if <code>null</code> a new image is created\n @param pm         the progress monitor\n\n @return the density plot image\n\n @throws java.io.IOException when an error occurred.\n"},
    {"ProductUtils_overlayMasks", BeamPyProductUtils_overlayMasks, METH_VARARGS, " Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.\n\n @param raster     the raster data node which contains all the activated bitmask definitions\n @param overlayBIm the source image which is used as base image for all the overlays.\n @param pm         a monitor to inform the user about progress\n\n @return the modified given overlayBImm which contains all the activated masks.\n\n @see RasterDataNode#getOverlayMaskGroup()\n"},
    {"ProductUtils_getCenterGeoPos", BeamPyProductUtils_getCenterGeoPos, METH_VARARGS, ""},
    {"ProductUtils_normalizeGeoPolygon", BeamPyProductUtils_normalizeGeoPolygon, METH_VARARGS, " Normalizes the given geographical polygon so that maximum longitude differences between two points are 180\n degrees. The method operates only on the longitude values of the given polygon.\n\n @param polygon a geographical, closed polygon\n\n @return 0 if normalizing has not been applied , -1 if negative normalizing has been applied, 1 if positive\n         normalizing has been applied, 2 if positive and negative normalising has been applied\n\n @see #denormalizeGeoPolygon(GeoPos[])\n"},
    {"ProductUtils_normalizeGeoPolygon_old", BeamPyProductUtils_normalizeGeoPolygon_old, METH_VARARGS, ""},
    {"ProductUtils_denormalizeGeoPolygon", BeamPyProductUtils_denormalizeGeoPolygon, METH_VARARGS, " Denormalizes the longitude values which have been normalized using the\n {@link #normalizeGeoPolygon(org.esa.beam.framework.datamodel.GeoPos[])} method. The\n method operates only on the longitude values of the given polygon.\n\n @param polygon a geographical, closed polygon\n"},
    {"ProductUtils_denormalizeGeoPos", BeamPyProductUtils_denormalizeGeoPos, METH_VARARGS, ""},
    {"ProductUtils_denormalizeGeoPos_old", BeamPyProductUtils_denormalizeGeoPos_old, METH_VARARGS, ""},
    {"ProductUtils_getRotationDirection", BeamPyProductUtils_getRotationDirection, METH_VARARGS, ""},
    {"ProductUtils_getAngleSum", BeamPyProductUtils_getAngleSum, METH_VARARGS, ""},
    {"ProductUtils_convertToPixelPath", BeamPyProductUtils_convertToPixelPath, METH_VARARGS, " Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in\n pixel coordinates using the supplied geo coding.\n\n @param geoPath   a <code>GeneralPath</code> given in geographic lon/lat coordinates, as returned by the {@link\n                  #convertToGeoPath(Shape, GeoCoding)} method\n @param geoCoding the geocoding used to convert the geographic coordinates into pixel coordinates.\n\n @return a <code>GeneralPath</code> given in pixel coordinates.\n\n @throws IllegalArgumentException if one of the given parameter is null.\n @throws IllegalStateException    if the given geoPath is not a geo referenced <code>GeneralPath</code> wich\n                                  contains only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n @see #convertToGeoPath(Shape, GeoCoding)\n"},
    {"ProductUtils_convertToGeoPath", BeamPyProductUtils_convertToGeoPath, METH_VARARGS, " Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic\n coordinates using the supplied geo coding.\n\n @param shape     a <code>Shape</code> given in pixel X/Y coordinates\n @param geoCoding the geo coding used to convert the pixel coordinates into geografic coordinates.\n\n @return a <code>GeneralPath</code> given in geografic coordinates\n\n @throws IllegalArgumentException if one of the given parameter is <code>null</code> or the given geo coding can\n                                  not get geografic coordinates.\n @throws IllegalStateException    if this method was used with a java runtime version in which it is not guaranted\n                                  that a <code>PathIterator</code> returned by {@link Shape#getPathIterator(java.awt.geom.AffineTransform,\n                                  double)} returnes only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n @see GeoCoding#canGetGeoPos()\n"},
    {"ProductUtils_copyMetadata2", BeamPyProductUtils_copyMetadata2, METH_VARARGS, " Copies all metadata elements and attributes of the source product to the target product.\n The copied elements and attributes are deeply cloned.\n\n @param source the source product.\n @param target the target product.\n\n @throws NullPointerException if the source or the target product is {@code null}.\n"},
    {"ProductUtils_copyMetadata1", BeamPyProductUtils_copyMetadata1, METH_VARARGS, " Copies all metadata elements and attributes of the source element to the target element.\n The copied elements and attributes are deeply cloned.\n\n @param source the source element.\n @param target the target element.\n\n @throws NullPointerException if the source or the target element is {@code null}.\n"},
    {"ProductUtils_copyPreferredTileSize", BeamPyProductUtils_copyPreferredTileSize, METH_VARARGS, " Copies the source product's preferred tile size (if any) to the target product.\n\n @param sourceProduct The source product.\n @param targetProduct The target product.\n"},
    {"ProductUtils_createGeoTIFFMetadata2", BeamPyProductUtils_createGeoTIFFMetadata2, METH_VARARGS, ""},
    {"ProductUtils_createGeoTIFFMetadata1", BeamPyProductUtils_createGeoTIFFMetadata1, METH_VARARGS, ""},
    {"ProductUtils_areaToPath", BeamPyProductUtils_areaToPath, METH_VARARGS, ""},
    {"ProductUtils_addElementToHistory", BeamPyProductUtils_addElementToHistory, METH_VARARGS, " Adds a given elem to the history of the given product. If the products metadata root\n does not contain a history entry a new one will be created.\n\n @param product the product to add the history element.\n @param elem    the element to add to the products history. If <code>null</code> nothing will be added.\n"},
    {"ProductUtils_removeInvalidExpressions", BeamPyProductUtils_removeInvalidExpressions, METH_VARARGS, " Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given\n product, the related element is removed.\n\n @param product the (output) product to be cleaned up\n\n @return an array of messages which changes are done to the given product.\n"},
    {"ProductUtils_findSuitableQuicklookBandName", BeamPyProductUtils_findSuitableQuicklookBandName, METH_VARARGS, " Finds the name of a band in the given product which is suitable to product a good quicklook.\n The method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.\n\n @param product the product to be searched\n\n @return the name of a suitable band or null if the given product does not contain any bands\n"},
    {"ProductUtils_computeSourcePixelCoordinates", BeamPyProductUtils_computeSourcePixelCoordinates, METH_VARARGS, ""},
    {"ProductUtils_computeMinMaxY", BeamPyProductUtils_computeMinMaxY, METH_VARARGS, " Computes the minimum and maximum y value of the given {@link PixelPos} array.\n\n @param pixelPositions the {@link PixelPos} array\n\n @return an int array which containes the minimum and maximum y value of the given {@link PixelPos} array in the\n         order:<br> &nbsp;&nbsp;&nbsp;&nbsp;[0] - the minimum value<br>&nbsp;&nbsp;&nbsp;&nbsp;[1] - the maximum\n         value<br><br>or <code>null</code> if no minimum or maximum can be retrieved because there given array is\n         empty.\n\n @throws IllegalArgumentException if the given pixelPositions are <code>null</code>.\n"},
    {"ProductUtils_copyBandsForGeomTransform1", BeamPyProductUtils_copyBandsForGeomTransform1, METH_VARARGS, " Copies only the bands from source to target.\n\n @see #copyBandsForGeomTransform(org.esa.beam.framework.datamodel.Product, org.esa.beam.framework.datamodel.Product, boolean, double, java.util.Map)\n"},
    {"ProductUtils_copyBandsForGeomTransform2", BeamPyProductUtils_copyBandsForGeomTransform2, METH_VARARGS, " Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target\n product is a geometric transformation (e.g. map-projection) of the source product.\n <p>If\n {@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,\n this method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},\n regardless which raw data type the source band has.\n In this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}\n will always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}\n will always be 0.0 and\n {@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.\n This ensures that source pixel resampling methods operating on floating point\n data can be stored without loss in accuracy in the target band.\n <p/>\n <p>Furthermore, the\n {@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}\n and {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}\n properties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},\n will be either the one from the source band, if any, or otherwise the one passed into this method.\n\n @param sourceProduct        the source product as the source for the band specifications. Must be not\n                             <code>null</code>.\n @param targetProduct        the destination product to receive the bands created. Must be not <code>null</code>.\n @param includeTiePointGrids if {@code true}, tie-point grids of source product will be included as bands in target product\n @param defaultNoDataValue   the default, geophysical no-data value to be used if no no-data value is used by the source band.\n @param targetToSourceMap    a mapping from a target band to a source raster data node, can be {@code null}\n"},
    {"ProductUtils_getScanLineTime", BeamPyProductUtils_getScanLineTime, METH_VARARGS, ""},
    {"ProductUtils_getGeophysicalSampleDouble", BeamPyProductUtils_getGeophysicalSampleDouble, METH_VARARGS, ""},
    {"ProductUtils_getGeophysicalSampleLong", BeamPyProductUtils_getGeophysicalSampleLong, METH_VARARGS, ""},
    {"MetadataAttribute_newMetadataAttribute", BeamPyMetadataAttribute_newMetadataAttribute, METH_VARARGS, ""},
    {"MetadataAttribute_getParentElement", BeamPyMetadataAttribute_getParentElement, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_equals", BeamPyMetadataAttribute_equals, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_acceptVisitor", BeamPyMetadataAttribute_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The MetadataAttribute object.\n@param visitor the visitor\n"},
    {"MetadataAttribute_createDeepClone", BeamPyMetadataAttribute_createDeepClone, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataType", BeamPyMetadataAttribute_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isFloatingPointType", BeamPyMetadataAttribute_isFloatingPointType, METH_VARARGS, " Tests whether the data type of this node is a floating point type.\n\n @return true, if so\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getNumDataElems", BeamPyMetadataAttribute_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setData", BeamPyMetadataAttribute_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getData", BeamPyMetadataAttribute_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setDataElems", BeamPyMetadataAttribute_setDataElems, METH_VARARGS, " Sets the data elements of this data node.\n @deprecated since 5.0\n @see ProductData#setElems(Object)\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataElems", BeamPyMetadataAttribute_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataElemSize", BeamPyMetadataAttribute_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setReadOnly", BeamPyMetadataAttribute_setReadOnly, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isReadOnly", BeamPyMetadataAttribute_isReadOnly, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setUnit", BeamPyMetadataAttribute_setUnit, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getUnit", BeamPyMetadataAttribute_getUnit, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isSynthetic", BeamPyMetadataAttribute_isSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setSynthetic", BeamPyMetadataAttribute_setSynthetic, METH_VARARGS, " @deprecated since BEAM 4.10 (not used, no replacement)\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_fireProductNodeDataChanged", BeamPyMetadataAttribute_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_dispose", BeamPyMetadataAttribute_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_createCompatibleProductData", BeamPyMetadataAttribute_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The MetadataAttribute object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"MetadataAttribute_getOwner", BeamPyMetadataAttribute_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getName", BeamPyMetadataAttribute_getName, METH_VARARGS, " @return This node's name.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setName", BeamPyMetadataAttribute_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The MetadataAttribute object.\n@param name The name.\n"},
    {"MetadataAttribute_getDescription", BeamPyMetadataAttribute_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setDescription", BeamPyMetadataAttribute_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The MetadataAttribute object.\n@param description a description, can be <code>null</code>\n"},
    {"MetadataAttribute_isModified", BeamPyMetadataAttribute_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setModified", BeamPyMetadataAttribute_setModified, METH_VARARGS, " Sets this node's modified flag.\n <p/>\n If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\n true.\n\n \n@param this The MetadataAttribute object.\n@param modified whether or not this node is beeing marked as modified.\n @see org.esa.beam.framework.datamodel.Product#fireNodeChanged\n"},
    {"MetadataAttribute_toString", BeamPyMetadataAttribute_toString, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isValidNodeName", BeamPyMetadataAttribute_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"MetadataAttribute_getProduct", BeamPyMetadataAttribute_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductReader", BeamPyMetadataAttribute_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductWriter", BeamPyMetadataAttribute_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDisplayName", BeamPyMetadataAttribute_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductRefString", BeamPyMetadataAttribute_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_updateExpression", BeamPyMetadataAttribute_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The MetadataAttribute object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"MetadataAttribute_removeFromFile", BeamPyMetadataAttribute_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The MetadataAttribute object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"MetadataAttribute_getExtension", BeamPyMetadataAttribute_getExtension, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"Object_delete", BeamPyObject_delete, METH_VARARGS, "Deletes global references to Java objects held by Python objects"},
    {"String_newString", BeamPyString_newString, METH_VARARGS, "Converts a Python unicode string into a Java java.lang.String object"},
    {NULL, NULL, 0, NULL}  /* Sentinel */
};

/* java.lang classes. */
jclass classBoolean;
jclass classByte;
jclass classCharacter;
jclass classShort;
jclass classInteger;
jclass classLong;
jclass classFloat;
jclass classDouble;
jclass classString;

/* java.util classes. */
jclass classHashMap;
jclass classHashSet;

/* API classes. */
jclass classGeoCoding;
jclass classProductWriter;
jclass classGPF;
jclass classIndexCoding;
jclass classPixelPos;
jclass classProductIO;
jclass classPlacemark;
jclass classMetadataElement;
jclass classProduct;
jclass classColorPaletteDef;
jclass classImageInfo;
jclass classProductManager;
jclass classImageGeometry;
jclass classBand;
jclass classPlacemarkGroup;
jclass classTiePointGrid;
jclass classAngularDirection;
jclass classFlagCoding;
jclass classProductReader;
jclass classRGBChannelDef;
jclass classProductData;
jclass classGeoPos;
jclass classProductNodeGroup;
jclass classProductUtils;
jclass classMetadataAttribute;

/* Used non-API classes. */
jclass classProgressMonitor;
jclass classMultiLevelImage;
jclass classParser;
jclass classTerm;
jclass classWritableNamespace;
jclass classColor;
jclass classDimension;
jclass classRectangle;
jclass classRenderingHints;
jclass classRenderingHints_Key;
jclass classShape;
jclass classAffineTransform;
jclass classArea;
jclass classGeneralPath;
jclass classPoint2D;
jclass classRectangle2D;
jclass classBufferedImage;
jclass classComponentColorModel;
jclass classIndexColorModel;
jclass classRenderedImage;
jclass classFile;
jclass classClass;
jclass classObject;
jclass classCollection;
jclass classIterator;
jclass classMap;
jclass classImageInputStream;
jclass classImageOutputStream;
jclass classROI;
jclass classProductReaderPlugIn;
jclass classProductSubsetDef;
jclass classProductWriterPlugIn;
jclass classBitmaskDef;
jclass classColorPaletteDef_Point;
jclass classImageInfo_HistogramMatching;
jclass classMask;
jclass classPlacemarkDescriptor;
jclass classPointing;
jclass classPointingFactory;
jclass classProduct_AutoGrouping;
jclass classProductData_UTC;
jclass classProductManager_Listener;
jclass classProductNode;
jclass classProductNodeListener;
jclass classProductVisitor;
jclass classRasterDataNode;
jclass classSampleCoding;
jclass classScaling;
jclass classStx;
jclass classTransectProfileData;
jclass classVectorDataNode;
jclass classDatum;
jclass classMapInfo;
jclass classMapProjection;
jclass classMapTransform;
jclass classOperator;
jclass classOperatorSpiRegistry;
jclass classBitRaster;
jclass classGeoTIFFMetadata;
jclass classHistogram;
jclass classIndexValidator;
jclass classSimpleFeature;
jclass classSimpleFeatureType;
jclass classCoordinateReferenceSystem;
jclass classMathTransform;


// <<<<<<<< Begin include from PyCModuleGenerator-stub-buffer.c

PyObject* beampy_getPrimitiveArrayBuffer(PyObject* obj, Py_buffer* view, int flags, const char* format, int len)
{
    if (obj == NULL || obj == Py_None) {
        if (len <= 0) {
            PyErr_SetString(PyExc_ValueError, "no buffer length specified");
            return NULL;
        }
        obj = CArray_createFromLength(format, len);
        if (obj == NULL) {
            PyErr_SetString(PyExc_MemoryError, "out of memory");
            return NULL;
        }
    }

    if (PyObject_CheckBuffer(obj)) {
        if (PyObject_GetBuffer(obj, view, flags) == 0) {
            if (view->ndim <= 1 && (len < 0 || view->len / view->itemsize >= len)) {
                Py_INCREF(obj);
                return obj;
            } else {
                //printf("ndim=%d, len=%d, itemsize=%d, expected len=%d\n", view->ndim, view->len, view->itemsize, len);
                PyBuffer_Release(view);
                PyErr_SetString(PyExc_ValueError, "illegal buffer configuration");
                return NULL;
            }
        }  else {
            PyErr_SetString(PyExc_TypeError, "failed to access buffer");
            return NULL;
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "buffer type expected");
        return NULL;
    }
}

PyObject* beampy_getPrimitiveArrayBufferReadOnly(PyObject* obj, Py_buffer* view, const char* format, int len)
{
    return beampy_getPrimitiveArrayBuffer(obj, view, PyBUF_SIMPLE, format, len);
}


PyObject* beampy_getPrimitiveArrayBufferWritable(PyObject* obj, Py_buffer* view, const char* format, int len)
{
    return beampy_getPrimitiveArrayBuffer(obj, view, PyBUF_WRITABLE, format, len);
}
// >>>>>>>> End include from PyCModuleGenerator-stub-buffer.c

// <<<<<<<< Begin include from PyCModuleGenerator-stub-jobject.c
/**
 * Represents an instance of the BeamPy_JObjectType class.
 * Used to represent Java JNI objects.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
typedef struct {
    PyObject_HEAD
    /** The pointer to the Java object obtained from JNI. */
    void* jobjectId;
} BeamPyJObject;

/**
 * Implements the __init__() method of the BeamPy_JObjectType class.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
static int BeamPyJObject_init(BeamPyJObject* self, PyObject* args, PyObject* kwds)
{
    printf("BeamPyJObject_init\n");
    self->jobjectId = PyLong_AsVoidPtr(args);
    return self->jobjectId != NULL ? 0 : 1;
}

/**
 * Implements the dealloc() method of the BeamPy_JObjectType class.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
static void BeamPyJObject_dealloc(BeamPyJObject* self)
{
    printf("BeamPyJObject_dealloc\n");
    Object_delete(self->jobjectId);
    self->jobjectId = NULL;
}

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
static PyTypeObject BeamPyJObject_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.JObject",         /* tp_name */
    sizeof (BeamPyJObject),       /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)BeamPyJObject_dealloc, /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "BEAM Java Object",           /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    NULL,                         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc)BeamPyJObject_init, /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

/**
 * The BEAM/Python API module definition structure.
 * The variable 'BeamPy_Methods' is defined in the generated file 'beampy_module.c'.
 */
static struct PyModuleDef BeamPy_Module =
{
   PyModuleDef_HEAD_INIT,
   "_beampy",           /* Name of the Python module */
   "Native BEAM/Python API",  /* Module documentation */
   -1,                 /* Size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
   BeamPy_Methods      /* Structure containing all BEAM/Python API functions */
};

/**
 * Called by the Python interpreter once immediately after the shared lib _beampy.pyk has been loaded.
 */
PyMODINIT_FUNC PyInit__beampy()
{
    PyObject* beampy_module;

    fprintf(stdout, "beampy: enter PyInit__beampy()\n");

    /////////////////////////////////////////////////////////////////////////
    // Create BeamPy_Module

    beampy_module = PyModule_Create(&BeamPy_Module);
    if (beampy_module == NULL) {
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Register CArray_Type / CArray_module

    // In some forum I (nf) found one should use: CArray_type.tp_new = PyType_GenericNew;
    if (PyType_Ready(&CArray_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&CArray_Type);
    PyModule_AddObject(beampy_module, "CArray", (PyObject*) &CArray_Type);
   

    /////////////////////////////////////////////////////////////////////////
    // Register BeamPyJObject_Type ('JObject')
    //
    if (PyType_Ready(&BeamPyJObject_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&BeamPyJObject_Type);
    PyModule_AddObject(beampy_module, "JObject", (PyObject*) &BeamPyJObject_Type);

    // todo - use the new BeamPy_JObjectType object instead of the currently used (sK) tuples. (nf, 29.04.2013)
    // // JObject instances shall be created using the following pattern:
    // PyObject* arg = PyLong_FromVoidPtr(ptr); // ptr is the JNI Java object
    // PyObject* obj = PyObject_Call(BeamPy_JObjectType, arg, NULL);
    // Py_DECREF(arg);
    //
    // todo - in BeamPyJObject_init use the following pattern:  (nf, 29.04.2013)
    // self->jobject = PyLong_AsVoidPtr(args);

    /////////////////////////////////////////////////////////////////////////
    // Define exception type BeamPy_Error ('beampy.error')

    BeamPy_Error = PyErr_NewException("beampy.error", NULL, NULL);
    Py_INCREF(BeamPy_Error);
    PyModule_AddObject(beampy_module, "error", BeamPy_Error);

    /////////////////////////////////////////////////////////////////////////
    // Create JVM

    if (!beam_createJvmWithDefaults()) {
        PyErr_SetString(BeamPy_Error, "Failed to create Java VM");
        return NULL;
    }

    fprintf(stdout, "beampy: exit PyInit__beampy()\n");

    return beampy_module;
}

/**
 * Factory method for Java string instances.
 *
 * In Python, call <code>beampy.String_newString('foobar')</code>
 * or <code>beampy.String.newString('foobar')</code>.
 */
PyObject* BeamPyString_newString(PyObject* self, PyObject* args)
{
    const char* str;
    void* result;

    if (!PyArg_ParseTuple(args, "s:newString", &str)) {
        return NULL;
    }

    result = String_newString(str);

    if (result != NULL) {
        return Py_BuildValue("(sK)", "String", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyObject_delete(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Object_delete", &thisObjType, &thisObj)) {
        return NULL;
    }
    Object_delete((void *) thisObj);
    return Py_BuildValue("");
}

// >>>>>>>> End include from PyCModuleGenerator-stub-jobject.c

// <<<<<<<< Begin include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.c

static JavaVM* jvm = NULL;
static JNIEnv* jenv = NULL;

/* Shared library callbacks (called if this module's code is linked into a shared library and loaded by a Java VM) */

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved)
{
    fprintf(stdout, "beampy: JNI_OnLoad() called\n");
    jvm = vm;
    (*jvm)->GetEnv(vm, &jenv, JNI_VERSION_1_6);
    return JNI_VERSION_1_6;
}

JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *vm, void *reserved)
{
    fprintf(stdout, "beampy: JNI_OnUnload() called\n");
    jvm = NULL;
    jenv = NULL;
}

/* Java VM functions that must be used if this module is used in stand-alone mode (= not loaded as shared library by a Java VM) */

boolean beam_isJvmCreated()
{
    return jvm != NULL;
}

boolean beam_createJvm(const char* option_strings[], int option_count)
{
    JavaVMInitArgs vm_args; 
    JavaVMOption* options;
    int res;

    if (jvm != NULL) {
        return JNI_TRUE;
    }

    fprintf(stdout, "beampy: creating Java VM using %d options\n", option_count);

    options = (JavaVMOption*) calloc(option_count, sizeof (JavaVMOption));
    {
        int i;
        for (i = 0; i < option_count; i++) {
            options[i].optionString = (char*) option_strings[i];
            fprintf(stdout, "beampy: option(%d) = \"%s\"\n", i, options[i].optionString);
        }
    }

    vm_args.version = JNI_VERSION_1_6;
    vm_args.options = options;
    vm_args.nOptions = option_count;
    vm_args.ignoreUnrecognized = 0;
    res = JNI_CreateJavaVM(&jvm, (void**) &jenv, &vm_args);

    free(options);

    if (res != 0) {
        fprintf(stderr, "beampy: JNI_CreateJavaVM failed with exit code %d\n", res);
        return JNI_FALSE;
    } else {
        fprintf(stdout, "beampy: Java VM successfully created\n");
    }

    return JNI_TRUE;
}

boolean beam_destroyJvm()
{
    jint res;

    if (jvm == NULL) {
        return JNI_TRUE;
    }
    
    res = (*jvm)->DestroyJavaVM(jvm);
    if (res != 0) {
        fprintf(stderr, "beampy: DestroyJavaVM failed with exit code %d\n", res);
        return JNI_FALSE;
    }

    jvm = NULL;
    jenv = NULL;
    return JNI_TRUE;
}

#ifdef WIN32
#define OS_FILESEP "\\"
#define OS_PATHSEP ";"
#else
#define OS_FILESEP "/"
#define OS_PATHSEP ":"
#endif

void beam_createJvmClassPathOptionHandler(const char* parent_dir, const char* file_name, int is_dir, void* user_data)
{
    char** class_path = (char**) user_data;

    if (strcmp(file_name, ".") == 0 || strcmp(file_name, "..") == 0) {
        return;
    }

    if (*class_path == NULL) {
        Util_appendString(class_path, "-Djava.class.path=");
    } else {
        Util_appendString(class_path, OS_PATHSEP);
    }

    Util_appendString(class_path, parent_dir);
    Util_appendString(class_path, OS_FILESEP);
    Util_appendString(class_path, file_name);
}

char* beam_createJvmClassPathOption()
{
    const char* beam_home;
    char* path;
    char* class_path;

    beam_home = getenv("BEAM_HOME");
    if (beam_home == NULL) {
        fprintf(stderr, "beampy: missing environment variable 'BEAM_HOME'\n");
        fprintf(stderr, "beampy: please make sure 'BEAM_HOME' points to a valid BEAM installation directory\n");
        return NULL;
    }

    class_path = NULL;

    path = NULL;
    Util_appendString(&path, beam_home);
    Util_appendString(&path, OS_FILESEP);
    Util_appendString(&path, "lib");
    Util_listDir(path, beam_createJvmClassPathOptionHandler, &class_path);
    free(path);

    path = NULL;
    Util_appendString(&path, beam_home);
    Util_appendString(&path, OS_FILESEP);
    Util_appendString(&path, "modules");
    Util_listDir(path, beam_createJvmClassPathOptionHandler, &class_path);
    free(path);

    return class_path;
}

#undef OS_FILESEP
#undef OS_PATHSEP

boolean beam_createJvmWithDefaults()
{
    const char* jvm_options[5];
    char* class_path_option;
    boolean result;

    class_path_option = beam_createJvmClassPathOption();
    if (class_path_option == NULL) {
        const char* beam_home = getenv("BEAM_HOME");
        fprintf(stderr, "beampy: failed to construct Java classpath\n");
        if (beam_home != NULL) {
            fprintf(stderr, "beampy: please make sure 'BEAM_HOME' points to a valid BEAM installation directory\n");
            fprintf(stderr, "beampy: currently BEAM_HOME = %s\n", beam_home);
        }
        return JNI_FALSE;
    }

    fprintf(stdout, "beampy: %s\n", class_path_option);

    jvm_options[0] = class_path_option;
    /*jvm_options[1] = "-Djava.library.path=c:\\mylibs";*/
    jvm_options[1] = "-Djava.awt.headless=true";
    jvm_options[2] = "-Xms128M";
    jvm_options[3] = "-Xmx512M";
    jvm_options[4] = "-verbose:jni";

    result = beam_createJvm(jvm_options, 5);

    free(class_path_option);

    return result;
}


jclass beam_findJvmClass(const char* classResourceName)
{
    jclass c = (*jenv)->FindClass(jenv, classResourceName);
    if (c == NULL) {
        fprintf(stderr, "beampy: Java class not found: %s\n", classResourceName);
    }
    return c;
}




String String_newString(const char* chars)
{
    jstring str = (*jenv)->NewStringUTF(jenv, chars);
    return (*jenv)->NewGlobalRef(jenv, str);
}

void Object_delete(Object object)
{
    if (object != NULL) {
        (*jenv)->DeleteGlobalRef(jenv, object);
    }
}

// >>>>>>>> End include from /org/esa/beam/extapi/gen/c/CModuleGenerator-stub-jvm.c

int beam_initApi()
{
    static int exitCode = -1;
    if (exitCode >= 0) {
        return exitCode;
    }

    if (!beam_isJvmCreated() && !beam_createJvmWithDefaults()) {
        exitCode = 1;
        return exitCode;
    }

    classBoolean = beam_findJvmClass("java/lang/Boolean");
    if (classBoolean == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Boolean\n");
        exitCode = 1000;
        return exitCode;
    }

    classByte = beam_findJvmClass("java/lang/Byte");
    if (classByte == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Byte\n");
        exitCode = 1001;
        return exitCode;
    }

    classCharacter = beam_findJvmClass("java/lang/Character");
    if (classCharacter == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Character\n");
        exitCode = 1002;
        return exitCode;
    }

    classShort = beam_findJvmClass("java/lang/Short");
    if (classShort == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Short\n");
        exitCode = 1003;
        return exitCode;
    }

    classInteger = beam_findJvmClass("java/lang/Integer");
    if (classInteger == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Integer\n");
        exitCode = 1004;
        return exitCode;
    }

    classLong = beam_findJvmClass("java/lang/Long");
    if (classLong == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Long\n");
        exitCode = 1005;
        return exitCode;
    }

    classFloat = beam_findJvmClass("java/lang/Float");
    if (classFloat == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Float\n");
        exitCode = 1006;
        return exitCode;
    }

    classDouble = beam_findJvmClass("java/lang/Double");
    if (classDouble == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/Double\n");
        exitCode = 1007;
        return exitCode;
    }

    classString = beam_findJvmClass("java/lang/String");
    if (classString == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/lang/String\n");
        exitCode = 1008;
        return exitCode;
    }

    classHashMap = beam_findJvmClass("java/util/HashMap");
    if (classHashMap == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/HashMap\n");
        exitCode = 1009;
        return exitCode;
    }

    classHashSet = beam_findJvmClass("java/util/HashSet");
    if (classHashSet == NULL) { 
        fprintf(stderr, "beampy: Java class not found: java/util/HashSet\n");
        exitCode = 1010;
        return exitCode;
    }

    classGeoCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/GeoCoding");
    if (classGeoCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/GeoCoding\n");
        exitCode = 2000;
        return exitCode;
    }

    classProductWriter = beam_findJvmClass("org/esa/beam/framework/dataio/ProductWriter");
    if (classProductWriter == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductWriter\n");
        exitCode = 2001;
        return exitCode;
    }

    classGPF = beam_findJvmClass("org/esa/beam/framework/gpf/GPF");
    if (classGPF == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/gpf/GPF\n");
        exitCode = 2002;
        return exitCode;
    }

    classIndexCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/IndexCoding");
    if (classIndexCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/IndexCoding\n");
        exitCode = 2003;
        return exitCode;
    }

    classPixelPos = beam_findJvmClass("org/esa/beam/framework/datamodel/PixelPos");
    if (classPixelPos == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/PixelPos\n");
        exitCode = 2004;
        return exitCode;
    }

    classProductIO = beam_findJvmClass("org/esa/beam/framework/dataio/ProductIO");
    if (classProductIO == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductIO\n");
        exitCode = 2005;
        return exitCode;
    }

    classPlacemark = beam_findJvmClass("org/esa/beam/framework/datamodel/Placemark");
    if (classPlacemark == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Placemark\n");
        exitCode = 2006;
        return exitCode;
    }

    classMetadataElement = beam_findJvmClass("org/esa/beam/framework/datamodel/MetadataElement");
    if (classMetadataElement == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/MetadataElement\n");
        exitCode = 2007;
        return exitCode;
    }

    classProduct = beam_findJvmClass("org/esa/beam/framework/datamodel/Product");
    if (classProduct == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Product\n");
        exitCode = 2008;
        return exitCode;
    }

    classColorPaletteDef = beam_findJvmClass("org/esa/beam/framework/datamodel/ColorPaletteDef");
    if (classColorPaletteDef == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ColorPaletteDef\n");
        exitCode = 2009;
        return exitCode;
    }

    classImageInfo = beam_findJvmClass("org/esa/beam/framework/datamodel/ImageInfo");
    if (classImageInfo == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ImageInfo\n");
        exitCode = 2010;
        return exitCode;
    }

    classProductManager = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductManager");
    if (classProductManager == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductManager\n");
        exitCode = 2011;
        return exitCode;
    }

    classImageGeometry = beam_findJvmClass("org/esa/beam/framework/datamodel/ImageGeometry");
    if (classImageGeometry == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ImageGeometry\n");
        exitCode = 2012;
        return exitCode;
    }

    classBand = beam_findJvmClass("org/esa/beam/framework/datamodel/Band");
    if (classBand == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/Band\n");
        exitCode = 2013;
        return exitCode;
    }

    classPlacemarkGroup = beam_findJvmClass("org/esa/beam/framework/datamodel/PlacemarkGroup");
    if (classPlacemarkGroup == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/PlacemarkGroup\n");
        exitCode = 2014;
        return exitCode;
    }

    classTiePointGrid = beam_findJvmClass("org/esa/beam/framework/datamodel/TiePointGrid");
    if (classTiePointGrid == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/TiePointGrid\n");
        exitCode = 2015;
        return exitCode;
    }

    classAngularDirection = beam_findJvmClass("org/esa/beam/framework/datamodel/AngularDirection");
    if (classAngularDirection == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/AngularDirection\n");
        exitCode = 2016;
        return exitCode;
    }

    classFlagCoding = beam_findJvmClass("org/esa/beam/framework/datamodel/FlagCoding");
    if (classFlagCoding == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/FlagCoding\n");
        exitCode = 2017;
        return exitCode;
    }

    classProductReader = beam_findJvmClass("org/esa/beam/framework/dataio/ProductReader");
    if (classProductReader == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/dataio/ProductReader\n");
        exitCode = 2018;
        return exitCode;
    }

    classRGBChannelDef = beam_findJvmClass("org/esa/beam/framework/datamodel/RGBChannelDef");
    if (classRGBChannelDef == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/RGBChannelDef\n");
        exitCode = 2019;
        return exitCode;
    }

    classProductData = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductData");
    if (classProductData == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductData\n");
        exitCode = 2020;
        return exitCode;
    }

    classGeoPos = beam_findJvmClass("org/esa/beam/framework/datamodel/GeoPos");
    if (classGeoPos == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/GeoPos\n");
        exitCode = 2021;
        return exitCode;
    }

    classProductNodeGroup = beam_findJvmClass("org/esa/beam/framework/datamodel/ProductNodeGroup");
    if (classProductNodeGroup == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/ProductNodeGroup\n");
        exitCode = 2022;
        return exitCode;
    }

    classProductUtils = beam_findJvmClass("org/esa/beam/util/ProductUtils");
    if (classProductUtils == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/util/ProductUtils\n");
        exitCode = 2023;
        return exitCode;
    }

    classMetadataAttribute = beam_findJvmClass("org/esa/beam/framework/datamodel/MetadataAttribute");
    if (classMetadataAttribute == NULL) { 
        fprintf(stderr, "beampy: Java class not found: org/esa/beam/framework/datamodel/MetadataAttribute\n");
        exitCode = 2024;
        return exitCode;
    }

    exitCode = 0;
    return exitCode;
}


// <<<<<<<< Begin include from PyCModuleGenerator-stub-init-method.c

boolean beampy_initApi()
{
    int errCode = beam_initApi();
    if (errCode != 0) {
        char msg[64];
        sprintf(msg, "beam_initApi() failed with error code %d", errCode);
        PyErr_SetString(BeamPy_Error, msg);
        return 0;
    }
    return 1;
}

boolean beampy_initJMethod(jmethodID* methodPtr, jclass cls, const char* className, const char* methodName, const char* methodSig, boolean isstatic)
{
    //printf("methodPtr=%p, *methodPtr=%p, cls=%p, className=%s, methodName=%s, methodSig=%s, isstatic=%d\n",
    //       methodPtr,*methodPtr, cls, className, methodName, methodSig, isstatic);

    if (*methodPtr == NULL) {
        if (isstatic) {
            *methodPtr = (*jenv)->GetStaticMethodID(jenv, cls, methodName, methodSig);
        } else {
            *methodPtr = (*jenv)->GetMethodID(jenv, cls, methodName, methodSig);
        }
        if (*methodPtr == NULL) {
            char msg[1024];
            sprintf(msg, "Java method not found: %s.%s%s", className, methodName, methodSig);
            PyErr_SetString(BeamPy_Error, msg);
            return 0;
        }
    }
    return 1;
}
// >>>>>>>> End include from PyCModuleGenerator-stub-init-method.c

// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Boolean
 *   typeLC =         boolean
 *   bufferFormat =   b
 *   itemToElemCall = (jboolean)(PyLong_AsLong(item) != 0)
 *   elemToItemCall = PyBool_FromLong(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJBooleanArrayFromBuffer(const jboolean* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewBooleanArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jboolean));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJBooleanArrayToBuffer(jarray arrayJObj, jboolean* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jboolean));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJBooleanArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("b", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJBooleanArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jboolean* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewBooleanArray(jenv, length);
    data = (jboolean*) malloc(size * sizeof (jboolean));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jboolean[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jboolean)(PyLong_AsLong(item) != 0);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Boolean
 *   typeLC =         boolean
 *   elemToItemCall = PyBool_FromLong(data[i])
 */
 /*
PyObject* beampy_newPyListFromJBooleanArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyBool_FromLong(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Char
 *   typeLC =         char
 *   bufferFormat =   h
 *   itemToElemCall = (jchar) PyLong_AsLong(item)
 *   elemToItemCall = PyUnicode_FromFormat("%c", data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJCharArrayFromBuffer(const jchar* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewCharArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jchar));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJCharArrayToBuffer(jarray arrayJObj, jchar* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jchar));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJCharArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("h", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJCharArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jchar* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewCharArray(jenv, length);
    data = (jchar*) malloc(size * sizeof (jchar));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jchar[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jchar) PyLong_AsLong(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Char
 *   typeLC =         char
 *   elemToItemCall = PyUnicode_FromFormat("%c", data[i])
 */
 /*
PyObject* beampy_newPyListFromJCharArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyUnicode_FromFormat("%c", data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Byte
 *   typeLC =         byte
 *   bufferFormat =   b
 *   itemToElemCall = (jbyte) PyLong_AsLong(item)
 *   elemToItemCall = PyLong_FromLong(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJByteArrayFromBuffer(const jbyte* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewByteArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jbyte));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJByteArrayToBuffer(jarray arrayJObj, jbyte* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jbyte));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJByteArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("b", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJByteArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jbyte* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewByteArray(jenv, length);
    data = (jbyte*) malloc(size * sizeof (jbyte));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jbyte[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jbyte) PyLong_AsLong(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Byte
 *   typeLC =         byte
 *   elemToItemCall = PyLong_FromLong(data[i])
 */
 /*
PyObject* beampy_newPyListFromJByteArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Short
 *   typeLC =         short
 *   bufferFormat =   h
 *   itemToElemCall = (jshort) PyLong_AsLong(item)
 *   elemToItemCall = PyLong_FromLong(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJShortArrayFromBuffer(const jshort* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewShortArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jshort));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJShortArrayToBuffer(jarray arrayJObj, jshort* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jshort));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJShortArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("h", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJShortArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jshort* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewShortArray(jenv, length);
    data = (jshort*) malloc(size * sizeof (jshort));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jshort[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jshort) PyLong_AsLong(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Short
 *   typeLC =         short
 *   elemToItemCall = PyLong_FromLong(data[i])
 */
 /*
PyObject* beampy_newPyListFromJShortArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Int
 *   typeLC =         int
 *   bufferFormat =   i
 *   itemToElemCall = (jint) PyLong_AsLong(item)
 *   elemToItemCall = PyLong_FromLong(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJIntArrayFromBuffer(const jint* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewIntArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jint));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJIntArrayToBuffer(jarray arrayJObj, jint* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jint));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJIntArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("i", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJIntArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jint* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewIntArray(jenv, length);
    data = (jint*) malloc(size * sizeof (jint));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jint[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jint) PyLong_AsLong(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Int
 *   typeLC =         int
 *   elemToItemCall = PyLong_FromLong(data[i])
 */
 /*
PyObject* beampy_newPyListFromJIntArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Long
 *   typeLC =         long
 *   bufferFormat =   l
 *   itemToElemCall = (jlong) PyLong_AsLongLong(item)
 *   elemToItemCall = PyLong_FromLongLong(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJLongArrayFromBuffer(const jlong* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewLongArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jlong));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJLongArrayToBuffer(jarray arrayJObj, jlong* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jlong));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJLongArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("l", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJLongArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jlong* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewLongArray(jenv, length);
    data = (jlong*) malloc(size * sizeof (jlong));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jlong[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jlong) PyLong_AsLongLong(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Long
 *   typeLC =         long
 *   elemToItemCall = PyLong_FromLongLong(data[i])
 */
 /*
PyObject* beampy_newPyListFromJLongArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLongLong(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Float
 *   typeLC =         float
 *   bufferFormat =   f
 *   itemToElemCall = (jfloat) PyFloat_AsDouble(item)
 *   elemToItemCall = PyFloat_FromDouble(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJFloatArrayFromBuffer(const jfloat* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewFloatArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jfloat));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJFloatArrayToBuffer(jarray arrayJObj, jfloat* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jfloat));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJFloatArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("f", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJFloatArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jfloat* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewFloatArray(jenv, length);
    data = (jfloat*) malloc(size * sizeof (jfloat));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jfloat[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jfloat) PyFloat_AsDouble(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Float
 *   typeLC =         float
 *   elemToItemCall = PyFloat_FromDouble(data[i])
 */
 /*
PyObject* beampy_newPyListFromJFloatArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyFloat_FromDouble(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c
// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv-primarr.c

/*
 * This template generates functions for converting Java primitive array to Python buffers and back.
 * Template parameters:
 *   typeUC =         Double
 *   typeLC =         double
 *   bufferFormat =   d
 *   itemToElemCall = (jdouble) PyFloat_AsDouble(item)
 *   elemToItemCall = PyFloat_FromDouble(data[i])
 */

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
jarray beampy_newJDoubleArrayFromBuffer(const jdouble* buffer, jint bufferLength)
{
    jarray arrayJObj;

    arrayJObj = (*jenv)->NewDoubleArray(jenv, bufferLength);
    if (arrayJObj != NULL) {
        void* addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
        if (addr != NULL) {
            memcpy(addr, buffer, bufferLength * sizeof (jdouble));
            (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
        }
    }

    return arrayJObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_copyJDoubleArrayToBuffer(jarray arrayJObj, jdouble* buffer, jint bufferLength, PyObject* bufferPyObj)
{
    void* addr;
    jsize n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    if (bufferLength < n) {
         PyErr_SetString(PyExc_ValueError, "array buffer too small");
         return NULL;
    }

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        memcpy(buffer, addr, bufferLength * sizeof (jdouble));
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    }

    return bufferPyObj;
}

// Used in /org/esa/beam/extapi/gen/py/PyCParameterGenerator.java, PrimitiveArray
PyObject* beampy_newPyObjectFromJDoubleArray(jarray arrayJObj)
{
    PyObject* bufferPyObj;
    void* addr;
    jsize arrayLength;

    arrayLength = (*jenv)->GetArrayLength(jenv, arrayJObj);

    addr = (*jenv)->GetPrimitiveArrayCritical(jenv, arrayJObj, NULL);
    if (addr != NULL) {
        bufferPyObj = CArray_createFromItems("d", addr, arrayLength, CArray_releaseElements);
        (*jenv)->ReleasePrimitiveArrayCritical(jenv, arrayJObj, addr, 0);
    } else {
        bufferPyObj = NULL;
    }

    return bufferPyObj;
}

// The following code is commented out because its uses Python lists to represent Java primitive arrays.
// We now use Python buffers to do so.
// However the code might be useful at a later stage.

 /*
jarray beampy_newJDoubleArrayFromPySeq(PyObject* seq, jint* length)
{
    jarray arrayJObj;
    Py_ssize_t size;
    jdouble* data;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewDoubleArray(jenv, length);
    data = (jdouble*) malloc(size * sizeof (jdouble));
    if (data == NULL) {
        char msg[256];
        sprintf(msg, "out of memory while allocating jdouble[%s]", size);
        PyErr_SetString(PyExc_MemoryError, msg);
        return NULL;
    }

    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        data[i] = (jdouble) PyFloat_AsDouble(item);
    }

    *length = (jint) size;
    return elems;
}
*/


/*
 * Creates a Python sequence (a list) from a C-array of primitive type ${typeName}.
 * Template parameters:
 *   typeUC =         Double
 *   typeLC =         double
 *   elemToItemCall = PyFloat_FromDouble(data[i])
 */
 /*
PyObject* beampy_newPyListFromJDoubleArray(jarray arrayJObj)
{
    jint length;
    PyObject* list;
    PyObject* item;
    jint i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyFloat_FromDouble(data[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
      return list;
  }
  */
// >>>>>>>> End include from PyCModuleGenerator-stub-conv-primarr.c

// <<<<<<<< Begin include from PyCModuleGenerator-stub-conv.c
///////////////////////////////////////////////
// Java String and String array
///////////////////////////////////////////////

PyObject* beampy_newPyStringFromJString(jstring strJObj)
{
    const char* utf8Chars;
    PyObject* strPyObj;

    utf8Chars = (*jenv)->GetStringUTFChars(jenv, strJObj, 0);
    strPyObj = PyUnicode_FromString(utf8Chars);
    (*jenv)->ReleaseStringUTFChars(jenv, strJObj, utf8Chars);

    return strPyObj;
}

/**
 * Returns a local reference to a String array.
 */
jstring beampy_newJStringFromPyObject(PyObject* anyPyObj)
{
    char* utf8Chars;
    PyObject* strPyObj;
    jstring strJObj;

    strPyObj = PyObject_Str(anyPyObj);
    if (strPyObj == NULL) {
        return NULL;
    }

    utf8Chars = PyUnicode_AsUTF8(strPyObj);
    strJObj = (*jenv)->NewStringUTF(jenv, utf8Chars);
    Py_DECREF(strPyObj);

    if (strJObj == NULL) {
        return NULL;
    }

    return strJObj;
}

PyObject* beampy_newPySeqFromJStringArray(jarray arrayJObj)
{
    PyObject* listPyObj;
    jsize i, n;

    n = (*jenv)->GetArrayLength(jenv, arrayJObj);
    listPyObj = PyList_New(n);
    if (listPyObj == NULL) {
        return NULL;
    }

    for (i = 0; i < n; i++) {
        jstring itemJObj = (jstring) (*jenv)->GetObjectArrayElement(jenv, arrayJObj, i);
        PyObject* itemPyObj = beampy_newPyStringFromJString(itemJObj);
        (*jenv)->DeleteLocalRef(jenv, itemJObj);
        if (itemPyObj == NULL) {
            Py_DECREF(listPyObj);
            return NULL;
        }
        if (PyList_SetItem(listPyObj, i, itemPyObj) != 0) {
            Py_DECREF(itemPyObj);
            Py_DECREF(listPyObj);
            return NULL;
        }
    }

    return listPyObj;
}

/**
 * Returns a local reference to a String array.
 */
jarray beampy_newJStringArrayFromPySeq(PyObject* seqPyObj)
{
    jarray arrayJObj;
    Py_ssize_t size;
    Py_ssize_t i;

    size = PySequence_Size(seqPyObj);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewObjectArray(jenv, (jsize) size, classString, NULL);

    for (i = 0; i < size; i++) {
        PyObject* itemPyObj = PySequence_GetItem(seqPyObj, i);
        if (itemPyObj == NULL) {
            (*jenv)->DeleteLocalRef(jenv, arrayJObj);
            return NULL;
        }
        if (itemPyObj != Py_None) {
            (*jenv)->SetObjectArrayElement(jenv, arrayJObj, (jint) i, beampy_newJStringFromPyObject(itemPyObj));
        } else {
            (*jenv)->SetObjectArrayElement(jenv, arrayJObj, (jint) i, NULL);
        }
    }

    return arrayJObj;
}



///////////////////////////////////////////////
// Java Object and Object array
///////////////////////////////////////////////

/**
 * Stores a global reference to a Java object
 */
PyObject* beampy_newPyObjectFromJObject(jobject anyJObj, const char* typeName)
{
    if (anyJObj != NULL) {
        jobject refJObj = (*jenv)->NewGlobalRef(jenv, anyJObj);
        return Py_BuildValue("(sK)", typeName, (unsigned PY_LONG_LONG) refJObj);
    } else {
        return Py_BuildValue("");
    }
}

jobject beampy_newJObjectFromPyObject(PyObject* anyPyObj, const char* typeName)
{
    if (PyTuple_Check(anyPyObj) && PyTuple_Size(anyPyObj) == 2) {
        PyObject* typePyObj = PyTuple_GetItem(anyPyObj, 0);
        PyObject* jobjPyObj = PyTuple_GetItem(anyPyObj, 1);
        const char* typeNameActual = PyUnicode_AsUTF8(typePyObj);
        // todo - using a more generic approach we would here use the Java type hierarchy to perform type-checking
        if (strcmp(typeName, "Object") == 0 || strcmp(typeName, typeNameActual) == 0) {
            return (jobject) PyLong_AsVoidPtr(jobjPyObj);
        } else {
            PyErr_SetString(PyExc_ValueError, "illegal object type");
            return NULL;
        }
    } else {
        // todo - using a more generic approach we would here try to convert the python object to a Java one
        PyErr_SetString(PyExc_ValueError, "tuple of length 2 expected");
        return NULL;
    }
}

PyObject* beampy_newPySeqFromJObjectArray(jarray arrJObj, const char* typeName)
{
    PyObject* listPyObj;
    jsize i, n;

    n = (*jenv)->GetArrayLength(jenv, arrJObj);
    listPyObj = PyList_New(n);
    if (listPyObj == NULL) {
        return NULL;
    }

    for (i = 0; i < n; i++) {
        jobject itemJObj = (*jenv)->GetObjectArrayElement(jenv, arrJObj, i);
        PyObject* itemPyObj = beampy_newPyObjectFromJObject(itemJObj, typeName);
        (*jenv)->DeleteLocalRef(jenv, itemJObj);
        if (itemPyObj == NULL) {
            Py_DECREF(listPyObj);
            return NULL;
        }
        if (PyList_SetItem(listPyObj, i, itemPyObj) != 0) {
            Py_DECREF(itemPyObj);
            Py_DECREF(listPyObj);
            return NULL;
        }
    }

    return listPyObj;
}

jarray beampy_newJObjectArrayFromPySeq(PyObject* seqPyObj, const char* typeName)
{
    jarray arrayJObj;
    Py_ssize_t size;
    Py_ssize_t i;

    size = PySequence_Size(seqPyObj);
    if (size < 0 || size >= (1 << 31)) {
        char msg[256];
        sprintf(msg, "invalid sequence size: %d", size);
        PyErr_SetString(PyExc_ValueError, msg);
        return NULL;
    }

    arrayJObj = (*jenv)->NewObjectArray(jenv, (jsize) size, classObject, NULL);

    for (i = 0; i < size; i++) {
        PyObject* itemPyObj = PySequence_GetItem(seqPyObj, i);
        if (itemPyObj == NULL) {
            (*jenv)->DeleteLocalRef(jenv, arrayJObj);
            return NULL;
        }
        if (itemPyObj != Py_None) {
            (*jenv)->SetObjectArrayElement(jenv, arrayJObj, (jint) i, beampy_newJObjectFromPyObject(itemPyObj, typeName));
        } else {
            (*jenv)->SetObjectArrayElement(jenv, arrayJObj, (jint) i, NULL);
        }
    }

    return arrayJObj;
}






///////////////////////////////////////////////
// Java Map
///////////////////////////////////////////////



/*
static jclass classBoolean = NULL;
static jclass classInteger = NULL;
static jclass classDouble = NULL;
static jclass classHashMap = NULL;
*/

static jmethodID _booleanConstr = NULL;
static jmethodID _integerConstr = NULL;
static jmethodID _doubleConstr = NULL;
static jmethodID _hashMapConstr = NULL;
static jmethodID _hashMapPutMethod = NULL;

boolean beampy_initJavaCoreVars() {
    static init = 0;
    if (init == 0) {
        init = 1;

        if (!beampy_initJMethod(&_booleanConstr, classBoolean, "java.lang.Boolean", "<init>", "(Z)V", 0)) {
            return 0;
        }
        if (!beampy_initJMethod(&_integerConstr, classInteger, "java.lang.Integer", "<init>", "(I)V", 0)) {
            return 0;
        }
        if (!beampy_initJMethod(&_doubleConstr, classDouble, "java.lang.Double", "<init>", "(D)V", 0)) {
            return 0;
        }
        if (!beampy_initJMethod(&_hashMapConstr, classHashMap, "java.util.HashMap", "<init>", "()V", 0)) {
            return 0;
        }
        if (!beampy_initJMethod(&_hashMapPutMethod, classHashMap, "java.util.HashMap", "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
            return 0;
        }
    }
    return 1;
}

jobject beampy_newJMapFromPyObject(PyObject* anyPyObj);

jobject beampy_newGenericJObjectFromPyObject(PyObject* anyPyObj)
{
    jobject anyJObj = NULL;

    if (!beampy_initJavaCoreVars()) {
        return NULL;
    }

    if (PyBool_Check(anyPyObj)) {
        boolean v = (anyPyObj == Py_True);
        anyJObj = (*jenv)->NewObject(jenv, classBoolean, _booleanConstr, v);
    } else if (PyLong_Check(anyPyObj)) {
        long v = PyLong_AsLong(anyPyObj);
        anyJObj = (*jenv)->NewObject(jenv, classInteger, _integerConstr, v);
    } else if (PyFloat_Check(anyPyObj)) {
        double v = PyFloat_AsDouble(anyPyObj);
        anyJObj = (*jenv)->NewObject(jenv, classDouble, _doubleConstr, v);
    } else if (PyUnicode_Check(anyPyObj)) {
        char* v = PyUnicode_AsUTF8(anyPyObj);
        anyJObj = (*jenv)->NewStringUTF(jenv, v);
    } else if (PyDict_Check(anyPyObj)) {
        anyJObj = beampy_newJMapFromPyObject(anyPyObj);
    } else {
        PyErr_SetString(PyExc_ValueError, "Expected a boolean, number, string or dictionary");
    }

    return anyJObj;
}


jobject beampy_newJMapFromPyObject(PyObject* anyPyObj)
{
    PyObject* dictKeyPyObj;
    PyObject* dictValuePyObj;
    Py_ssize_t dictPos = 0;
    jobject mapJObj = NULL;

    if (!beampy_initJavaCoreVars()) {
        return NULL;
    }

    if (!PyDict_Check(anyPyObj)) {
        PyErr_SetString(PyExc_TypeError, "dictionary expected");
        return NULL;
    }

    mapJObj = (*jenv)->NewObject(jenv, classHashMap, _hashMapConstr);
    if (mapJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "failed to create Java Map");
        return NULL;
    }

    while (PyDict_Next(anyPyObj, &dictPos, &dictKeyPyObj, &dictValuePyObj)) {
        jobject mapKeyJObj   = beampy_newGenericJObjectFromPyObject(dictKeyPyObj);
        jobject mapValueJObj = beampy_newGenericJObjectFromPyObject(dictValuePyObj);
        if (mapKeyJObj != NULL && mapValueJObj != NULL) {
            (*jenv)->CallObjectMethod(jenv, mapJObj, _hashMapPutMethod, mapKeyJObj, mapValueJObj);
        }
    }

    return mapJObj;
}
// >>>>>>>> End include from PyCModuleGenerator-stub-conv.c

PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "isCrossingMeridianAt180", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_isCrossingMeridianAt180", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "canGetPixelPos", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_canGetPixelPos", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "canGetGeoPos", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_canGetGeoPos", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    const char* pixelPosType = NULL;
    unsigned PY_LONG_LONG pixelPos = 0;
    jobject pixelPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getPixelPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/PixelPos;)Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyGeoCoding_getPixelPos", &_thisType, &_this, &geoPosType, &geoPos, &pixelPosType, &pixelPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    geoPosJObj = (jobject) geoPos;
    pixelPosJObj = (jobject) pixelPos;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, geoPosJObj, pixelPosJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pixelPosType = NULL;
    unsigned PY_LONG_LONG pixelPos = 0;
    jobject pixelPosJObj = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;)Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyGeoCoding_getGeoPos", &_thisType, &_this, &pixelPosType, &pixelPos, &geoPosType, &geoPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelPosJObj = (jobject) pixelPos;
    geoPosJObj = (jobject) geoPos;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelPosJObj, geoPosJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getDatum", "()Lorg/esa/beam/framework/dataop/maptransf/Datum;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_getDatum", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Datum");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getImageCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_getImageCRS", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "CoordinateReferenceSystem");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getMapCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_getMapCRS", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "CoordinateReferenceSystem");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_getGeoCRS", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "CoordinateReferenceSystem");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoCoding, "org.esa.beam.framework.datamodel.GeoCoding", "getImageToMapTransform", "()Lorg/opengis/referencing/operation/MathTransform;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoCoding_getImageToMapTransform", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MathTransform");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "getWriterPlugIn", "()Lorg/esa/beam/framework/dataio/ProductWriterPlugIn;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_getWriterPlugIn", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriterPlugIn");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "getOutput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_getOutput", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "writeProductNodes", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProductWriter_writeProductNodes", &_thisType, &_this, &productType, &product, &outputType, &output)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* sourceBandType = NULL;
    unsigned PY_LONG_LONG sourceBand = 0;
    jobject sourceBandJObj = NULL;
    jint sourceOffsetX = (jint) 0;
    jint sourceOffsetY = (jint) 0;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    const char* sourceBufferType = NULL;
    unsigned PY_LONG_LONG sourceBuffer = 0;
    jobject sourceBufferJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "writeBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)iiii(sK)(sK):BeamPyProductWriter_writeBandRasterData", &_thisType, &_this, &sourceBandType, &sourceBand, &sourceOffsetX, &sourceOffsetY, &sourceWidth, &sourceHeight, &sourceBufferType, &sourceBuffer, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    sourceBandJObj = (jobject) sourceBand;
    sourceBufferJObj = (jobject) sourceBuffer;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceBandJObj, sourceOffsetX, sourceOffsetY, sourceWidth, sourceHeight, sourceBufferJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "flush", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_flush", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "close", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_close", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "shouldWrite", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductWriter_shouldWrite", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "isIncrementalMode", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_isIncrementalMode", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean enabled = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "setIncrementalMode", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyProductWriter_setIncrementalMode", &_thisType, &_this, &enabled)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, enabled);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "deleteOutput", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductWriter_deleteOutput", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandType = NULL;
    unsigned PY_LONG_LONG band = 0;
    jobject bandJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductWriter, "org.esa.beam.framework.dataio.ProductWriter", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductWriter_removeBand", &_thisType, &_this, &bandType, &band)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandJObj = (jobject) band;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:BeamPyGPF_createProductWithoutSourceProducts", &operatorName, &parametersPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO(sK):BeamPyGPF_createProductFromSourceProduct", &operatorName, &parametersPyObj, &sourceProductType, &sourceProduct)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;[Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyGPF_createProductFromSourceProducts", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    sourceProductsJObj = beampy_newJObjectArrayFromPySeq(sourceProductsPyObj, "Product");
    if (sourceProductsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:BeamPyGPF_createProductFromNamedSourceProducts", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    sourceProductsJObj = beampy_newJMapFromPyObject(sourceProductsPyObj);
    if (sourceProductsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    const char* renderingHintsType = NULL;
    unsigned PY_LONG_LONG renderingHints = 0;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createProductNS", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sOO(sK):BeamPyGPF_createProductNS", &_thisType, &_this, &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsType, &renderingHints)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    sourceProductsJObj = beampy_newJMapFromPyObject(sourceProductsPyObj);
    if (sourceProductsJObj == NULL) {
        return NULL;
    }
    renderingHintsJObj = (jobject) renderingHints;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    const char* renderingHintsType = NULL;
    unsigned PY_LONG_LONG renderingHints = 0;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "createOperator", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/gpf/Operator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sOO(sK):BeamPyGPF_createOperator", &_thisType, &_this, &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsType, &renderingHints)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    parametersJObj = beampy_newJMapFromPyObject(parametersPyObj);
    if (parametersJObj == NULL) {
        return NULL;
    }
    sourceProductsJObj = beampy_newJMapFromPyObject(sourceProductsPyObj);
    if (sourceProductsJObj == NULL) {
        return NULL;
    }
    renderingHintsJObj = (jobject) renderingHints;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Operator");
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, parametersJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "getOperatorSpiRegistry", "()Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGPF_getOperatorSpiRegistry", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "OperatorSpiRegistry");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* spiRegistryType = NULL;
    unsigned PY_LONG_LONG spiRegistry = 0;
    jobject spiRegistryJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "setOperatorSpiRegistry", "(Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyGPF_setOperatorSpiRegistry", &_thisType, &_this, &spiRegistryType, &spiRegistry)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    spiRegistryJObj = (jobject) spiRegistry;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spiRegistryJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "getDefaultInstance", "()Lorg/esa/beam/framework/gpf/GPF;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classGPF, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GPF");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* defaultInstanceType = NULL;
    unsigned PY_LONG_LONG defaultInstance = 0;
    jobject defaultInstanceJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "setDefaultInstance", "(Lorg/esa/beam/framework/gpf/GPF;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGPF_setDefaultInstance", &defaultInstanceType, &defaultInstance)) {
        return NULL;
    }
    defaultInstanceJObj = (jobject) defaultInstance;
    (*jenv)->CallStaticVoidMethod(jenv, classGPF, _method, defaultInstanceJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* fileType = NULL;
    unsigned PY_LONG_LONG file = 0;
    jobject fileJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    jboolean incremental = (jboolean) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGPF, "org.esa.beam.framework.gpf.GPF", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/io/File;Ljava/lang/String;ZLcom/bc/ceres/core/ProgressMonitor;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)sb(sK):BeamPyGPF_writeProduct", &productType, &product, &fileType, &file, &formatName, &incremental, &pmType, &pm)) {
        return NULL;
    }
    productJObj = (jobject) product;
    fileJObj = (jobject) file;
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    pmJObj = (jobject) pm;
    (*jenv)->CallStaticVoidMethod(jenv, classGPF, _method, productJObj, fileJObj, formatNameJObj, incremental, pmJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyIndexCoding_newIndexCoding", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classIndexCoding, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexCoding");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndex", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_getIndex", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getIndexNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addIndex", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sis:BeamPyIndexCoding_addIndex", &_thisType, &_this, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexValue", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_getIndexValue", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_addElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_addAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sis:BeamPyIndexCoding_addSample", &_thisType, &_this, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getSampleCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyIndexCoding_getSampleName", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyIndexCoding_getSampleValue", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getElementGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getParentElement", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyIndexCoding_addElementAt", &_thisType, &_this, &elementType, &element, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_removeElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getNumElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyIndexCoding_getElementAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getElementNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_getElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_containsElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_getElementIndex", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_removeAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getNumAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyIndexCoding_getAttributeAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getAttributeNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_getAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_containsAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_getAttributeIndex", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyIndexCoding_getAttributeDouble", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValueType = NULL;
    unsigned PY_LONG_LONG defaultValue = 0;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyIndexCoding_getAttributeUTC", &_thisType, &_this, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = (jobject) defaultValue;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyIndexCoding_getAttributeInt", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyIndexCoding_setAttributeInt", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyIndexCoding_setAttributeDouble", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* valueType = NULL;
    unsigned PY_LONG_LONG value = 0;
    jobject valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyIndexCoding_setAttributeUTC", &_thisType, &_this, &name, &valueType, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = (jobject) value;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyIndexCoding_getAttributeString", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyIndexCoding_setAttributeString", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyIndexCoding_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_createDeepClone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyIndexCoding_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyIndexCoding_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classIndexCoding, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyIndexCoding_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyIndexCoding_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classIndexCoding, "org.esa.beam.framework.datamodel.IndexCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyIndexCoding_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classPixelPos, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:BeamPyPixelPos_newPixelPos2", &x, &y)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classPixelPos, _method, x, y);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_isValid", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_setInvalid", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "getX", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_getX", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "getY", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_getY", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)dd:BeamPyPixelPos_setLocation1", &_thisType, &_this, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat arg0 = (jfloat) 0;
    jfloat arg1 = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ff:BeamPyPixelPos_setLocation2", &_thisType, &_this, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(Ljava/awt/geom/Point2D;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPixelPos_setLocation3", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0JObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:BeamPyPixelPos_distanceSq2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classPixelPos, _method, arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:BeamPyPixelPos_distance2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classPixelPos, _method, arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DD)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)dd:BeamPyPixelPos_distanceSq1", &_thisType, &_this, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPixelPos_distanceSq3", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DD)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)dd:BeamPyPixelPos_distance1", &_thisType, &_this, &arg0, &arg1)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPixelPos_distance3", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_clone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPixelPos_hashCode", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPixelPos, "org.esa.beam.framework.datamodel.PixelPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPixelPos_equals", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReader", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductReader", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductWriterExtensions", "(Ljava/lang/String;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductWriterExtensions", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductWriter", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductWriter;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_getProductWriter", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, formatNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "readProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductIO_readProduct", &filePath)) {
        return NULL;
    }
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, filePathJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* fileType = NULL;
    unsigned PY_LONG_LONG file = 0;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForFile", "(Ljava/io/File;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductIO_getProductReaderForFile", &fileType, &file)) {
        return NULL;
    }
    fileJObj = (jobject) file;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, fileJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForInput", "(Ljava/lang/Object;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductIO_getProductReaderForInput", &inputType, &input)) {
        return NULL;
    }
    inputJObj = (jobject) input;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductIO, _method, inputJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductIO, "org.esa.beam.framework.dataio.ProductIO", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Ljava/lang/String;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyProductIO_writeProduct", &productType, &product, &filePath, &formatName)) {
        return NULL;
    }
    productJObj = (jobject) product;
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    (*jenv)->CallStaticVoidMethod(jenv, classProductIO, _method, productJObj, filePathJObj, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* descriptorType = NULL;
    unsigned PY_LONG_LONG descriptor = 0;
    jobject descriptorJObj = NULL;
    const char* featureType = NULL;
    unsigned PY_LONG_LONG feature = 0;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "<init>", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Lorg/opengis/feature/simple/SimpleFeature;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_newPlacemark", &descriptorType, &descriptor, &featureType, &feature)) {
        return NULL;
    }
    descriptorJObj = (jobject) descriptor;
    featureJObj = (jobject) feature;
    _resultJObj = (*jenv)->NewObject(jenv, classPlacemark, _method, descriptorJObj, featureJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Placemark");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* descriptorType = NULL;
    unsigned PY_LONG_LONG descriptor = 0;
    jobject descriptorJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    const char* pixelPosType = NULL;
    unsigned PY_LONG_LONG pixelPos = 0;
    jobject pixelPosJObj = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPointPlacemark", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/GeoCoding;)Lorg/esa/beam/framework/datamodel/Placemark;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sss(sK)(sK)(sK):BeamPyPlacemark_createPointPlacemark", &descriptorType, &descriptor, &name, &label, &text, &pixelPosType, &pixelPos, &geoPosType, &geoPos, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    descriptorJObj = (jobject) descriptor;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    pixelPosJObj = (jobject) pixelPos;
    geoPosJObj = (jobject) geoPos;
    geoCodingJObj = (jobject) geoCoding;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method, descriptorJObj, nameJObj, labelJObj, textJObj, pixelPosJObj, geoPosJObj, geoCodingJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Placemark");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDescriptor", "()Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getDescriptor", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PlacemarkDescriptor");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getFeature", "()Lorg/opengis/feature/simple/SimpleFeature;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getFeature", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SimpleFeature");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getAttributeValue", "(Ljava/lang/String;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_getAttributeValue", &_thisType, &_this, &attributeName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, attributeNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    const char* attributeValueType = NULL;
    unsigned PY_LONG_LONG attributeValue = 0;
    jobject attributeValueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setAttributeValue", "(Ljava/lang/String;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyPlacemark_setAttributeValue", &_thisType, &_this, &attributeName, &attributeValueType, &attributeValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    attributeValueJObj = (jobject) attributeValue;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeNameJObj, attributeValueJObj);
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setLabel", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_setLabel", &_thisType, &_this, &label)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, labelJObj);
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getLabel", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getLabel", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setText", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_setText", &_thisType, &_this, &text)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, textJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getText", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getText", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* styleCss = NULL;
    jstring styleCssJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setStyleCss", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_setStyleCss", &_thisType, &_this, &styleCss)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    styleCssJObj =(*jenv)->NewStringUTF(jenv, styleCss);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, styleCssJObj);
    (*jenv)->DeleteLocalRef(jenv, styleCssJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getStyleCss", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getStyleCss", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getPixelPos", "()Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getPixelPos", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pixelPosType = NULL;
    unsigned PY_LONG_LONG pixelPos = 0;
    jobject pixelPosJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setPixelPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_setPixelPos", &_thisType, &_this, &pixelPosType, &pixelPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelPosJObj = (jobject) pixelPos;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pixelPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getGeoPos", "()Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getGeoPos", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_setGeoPos", &_thisType, &_this, &geoPosType, &geoPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    geoPosJObj = (jobject) geoPos;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "updatePositions", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_updatePositions", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPinFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SimpleFeatureType");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createGcpFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SimpleFeatureType");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createGeometryFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SimpleFeatureType");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "createPointFeatureType", "(Ljava/lang/String;)Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemark_createPointFeatureType", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classPlacemark, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SimpleFeatureType");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemark_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyPlacemark_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemark_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classPlacemark, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemark_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyPlacemark_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemark, "org.esa.beam.framework.datamodel.Placemark", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemark_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataElement_newMetadataElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classMetadataElement, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getElementGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getParentElement", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_addElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyMetadataElement_addElementAt", &_thisType, &_this, &elementType, &element, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_removeElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getNumElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyMetadataElement_getElementAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getElementNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_getElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_containsElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_getElementIndex", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_addAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_removeAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getNumAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyMetadataElement_getAttributeAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getAttributeNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_getAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_containsAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_getAttributeIndex", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyMetadataElement_getAttributeDouble", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValueType = NULL;
    unsigned PY_LONG_LONG defaultValue = 0;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyMetadataElement_getAttributeUTC", &_thisType, &_this, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = (jobject) defaultValue;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyMetadataElement_getAttributeInt", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyMetadataElement_setAttributeInt", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyMetadataElement_setAttributeDouble", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* valueType = NULL;
    unsigned PY_LONG_LONG value = 0;
    jobject valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyMetadataElement_setAttributeUTC", &_thisType, &_this, &name, &valueType, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = (jobject) value;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyMetadataElement_getAttributeString", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyMetadataElement_setAttributeString", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyMetadataElement_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_createDeepClone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataElement_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataElement_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classMetadataElement, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataElement_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyMetadataElement_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataElement, "org.esa.beam.framework.datamodel.MetadataElement", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataElement_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint sceneRasterWidth = (jint) 0;
    jint sceneRasterHeight = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "<init>", "(Ljava/lang/String;Ljava/lang/String;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ssii:BeamPyProduct_newProduct", &name, &type, &sceneRasterWidth, &sceneRasterHeight)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _resultJObj = (*jenv)->NewObject(jenv, classProduct, _method, nameJObj, typeJObj, sceneRasterWidth, sceneRasterHeight);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getFileLocation", "()Ljava/io/File;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getFileLocation", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "File");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* fileLocationType = NULL;
    unsigned PY_LONG_LONG fileLocation = 0;
    jobject fileLocationJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setFileLocation", "(Ljava/io/File;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setFileLocation", &_thisType, &_this, &fileLocationType, &fileLocation)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    fileLocationJObj = (jobject) fileLocation;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, fileLocationJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductType", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    jstring productTypeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductType", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_setProductType", &_thisType, &_this, &productType)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productTypeJObj =(*jenv)->NewStringUTF(jenv, productType);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productTypeJObj);
    (*jenv)->DeleteLocalRef(jenv, productTypeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* readerType = NULL;
    unsigned PY_LONG_LONG reader = 0;
    jobject readerJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductReader", "(Lorg/esa/beam/framework/dataio/ProductReader;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setProductReader", &_thisType, &_this, &readerType, &reader)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    readerJObj = (jobject) reader;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* writerType = NULL;
    unsigned PY_LONG_LONG writer = 0;
    jobject writerJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setProductWriter", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setProductWriter", &_thisType, &_this, &writerType, &writer)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    writerJObj = (jobject) writer;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, writerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "writeHeader", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_writeHeader", &_thisType, &_this, &outputType, &output)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeProductReader", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_closeProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeProductWriter", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_closeProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "closeIO", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_closeIO", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPointingFactory", "()Lorg/esa/beam/framework/datamodel/PointingFactory;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getPointingFactory", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PointingFactory");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pointingFactoryType = NULL;
    unsigned PY_LONG_LONG pointingFactory = 0;
    jobject pointingFactoryJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setPointingFactory", "(Lorg/esa/beam/framework/datamodel/PointingFactory;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setPointingFactory", &_thisType, &_this, &pointingFactoryType, &pointingFactory)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pointingFactoryJObj = (jobject) pointingFactory;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointingFactoryJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setGeoCoding", &_thisType, &_this, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    geoCodingJObj = (jobject) geoCoding;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getGeoCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isUsingSingleGeoCoding", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_isUsingSingleGeoCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* destProductType = NULL;
    unsigned PY_LONG_LONG destProduct = 0;
    jobject destProductJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "transferGeoCodingTo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProduct_transferGeoCodingTo", &_thisType, &_this, &destProductType, &destProduct, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    destProductJObj = (jobject) destProduct;
    subsetDefJObj = (jobject) subsetDef;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, destProductJObj, subsetDefJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getSceneRasterWidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getSceneRasterHeight", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getStartTime", "()Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getStartTime", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* startTimeType = NULL;
    unsigned PY_LONG_LONG startTime = 0;
    jobject startTimeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setStartTime", "(Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setStartTime", &_thisType, &_this, &startTimeType, &startTime)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    startTimeJObj = (jobject) startTime;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startTimeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getEndTime", "()Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getEndTime", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* endTimeType = NULL;
    unsigned PY_LONG_LONG endTime = 0;
    jobject endTimeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setEndTime", "(Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_setEndTime", &_thisType, &_this, &endTimeType, &endTime)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    endTimeJObj = (jobject) endTime;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, endTimeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getMetadataRoot", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getMetadataRoot", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getGroups(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGroups", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getGroups", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGroup", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getGroup", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getTiePointGridGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* tiePointGridType = NULL;
    unsigned PY_LONG_LONG tiePointGrid = 0;
    jobject tiePointGridJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_addTiePointGrid", &_thisType, &_this, &tiePointGridType, &tiePointGrid)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    tiePointGridJObj = (jobject) tiePointGrid;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* tiePointGridType = NULL;
    unsigned PY_LONG_LONG tiePointGrid = 0;
    jobject tiePointGridJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_removeTiePointGrid", &_thisType, &_this, &tiePointGridType, &tiePointGrid)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    tiePointGridJObj = (jobject) tiePointGrid;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getNumTiePointGrids", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getNumTiePointGrids", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridAt", "(I)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProduct_getTiePointGridAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGridNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getTiePointGridNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGrids", "()[Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getTiePointGrids", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getTiePointGrid", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getTiePointGrid", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsTiePointGrid", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_containsTiePointGrid", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getBandGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandType = NULL;
    unsigned PY_LONG_LONG band = 0;
    jobject bandJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_addBand", &_thisType, &_this, &bandType, &band)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandJObj = (jobject) band;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    jint dataType = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyProduct_addNewBand", &_thisType, &_this, &bandName, &dataType)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, dataType);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyProduct_addComputedBand", &_thisType, &_this, &bandName, &expression)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, expressionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandType = NULL;
    unsigned PY_LONG_LONG band = 0;
    jobject bandJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_removeBand", &_thisType, &_this, &bandType, &band)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandJObj = (jobject) band;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, bandJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getNumBands", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getNumBands", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandAt", "(I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProduct_getBandAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getBandNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBands", "()[Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getBands", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBand", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getBand", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBandIndex", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getBandIndex", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsBand", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_containsBand", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsRasterDataNode", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_containsRasterDataNode", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRasterDataNode", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/RasterDataNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getRasterDataNode", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "RasterDataNode");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getMaskGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getVectorDataGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getVectorDataGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getFlagCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getFlagCodingGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getIndexCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getIndexCodingGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "containsPixel", "(FF)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ff:BeamPyProduct_containsPixel", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getGcpGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getGcpGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PlacemarkGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPinGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getPinGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "PlacemarkGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getNumResolutionsMax(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getNumResolutionsMax", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getNumResolutionsMax", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_setNumResolutionsMax(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numResolutionsMax = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setNumResolutionsMax", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProduct_setNumResolutionsMax", &_thisType, &_this, &numResolutionsMax)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numResolutionsMax);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jfloat eps = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isCompatibleProduct", "(Lorg/esa/beam/framework/datamodel/Product;F)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)f:BeamPyProduct_isCompatibleProduct", &_thisType, &_this, &productType, &product, &eps)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj, eps);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "parseExpression", "(Ljava/lang/String;)Lcom/bc/jexp/Term;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_parseExpression", &_thisType, &_this, &expression)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Term");
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* listenerType = NULL;
    unsigned PY_LONG_LONG listener = 0;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_addProductNodeListener", &_thisType, &_this, &listenerType, &listener)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    listenerJObj = (jobject) listener;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* listenerType = NULL;
    unsigned PY_LONG_LONG listener = 0;
    jobject listenerJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_removeProductNodeListener", &_thisType, &_this, &listenerType, &listener)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    listenerJObj = (jobject) listener;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, listenerJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductNodeListeners", "()[Lorg/esa/beam/framework/datamodel/ProductNodeListener;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductNodeListeners", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "ProductNodeListener");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRefNo", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getRefNo", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setRefNo", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProduct_setRefNo", &_thisType, &_this, &refNo)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, refNo);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "resetRefNo", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_resetRefNo", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductManager", "()Lorg/esa/beam/framework/datamodel/ProductManager;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductManager", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductManager");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticParser", "()Lcom/bc/jexp/Parser;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_createBandArithmeticParser", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Parser");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticDefaultNamespace", "()Lcom/bc/jexp/WritableNamespace;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_createBandArithmeticDefaultNamespace", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "WritableNamespace");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createSubset", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ss:BeamPyProduct_createSubset", &_thisType, &_this, &subsetDefType, &subsetDef, &name, &desc)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    subsetDefJObj = (jobject) subsetDef;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, subsetDefJObj, nameJObj, descJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint flipType = (jint) 0;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createFlippedProduct", "(ILjava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iss:BeamPyProduct_createFlippedProduct", &_thisType, &_this, &flipType, &name, &desc)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, flipType, nameJObj, descJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyProduct_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getQuicklookBandName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getQuicklookBandName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* quicklookBandName = NULL;
    jstring quicklookBandNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setQuicklookBandName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_setQuicklookBandName", &_thisType, &_this, &quicklookBandName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    quicklookBandNameJObj =(*jenv)->NewStringUTF(jenv, quicklookBandName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, quicklookBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, quicklookBandNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createPixelInfoString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyProduct_createPixelInfoString", &_thisType, &_this, &pixelX, &pixelY)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelX, pixelY);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getRemovedChildNodes", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getRemovedChildNodes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_canBeOrthorectified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getPreferredTileSize", "()Ljava/awt/Dimension;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getPreferredTileSize", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Dimension");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint tileWidth = (jint) 0;
    jint tileHeight = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setPreferredTileSize", "(II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyProduct_setPreferredTileSize", &_thisType, &_this, &tileWidth, &tileHeight)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tileWidth, tileHeight);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getAllFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getAllFlagNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getAutoGrouping", "()Lorg/esa/beam/framework/datamodel/Product/AutoGrouping;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getAutoGrouping", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "AutoGrouping");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pattern = NULL;
    jstring patternJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setAutoGrouping", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_setAutoGrouping", &_thisType, &_this, &pattern)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    patternJObj =(*jenv)->NewStringUTF(jenv, pattern);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, patternJObj);
    (*jenv)->DeleteLocalRef(jenv, patternJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* maskName = NULL;
    jstring maskNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    const char* colorType = NULL;
    unsigned PY_LONG_LONG color = 0;
    jobject colorJObj = NULL;
    jdouble transparency = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addMask", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/awt/Color;D)Lorg/esa/beam/framework/datamodel/Mask;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sss(sK)d:BeamPyProduct_addComputedMask", &_thisType, &_this, &maskName, &expression, &description, &colorType, &color, &transparency)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    maskNameJObj =(*jenv)->NewStringUTF(jenv, maskName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    colorJObj = (jobject) color;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, maskNameJObj, expressionJObj, descriptionJObj, colorJObj, transparency);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Mask");
    (*jenv)->DeleteLocalRef(jenv, maskNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bitmaskDefType = NULL;
    unsigned PY_LONG_LONG bitmaskDef = 0;
    jobject bitmaskDefJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "addBitmaskDef", "(Lorg/esa/beam/framework/datamodel/BitmaskDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_addBitmaskDef", &_thisType, &_this, &bitmaskDefType, &bitmaskDef)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bitmaskDefJObj = (jobject) bitmaskDef;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bitmaskDefJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBitmaskDefNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getBitmaskDefNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getBitmaskDef", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/BitmaskDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getBitmaskDef", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BitmaskDef");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getValidMask", "(Ljava/lang/String;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_getValidMask", &_thisType, &_this, &id)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, idJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BitRaster");
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    const char* validMaskType = NULL;
    unsigned PY_LONG_LONG validMask = 0;
    jobject validMaskJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setValidMask", "(Ljava/lang/String;Lorg/esa/beam/util/BitRaster;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyProduct_setValidMask", &_thisType, &_this, &id, &validMaskType, &validMask)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    validMaskJObj = (jobject) validMask;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, idJObj, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Ljava/lang/String;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyProduct_createValidMask2", &_thisType, &_this, &expression, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BitRaster");
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* termType = NULL;
    unsigned PY_LONG_LONG term = 0;
    jobject termJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Lcom/bc/jexp/Term;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProduct_createValidMask1", &_thisType, &_this, &termType, &term, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    termJObj = (jobject) term;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, termJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BitRaster");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* bitmaskTermType = NULL;
    unsigned PY_LONG_LONG bitmaskTerm = 0;
    jobject bitmaskTermJObj = NULL;
    jboolean* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[ZLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)O(sK):BeamPyProduct_readBitmask2", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &bitmaskTermType, &bitmaskTerm, &bitmaskPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bitmaskTermJObj = (jobject) bitmaskTerm;
    bitmaskPyObj = beampy_getPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jboolean*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = beampy_newJBooleanArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, pmJObj);
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* bitmaskTermType = NULL;
    unsigned PY_LONG_LONG bitmaskTerm = 0;
    jobject bitmaskTermJObj = NULL;
    jbyte* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    jbyte trueValue = (jbyte) 0;
    jbyte falseValue = (jbyte) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[BBBLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)Obb(sK):BeamPyProduct_readBitmask1", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &bitmaskTermType, &bitmaskTerm, &bitmaskPyObj, &trueValue, &falseValue, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bitmaskTermJObj = (jobject) bitmaskTerm;
    bitmaskPyObj = beampy_getPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jbyte*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = beampy_newJByteArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, trueValue, falseValue, pmJObj);
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProduct_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProduct_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProduct, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProduct_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyProduct_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProduct, "org.esa.beam.framework.datamodel.Product", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProduct_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:BeamPyColorPaletteDef_newColorPaletteDefFromRange", &minSample, &maxSample)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classColorPaletteDef, _method, minSample, maxSample);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ColorPaletteDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    jint numColors = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:BeamPyColorPaletteDef_newColorPaletteDefFromPoints", &pointsPyObj, &numColors)) {
        return NULL;
    }
    pointsJObj = beampy_newJObjectArrayFromPySeq(pointsPyObj, "Point");
    if (pointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classColorPaletteDef, _method, pointsJObj, numColors);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ColorPaletteDef");
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isDiscrete", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_isDiscrete", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean discrete = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setDiscrete", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyColorPaletteDef_setDiscrete", &_thisType, &_this, &discrete)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discrete);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumColors", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getNumColors", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numColors = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumColors", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyColorPaletteDef_setNumColors", &_thisType, &_this, &numColors)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numColors);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumPoints", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getNumPoints", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numPoints = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumPoints", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyColorPaletteDef_setNumPoints", &_thisType, &_this, &numPoints)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numPoints);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isAutoDistribute", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_isAutoDistribute", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean autoDistribute = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setAutoDistribute", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyColorPaletteDef_setAutoDistribute", &_thisType, &_this, &autoDistribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPointAt", "(I)Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyColorPaletteDef_getPointAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Point");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getFirstPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getFirstPoint", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Point");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getLastPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getLastPoint", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Point");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMinDisplaySample", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getMinDisplaySample", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMaxDisplaySample", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getMaxDisplaySample", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* pointType = NULL;
    unsigned PY_LONG_LONG point = 0;
    jobject pointJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "insertPointAfter", "(ILorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyColorPaletteDef_insertPointAfter", &_thisType, &_this, &index, &pointType, &point)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pointJObj = (jobject) point;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, pointJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* scalingType = NULL;
    unsigned PY_LONG_LONG scaling = 0;
    jobject scalingJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createPointAfter", "(ILorg/esa/beam/framework/datamodel/Scaling;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyColorPaletteDef_createPointAfter", &_thisType, &_this, &index, &scalingType, &scaling)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    scalingJObj = (jobject) scaling;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index, scalingJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* c1Type = NULL;
    unsigned PY_LONG_LONG c1 = 0;
    jobject c1JObj = NULL;
    const char* c2Type = NULL;
    unsigned PY_LONG_LONG c2 = 0;
    jobject c2JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getCenterColor", "(Ljava/awt/Color;Ljava/awt/Color;)Ljava/awt/Color;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyColorPaletteDef_getCenterColor", &c1Type, &c1, &c2Type, &c2)) {
        return NULL;
    }
    c1JObj = (jobject) c1;
    c2JObj = (jobject) c2;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classColorPaletteDef, _method, c1JObj, c2JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "removePointAt", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyColorPaletteDef_removePointAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pointType = NULL;
    unsigned PY_LONG_LONG point = 0;
    jobject pointJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "addPoint", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyColorPaletteDef_addPoint", &_thisType, &_this, &pointType, &point)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pointJObj = (jobject) point;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPoints", "()[Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getPoints", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Point");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setPoints", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef/Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O:BeamPyColorPaletteDef_setPoints", &_thisType, &_this, &pointsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pointsJObj = beampy_newJObjectArrayFromPySeq(pointsPyObj, "Point");
    if (pointsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getIterator", "()Ljava/util/Iterator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getIterator", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Iterator");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_clone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_createDeepCopy", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ColorPaletteDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* fileType = NULL;
    unsigned PY_LONG_LONG file = 0;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "loadColorPaletteDef", "(Ljava/io/File;)Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_loadColorPaletteDef", &fileType, &file)) {
        return NULL;
    }
    fileJObj = (jobject) file;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classColorPaletteDef, _method, fileJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ColorPaletteDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* colorPaletteDefType = NULL;
    unsigned PY_LONG_LONG colorPaletteDef = 0;
    jobject colorPaletteDefJObj = NULL;
    const char* fileType = NULL;
    unsigned PY_LONG_LONG file = 0;
    jobject fileJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "storeColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;Ljava/io/File;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyColorPaletteDef_storeColorPaletteDef", &colorPaletteDefType, &colorPaletteDef, &fileType, &file)) {
        return NULL;
    }
    colorPaletteDefJObj = (jobject) colorPaletteDef;
    fileJObj = (jobject) file;
    (*jenv)->CallStaticVoidMethod(jenv, classColorPaletteDef, _method, colorPaletteDefJObj, fileJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyColorPaletteDef_getColors", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* scalingType = NULL;
    unsigned PY_LONG_LONG scaling = 0;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createColorPalette", "(Lorg/esa/beam/framework/datamodel/Scaling;)[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyColorPaletteDef_createColorPalette", &_thisType, &_this, &scalingType, &scaling)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    scalingJObj = (jobject) scaling;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* scalingType = NULL;
    unsigned PY_LONG_LONG scaling = 0;
    jobject scalingJObj = NULL;
    jdouble sample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classColorPaletteDef, "org.esa.beam.framework.datamodel.ColorPaletteDef", "computeColor", "(Lorg/esa/beam/framework/datamodel/Scaling;D)Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)d:BeamPyColorPaletteDef_computeColor", &_thisType, &_this, &scalingType, &scaling, &sample)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    scalingJObj = (jobject) scaling;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj, sample);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* colorPaletteDefType = NULL;
    unsigned PY_LONG_LONG colorPaletteDef = 0;
    jobject colorPaletteDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_newImageInfoPalette", &colorPaletteDefType, &colorPaletteDef)) {
        return NULL;
    }
    colorPaletteDefJObj = (jobject) colorPaletteDef;
    _resultJObj = (*jenv)->NewObject(jenv, classImageInfo, _method, colorPaletteDefJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rgbChannelDefType = NULL;
    unsigned PY_LONG_LONG rgbChannelDef = 0;
    jobject rgbChannelDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/RGBChannelDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_newImageInfoRGB", &rgbChannelDefType, &rgbChannelDef)) {
        return NULL;
    }
    rgbChannelDefJObj = (jobject) rgbChannelDef;
    _resultJObj = (*jenv)->NewObject(jenv, classImageInfo, _method, rgbChannelDefJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColorPaletteDef", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_getColorPaletteDef", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ColorPaletteDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getRgbChannelDef", "()Lorg/esa/beam/framework/datamodel/RGBChannelDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_getRgbChannelDef", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "RGBChannelDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getNoDataColor", "()Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_getNoDataColor", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* noDataColorType = NULL;
    unsigned PY_LONG_LONG noDataColor = 0;
    jobject noDataColorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setNoDataColor", "(Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyImageInfo_setNoDataColor", &_thisType, &_this, &noDataColorType, &noDataColor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    noDataColorJObj = (jobject) noDataColor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataColorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* histogramMatchingType = NULL;
    unsigned PY_LONG_LONG histogramMatching = 0;
    jobject histogramMatchingJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setHistogramMatching", "(Lorg/esa/beam/framework/datamodel/ImageInfo/HistogramMatching;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyImageInfo_setHistogramMatching", &_thisType, &_this, &histogramMatchingType, &histogramMatching)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    histogramMatchingJObj = (jobject) histogramMatching;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, histogramMatchingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "isLogScaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_isLogScaled", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean logScaled = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setLogScaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyImageInfo_setLogScaled", &_thisType, &_this, &logScaled)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, logScaled);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_getColors", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Color");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getColorComponentCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_getColorComponentCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* scalingType = NULL;
    unsigned PY_LONG_LONG scaling = 0;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createIndexColorModel", "(Lorg/esa/beam/framework/datamodel/Scaling;)Ljava/awt/image/IndexColorModel;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyImageInfo_createIndexColorModel", &_thisType, &_this, &scalingType, &scaling)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    scalingJObj = (jobject) scaling;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexColorModel");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createComponentColorModel", "()Ljava/awt/image/ComponentColorModel;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_createComponentColorModel", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ComponentColorModel");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_clone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_createDeepCopy", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageInfo_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* colorsPyObj = NULL;
    jarray colorsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setColors", "([Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O:BeamPyImageInfo_setColors", &_thisType, &_this, &colorsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    colorsJObj = beampy_newJObjectArrayFromPySeq(colorsPyObj, "Color");
    if (colorsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorsJObj);
    (*jenv)->DeleteLocalRef(jenv, colorsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* colorPaletteDefType = NULL;
    unsigned PY_LONG_LONG colorPaletteDef = 0;
    jobject colorPaletteDefJObj = NULL;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    jboolean autoDistribute = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "setColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;DDZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ddb:BeamPyImageInfo_setColorPaletteDef", &_thisType, &_this, &colorPaletteDefType, &colorPaletteDef, &minSample, &maxSample, &autoDistribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    colorPaletteDefJObj = (jobject) colorPaletteDef;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorPaletteDefJObj, minSample, maxSample, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* mode = NULL;
    jstring modeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageInfo, "org.esa.beam.framework.datamodel.ImageInfo", "getHistogramMatching", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ImageInfo/HistogramMatching;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyImageInfo_getHistogramMatching", &mode)) {
        return NULL;
    }
    modeJObj =(*jenv)->NewStringUTF(jenv, mode);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageInfo, _method, modeJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "HistogramMatching");
    (*jenv)->DeleteLocalRef(jenv, modeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classProductManager, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductManager");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductManager_getProductCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductManager_getProduct", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductManager_getProductDisplayNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductManager_getProductNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProducts", "()[Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductManager_getProducts", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductManager_getProductByDisplayName", &_thisType, &_this, &displayName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductByRefNo", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductManager_getProductByRefNo", &_thisType, &_this, &refNo)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, refNo);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductManager_getProductByName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "getProductIndex", "(Lorg/esa/beam/framework/datamodel/Product;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_getProductIndex", &_thisType, &_this, &productType, &product)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, productJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "containsProduct", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductManager_containsProduct", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "contains", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_contains", &_thisType, &_this, &productType, &product)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "addProduct", "(Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_addProduct", &_thisType, &_this, &productType, &product)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeProduct", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_removeProduct", &_thisType, &_this, &productType, &product)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productJObj = (jobject) product;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeAllProducts", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductManager_removeAllProducts", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* listenerType = NULL;
    unsigned PY_LONG_LONG listener = 0;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "addListener", "(Lorg/esa/beam/framework/datamodel/ProductManager/Listener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_addListener", &_thisType, &_this, &listenerType, &listener)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    listenerJObj = (jobject) listener;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* listenerType = NULL;
    unsigned PY_LONG_LONG listener = 0;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductManager, "org.esa.beam.framework.datamodel.ProductManager", "removeListener", "(Lorg/esa/beam/framework/datamodel/ProductManager/Listener;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductManager_removeListener", &_thisType, &_this, &listenerType, &listener)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    listenerJObj = (jobject) listener;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* boundsType = NULL;
    unsigned PY_LONG_LONG bounds = 0;
    jobject boundsJObj = NULL;
    const char* mapCrsType = NULL;
    unsigned PY_LONG_LONG mapCrs = 0;
    jobject mapCrsJObj = NULL;
    const char* image2mapType = NULL;
    unsigned PY_LONG_LONG image2map = 0;
    jobject image2mapJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "<init>", "(Ljava/awt/Rectangle;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/awt/geom/AffineTransform;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyImageGeometry_newImageGeometry", &boundsType, &bounds, &mapCrsType, &mapCrs, &image2mapType, &image2map)) {
        return NULL;
    }
    boundsJObj = (jobject) bounds;
    mapCrsJObj = (jobject) mapCrs;
    image2mapJObj = (jobject) image2map;
    _resultJObj = (*jenv)->NewObject(jenv, classImageGeometry, _method, boundsJObj, mapCrsJObj, image2mapJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageGeometry");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getImage2MapTransform", "()Ljava/awt/geom/AffineTransform;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageGeometry_getImage2MapTransform", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "AffineTransform");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getImageRect", "()Ljava/awt/Rectangle;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageGeometry_getImageRect", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Rectangle");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "getMapCrs", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageGeometry_getMapCrs", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "CoordinateReferenceSystem");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "changeYAxisDirection", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageGeometry_changeYAxisDirection", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetCrsType = NULL;
    unsigned PY_LONG_LONG targetCrs = 0;
    jobject targetCrsJObj = NULL;
    jdouble referencePixelX = (jdouble) 0;
    jdouble referencePixelY = (jdouble) 0;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateEastingNorthing", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DDDD)Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)dddd:BeamPyImageGeometry_calculateEastingNorthing", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &referencePixelX, &referencePixelY, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetCrsJObj = (jobject) targetCrs;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, referencePixelX, referencePixelY, pixelSizeX, pixelSizeY);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Point2D");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetCrsType = NULL;
    unsigned PY_LONG_LONG targetCrs = 0;
    jobject targetCrsJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateProductSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DD)Ljava/awt/Rectangle;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)dd:BeamPyImageGeometry_calculateProductSize", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetCrsJObj = (jobject) targetCrs;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, pixelSizeX, pixelSizeY);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Rectangle");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetCrsType = NULL;
    unsigned PY_LONG_LONG targetCrs = 0;
    jobject targetCrsJObj = NULL;
    const char* pixelSizeXType = NULL;
    unsigned PY_LONG_LONG pixelSizeX = 0;
    jobject pixelSizeXJObj = NULL;
    const char* pixelSizeYType = NULL;
    unsigned PY_LONG_LONG pixelSizeY = 0;
    jobject pixelSizeYJObj = NULL;
    const char* widthType = NULL;
    unsigned PY_LONG_LONG width = 0;
    jobject widthJObj = NULL;
    const char* heightType = NULL;
    unsigned PY_LONG_LONG height = 0;
    jobject heightJObj = NULL;
    const char* orientationType = NULL;
    unsigned PY_LONG_LONG orientation = 0;
    jobject orientationJObj = NULL;
    const char* eastingType = NULL;
    unsigned PY_LONG_LONG easting = 0;
    jobject eastingJObj = NULL;
    const char* northingType = NULL;
    unsigned PY_LONG_LONG northing = 0;
    jobject northingJObj = NULL;
    const char* referencePixelXType = NULL;
    unsigned PY_LONG_LONG referencePixelX = 0;
    jobject referencePixelXJObj = NULL;
    const char* referencePixelYType = NULL;
    unsigned PY_LONG_LONG referencePixelY = 0;
    jobject referencePixelYJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "createTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK):BeamPyImageGeometry_createTargetGeometry", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &pixelSizeXType, &pixelSizeX, &pixelSizeYType, &pixelSizeY, &widthType, &width, &heightType, &height, &orientationType, &orientation, &eastingType, &easting, &northingType, &northing, &referencePixelXType, &referencePixelX, &referencePixelYType, &referencePixelY)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetCrsJObj = (jobject) targetCrs;
    pixelSizeXJObj = (jobject) pixelSizeX;
    pixelSizeYJObj = (jobject) pixelSizeY;
    widthJObj = (jobject) width;
    heightJObj = (jobject) height;
    orientationJObj = (jobject) orientation;
    eastingJObj = (jobject) easting;
    northingJObj = (jobject) northing;
    referencePixelXJObj = (jobject) referencePixelX;
    referencePixelYJObj = (jobject) referencePixelY;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, sourceProductJObj, targetCrsJObj, pixelSizeXJObj, pixelSizeYJObj, widthJObj, heightJObj, orientationJObj, eastingJObj, northingJObj, referencePixelXJObj, referencePixelYJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageGeometry");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    const char* collocationProductType = NULL;
    unsigned PY_LONG_LONG collocationProduct = 0;
    jobject collocationProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "createCollocationTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyImageGeometry_createCollocationTargetGeometry", &targetProductType, &targetProduct, &collocationProductType, &collocationProduct)) {
        return NULL;
    }
    targetProductJObj = (jobject) targetProduct;
    collocationProductJObj = (jobject) collocationProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, targetProductJObj, collocationProductJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageGeometry");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createValidRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classImageGeometry, "org.esa.beam.framework.datamodel.ImageGeometry", "createValidRect", "(Lorg/esa/beam/framework/datamodel/Product;)Ljava/awt/geom/Rectangle2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyImageGeometry_createValidRect", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classImageGeometry, _method, productJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Rectangle2D");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint dataType = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "<init>", "(Ljava/lang/String;III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siii:BeamPyBand_newBand", &name, &dataType, &width, &height)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classBand, _method, nameJObj, dataType, width, height);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getFlagCoding", "()Lorg/esa/beam/framework/datamodel/FlagCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getFlagCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "FlagCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isFlagBand", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isFlagBand", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getIndexCoding", "()Lorg/esa/beam/framework/datamodel/IndexCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getIndexCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isIndexBand", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isIndexBand", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleCoding", "()Lorg/esa/beam/framework/datamodel/SampleCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSampleCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "SampleCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* sampleCodingType = NULL;
    unsigned PY_LONG_LONG sampleCoding = 0;
    jobject sampleCodingJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSampleCoding", "(Lorg/esa/beam/framework/datamodel/SampleCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setSampleCoding", &_thisType, &_this, &sampleCodingType, &sampleCoding)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    sampleCodingJObj = (jobject) sampleCoding;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sampleCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralBandIndex", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSpectralBandIndex", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint spectralBandIndex = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralBandIndex", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyBand_setSpectralBandIndex", &_thisType, &_this, &spectralBandIndex)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandIndex);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralWavelength", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSpectralWavelength", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat spectralWavelength = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralWavelength", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)f:BeamPyBand_setSpectralWavelength", &_thisType, &_this, &spectralWavelength)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralWavelength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSpectralBandwidth", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSpectralBandwidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat spectralBandwidth = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSpectralBandwidth", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)f:BeamPyBand_setSpectralBandwidth", &_thisType, &_this, &spectralBandwidth)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandwidth);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSolarFlux", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSolarFlux", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat solarFlux = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSolarFlux", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)f:BeamPyBand_setSolarFlux", &_thisType, &_this, &solarFlux)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, solarFlux);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getViewModeId", "(Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyBand_getViewModeId", &_thisType, &_this, &bandName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* validMaskExpression = NULL;
    jstring validMaskExpressionJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    jint defaultProductIndex = (jint) 0;
    jboolean checkInvalids = (jboolean) 0;
    jboolean useInvalidValue = (jboolean) 0;
    jdouble noDataValue = (jdouble) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "computeBand", "(Ljava/lang/String;Ljava/lang/String;[Lorg/esa/beam/framework/datamodel/Product;IZZDLcom/bc/ceres/core/ProgressMonitor;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ssOibbd(sK):BeamPyBand_computeBand", &_thisType, &_this, &expression, &validMaskExpression, &sourceProductsPyObj, &defaultProductIndex, &checkInvalids, &useInvalidValue, &noDataValue, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    validMaskExpressionJObj =(*jenv)->NewStringUTF(jenv, validMaskExpression);
    sourceProductsJObj = beampy_newJObjectArrayFromPySeq(sourceProductsPyObj, "Product");
    if (sourceProductsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, expressionJObj, validMaskExpressionJObj, sourceProductsJObj, defaultProductIndex, checkInvalids, useInvalidValue, noDataValue, pmJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validMaskExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSceneRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getPixelInt", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getPixelFloat", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getPixelDouble", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iii:BeamPyBand_setPixelInt", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iif:BeamPyBand_setPixelFloat", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iid:BeamPyBand_setPixelDouble", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_setPixelsInt", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_setPixelsFloat", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_setPixelsDouble", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "ensureRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_ensureRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_unloadRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSceneRasterWidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSceneRasterHeight", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getRasterWidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getRasterHeight", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyBand_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getGeoCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setGeoCoding", &_thisType, &_this, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    geoCodingJObj = (jobject) geoCoding;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getPointing", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Pointing");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_canBeOrthorectified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isFloatingPointType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getGeophysicalDataType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getScalingFactor", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_setScalingFactor", &_thisType, &_this, &scalingFactor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getScalingOffset", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_setScalingOffset", &_thisType, &_this, &scalingOffset)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isLog10Scaled", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyBand_setLog10Scaled", &_thisType, &_this, &log10Scaled)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isScalingApplied", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyBand_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classBand, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isNoDataValueSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_clearNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isNoDataValueUsed", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyBand_setNoDataValueUsed", &_thisType, &_this, &noDataValueUsed)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_setNoDataValue", &_thisType, &_this, &noDataValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getGeophysicalNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_setGeophysicalNoDataValue", &_thisType, &_this, &noDataValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getValidPixelExpression", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyBand_setValidPixelExpression", &_thisType, &_this, &validPixelExpression)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isValidMaskUsed", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_resetValidMask", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getValidMaskExpression", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyBand_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_hasRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setRasterData", &_thisType, &_this, &rasterDataType, &rasterData)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_loadRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_isPixelValid", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getSampleInt", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getSampleFloat", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_getPixelsInt", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_getPixelsFloat", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_getPixelsDouble", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_readPixelsInt", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "i", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = beampy_copyJIntArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_readPixelsFloat", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "f", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = beampy_copyJFloatArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_readPixelsDouble", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "d", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = beampy_copyJDoubleArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_writePixelsInt", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_writePixelsFloat", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_writePixelsDouble", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyBand_readValidMask", &_thisType, &_this, &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    validMaskPyObj = beampy_getPrimitiveArrayBufferWritable(validMaskPyObj, &validMaskBuf, "b", w*h);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = beampy_newJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    if (validMaskData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, validMaskJObj)) {
        _resultPyObj = beampy_copyJBooleanArrayToBuffer((jarray) validMaskJObj, validMaskData, validMaskLength, validMaskPyObj);
    } else {
        _resultPyObj = beampy_newPyObjectFromJBooleanArray((jarray) validMaskJObj);
    }
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_writeRasterDataFully", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):BeamPyBand_writeRasterData", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_createCompatibleRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_createCompatibleSceneRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_createCompatibleRasterDataForRect", &_thisType, &_this, &width, &height)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:BeamPyBand_isCompatibleRasterData", &_thisType, &_this, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:BeamPyBand_checkCompatibleRasterData", &_thisType, &_this, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_hasIntPixels", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* shapeType = NULL;
    unsigned PY_LONG_LONG shape = 0;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_createTransectProfileData", &_thisType, &_this, &shapeType, &shape)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    shapeJObj = (jobject) shape;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TransectProfileData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getImageInfo", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* imageInfoType = NULL;
    unsigned PY_LONG_LONG imageInfo = 0;
    jobject imageInfoJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setImageInfo", &_thisType, &_this, &imageInfoType, &imageInfo)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    imageInfoJObj = (jobject) imageInfo;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_fireImageInfoChanged", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    const char* histogramType = NULL;
    unsigned PY_LONG_LONG histogram = 0;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O(sK):BeamPyBand_createDefaultImageInfo", &_thisType, &_this, &histoSkipAreasPyObj, &histogramType, &histogram)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    histoSkipAreasPyObj = beampy_getPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = beampy_newJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    histogramJObj = (jobject) histogram;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getOverlayMaskGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_createColorIndexedImage", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_createRgbImage", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    const char* roiType = NULL;
    unsigned PY_LONG_LONG roi = 0;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyBand_createPixelValidator", &_thisType, &_this, &lineOffset, &roiType, &roi)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    roiJObj = (jobject) roi;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexValidator");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "scale", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_scale", &_thisType, &_this, &v)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyBand_scaleInverse", &_thisType, &_this, &v)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyBand_getPixelString", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isSourceImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getSourceImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isGeophysicalImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getGeophysicalImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isValidMaskImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getValidMaskImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isStxSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getStx", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Stx");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* stxType = NULL;
    unsigned PY_LONG_LONG stx = 0;
    jobject stxJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setStx", &_thisType, &_this, &stxType, &stx)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    stxJObj = (jobject) stx;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getValidShape", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Shape");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getRoiMaskGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getDataType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getNumDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyBand_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setData", &_thisType, &_this, &dataType, &data)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    dataJObj = (jobject) data;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elemsType = NULL;
    unsigned PY_LONG_LONG elems = 0;
    jobject elemsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_setDataElems", &_thisType, &_this, &elemsType, &elems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elemsJObj = (jobject) elems;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getDataElemSize", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyBand_setReadOnly", &_thisType, &_this, &readOnly)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isReadOnly", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyBand_setUnit", &_thisType, &_this, &unit)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getUnit", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isSynthetic", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyBand_setSynthetic", &_thisType, &_this, &synthetic)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_fireProductNodeDataChanged", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyBand_createCompatibleProductData", &_thisType, &_this, &numElems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyBand_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyBand_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyBand_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classBand, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyBand_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classBand, "org.esa.beam.framework.datamodel.Band", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyBand_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getVectorDataNode", "()Lorg/esa/beam/framework/datamodel/VectorDataNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getVectorDataNode", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "VectorDataNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* featureType = NULL;
    unsigned PY_LONG_LONG feature = 0;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getPlacemark", "(Lorg/opengis/feature/simple/SimpleFeature;)Lorg/esa/beam/framework/datamodel/Placemark;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_getPlacemark", &_thisType, &_this, &featureType, &feature)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    featureJObj = (jobject) feature;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, featureJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Placemark");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* placemarkType = NULL;
    unsigned PY_LONG_LONG placemark = 0;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_add3", &_thisType, &_this, &placemarkType, &placemark)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    placemarkJObj = (jobject) placemark;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* placemarkType = NULL;
    unsigned PY_LONG_LONG placemark = 0;
    jobject placemarkJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/Placemark;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyPlacemarkGroup_add1", &_thisType, &_this, &index, &placemarkType, &placemark)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    placemarkJObj = (jobject) placemark;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, placemarkJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* placemarkType = NULL;
    unsigned PY_LONG_LONG placemark = 0;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_remove1", &_thisType, &_this, &placemarkType, &placemark)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    placemarkJObj = (jobject) placemark;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_isTakingOverNodeOwnership", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getNodeCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyPlacemarkGroup_get1", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getNodeDisplayNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getNodeNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_toArray1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* arrayPyObj = NULL;
    jarray arrayJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "([Lorg/esa/beam/framework/datamodel/ProductNode;)[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O:BeamPyPlacemarkGroup_toArray2", &_thisType, &_this, &arrayPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arrayJObj = beampy_newJObjectArrayFromPySeq(arrayPyObj, "ProductNode");
    if (arrayJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arrayJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, arrayJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_indexOf1", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_indexOf2", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_getByDisplayName", &_thisType, &_this, &displayName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_get2", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_contains1", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_contains2", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_add4", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyPlacemarkGroup_add2", &_thisType, &_this, &index, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_remove2", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_removeAll", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_clearRemovedList", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getRemovedNodes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Collection");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_getRawStorageSize2", &_thisType, &_this, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    subsetDefJObj = (jobject) subsetDef;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyPlacemarkGroup_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyPlacemarkGroup_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyPlacemarkGroup_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classPlacemarkGroup, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyPlacemarkGroup_getRawStorageSize1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyPlacemarkGroup_fireProductNodeChanged1", &_thisType, &_this, &propertyName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    const char* oldValueType = NULL;
    unsigned PY_LONG_LONG oldValue = 0;
    jobject oldValueJObj = NULL;
    const char* newValueType = NULL;
    unsigned PY_LONG_LONG newValue = 0;
    jobject newValueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK)(sK):BeamPyPlacemarkGroup_fireProductNodeChanged2", &_thisType, &_this, &propertyName, &oldValueType, &oldValue, &newValueType, &newValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    oldValueJObj = (jobject) oldValue;
    newValueJObj = (jobject) newValue;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classPlacemarkGroup, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyPlacemarkGroup_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffO:BeamPyTiePointGrid_newTiePointGrid1", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = beampy_getPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = beampy_newJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint discontinuity = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FI)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOi:BeamPyTiePointGrid_newTiePointGrid2", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &discontinuity)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = beampy_getPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = beampy_newJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, discontinuity);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jboolean containsAngles = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOb:BeamPyTiePointGrid_newTiePointGrid3", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &containsAngles)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = beampy_getPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = beampy_newJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classTiePointGrid, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, containsAngles);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "([F)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyTiePointGrid_getDiscontinuity2", &tiePointsPyObj)) {
        return NULL;
    }
    tiePointsPyObj = beampy_getPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = beampy_newJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classTiePointGrid, _method, tiePointsJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDiscontinuity1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint discontinuity = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDiscontinuity", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyTiePointGrid_setDiscontinuity", &_thisType, &_this, &discontinuity)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discontinuity);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isFloatingPointType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getGeophysicalDataType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSceneRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSceneRasterWidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSceneRasterHeight", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetX", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getOffsetX", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetY", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getOffsetY", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingX", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSubSamplingX", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingY", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSubSamplingY", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getTiePoints", "()[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getTiePoints", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getPixelInt", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getPixelFloat2", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(FF)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ff:BeamPyTiePointGrid_getPixelFloat1", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getPixelDouble", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iii:BeamPyTiePointGrid_setPixelInt", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iif:BeamPyTiePointGrid_setPixelFloat", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iid:BeamPyTiePointGrid_setPixelDouble", &_thisType, &_this, &x, &y, &pixelValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_getPixels6", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_getPixels4", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_getPixels2", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_setPixels3", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_setPixels2", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_setPixels1", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_readPixels6", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_readPixels4", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_readPixels2", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_writePixels6", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_writePixels4", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):BeamPyTiePointGrid_writePixels2", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)(sK):BeamPyTiePointGrid_readRasterData2", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_readRasterDataFully2", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)(sK):BeamPyTiePointGrid_writeRasterData2", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_writeRasterDataFully2", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "cloneTiePointGrid", "()Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_cloneTiePointGrid", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* elevationAngleGridType = NULL;
    unsigned PY_LONG_LONG elevationAngleGrid = 0;
    jobject elevationAngleGridJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createZenithFromElevationAngleTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid", &elevationAngleGridType, &elevationAngleGrid)) {
        return NULL;
    }
    elevationAngleGridJObj = (jobject) elevationAngleGrid;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classTiePointGrid, _method, elevationAngleGridJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceTiePointGridType = NULL;
    unsigned PY_LONG_LONG sourceTiePointGrid = 0;
    jobject sourceTiePointGridJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createSubset", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_createSubset", &sourceTiePointGridType, &sourceTiePointGrid, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    sourceTiePointGridJObj = (jobject) sourceTiePointGrid;
    subsetDefJObj = (jobject) subsetDef;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classTiePointGrid, _method, sourceTiePointGridJObj, subsetDefJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getRasterWidth", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getRasterHeight", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyTiePointGrid_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getGeoCoding", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setGeoCoding", &_thisType, &_this, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    geoCodingJObj = (jobject) geoCoding;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getPointing", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Pointing");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_canBeOrthorectified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getScalingFactor", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_setScalingFactor", &_thisType, &_this, &scalingFactor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getScalingOffset", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_setScalingOffset", &_thisType, &_this, &scalingOffset)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isLog10Scaled", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyTiePointGrid_setLog10Scaled", &_thisType, &_this, &log10Scaled)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isScalingApplied", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyTiePointGrid_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classTiePointGrid, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isNoDataValueSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_clearNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isNoDataValueUsed", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyTiePointGrid_setNoDataValueUsed", &_thisType, &_this, &noDataValueUsed)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_setNoDataValue", &_thisType, &_this, &noDataValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getGeophysicalNoDataValue", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_setGeophysicalNoDataValue", &_thisType, &_this, &noDataValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getValidPixelExpression", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyTiePointGrid_setValidPixelExpression", &_thisType, &_this, &validPixelExpression)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isValidMaskUsed", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_resetValidMask", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getValidMaskExpression", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyTiePointGrid_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_hasRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setRasterData", &_thisType, &_this, &rasterDataType, &rasterData)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_loadRasterData1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_loadRasterData2", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_unloadRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_isPixelValid2", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getSampleInt", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getSampleFloat", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint pixelIndex = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyTiePointGrid_isPixelValid1", &_thisType, &_this, &pixelIndex)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, pixelIndex);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    const char* roiType = NULL;
    unsigned PY_LONG_LONG roi = 0;
    jobject roiJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(IILjavax/media/jai/ROI;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):BeamPyTiePointGrid_isPixelValid3", &_thisType, &_this, &x, &y, &roiType, &roi)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    roiJObj = (jobject) roi;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y, roiJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_getPixels5", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_getPixels3", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_getPixels1", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_readPixels5", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_readPixels3", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_readPixels1", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    _resultPyObj = beampy_newPyObjectFromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_writePixels5", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_writePixels3", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_writePixels1", &_thisType, &_this, &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pixelsPyObj = beampy_getPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = beampy_newJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:BeamPyTiePointGrid_readValidMask", &_thisType, &_this, &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    validMaskPyObj = beampy_getPrimitiveArrayBufferReadOnly(validMaskPyObj, &validMaskBuf, "b", -1);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = beampy_newJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    _resultPyObj = beampy_newPyObjectFromJBooleanArray((jarray) _resultJObj);
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_readRasterDataFully1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):BeamPyTiePointGrid_readRasterData1", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_writeRasterDataFully1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):BeamPyTiePointGrid_writeRasterData1", &_thisType, &_this, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_createCompatibleRasterData1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_createCompatibleSceneRasterData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_createCompatibleRasterData2", &_thisType, &_this, &width, &height)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:BeamPyTiePointGrid_isCompatibleRasterData", &_thisType, &_this, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* rasterDataType = NULL;
    unsigned PY_LONG_LONG rasterData = 0;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:BeamPyTiePointGrid_checkCompatibleRasterData", &_thisType, &_this, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    rasterDataJObj = (jobject) rasterData;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_hasIntPixels", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* shapeType = NULL;
    unsigned PY_LONG_LONG shape = 0;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_createTransectProfileData", &_thisType, &_this, &shapeType, &shape)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    shapeJObj = (jobject) shape;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TransectProfileData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getImageInfo1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* imageInfoType = NULL;
    unsigned PY_LONG_LONG imageInfo = 0;
    jobject imageInfoJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setImageInfo", &_thisType, &_this, &imageInfoType, &imageInfo)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    imageInfoJObj = (jobject) imageInfo;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_fireImageInfoChanged", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "(Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_getImageInfo2", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O(sK):BeamPyTiePointGrid_getImageInfo3", &_thisType, &_this, &histoSkipAreasPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    histoSkipAreasPyObj = beampy_getPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = beampy_newJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O(sK):BeamPyTiePointGrid_createDefaultImageInfo1", &_thisType, &_this, &histoSkipAreasPyObj, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    histoSkipAreasPyObj = beampy_getPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = beampy_newJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    const char* histogramType = NULL;
    unsigned PY_LONG_LONG histogram = 0;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O(sK):BeamPyTiePointGrid_createDefaultImageInfo2", &_thisType, &_this, &histoSkipAreasPyObj, &histogramType, &histogram)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    histoSkipAreasPyObj = beampy_getPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = beampy_newJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    histogramJObj = (jobject) histogram;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getOverlayMaskGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_createColorIndexedImage", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_createRgbImage", &_thisType, &_this, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDDLcom/bc/ceres/core/ProgressMonitor;)[B", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ddd(sK):BeamPyTiePointGrid_quantizeRasterData1", &_thisType, &_this, &newMin, &newMax, &gamma, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJByteArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    jbyte* samplesData = NULL;
    int samplesLength = 0;
    PyObject* samplesPyObj = NULL;
    Py_buffer samplesBuf;
    jarray samplesJObj = NULL;
    jint offset = (jint) 0;
    jint stride = (jint) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDD[BIILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)dddOii(sK):BeamPyTiePointGrid_quantizeRasterData2", &_thisType, &_this, &newMin, &newMax, &gamma, &samplesPyObj, &offset, &stride, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    samplesPyObj = beampy_getPrimitiveArrayBufferReadOnly(samplesPyObj, &samplesBuf, "b", -1);
    if (samplesPyObj == NULL) {
        return NULL;
    }
    samplesData = (jbyte*) samplesBuf.buf;
    samplesLength = samplesBuf.len / samplesBuf.itemsize;
    samplesJObj = beampy_newJByteArrayFromBuffer(samplesData, samplesLength);
    if (samplesJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, samplesJObj, offset, stride, pmJObj);
    PyBuffer_Release(&samplesBuf);
    (*jenv)->DeleteLocalRef(jenv, samplesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    const char* roiType = NULL;
    unsigned PY_LONG_LONG roi = 0;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyTiePointGrid_createPixelValidator", &_thisType, &_this, &lineOffset, &roiType, &roi)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    roiJObj = (jobject) roi;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexValidator");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "scale", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_scale", &_thisType, &_this, &v)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyTiePointGrid_scaleInverse", &_thisType, &_this, &v)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyTiePointGrid_getPixelString", &_thisType, &_this, &x, &y)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isSourceImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getSourceImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* sourceImageType = NULL;
    unsigned PY_LONG_LONG sourceImage = 0;
    jobject sourceImageJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Ljava/awt/image/RenderedImage;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setSourceImage2", &_thisType, &_this, &sourceImageType, &sourceImage)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    sourceImageJObj = (jobject) sourceImage;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* sourceImageType = NULL;
    unsigned PY_LONG_LONG sourceImage = 0;
    jobject sourceImageJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Lcom/bc/ceres/glevel/MultiLevelImage;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setSourceImage1", &_thisType, &_this, &sourceImageType, &sourceImage)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    sourceImageJObj = (jobject) sourceImage;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isGeophysicalImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getGeophysicalImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isValidMaskImageSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getValidMaskImage", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MultiLevelImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isStxSet", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getStx1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Stx");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean accurate = (jboolean) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "(ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b(sK):BeamPyTiePointGrid_getStx2", &_thisType, &_this, &accurate, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, accurate, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Stx");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* stxType = NULL;
    unsigned PY_LONG_LONG stx = 0;
    jobject stxJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setStx", &_thisType, &_this, &stxType, &stx)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    stxJObj = (jobject) stx;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getValidShape", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Shape");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getRoiMaskGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDataType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getNumDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setData", &_thisType, &_this, &dataType, &data)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    dataJObj = (jobject) data;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elemsType = NULL;
    unsigned PY_LONG_LONG elems = 0;
    jobject elemsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_setDataElems", &_thisType, &_this, &elemsType, &elems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elemsJObj = (jobject) elems;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDataElemSize", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyTiePointGrid_setReadOnly", &_thisType, &_this, &readOnly)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isReadOnly", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyTiePointGrid_setUnit", &_thisType, &_this, &unit)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getUnit", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isSynthetic", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyTiePointGrid_setSynthetic", &_thisType, &_this, &synthetic)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_fireProductNodeDataChanged", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_getRawStorageSize2", &_thisType, &_this, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    subsetDefJObj = (jobject) subsetDef;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyTiePointGrid_createCompatibleProductData", &_thisType, &_this, &numElems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyTiePointGrid_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyTiePointGrid_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyTiePointGrid_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classTiePointGrid, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyTiePointGrid_getRawStorageSize1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyTiePointGrid_fireProductNodeChanged1", &_thisType, &_this, &propertyName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    const char* oldValueType = NULL;
    unsigned PY_LONG_LONG oldValue = 0;
    jobject oldValueJObj = NULL;
    const char* newValueType = NULL;
    unsigned PY_LONG_LONG newValue = 0;
    jobject newValueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK)(sK):BeamPyTiePointGrid_fireProductNodeChanged2", &_thisType, &_this, &propertyName, &oldValueType, &oldValue, &newValueType, &newValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    oldValueJObj = (jobject) oldValue;
    newValueJObj = (jobject) newValue;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classTiePointGrid, "org.esa.beam.framework.datamodel.TiePointGrid", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyTiePointGrid_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble azimuth = (jdouble) 0;
    jdouble zenith = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:BeamPyAngularDirection_newAngularDirection", &azimuth, &zenith)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classAngularDirection, _method, azimuth, zenith);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "AngularDirection");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* objType = NULL;
    unsigned PY_LONG_LONG obj = 0;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyAngularDirection_equals", &_thisType, &_this, &objType, &obj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    objJObj = (jobject) obj;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classAngularDirection, "org.esa.beam.framework.datamodel.AngularDirection", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyAngularDirection_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyFlagCoding_newFlagCoding", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classFlagCoding, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "FlagCoding");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlag", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_getFlag", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getFlagNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint flagMask = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addFlag", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sis:BeamPyFlagCoding_addFlag", &_thisType, &_this, &name, &flagMask, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, flagMask, descriptionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagMask", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_getFlagMask", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_addElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_addAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sis:BeamPyFlagCoding_addSample", &_thisType, &_this, &name, &value, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getSampleCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyFlagCoding_getSampleName", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyFlagCoding_getSampleValue", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getElementGroup", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getParentElement", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyFlagCoding_addElementAt", &_thisType, &_this, &elementType, &element, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_removeElement", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getNumElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyFlagCoding_getElementAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getElementNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getElements", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_getElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_containsElement", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_getElementIndex", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_removeAttribute", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getNumAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyFlagCoding_getAttributeAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getAttributeNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getAttributes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_getAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_containsAttribute", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* attributeType = NULL;
    unsigned PY_LONG_LONG attribute = 0;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_getAttributeIndex", &_thisType, &_this, &attributeType, &attribute)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    attributeJObj = (jobject) attribute;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyFlagCoding_getAttributeDouble", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValueType = NULL;
    unsigned PY_LONG_LONG defaultValue = 0;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyFlagCoding_getAttributeUTC", &_thisType, &_this, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj = (jobject) defaultValue;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyFlagCoding_getAttributeInt", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)si:BeamPyFlagCoding_setAttributeInt", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)sd:BeamPyFlagCoding_setAttributeDouble", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* valueType = NULL;
    unsigned PY_LONG_LONG value = 0;
    jobject valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData/UTC;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s(sK):BeamPyFlagCoding_setAttributeUTC", &_thisType, &_this, &name, &valueType, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj = (jobject) value;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyFlagCoding_getAttributeString", &_thisType, &_this, &name, &defaultValue)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyFlagCoding_setAttributeString", &_thisType, &_this, &name, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyFlagCoding_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_createDeepClone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyFlagCoding_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyFlagCoding_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classFlagCoding, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyFlagCoding_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyFlagCoding_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classFlagCoding, "org.esa.beam.framework.datamodel.FlagCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyFlagCoding_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getReaderPlugIn", "()Lorg/esa/beam/framework/dataio/ProductReaderPlugIn;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductReader_getReaderPlugIn", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReaderPlugIn");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getInput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductReader_getInput", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "getSubsetDef", "()Lorg/esa/beam/framework/dataio/ProductSubsetDef;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductReader_getSubsetDef", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductSubsetDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    const char* subsetDefType = NULL;
    unsigned PY_LONG_LONG subsetDef = 0;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "readProductNodes", "(Ljava/lang/Object;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProductReader_readProductNodes", &_thisType, &_this, &inputType, &input, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    inputJObj = (jobject) input;
    subsetDefJObj = (jobject) subsetDef;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, inputJObj, subsetDefJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* destBandType = NULL;
    unsigned PY_LONG_LONG destBand = 0;
    jobject destBandJObj = NULL;
    jint destOffsetX = (jint) 0;
    jint destOffsetY = (jint) 0;
    jint destWidth = (jint) 0;
    jint destHeight = (jint) 0;
    const char* destBufferType = NULL;
    unsigned PY_LONG_LONG destBuffer = 0;
    jobject destBufferJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "readBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)iiii(sK)(sK):BeamPyProductReader_readBandRasterData", &_thisType, &_this, &destBandType, &destBand, &destOffsetX, &destOffsetY, &destWidth, &destHeight, &destBufferType, &destBuffer, &pmType, &pm)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    destBandJObj = (jobject) destBand;
    destBufferJObj = (jobject) destBuffer;
    pmJObj = (jobject) pm;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, destBandJObj, destOffsetX, destOffsetY, destWidth, destHeight, destBufferJObj, pmJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductReader, "org.esa.beam.framework.dataio.ProductReader", "close", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductReader_close", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classRGBChannelDef, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "RGBChannelDef");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyRGBChannelDef_getSourceName", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* sourceName = NULL;
    jstring sourceNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceName", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)is:BeamPyRGBChannelDef_setSourceName", &_thisType, &_this, &index, &sourceName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    sourceNameJObj =(*jenv)->NewStringUTF(jenv, sourceName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, sourceNameJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyRGBChannelDef_getSourceNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* bandNamesPyObj = NULL;
    jarray bandNamesJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)O:BeamPyRGBChannelDef_setSourceNames", &_thisType, &_this, &bandNamesPyObj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    bandNamesJObj = beampy_newJStringArrayFromPySeq(bandNamesPyObj);
    if (bandNamesJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandNamesJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNamesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "isAlphaUsed", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyRGBChannelDef_isAlphaUsed", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "isGammaUsed", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyRGBChannelDef_isGammaUsed", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getGamma", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyRGBChannelDef_getGamma", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble gamma = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setGamma", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)id:BeamPyRGBChannelDef_setGamma", &_thisType, &_this, &index, &gamma)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, gamma);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMinDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyRGBChannelDef_getMinDisplaySample", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble min = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMinDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)id:BeamPyRGBChannelDef_setMinDisplaySample", &_thisType, &_this, &index, &min)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, min);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMaxDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyRGBChannelDef_getMaxDisplaySample", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble max = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMaxDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)id:BeamPyRGBChannelDef_setMaxDisplaySample", &_thisType, &_this, &index, &max)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, max);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classRGBChannelDef, "org.esa.beam.framework.datamodel.RGBChannelDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyRGBChannelDef_clone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_createInstance1", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:BeamPyProductData_createInstance2", &type, &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type, numElems);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(ILjava/lang/Object;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i(sK):BeamPyProductData_createInstance3", &type, &dataType, &data)) {
        return NULL;
    }
    dataJObj = (jobject) data;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type, dataJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance5", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance1", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance10", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance3", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance8", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createUnsignedInstance2", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jlong* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([J)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance9", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "l", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jlong*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJLongArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* strData = NULL;
    jstring strDataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductData_createInstance4", &strData)) {
        return NULL;
    }
    strDataJObj =(*jenv)->NewStringUTF(jenv, strData);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, strDataJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, strDataJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([F)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance7", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "f", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jfloat*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJFloatArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([D)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductData_createInstance6", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = beampy_getPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "d", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jdouble*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = beampy_newJDoubleArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, elemsJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getType1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "(I)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_getElemSize2", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductData, _method, type);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemSize1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "(I)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_getTypeString2", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductData, _method, type);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getType", "(Ljava/lang/String;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductData_getType2", &type)) {
        return NULL;
    }
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductData, _method, typeJObj);
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getTypeString1", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isInt", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_isInt", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isSigned", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_isSigned", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isUnsigned", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_isUnsigned", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isUIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isUIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isFloatingPointType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:BeamPyProductData_isFloatingPointType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductData, _method, type);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "isScalar", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_isScalar", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getNumElems", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getNumElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemInt", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemInt", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemUInt", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemUInt", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemFloat", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemFloat", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemDouble", "()D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemDouble", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemBoolean", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElemBoolean", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemIntAt", "(I)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemIntAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemUIntAt", "(I)J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemUIntAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, index);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemFloatAt", "(I)F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemFloatAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemDoubleAt", "(I)D", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemDoubleAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemStringAt", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemStringAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElemBooleanAt", "(I)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_getElemBooleanAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint value = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemInt", "(I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductData_setElemInt", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong value = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemUInt", "(J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)L:BeamPyProductData_setElemUInt", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat value = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemFloat", "(F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)f:BeamPyProductData_setElemFloat", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemDouble", "(D)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyProductData_setElemDouble", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemString", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductData_setElemString", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean value = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemBoolean", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyProductData_setElemBoolean", &_thisType, &_this, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint value = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemIntAt", "(II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyProductData_setElemIntAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong value = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemUIntAt", "(IJ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iL:BeamPyProductData_setElemUIntAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat value = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemFloatAt", "(IF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)if:BeamPyProductData_setElemFloatAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble value = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemDoubleAt", "(ID)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)id:BeamPyProductData_setElemDoubleAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemStringAt", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)is:BeamPyProductData_setElemStringAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, valueJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean value = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElemBooleanAt", "(IZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ib:BeamPyProductData_setElemBooleanAt", &_thisType, &_this, &index, &value)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "getElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_getElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "setElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductData_setElems", &_thisType, &_this, &dataType, &data)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    dataJObj = (jobject) data;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(Ljavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductData_readFrom4", &_thisType, &_this, &inputType, &input)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    inputJObj = (jobject) input;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(ILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyProductData_readFrom3", &_thisType, &_this, &pos, &inputType, &input)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    inputJObj = (jobject) input;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):BeamPyProductData_readFrom1", &_thisType, &_this, &startPos, &numElems, &inputType, &input)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    inputJObj = (jobject) input;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    const char* inputType = NULL;
    unsigned PY_LONG_LONG input = 0;
    jobject inputJObj = NULL;
    jlong inputPos = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)L:BeamPyProductData_readFrom2", &_thisType, &_this, &startPos, &numElems, &inputType, &input, &inputPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    inputJObj = (jobject) input;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj, inputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(Ljavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductData_writeTo4", &_thisType, &_this, &outputType, &output)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(ILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyProductData_writeTo3", &_thisType, &_this, &pos, &outputType, &output)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):BeamPyProductData_writeTo1", &_thisType, &_this, &startPos, &numElems, &outputType, &output)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    const char* outputType = NULL;
    unsigned PY_LONG_LONG output = 0;
    jobject outputJObj = NULL;
    jlong outputPos = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;J)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)L:BeamPyProductData_writeTo2", &_thisType, &_this, &startPos, &numElems, &outputType, &output, &outputPos)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    outputJObj = (jobject) output;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj, outputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_hashCode", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* otherType = NULL;
    unsigned PY_LONG_LONG other = 0;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductData_equals", &_thisType, &_this, &otherType, &other)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    otherJObj = (jobject) other;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* otherType = NULL;
    unsigned PY_LONG_LONG other = 0;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "equalElems", "(Lorg/esa/beam/framework/datamodel/ProductData;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductData_equalElems", &_thisType, &_this, &otherType, &other)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    otherJObj = (jobject) other;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductData, "org.esa.beam.framework.datamodel.ProductData", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductData_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:BeamPyGeoPos_newGeoPos", &lat, &lon)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classGeoPos, _method, lat, lon);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLat", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_getLat", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLon", "()F", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_getLon", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ff:BeamPyGeoPos_setLocation", &_thisType, &_this, &lat, &lon)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, lat, lon);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_isValid", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* aPyObj = NULL;
    jarray aJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "areValid", "([Lorg/esa/beam/framework/datamodel/GeoPos;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyGeoPos_areValid", &aPyObj)) {
        return NULL;
    }
    aJObj = beampy_newJObjectArrayFromPySeq(aPyObj, "GeoPos");
    if (aJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classGeoPos, _method, aJObj);
    (*jenv)->DeleteLocalRef(jenv, aJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_setInvalid", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* objType = NULL;
    unsigned PY_LONG_LONG obj = 0;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyGeoPos_equals", &_thisType, &_this, &objType, &obj)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    objJObj = (jobject) obj;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_hashCode", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "normalize", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_normalize", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat lon = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "normalizeLon", "(F)F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:BeamPyGeoPos_normalizeLon", &lon)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticFloatMethod(jenv, classGeoPos, _method, lon);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLatString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_getLatString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classGeoPos, "org.esa.beam.framework.datamodel.GeoPos", "getLonString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyGeoPos_getLonString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductNodeGroup_newProductNodeGroup", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, classProductNodeGroup, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNodeGroup");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_isTakingOverNodeOwnership", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getNodeCount", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductNodeGroup_getAt", &_thisType, &_this, &index)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getNodeDisplayNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getNodeNames", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_indexOfName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elementType = NULL;
    unsigned PY_LONG_LONG element = 0;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_indexOf", &_thisType, &_this, &elementType, &element)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elementJObj = (jobject) element;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_getByDisplayName", &_thisType, &_this, &displayName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_get", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_containsName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_contains", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_add", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i(sK):BeamPyProductNodeGroup_addAt", &_thisType, &_this, &index, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* nodeType = NULL;
    unsigned PY_LONG_LONG node = 0;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_remove", &_thisType, &_this, &nodeType, &node)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nodeJObj = (jobject) node;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_removeAll", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_clearRemovedList", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getRemovedNodes", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Collection");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyProductNodeGroup_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyProductNodeGroup_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyProductNodeGroup_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyProductNodeGroup_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductNodeGroup, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductNodeGroup_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductNodeGroup, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductNodeGroup_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, classProductUtils, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductUtils");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    jboolean assignMissingImageInfos = (jboolean) 0;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createImageInfo", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Ob(sK):BeamPyProductUtils_createImageInfo", &rastersPyObj, &assignMissingImageInfos, &pmType, &pm)) {
        return NULL;
    }
    rastersJObj = beampy_newJObjectArrayFromPySeq(rastersPyObj, "RasterDataNode");
    if (rastersJObj == NULL) {
        return NULL;
    }
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rastersJObj, assignMissingImageInfos, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ImageInfo");
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    const char* imageInfoType = NULL;
    unsigned PY_LONG_LONG imageInfo = 0;
    jobject imageInfoJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRgbImage", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/ImageInfo;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O(sK)(sK):BeamPyProductUtils_createRgbImage", &rastersPyObj, &imageInfoType, &imageInfo, &pmType, &pm)) {
        return NULL;
    }
    rastersJObj = beampy_newJObjectArrayFromPySeq(rastersPyObj, "RasterDataNode");
    if (rastersJObj == NULL) {
        return NULL;
    }
    imageInfoJObj = (jobject) imageInfo;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rastersJObj, imageInfoJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rasterDataNodeType = NULL;
    unsigned PY_LONG_LONG rasterDataNode = 0;
    jobject rasterDataNodeJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createColorIndexedImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_createColorIndexedImage", &rasterDataNodeType, &rasterDataNode, &pmType, &pm)) {
        return NULL;
    }
    rasterDataNodeJObj = (jobject) rasterDataNode;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterDataNodeJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    const char* mapProjectionType = NULL;
    unsigned PY_LONG_LONG mapProjection = 0;
    jobject mapProjectionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProductUtils_createSuitableMapInfo1", &productType, &product, &rectType, &rect, &mapProjectionType, &mapProjection)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    mapProjectionJObj = (jobject) mapProjection;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapProjectionJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MapInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* mapProjectionType = NULL;
    unsigned PY_LONG_LONG mapProjection = 0;
    jobject mapProjectionJObj = NULL;
    jdouble orientation = (jdouble) 0;
    jdouble noDataValue = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;DD)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)dd:BeamPyProductUtils_createSuitableMapInfo2", &productType, &product, &mapProjectionType, &mapProjection, &orientation, &noDataValue)) {
        return NULL;
    }
    productJObj = (jobject) product;
    mapProjectionJObj = (jobject) mapProjection;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, mapProjectionJObj, orientation, noDataValue);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MapInfo");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    const char* mapTransformType = NULL;
    unsigned PY_LONG_LONG mapTransform = 0;
    jobject mapTransformJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getOutputRasterSize", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;DD)Ljava/awt/Dimension;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)dd:BeamPyProductUtils_getOutputRasterSize", &productType, &product, &rectType, &rect, &mapTransformType, &mapTransform, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    mapTransformJObj = (jobject) mapTransform;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapTransformJObj, pixelSizeX, pixelSizeY);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Dimension");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    const char* mapTransformType = NULL;
    unsigned PY_LONG_LONG mapTransform = 0;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProductUtils_createMapEnvelope2", &productType, &product, &rectType, &rect, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    mapTransformJObj = (jobject) mapTransform;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, mapTransformJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Point2D");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    const char* mapTransformType = NULL;
    unsigned PY_LONG_LONG mapTransform = 0;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i(sK):BeamPyProductUtils_createMapEnvelope1", &productType, &product, &rectType, &rect, &step, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    mapTransformJObj = (jobject) mapTransform;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, mapTransformJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Point2D");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* boundaryPyObj = NULL;
    jarray boundaryJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getMinMax", "([Ljava/awt/geom/Point2D;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getMinMax", &boundaryPyObj)) {
        return NULL;
    }
    boundaryJObj = beampy_newJObjectArrayFromPySeq(boundaryPyObj, "Point2D");
    if (boundaryJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, boundaryJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Point2D");
    (*jenv)->DeleteLocalRef(jenv, boundaryJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    const char* mapTransformType = NULL;
    unsigned PY_LONG_LONG mapTransform = 0;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createMapBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i(sK):BeamPyProductUtils_createMapBoundary", &productType, &product, &rectType, &rect, &step, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    mapTransformJObj = (jobject) mapTransform;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, mapTransformJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "Point2D");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductUtils_createGeoBoundary1", &productType, &product, &step)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyProductUtils_createGeoBoundary2", &productType, &product, &regionType, &region, &step)) {
        return NULL;
    }
    productJObj = (jobject) product;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ib:BeamPyProductUtils_createGeoBoundary3", &productType, &product, &regionType, &region, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = (jobject) product;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step, usePixelCenter);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getClosestGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* gcType = NULL;
    unsigned PY_LONG_LONG gc = 0;
    jobject gcJObj = NULL;
    const char* origPosType = NULL;
    unsigned PY_LONG_LONG origPos = 0;
    jobject origPosJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getClosestGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoCoding;Lorg/esa/beam/framework/datamodel/PixelPos;Ljava/awt/Rectangle;I)Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)i:BeamPyProductUtils_getClosestGeoPos", &gcType, &gc, &origPosType, &origPos, &regionType, &region, &step)) {
        return NULL;
    }
    gcJObj = (jobject) gc;
    origPosJObj = (jobject) origPos;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, gcJObj, origPosJObj, regionJObj, step);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rasterType = NULL;
    unsigned PY_LONG_LONG raster = 0;
    jobject rasterJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyProductUtils_createGeoBoundary4", &rasterType, &raster, &regionType, &region, &step)) {
        return NULL;
    }
    rasterJObj = (jobject) raster;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, regionJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_createGeoBoundaryPaths1", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyProductUtils_createGeoBoundaryPaths2", &productType, &product, &regionType, &region, &step)) {
        return NULL;
    }
    productJObj = (jobject) product;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* regionType = NULL;
    unsigned PY_LONG_LONG region = 0;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ib:BeamPyProductUtils_createGeoBoundaryPaths3", &productType, &product, &regionType, &region, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = (jobject) product;
    regionJObj = (jobject) region;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, regionJObj, step, usePixelCenter);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyProductUtils_createPixelBoundary1", &productType, &product, &rectType, &rect, &step)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)ib:BeamPyProductUtils_createPixelBoundary2", &productType, &product, &rectType, &rect, &step, &usePixelCenter)) {
        return NULL;
    }
    productJObj = (jobject) product;
    rectJObj = (jobject) rect;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, rectJObj, step, usePixelCenter);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rasterType = NULL;
    unsigned PY_LONG_LONG raster = 0;
    jobject rasterJObj = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:BeamPyProductUtils_createPixelBoundary3", &rasterType, &raster, &rectType, &rect, &step)) {
        return NULL;
    }
    rasterJObj = (jobject) raster;
    rectJObj = (jobject) rect;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, rectJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyProductUtils_createRectBoundary1", &rectType, &rect, &step)) {
        return NULL;
    }
    rectJObj = (jobject) rect;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rectJObj, step);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rectType = NULL;
    unsigned PY_LONG_LONG rect = 0;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ib:BeamPyProductUtils_createRectBoundary2", &rectType, &rect, &step, &usePixelCenter)) {
        return NULL;
    }
    rectJObj = (jobject) rect;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rectJObj, step, usePixelCenter);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceType = NULL;
    unsigned PY_LONG_LONG source = 0;
    jobject sourceJObj = NULL;
    const char* targetType = NULL;
    unsigned PY_LONG_LONG target = 0;
    jobject targetJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagCodings", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyFlagCodings", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    sourceJObj = (jobject) source;
    targetJObj = (jobject) target;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceFlagCodingType = NULL;
    unsigned PY_LONG_LONG sourceFlagCoding = 0;
    jobject sourceFlagCodingJObj = NULL;
    const char* targetType = NULL;
    unsigned PY_LONG_LONG target = 0;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagCoding", "(Lorg/esa/beam/framework/datamodel/FlagCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/FlagCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyFlagCoding", &sourceFlagCodingType, &sourceFlagCoding, &targetType, &target)) {
        return NULL;
    }
    sourceFlagCodingJObj = (jobject) sourceFlagCoding;
    targetJObj = (jobject) target;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceFlagCodingJObj, targetJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "FlagCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceIndexCodingType = NULL;
    unsigned PY_LONG_LONG sourceIndexCoding = 0;
    jobject sourceIndexCodingJObj = NULL;
    const char* targetType = NULL;
    unsigned PY_LONG_LONG target = 0;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyIndexCoding", "(Lorg/esa/beam/framework/datamodel/IndexCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/IndexCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyIndexCoding", &sourceIndexCodingType, &sourceIndexCoding, &targetType, &target)) {
        return NULL;
    }
    sourceIndexCodingJObj = (jobject) sourceIndexCoding;
    targetJObj = (jobject) target;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceIndexCodingJObj, targetJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "IndexCoding");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyMasks", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyOverlayMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyOverlayMasks", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyRoiMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyRoiMasks", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)b:BeamPyProductUtils_copyFlagBands2", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, copySourceImage);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyFlagBands1", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* gridName = NULL;
    jstring gridNameJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyTiePointGrid", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)(sK):BeamPyProductUtils_copyTiePointGrid", &gridName, &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    gridNameJObj =(*jenv)->NewStringUTF(jenv, gridName);
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, gridNameJObj, sourceProductJObj, targetProductJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "TiePointGrid");
    (*jenv)->DeleteLocalRef(jenv, gridNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)(sK)b:BeamPyProductUtils_copyBand4", &sourceBandName, &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj, copySourceImage);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)s(sK)b:BeamPyProductUtils_copyBand2", &sourceBandName, &sourceProductType, &sourceProduct, &targetBandName, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = (jobject) sourceProduct;
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    targetProductJObj = (jobject) targetProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj, copySourceImage);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceRasterType = NULL;
    unsigned PY_LONG_LONG sourceRaster = 0;
    jobject sourceRasterJObj = NULL;
    const char* targetRasterType = NULL;
    unsigned PY_LONG_LONG targetRaster = 0;
    jobject targetRasterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyRasterDataNodeProperties", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/RasterDataNode;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyRasterDataNodeProperties", &sourceRasterType, &sourceRaster, &targetRasterType, &targetRaster)) {
        return NULL;
    }
    sourceRasterJObj = (jobject) sourceRaster;
    targetRasterJObj = (jobject) targetRaster;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceRasterJObj, targetRasterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)(sK):BeamPyProductUtils_copyBand3", &sourceBandName, &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)s(sK):BeamPyProductUtils_copyBand1", &sourceBandName, &sourceProductType, &sourceProduct, &targetBandName, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    sourceProductJObj = (jobject) sourceProduct;
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    targetProductJObj = (jobject) targetProduct;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Band");
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandType = NULL;
    unsigned PY_LONG_LONG sourceBand = 0;
    jobject sourceBandJObj = NULL;
    const char* targetBandType = NULL;
    unsigned PY_LONG_LONG targetBand = 0;
    jobject targetBandJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copySpectralBandProperties", "(Lorg/esa/beam/framework/datamodel/Band;Lorg/esa/beam/framework/datamodel/Band;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copySpectralBandProperties", &sourceBandType, &sourceBand, &targetBandType, &targetBand)) {
        return NULL;
    }
    sourceBandJObj = (jobject) sourceBand;
    targetBandJObj = (jobject) targetBand;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceBandJObj, targetBandJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyGeoCoding", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyGeoCoding", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyTiePointGrids", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyTiePointGrids", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyVectorData", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyVectorData", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_canGetPixelPos1", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductUtils, _method, productJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rasterType = NULL;
    unsigned PY_LONG_LONG raster = 0;
    jobject rasterJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_canGetPixelPos2", &rasterType, &raster)) {
        return NULL;
    }
    rasterJObj = (jobject) raster;
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classProductUtils, _method, rasterJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* raster1Type = NULL;
    unsigned PY_LONG_LONG raster1 = 0;
    jobject raster1JObj = NULL;
    jfloat sampleMin1 = (jfloat) 0;
    jfloat sampleMax1 = (jfloat) 0;
    const char* raster2Type = NULL;
    unsigned PY_LONG_LONG raster2 = 0;
    jobject raster2JObj = NULL;
    jfloat sampleMin2 = (jfloat) 0;
    jfloat sampleMax2 = (jfloat) 0;
    const char* roiMaskType = NULL;
    unsigned PY_LONG_LONG roiMask = 0;
    jobject roiMaskJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    const char* backgroundType = NULL;
    unsigned PY_LONG_LONG background = 0;
    jobject backgroundJObj = NULL;
    const char* imageType = NULL;
    unsigned PY_LONG_LONG image = 0;
    jobject imageJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createDensityPlotImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/Mask;IILjava/awt/Color;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ff(sK)ff(sK)ii(sK)(sK)(sK):BeamPyProductUtils_createDensityPlotImage", &raster1Type, &raster1, &sampleMin1, &sampleMax1, &raster2Type, &raster2, &sampleMin2, &sampleMax2, &roiMaskType, &roiMask, &width, &height, &backgroundType, &background, &imageType, &image, &pmType, &pm)) {
        return NULL;
    }
    raster1JObj = (jobject) raster1;
    raster2JObj = (jobject) raster2;
    roiMaskJObj = (jobject) roiMask;
    backgroundJObj = (jobject) background;
    imageJObj = (jobject) image;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, raster1JObj, sampleMin1, sampleMax1, raster2JObj, sampleMin2, sampleMax2, roiMaskJObj, width, height, backgroundJObj, imageJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* rasterType = NULL;
    unsigned PY_LONG_LONG raster = 0;
    jobject rasterJObj = NULL;
    const char* overlayBImType = NULL;
    unsigned PY_LONG_LONG overlayBIm = 0;
    jobject overlayBImJObj = NULL;
    const char* pmType = NULL;
    unsigned PY_LONG_LONG pm = 0;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "overlayMasks", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):BeamPyProductUtils_overlayMasks", &rasterType, &raster, &overlayBImType, &overlayBIm, &pmType, &pm)) {
        return NULL;
    }
    rasterJObj = (jobject) raster;
    overlayBImJObj = (jobject) overlayBIm;
    pmJObj = (jobject) pm;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, rasterJObj, overlayBImJObj, pmJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "BufferedImage");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getCenterGeoPos", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_getCenterGeoPos", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_normalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = beampy_newJObjectArrayFromPySeq(polygonPyObj, "GeoPos");
    if (polygonJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon_old", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_normalizeGeoPolygon_old", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = beampy_newJObjectArrayFromPySeq(polygonPyObj, "GeoPos");
    if (polygonJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_denormalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = beampy_newJObjectArrayFromPySeq(polygonPyObj, "GeoPos");
    if (polygonJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_denormalizeGeoPos", &geoPosType, &geoPos)) {
        return NULL;
    }
    geoPosJObj = (jobject) geoPos;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* geoPosType = NULL;
    unsigned PY_LONG_LONG geoPos = 0;
    jobject geoPosJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos_old", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_denormalizeGeoPos_old", &geoPosType, &geoPos)) {
        return NULL;
    }
    geoPosJObj = (jobject) geoPos;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, geoPosJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getRotationDirection", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getRotationDirection", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = beampy_newJObjectArrayFromPySeq(polygonPyObj, "GeoPos");
    if (polygonJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getAngleSum", "([Lorg/esa/beam/framework/datamodel/GeoPos;)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_getAngleSum", &polygonPyObj)) {
        return NULL;
    }
    polygonJObj = beampy_newJObjectArrayFromPySeq(polygonPyObj, "GeoPos");
    if (polygonJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classProductUtils, _method, polygonJObj);
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* geoPathType = NULL;
    unsigned PY_LONG_LONG geoPath = 0;
    jobject geoPathJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "convertToPixelPath", "(Ljava/awt/geom/GeneralPath;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_convertToPixelPath", &geoPathType, &geoPath, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    geoPathJObj = (jobject) geoPath;
    geoCodingJObj = (jobject) geoCoding;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, geoPathJObj, geoCodingJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* shapeType = NULL;
    unsigned PY_LONG_LONG shape = 0;
    jobject shapeJObj = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "convertToGeoPath", "(Ljava/awt/Shape;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_convertToGeoPath", &shapeType, &shape, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    shapeJObj = (jobject) shape;
    geoCodingJObj = (jobject) geoCoding;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, shapeJObj, geoCodingJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceType = NULL;
    unsigned PY_LONG_LONG source = 0;
    jobject sourceJObj = NULL;
    const char* targetType = NULL;
    unsigned PY_LONG_LONG target = 0;
    jobject targetJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyMetadata2", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    sourceJObj = (jobject) source;
    targetJObj = (jobject) target;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceType = NULL;
    unsigned PY_LONG_LONG source = 0;
    jobject sourceJObj = NULL;
    const char* targetType = NULL;
    unsigned PY_LONG_LONG target = 0;
    jobject targetJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/MetadataElement;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyMetadata1", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    sourceJObj = (jobject) source;
    targetJObj = (jobject) target;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceJObj, targetJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyPreferredTileSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_copyPreferredTileSize", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_createGeoTIFFMetadata2", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoTIFFMetadata");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* geoCodingType = NULL;
    unsigned PY_LONG_LONG geoCoding = 0;
    jobject geoCodingJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/GeoCoding;II)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii:BeamPyProductUtils_createGeoTIFFMetadata1", &geoCodingType, &geoCoding, &width, &height)) {
        return NULL;
    }
    geoCodingJObj = (jobject) geoCoding;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, geoCodingJObj, width, height);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeoTIFFMetadata");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* negativeAreaType = NULL;
    unsigned PY_LONG_LONG negativeArea = 0;
    jobject negativeAreaJObj = NULL;
    jdouble deltaX = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "areaToPath", "(Ljava/awt/geom/Area;D)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyProductUtils_areaToPath", &negativeAreaType, &negativeArea, &deltaX)) {
        return NULL;
    }
    negativeAreaJObj = (jobject) negativeArea;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, negativeAreaJObj, deltaX);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "GeneralPath");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    const char* elemType = NULL;
    unsigned PY_LONG_LONG elem = 0;
    jobject elemJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "addElementToHistory", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyProductUtils_addElementToHistory", &productType, &product, &elemType, &elem)) {
        return NULL;
    }
    productJObj = (jobject) product;
    elemJObj = (jobject) elem;
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, productJObj, elemJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "removeInvalidExpressions", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_removeInvalidExpressions", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = beampy_newPySeqFromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "findSuitableQuicklookBandName", "(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyProductUtils_findSuitableQuicklookBandName", &productType, &product)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceGeoCodingType = NULL;
    unsigned PY_LONG_LONG sourceGeoCoding = 0;
    jobject sourceGeoCodingJObj = NULL;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    const char* destGeoCodingType = NULL;
    unsigned PY_LONG_LONG destGeoCoding = 0;
    jobject destGeoCodingJObj = NULL;
    const char* destAreaType = NULL;
    unsigned PY_LONG_LONG destArea = 0;
    jobject destAreaJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "computeSourcePixelCoordinates", "(Lorg/esa/beam/framework/datamodel/GeoCoding;IILorg/esa/beam/framework/datamodel/GeoCoding;Ljava/awt/Rectangle;)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)(sK):BeamPyProductUtils_computeSourcePixelCoordinates", &sourceGeoCodingType, &sourceGeoCoding, &sourceWidth, &sourceHeight, &destGeoCodingType, &destGeoCoding, &destAreaType, &destArea)) {
        return NULL;
    }
    sourceGeoCodingJObj = (jobject) sourceGeoCoding;
    destGeoCodingJObj = (jobject) destGeoCoding;
    destAreaJObj = (jobject) destArea;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, sourceGeoCodingJObj, sourceWidth, sourceHeight, destGeoCodingJObj, destAreaJObj);
    _resultPyObj = beampy_newPySeqFromJObjectArray((jarray) _resultJObj, "PixelPos");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* pixelPositionsPyObj = NULL;
    jarray pixelPositionsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "computeMinMaxY", "([Lorg/esa/beam/framework/datamodel/PixelPos;)[F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:BeamPyProductUtils_computeMinMaxY", &pixelPositionsPyObj)) {
        return NULL;
    }
    pixelPositionsJObj = beampy_newJObjectArrayFromPySeq(pixelPositionsPyObj, "PixelPos");
    if (pixelPositionsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, pixelPositionsJObj);
    _resultPyObj = beampy_newPyObjectFromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pixelPositionsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* addedRasterDataNodesPyObj = NULL;
    jobject addedRasterDataNodesJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;DLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)dO:BeamPyProductUtils_copyBandsForGeomTransform1", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &defaultNoDataValue, &addedRasterDataNodesPyObj)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    addedRasterDataNodesJObj = beampy_newJMapFromPyObject(addedRasterDataNodesPyObj);
    if (addedRasterDataNodesJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, defaultNoDataValue, addedRasterDataNodesJObj);
    (*jenv)->DeleteLocalRef(jenv, addedRasterDataNodesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceProductType = NULL;
    unsigned PY_LONG_LONG sourceProduct = 0;
    jobject sourceProductJObj = NULL;
    const char* targetProductType = NULL;
    unsigned PY_LONG_LONG targetProduct = 0;
    jobject targetProductJObj = NULL;
    jboolean includeTiePointGrids = (jboolean) 0;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* targetToSourceMapPyObj = NULL;
    jobject targetToSourceMapJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;ZDLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK)bdO:BeamPyProductUtils_copyBandsForGeomTransform2", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &includeTiePointGrids, &defaultNoDataValue, &targetToSourceMapPyObj)) {
        return NULL;
    }
    sourceProductJObj = (jobject) sourceProduct;
    targetProductJObj = (jobject) targetProduct;
    targetToSourceMapJObj = beampy_newJMapFromPyObject(targetToSourceMapPyObj);
    if (targetToSourceMapJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, classProductUtils, _method, sourceProductJObj, targetProductJObj, includeTiePointGrids, defaultNoDataValue, targetToSourceMapJObj);
    (*jenv)->DeleteLocalRef(jenv, targetToSourceMapJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* productType = NULL;
    unsigned PY_LONG_LONG product = 0;
    jobject productJObj = NULL;
    jdouble y = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getScanLineTime", "(Lorg/esa/beam/framework/datamodel/Product;D)Lorg/esa/beam/framework/datamodel/ProductData/UTC;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)d:BeamPyProductUtils_getScanLineTime", &productType, &product, &y)) {
        return NULL;
    }
    productJObj = (jobject) product;
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, classProductUtils, _method, productJObj, y);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "UTC");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* bandType = NULL;
    unsigned PY_LONG_LONG band = 0;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleDouble", "(Lorg/esa/beam/framework/datamodel/Band;III)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iii:BeamPyProductUtils_getGeophysicalSampleDouble", &bandType, &band, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    bandJObj = (jobject) band;
    _result = (*jenv)->CallStaticDoubleMethod(jenv, classProductUtils, _method, bandJObj, pixelX, pixelY, level);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* bandType = NULL;
    unsigned PY_LONG_LONG band = 0;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classProductUtils, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleLong", "(Lorg/esa/beam/framework/datamodel/Band;III)J", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)iii:BeamPyProductUtils_getGeophysicalSampleLong", &bandType, &band, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    bandJObj = (jobject) band;
    _result = (*jenv)->CallStaticLongMethod(jenv, classProductUtils, _method, bandJObj, pixelX, pixelY, level);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "<init>", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData;Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s(sK)b:BeamPyMetadataAttribute_newMetadataAttribute", &name, &dataType, &data, &readOnly)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    dataJObj = (jobject) data;
    _resultJObj = (*jenv)->NewObject(jenv, classMetadataAttribute, _method, nameJObj, dataJObj, readOnly);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getParentElement", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataElement");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* objectType = NULL;
    unsigned PY_LONG_LONG object = 0;
    jobject objectJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_equals", &_thisType, &_this, &objectType, &object)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    objectJObj = (jobject) object;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objectJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* visitorType = NULL;
    unsigned PY_LONG_LONG visitor = 0;
    jobject visitorJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_acceptVisitor", &_thisType, &_this, &visitorType, &visitor)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    visitorJObj = (jobject) visitor;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_createDeepClone", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "MetadataAttribute");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataType", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getDataType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_isFloatingPointType", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getNumDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* dataType = NULL;
    unsigned PY_LONG_LONG data = 0;
    jobject dataJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_setData", &_thisType, &_this, &dataType, &data)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    dataJObj = (jobject) data;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getData", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* elemsType = NULL;
    unsigned PY_LONG_LONG elems = 0;
    jobject elemsJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_setDataElems", &_thisType, &_this, &elemsType, &elems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    elemsJObj = (jobject) elems;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getDataElems", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getDataElemSize", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyMetadataAttribute_setReadOnly", &_thisType, &_this, &readOnly)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_isReadOnly", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataAttribute_setUnit", &_thisType, &_this, &unit)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getUnit", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_isSynthetic", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyMetadataAttribute_setSynthetic", &_thisType, &_this, &synthetic)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_fireProductNodeDataChanged", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "dispose", "()V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_dispose", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)i:BeamPyMetadataAttribute_createCompatibleProductData", &_thisType, &_this, &numElems)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductData");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getOwner", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductNode");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataAttribute_setName", &_thisType, &_this, &name)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getDescription", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)s:BeamPyMetadataAttribute_setDescription", &_thisType, &_this, &description)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isModified", "()Z", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_isModified", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)b:BeamPyMetadataAttribute_setModified", &_thisType, &_this, &modified)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_toString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:BeamPyMetadataAttribute_isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, classMetadataAttribute, _method, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getProduct", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Product");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getProductReader", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductReader");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getProductWriter", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "ProductWriter");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getDisplayName", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK):BeamPyMetadataAttribute_getProductRefString", &_thisType, &_this)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    _resultPyObj = beampy_newPyStringFromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)ss:BeamPyMetadataAttribute_updateExpression", &_thisType, &_this, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* productWriterType = NULL;
    unsigned PY_LONG_LONG productWriter = 0;
    jobject productWriterJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_removeFromFile", &_thisType, &_this, &productWriterType, &productWriter)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    productWriterJObj = (jobject) productWriter;
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    const char* _thisType = NULL;
    unsigned PY_LONG_LONG _this = 0;
    jobject _thisJObj = NULL;
    const char* arg0Type = NULL;
    unsigned PY_LONG_LONG arg0 = 0;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!beampy_initApi()) {
        return NULL;
    }
    if (!beampy_initJMethod(&_method, classMetadataAttribute, "org.esa.beam.framework.datamodel.MetadataAttribute", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "(sK)(sK):BeamPyMetadataAttribute_getExtension", &_thisType, &_this, &arg0Type, &arg0)) {
        return NULL;
    }
    _thisJObj = (jobject) _this;
    arg0JObj = (jobject) arg0;
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    _resultPyObj = beampy_newPyObjectFromJObject(_resultJObj, "Object");
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}



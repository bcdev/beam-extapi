/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * This code has been generated using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */

// <<<<<<<< Begin include from PyCModuleGenerator-stub-init.c
#include "beampy.h"
#include "../beam_util.h"
#include "../beam_jvm.h"
#include "../beampy_carray.h"
#include "../beampy_jobject.h"
#include "../beampy_jpyutil.h"
#include "../beampy_buffer.h"

static PyObject* BeamPy_Error;

jboolean BPy_InitApi(void);

/**
 * This is a test for Python --> Java conversions.
 * Registered as a beampy-module function 'to_jobject'.
 * In Python, use e.g.: beampy.to_jobject('abc')
 */
PyObject* BPy_to_jobject(PyObject* self, PyObject* args)
{
    jboolean ok = 1;
    PyObject* arg = NULL;
    PyObject* resultPyObj = NULL;
    jobject resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:to_jobject", &arg)) {
        return NULL;
    }
    resultJObj = BPy_ToJObject(arg, &ok);
    if (!ok) {
        return NULL;
    }
    resultPyObj = BPy_FromJObject(&JObject_Type, resultJObj);
    return resultPyObj;
}

#define CHECK_JVM_EXCEPTION(M)              \
    if ((*jenv)->ExceptionCheck(jenv)) {    \
        (*jenv)->ExceptionDescribe(jenv);   \
        (*jenv)->ExceptionClear(jenv);      \
        PyErr_SetString(BeamPy_Error, "Java exception occurred: " M); \
        return NULL;                        \
    }                                       \


// >>>>>>>> End include from PyCModuleGenerator-stub-init.c

PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyJtsGeometryConverter_newJtsGeometryConverter(PyObject* self, PyObject* args);
PyObject* BeamPyJtsGeometryConverter_getValueType(PyObject* self, PyObject* args);
PyObject* BeamPyJtsGeometryConverter_parse(PyObject* self, PyObject* args);
PyObject* BeamPyJtsGeometryConverter_format(PyObject* self, PyObject* args);
PyObject* BeamPyJtsGeometryConverter_registerConverter(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_newProductSubsetDef1(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_newProductSubsetDef2(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getSubsetName(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setSubsetName(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setTreatVirtualBandsAsRealBands(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getTreatVirtualBandsAsRealBands(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_addNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_addNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_removeNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_containsNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_isNodeAccepted(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getRegion(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setRegion2(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setRegion1(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setSubSampling(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_getSceneRasterSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_setIgnoreMetadata(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_isIgnoreMetadata(PyObject* self, PyObject* args);
PyObject* BeamPyProductSubsetDef_isEntireProductSelected(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args);
PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeUTC2(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeUTC1(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeUTC2(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeUTC1(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setAutoGrouping2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setAutoGrouping1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDef1(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDef2(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getHistogramMatching1(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getHistogramMatching2(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_loadOperatorSpis(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_getServiceRegistry(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_getOperatorSpi(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_addOperatorSpi(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_removeOperatorSpi(PyObject* self, PyObject* args);
PyObject* BeamPyOperatorSpiRegistry_setAlias(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_toString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args);
PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scale(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeUTC2(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeUTC1(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyMap_size(PyObject* self, PyObject* args);
PyObject* BeamPyMap_isEmpty(PyObject* self, PyObject* args);
PyObject* BeamPyMap_containsKey(PyObject* self, PyObject* args);
PyObject* BeamPyMap_containsValue(PyObject* self, PyObject* args);
PyObject* BeamPyMap_get(PyObject* self, PyObject* args);
PyObject* BeamPyMap_put(PyObject* self, PyObject* args);
PyObject* BeamPyMap_remove(PyObject* self, PyObject* args);
PyObject* BeamPyMap_putAll(PyObject* self, PyObject* args);
PyObject* BeamPyMap_clear(PyObject* self, PyObject* args);
PyObject* BeamPyMap_keySet(PyObject* self, PyObject* args);
PyObject* BeamPyMap_values(PyObject* self, PyObject* args);
PyObject* BeamPyMap_entrySet(PyObject* self, PyObject* args);
PyObject* BeamPyMap_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMap_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_newSubsetOp(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getBandNames(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setBandNames(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setCopyMetadata(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getRegion(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setRegion(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getGeoRegion(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setGeoRegion(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_update(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_dispose(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getId(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setSourceProducts(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getSourceProduct(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setSourceProduct(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getSourceProductById(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setSourceProductById(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getSourceProductId(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getTargetProduct(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getTargetProperty(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_getParameter(PyObject* self, PyObject* args);
PyObject* BeamPySubsetOp_setParameter(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args);

//
// Global functions of module ${libName}
//
static PyMethodDef BeamPy_Functions[] = {
    {"newRectangle", BPy_NewRectangle, METH_VARARGS, "Creates a Java 'Rectangle' object from x, y, width, height (all integers)"},
    {"newFile", BPy_NewFile, METH_VARARGS, "Creates a Java 'File' object from a given string."},
    {"to_jobject", BPy_to_jobject, METH_VARARGS, "Test function which takes an argument, converts it into a Java object and returns a JObject"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

/* java.lang classes */
jclass BPy_Boolean_Class;
jclass BPy_Byte_Class;
jclass BPy_Character_Class;
jclass BPy_Short_Class;
jclass BPy_Integer_Class;
jclass BPy_Long_Class;
jclass BPy_Float_Class;
jclass BPy_Double_Class;
jclass BPy_String_Class;

/* java.util classes */
jclass BPy_HashMap_Class;
jclass BPy_HashSet_Class;
jclass BPy_ArrayList_Class;

/* BEAM API classes */
jclass BPy_ImageGeometry_Class;
jclass BPy_GeoCoding_Class;
jclass BPy_AffineTransform_Class;
jclass BPy_Mask_Class;
jclass BPy_IndexCoding_Class;
jclass BPy_GPF_Class;
jclass BPy_Class_Class;
jclass BPy_ServiceRegistry_Class;
jclass BPy_PixelPos_Class;
jclass BPy_BitRaster_Class;
jclass BPy_ProductNode_Class;
jclass BPy_Rectangle_Class;
jclass BPy_ProductIO_Class;
jclass BPy_SampleCoding_Class;
jclass BPy_Object_Class;
jclass BPy_ProductReader_Class;
jclass BPy_ProductReaderPlugIn_Class;
jclass BPy_Band_Class;
jclass BPy_ColorPaletteDef_Point_Class;
jclass BPy_Placemark_Class;
jclass BPy_IndexValidator_Class;
jclass BPy_Area_Class;
jclass BPy_ComponentColorModel_Class;
jclass BPy_MathTransform_Class;
jclass BPy_CoordinateReferenceSystem_Class;
jclass BPy_ProductWriterPlugIn_Class;
jclass BPy_IndexColorModel_Class;
jclass BPy_ProductNodeListener_Class;
jclass BPy_MetadataElement_Class;
jclass BPy_Color_Class;
jclass BPy_TransectProfileData_Class;
jclass BPy_PlacemarkGroup_Class;
jclass BPy_Product_Class;
jclass BPy_ProductVisitor_Class;
jclass BPy_WritableNamespace_Class;
jclass BPy_Set_Class;
jclass BPy_MultiLevelImage_Class;
jclass BPy_RenderingHints_Key_Class;
jclass BPy_ROI_Class;
jclass BPy_ProductManager_Listener_Class;
jclass BPy_ColorPaletteDef_Class;
jclass BPy_Geometry_Class;
jclass BPy_ImageInfo_Class;
jclass BPy_Histogram_Class;
jclass BPy_TiePointGrid_Class;
jclass BPy_RGBChannelDef_Class;
jclass BPy_VectorDataNode_Class;
jclass BPy_ImageInputStream_Class;
jclass BPy_RenderingHints_Class;
jclass BPy_Shape_Class;
jclass BPy_MapTransform_Class;
jclass BPy_Parser_Class;
jclass BPy_ProductData_Class;
jclass BPy_OperatorSpi_Class;
jclass BPy_JtsGeometryConverter_Class;
jclass BPy_Term_Class;
jclass BPy_RasterDataNode_Class;
jclass BPy_Product_AutoGrouping_Class;
jclass BPy_Dimension_Class;
jclass BPy_Stx_Class;
jclass BPy_ImageOutputStream_Class;
jclass BPy_AngularDirection_Class;
jclass BPy_SimpleFeatureType_Class;
jclass BPy_ProductData_UTC_Class;
jclass BPy_RenderedImage_Class;
jclass BPy_Iterator_Class;
jclass BPy_Mask_ImageType_Class;
jclass BPy_File_Class;
jclass BPy_GeoPos_Class;
jclass BPy_ProductNodeGroup_Class;
jclass BPy_ProductManager_Class;
jclass BPy_MapProjection_Class;
jclass BPy_FlagCoding_Class;
jclass BPy_Operator_Class;
jclass BPy_OperatorSpiRegistry_Class;
jclass BPy_BitmaskDef_Class;
jclass BPy_ImageInfo_HistogramMatching_Class;
jclass BPy_Datum_Class;
jclass BPy_ProductUtils_Class;
jclass BPy_Map_Class;
jclass BPy_SubsetOp_Class;
jclass BPy_Pointing_Class;
jclass BPy_PlacemarkDescriptor_Class;
jclass BPy_PointingFactory_Class;
jclass BPy_Point2D_Class;
jclass BPy_Scaling_Class;
jclass BPy_Collection_Class;
jclass BPy_GeoTIFFMetadata_Class;
jclass BPy_MapInfo_Class;
jclass BPy_BufferedImage_Class;
jclass BPy_SimpleFeature_Class;
jclass BPy_ProductSubsetDef_Class;
jclass BPy_ProductWriter_Class;
jclass BPy_ProgressMonitor_Class;
jclass BPy_MetadataAttribute_Class;
jclass BPy_GeneralPath_Class;


static PyMethodDef ImageGeometry_methods[] = {
    {"newImageGeometry", (PyCFunction) BeamPyImageGeometry_newImageGeometry, METH_VARARGS | METH_STATIC, ""},
    {"getImage2MapTransform", (PyCFunction) BeamPyImageGeometry_getImage2MapTransform, METH_VARARGS, ""},
    {"getImageRect", (PyCFunction) BeamPyImageGeometry_getImageRect, METH_VARARGS, ""},
    {"getMapCrs", (PyCFunction) BeamPyImageGeometry_getMapCrs, METH_VARARGS, ""},
    {"changeYAxisDirection", (PyCFunction) BeamPyImageGeometry_changeYAxisDirection, METH_VARARGS, ""},
    {"calculateEastingNorthing", (PyCFunction) BeamPyImageGeometry_calculateEastingNorthing, METH_VARARGS | METH_STATIC, ""},
    {"calculateProductSize", (PyCFunction) BeamPyImageGeometry_calculateProductSize, METH_VARARGS | METH_STATIC, ""},
    {"createTargetGeometry", (PyCFunction) BeamPyImageGeometry_createTargetGeometry, METH_VARARGS | METH_STATIC, ""},
    {"createCollocationTargetGeometry", (PyCFunction) BeamPyImageGeometry_createCollocationTargetGeometry, METH_VARARGS | METH_STATIC, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageGeometry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ImageGeometry",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Author:  Marco Zuehlke\nSince version:  BEAM 4.7",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageGeometry_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef GeoCoding_methods[] = {
    {"isCrossingMeridianAt180", (PyCFunction) BeamPyGeoCoding_isCrossingMeridianAt180, METH_VARARGS, "Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.\nReturns true, if so"},
    {"canGetPixelPos", (PyCFunction) BeamPyGeoCoding_canGetPixelPos, METH_VARARGS, "Checks whether or not this geo-coding can determine the pixel position from a geodetic position.\nReturns true, if so"},
    {"canGetGeoPos", (PyCFunction) BeamPyGeoCoding_canGetGeoPos, METH_VARARGS, "Checks whether or not this geo-coding can determine the geodetic position from a pixel position.\nReturns true, if so"},
    {"getPixelPos", (PyCFunction) BeamPyGeoCoding_getPixelPos, METH_VARARGS, "Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.\nReturns Parameter geoPos: the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\nReturns Parameter pixelPos: an instance of Point to be used as retun value. If this parameter is\nnull, the method creates a new instance which it then returns.\nReturns the pixel co-ordinates as x/y"},
    {"getGeoPos", (PyCFunction) BeamPyGeoCoding_getGeoPos, METH_VARARGS, "Returns the latitude and longitude value for a given pixel co-ordinate.\nReturns Parameter pixelPos: the pixel's co-ordinates given as x,y\nReturns Parameter geoPos: an instance of GeoPos to be used as retun value. If this parameter is\nnull, the method creates a new instance which it then returns.\nReturns the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}"},
    {"getDatum", (PyCFunction) BeamPyGeoCoding_getDatum, METH_VARARGS, "Gets the datum, the reference point or surface against which {@link GeoPos} measurements are made.\nReturns the datum\n@deprecated use the datum of the associated {@link #getMapCRS() map CRS}."},
    {"dispose", (PyCFunction) BeamPyGeoCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined."},
    {"getImageCRS", (PyCFunction) BeamPyGeoCoding_getImageCRS, METH_VARARGS, "Returns the image coordinate reference system (CRS). It is usually derived from the base CRS by including\na linear or non-linear transformation from base (geodetic) coordinates to image coordinates."},
    {"getMapCRS", (PyCFunction) BeamPyGeoCoding_getMapCRS, METH_VARARGS, "Returns the map coordinate reference system (CRS). It may be either a geographical CRS (nominal case is\n\"WGS-84\") or a derived projected CRS, e.g. \"UTM 32 - North\"."},
    {"getGeoCRS", (PyCFunction) BeamPyGeoCoding_getGeoCRS, METH_VARARGS, "Returns the geographical coordinate reference system (CRS). It may be either \"WGS-84\" (nominal case) or\nany other geographical CRS."},
    {"getImageToMapTransform", (PyCFunction) BeamPyGeoCoding_getImageToMapTransform, METH_VARARGS, "Returns the math transformation used to convert image coordinates to map coordinates."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.GeoCoding",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The GeoCoding interface provides geo-spatial latitude and longitude information for a given X/Y position\nof any (two-dimensional) raster.\n  Note: New geo-coding implementations shall implement the abstract class {@link AbstractGeoCoding},\ninstead of implementing this interface.\n\n\nAll GeoCoding implementations should override\nthe {@link Object#equals(Object) equals()} and  {@link Object#hashCode() hashCode()} methods.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoCoding_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef AffineTransform_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject AffineTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.AffineTransform",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    AffineTransform_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Mask_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Mask_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Mask",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A {@code Mask} is used to mask image pixels of other raster data nodes.\n\nThis is a preliminary API under construction for BEAM 4.7. Not intended for public use.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\nSince version:  BEAM 4.7",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Mask_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef IndexCoding_methods[] = {
    {"newIndexCoding", (PyCFunction) BeamPyIndexCoding_newIndexCoding, METH_VARARGS | METH_STATIC, "Constructs a new index coding object with the given name.\nReturns Parameter name: the name"},
    {"getIndex", (PyCFunction) BeamPyIndexCoding_getIndex, METH_VARARGS, "Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to\ngetPropertyValue(String).\nReturns Parameter name: the flag name\nReturns a metadata attribute wich is the representation of the flag with the given name"},
    {"getIndexNames", (PyCFunction) BeamPyIndexCoding_getIndexNames, METH_VARARGS, "Returns a string array which contains the names of all indexes contained in this IndexCoding object.\nReturns a string array which contains all names of this FlagCoding.<br> If this\nFlagCoding does not contain any flag, null is returned"},
    {"addIndex", (PyCFunction) BeamPyIndexCoding_addIndex, METH_VARARGS, "Adds a new index definition to this flags coding.\nReturns Parameter name: the index name\nReturns Parameter value: the index value\nReturns Parameter description: the description text\n@throws IllegalArgumentException if name is null\nReturns a new attribute representing the coded index."},
    {"getIndexValue", (PyCFunction) BeamPyIndexCoding_getIndexValue, METH_VARARGS, "Returns the flag mask value for the specified flag name.\nReturns Parameter name: the flag name\nReturns flagMask the flag's bit mask as a 32 bit integer\n@throws IllegalArgumentException if name is null, or a flag with the name does not exist"},
    {"acceptVisitor", (PyCFunction) BeamPyIndexCoding_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls visitor.visit(this).\nReturns Parameter visitor: the visitor, must not be null"},
    {"addElement", (PyCFunction) BeamPyIndexCoding_addElement, METH_VARARGS, "Overrides the base class addElement in order to not add an element to this flag coding\nbecause flag codings do not support inner elements.\nReturns Parameter element: the element to be added, always ignored"},
    {"addAttribute", (PyCFunction) BeamPyIndexCoding_addAttribute, METH_VARARGS, "Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\nReturns Parameter attribute: the attribute to be added\n@throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value"},
    {"addSample", (PyCFunction) BeamPyIndexCoding_addSample, METH_VARARGS, "Adds a new coding value to this sample coding.\nReturns Parameter name: the coding name\nReturns Parameter value: the value\nReturns Parameter description: the description text\n@throws IllegalArgumentException if name is null\nReturns a new attribute representing the coded sample."},
    {"getSampleCount", (PyCFunction) BeamPyIndexCoding_getSampleCount, METH_VARARGS, "Gets the number of coded sample values.\nReturns the number of coded sample values"},
    {"getSampleName", (PyCFunction) BeamPyIndexCoding_getSampleName, METH_VARARGS, "Gets the sample name at the specified attribute index.\nReturns Parameter index: the attribute index.\nReturns the sample name."},
    {"getSampleValue", (PyCFunction) BeamPyIndexCoding_getSampleValue, METH_VARARGS, "Gets the sample value at the specified attribute index.\nReturns Parameter index: the attribute index.\nReturns the sample value."},
    {"getElementGroup", (PyCFunction) BeamPyIndexCoding_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\nReturns the child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyIndexCoding_getParentElement, METH_VARARGS, ""},
    {"addElementAt", (PyCFunction) BeamPyIndexCoding_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\nReturns Parameter element: the element to added, ignored if null\nReturns Parameter index: where to put it"},
    {"removeElement", (PyCFunction) BeamPyIndexCoding_removeElement, METH_VARARGS, "Removes the given element from this element.\nReturns Parameter element: the element to be removed, ignored if null\nReturns true, if so"},
    {"getNumElements", (PyCFunction) BeamPyIndexCoding_getNumElements, METH_VARARGS, "Returns the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyIndexCoding_getElementAt, METH_VARARGS, "Returns the element at the given index.\nReturns Parameter index: the element index\nReturns the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyIndexCoding_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\nReturns a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyIndexCoding_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\nReturns an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyIndexCoding_getElement, METH_VARARGS, "Returns the element with the given name.\nReturns Parameter name: the element name\nReturns the element with the given name or null if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyIndexCoding_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\nReturns Parameter name: the name, must not be null\nReturns true if a element with the given name is contained in this element, false\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyIndexCoding_getElementIndex, METH_VARARGS, "Gets the index of the given element.\nReturns Parameter element: The element .\nReturns the element's index, or -1.\nSince version:  BEAM 4.7"},
    {"removeAttribute", (PyCFunction) BeamPyIndexCoding_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\nReturns Parameter attribute: the attribute to be removed, null is ignored\nReturns true if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyIndexCoding_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\nReturns the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyIndexCoding_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\nReturns Parameter index: the attribute index\nReturns the attribute, or null if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyIndexCoding_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\nReturns the attribute name array, never null"},
    {"getAttributes", (PyCFunction) BeamPyIndexCoding_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\nReturns an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyIndexCoding_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute with the given name or null if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyIndexCoding_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\nReturns Parameter name: the attribute name\nReturns true if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyIndexCoding_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\nReturns Parameter attribute: The attribute.\nReturns the attribute's index, or -1.\nSince version:  BEAM 4.7"},
    {"getAttributeDouble", (PyCFunction) BeamPyIndexCoding_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC2", (PyCFunction) BeamPyIndexCoding_getAttributeUTC2, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as UTC."},
    {"getAttributeUTC1", (PyCFunction) BeamPyIndexCoding_getAttributeUTC1, METH_VARARGS, "Returns the UTC value of the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute value as UTC.\n@throws IllegalArgumentException if an attribute with the given name could not be found"},
    {"getAttributeInt", (PyCFunction) BeamPyIndexCoding_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyIndexCoding_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\nProductData.TYPE_INT32 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyIndexCoding_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\nProductData.TYPE_FLOAT64 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyIndexCoding_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\nProductData.UTC is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"getAttributeString", (PyCFunction) BeamPyIndexCoding_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyIndexCoding_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\nProductData.TYPE_ASCII is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setModified", (PyCFunction) BeamPyIndexCoding_setModified, METH_VARARGS, ""},
    {"createDeepClone", (PyCFunction) BeamPyIndexCoding_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyIndexCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyIndexCoding_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyIndexCoding_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyIndexCoding_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyIndexCoding_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyIndexCoding_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyIndexCoding_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyIndexCoding_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyIndexCoding_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyIndexCoding_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyIndexCoding_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyIndexCoding_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyIndexCoding_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyIndexCoding_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyIndexCoding_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyIndexCoding_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyIndexCoding_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.IndexCoding",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nrepresent index values (e.g. types, classes, categories).\nSince version:  BEAM 4.2",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexCoding_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef GPF_methods[] = {
    {"createProductWithoutSourceProducts", (PyCFunction) BeamPyGPF_createProductWithoutSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromSourceProduct", (PyCFunction) BeamPyGPF_createProductFromSourceProduct, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns Parameter sourceProduct: a source product.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromSourceProducts", (PyCFunction) BeamPyGPF_createProductFromSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns Parameter sourceProducts: the source products.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductFromNamedSourceProducts", (PyCFunction) BeamPyGPF_createProductFromNamedSourceProducts, METH_VARARGS | METH_STATIC, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns Parameter sourceProducts: the map of named source products.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createProductNS", (PyCFunction) BeamPyGPF_createProductNS, METH_VARARGS, "Creates a product by using the operator specified by the given name.\nThe resulting product can be used as input product for a further call to {@code createProduct()}.\nBy concatenating multiple calls it is possible to set up a processing graph.\nAll static {@code createProduct} methods delegate to this non-static (= NS) version.\nIt can be overriden by clients in order to alter product creation behaviour of the static\n{@code createProduct} methods of the current GPF instance.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns Parameter sourceProducts: the map of named source products.\nReturns Parameter renderingHints: the rendering hints, may be {@code null}.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created."},
    {"createOperator", (PyCFunction) BeamPyGPF_createOperator, METH_VARARGS, "Creates an operator instance by using the given operator (alias) name.\nReturns Parameter operatorName: the name of the operator to use.\nReturns Parameter parameters: the named parameters needed by the operator.\nReturns Parameter sourceProducts: the map of named source products.\nReturns Parameter renderingHints: the rendering hints, may be {@code null}.\nReturns the product created by the operator.\n@throws OperatorException if the product could not be created.\nSince version:  BEAM 4.9"},
    {"getOperatorSpiRegistry", (PyCFunction) BeamPyGPF_getOperatorSpiRegistry, METH_VARARGS, "Gets the registry for operator SPIs.\nReturns the registry for operator SPIs."},
    {"setOperatorSpiRegistry", (PyCFunction) BeamPyGPF_setOperatorSpiRegistry, METH_VARARGS, "Sets the registry for operator SPIs.\nReturns Parameter spiRegistry: the registry for operator SPIs."},
    {"getDefaultInstance", (PyCFunction) BeamPyGPF_getDefaultInstance, METH_VARARGS | METH_STATIC, "Gets the default GPF instance.\nReturns the singelton instance."},
    {"setDefaultInstance", (PyCFunction) BeamPyGPF_setDefaultInstance, METH_VARARGS | METH_STATIC, "Sets the default GPF instance.\nReturns Parameter defaultInstance: the GPF default instance."},
    {"writeProduct", (PyCFunction) BeamPyGPF_writeProduct, METH_VARARGS | METH_STATIC, "Writes a product with the specified format to the given file.\nReturns Parameter product: the product\nReturns Parameter file: the product file\nReturns Parameter formatName: the name of a supported product format, e.g. \"HDF5\". If null, the default format\n\"BEAM-DIMAP\" will be used\nReturns Parameter incremental: switch the product writer in incremental mode or not.\nReturns Parameter pm: a monitor to inform the user about progress"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GPF_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.GPF",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The facade for the Graph Processing Framework.\nThe Graph Processing Framework makes extensive use of Java Advanced Imaging (JAI).\nTherefore, configuring the JAI {@link javax.media.jai.TileCache TileCache} and\n{@link javax.media.jai.TileScheduler TileScheduler} will also affect the overall performance of\nthe Graph Processing Framework.\nThis class may be overridden in order to alter product creation behaviour of the static\n{@code createProduct} methods of the GPF instance.\nThe current instance can be set by {@link #setDefaultInstance(GPF)}.\nAuthor:  Norman Fomferra\nSince version:  4.1",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GPF_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Class_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Class_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Class",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Class_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ServiceRegistry_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ServiceRegistry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ServiceRegistry",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ServiceRegistry_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef PixelPos_methods[] = {
    {"newPixelPos", (PyCFunction) BeamPyPixelPos_newPixelPos, METH_VARARGS | METH_STATIC, "Constructs and initializes a PixelPos with the specified coordinate.\nReturns Parameter x: the x component of the coordinate\nReturns Parameter y: the y component of the coordinate"},
    {"isValid", (PyCFunction) BeamPyPixelPos_isValid, METH_VARARGS, "Tests whether or not this pixel position is valid.\nReturns true, if so"},
    {"setInvalid", (PyCFunction) BeamPyPixelPos_setInvalid, METH_VARARGS, "Sets this pixel position so that is becomes invalid."},
    {"getX", (PyCFunction) BeamPyPixelPos_getX, METH_VARARGS, ""},
    {"getY", (PyCFunction) BeamPyPixelPos_getY, METH_VARARGS, ""},
    {"setLocation1", (PyCFunction) BeamPyPixelPos_setLocation1, METH_VARARGS, ""},
    {"setLocation2", (PyCFunction) BeamPyPixelPos_setLocation2, METH_VARARGS, ""},
    {"toString", (PyCFunction) BeamPyPixelPos_toString, METH_VARARGS, ""},
    {"setLocation3", (PyCFunction) BeamPyPixelPos_setLocation3, METH_VARARGS, ""},
    {"distanceSq2", (PyCFunction) BeamPyPixelPos_distanceSq2, METH_VARARGS | METH_STATIC, ""},
    {"distance2", (PyCFunction) BeamPyPixelPos_distance2, METH_VARARGS | METH_STATIC, ""},
    {"distanceSq1", (PyCFunction) BeamPyPixelPos_distanceSq1, METH_VARARGS, ""},
    {"distanceSq3", (PyCFunction) BeamPyPixelPos_distanceSq3, METH_VARARGS, ""},
    {"distance1", (PyCFunction) BeamPyPixelPos_distance1, METH_VARARGS, ""},
    {"distance3", (PyCFunction) BeamPyPixelPos_distance3, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyPixelPos_clone, METH_VARARGS, ""},
    {"hashCode", (PyCFunction) BeamPyPixelPos_hashCode, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyPixelPos_equals, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PixelPos_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.PixelPos",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A PixelPos represents a position or point in a pixel coordinate system.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PixelPos_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef BitRaster_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BitRaster_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.BitRaster",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A pixel mask provides a boolean value for a given pixel position.\nIt is used to identify valid pixels in a raster.\nSince version:  4.1\nAuthor:  Norman",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BitRaster_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductNode_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductNode",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductNode is the base class for all nodes within a remote sensing data product and even the data\nproduct itself.\nAuthor:  Norman Fomferra",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNode_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Rectangle_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Rectangle_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Rectangle",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Rectangle_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductIO_methods[] = {
    {"getProductReader", (PyCFunction) BeamPyProductIO_getProductReader, METH_VARARGS | METH_STATIC, "Gets a product reader for the given format name.\nReturns Parameter formatName: the product format name\nReturns a suitable product reader or null if none was found"},
    {"getProductWriterExtensions", (PyCFunction) BeamPyProductIO_getProductWriterExtensions, METH_VARARGS | METH_STATIC, "Gets an array of writer product file extensions for the given format name.\nReturns Parameter formatName: the format name\nReturns an array of extensions or null if the format does not exist"},
    {"getProductWriter", (PyCFunction) BeamPyProductIO_getProductWriter, METH_VARARGS | METH_STATIC, "Gets a product writer for the given format name.\nReturns Parameter formatName: the product format name\nReturns a suitable product writer or null if none was found"},
    {"readProduct", (PyCFunction) BeamPyProductIO_readProduct, METH_VARARGS | METH_STATIC, "Reads the data product specified by the given file path.\nThe product returned will be associated with the reader appropriate for the given\nfile format (see also {@link Product#getProductReader() Product.productReader}).\nThe method does not automatically read band data, thus\n{@link Band#getRasterData() Band.rasterData} will always be null\nfor all bands in the product returned by this method.\nReturns Parameter filePath: the data product file path\nReturns a data model as an in-memory representation of the given product file or null if no\nappropriate reader was found for the given product file\n@throws IOException if an I/O error occurs\n@see #readProduct(File)"},
    {"getProductReaderForFile", (PyCFunction) BeamPyProductIO_getProductReaderForFile, METH_VARARGS | METH_STATIC, "Returns a product reader instance for the given file if any registered product reader can decode the given file.\nReturns Parameter file: the file to decode.\nReturns a product reader for the given file or null if the file cannot be decoded.\n@deprecated Since BEAM 4.10. Use {@link #getProductReaderForInput(Object)} instead."},
    {"getProductReaderForInput", (PyCFunction) BeamPyProductIO_getProductReaderForInput, METH_VARARGS | METH_STATIC, "Tries to find a product reader instance suitable for the given input.\nThe method returns {@code null}, if no\nregistered product reader can handle the given {@code input} value.\n\nThe {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or\n{@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.\nReturns Parameter input: the input object.\nReturns a product reader for the given {@code input} or {@code null} if no registered reader can handle\nthe it.\n@see ProductReaderPlugIn#getDecodeQualification(Object)\n@see ProductReader#readProductNodes(Object, ProductSubsetDef)"},
    {"writeProduct", (PyCFunction) BeamPyProductIO_writeProduct, METH_VARARGS | METH_STATIC, "Writes a product with the specified format to the given file path.\nThe method also writes all band data to the file. Therefore the band data must either\n<ld>\n<li>be completely loaded ({@link Band#getRasterData() Band.rasterData} is not null)</li>\n<li>or the product must be associated with a product reader ({@link Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>\n</ld>.\nReturns Parameter product: the product, must not be null\nReturns Parameter filePath: the file path\nReturns Parameter formatName: the name of a supported product format, e.g. \"HDF5\". If null, the default format\n\"BEAM-DIMAP\" will be used\n@throws IOException if an IOException occurs"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductIO_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductIO",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductIO class provides several utility methods concerning data I/O for remote sensing data\nproducts.\n\n For example, a product can be read in using a single method call:\n<pre>\nProduct product =  ProductIO.readProduct(\"test.prd\");\n</pre>\nand written out in a similar way:\n<pre>\nProductIO.writeProduct(product, \"HDF5\", \"test.h5\", null);\n</pre>\nAuthor:  Norman Fomferra\nAuthor:  Sabine Embacher\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductIO_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef SampleCoding_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SampleCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.SampleCoding",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nare combined of single flags (bit indexes).\nSince version:  BEAM 4.2",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SampleCoding_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Object_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Object_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Object",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Object_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductReader_methods[] = {
    {"getReaderPlugIn", (PyCFunction) BeamPyProductReader_getReaderPlugIn, METH_VARARGS, "Returns the plug-in which created this product reader.\nReturns the product reader plug-in, should never be null"},
    {"getInput", (PyCFunction) BeamPyProductReader_getInput, METH_VARARGS, "Retrives the current input destination object. Thie return value might be null if the\nsetInput has not been called so far."},
    {"getSubsetDef", (PyCFunction) BeamPyProductReader_getSubsetDef, METH_VARARGS, "Returns the subset information with which this a data product is read from its physical source.\nReturns the subset information, can be null"},
    {"readProductNodes", (PyCFunction) BeamPyProductReader_readProductNodes, METH_VARARGS, "Reads a data product and returns a in-memory representation of it.\n\n The given subset info can be used to specify spatial and spectral portions of the original proudct. If the\nsubset is omitted, the complete product is read in.\n\n Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,\nis up to the implementation.\nReturns Parameter input: an object representing a valid output for this product reader, might be a\nImageInputStream or other Object to use for future decoding.\nReturns Parameter subsetDef: a spectral or spatial subset (or both) of the product. If null, the entire product\nis read in\n@throws IllegalArgumentException   if input is null or it's type is not one of the\nsupported input sources.\n@throws IOException                if an I/O error occurs\n@throws IllegalFileFormatException if the file format is illegal"},
    {"readBandRasterData", (PyCFunction) BeamPyProductReader_readBandRasterData, METH_VARARGS, "Reads raster data from the data source specified by the given destination band into the given in-memory buffer\nand region.\n\n<h3>Destination band</h3> The destination band is used to identify the data source from which this method\ntransfers the sample values into the given destination buffer. The method does not modify the given destination\nband at all. If this product reader has a ProductSubsetDef instance attached to it, the method\nshould also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.\n\n<h3>Destination region</h3> The given destination region specified by the destOffsetX,\ndestOffsetY, destWidth and destHeight parameters are given in the band's\nraster co-ordinates of the raster which results after applying the optional spatial subset and\nsub-sampling given by the ProductSubsetDef instance to the data source. If no spatial subset\nand sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The\ndestination region should always specify a sub-region of the band's scene raster.\n\n<h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given\ndestOffsetX and destOffsetY of the destination region. The offset parameters are\nnot an offset within the buffer.<br> The number of elements in the buffer exactly be destWidth *\ndestHeight. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies\nfaster than the Y co-ordinate.\nReturns Parameter destBand: the destination band which identifies the data source from which to read the sample values\nReturns Parameter destOffsetX: the X-offset in the band's raster co-ordinates\nReturns Parameter destOffsetY: the Y-offset in the band's raster co-ordinates\nReturns Parameter destWidth: the width of region to be read given in the band's raster co-ordinates\nReturns Parameter destHeight: the height of region to be read given in the band's raster co-ordinates\nReturns Parameter destBuffer: the destination buffer which receives the sample values to be read\n@throws IOException              if an I/O error occurs\n@throws IllegalArgumentException if the number of elements destination buffer not equals destWidth *\ndestHeight or the destination region is out of the band's scene raster\n@see Band#getSceneRasterWidth()\n@see Band#getSceneRasterHeight()"},
    {"close", (PyCFunction) BeamPyProductReader_close, METH_VARARGS, "Closes the access to all currently opened resources such as file input streams and all resources of this children\ndirectly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to close() are undefined.\n\nOverrides of this method should always call super.close(); after disposing this instance.\n@throws IOException if an I/O error occurs"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductReader_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductReader",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Classes implementing the ProductReader interface know how to create an in-memory representation of a\ngiven data product as input source.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see ProductWriter",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductReader_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductReaderPlugIn_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductReaderPlugIn_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductReaderPlugIn",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductReaderPlugIn interface is implemented by data product reader plug-ins.\n\nXMLDecoder plug-ins are used to provide meta-information about a particular data format and to create instances of\nthe actual reader objects.\n\n A plug-in can register itself in the ProductIO plug-in registry or it is automatically found during\na classpath scan.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see ProductWriterPlugIn",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductReaderPlugIn_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Band_methods[] = {
    {"newBand", (PyCFunction) BeamPyBand_newBand, METH_VARARGS | METH_STATIC, "Constructs a new Band.\nReturns Parameter name: the name of the new object\nReturns Parameter dataType: the raster data type, must be one of the multiple ProductData.TYPE_X\nconstants, with the exception of ProductData.TYPE_UINT32\nReturns Parameter width: the width of the raster in pixels\nReturns Parameter height: the height of the raster in pixels"},
    {"getFlagCoding", (PyCFunction) BeamPyBand_getFlagCoding, METH_VARARGS, "Gets the flag coding for this band.\nReturns a non-null value if this band is a flag dataset, null otherwise"},
    {"isFlagBand", (PyCFunction) BeamPyBand_isFlagBand, METH_VARARGS, "Tests whether or not this band is a flag band (getFlagCoding() != null).\nReturns true if so"},
    {"getIndexCoding", (PyCFunction) BeamPyBand_getIndexCoding, METH_VARARGS, "Gets the index coding for this band.\nReturns a non-null value if this band is a flag dataset, null otherwise"},
    {"isIndexBand", (PyCFunction) BeamPyBand_isIndexBand, METH_VARARGS, "Tests whether or not this band is an index band (getIndexCoding() != null).\nReturns true if so"},
    {"getSampleCoding", (PyCFunction) BeamPyBand_getSampleCoding, METH_VARARGS, "Gets the sample coding.\nReturns the sample coding, or {@value null} if not set."},
    {"setSampleCoding", (PyCFunction) BeamPyBand_setSampleCoding, METH_VARARGS, "Sets the sample coding for this band.\nReturns Parameter sampleCoding: the sample coding\n@throws IllegalArgumentException if this band does not contain integer pixels"},
    {"getSpectralBandIndex", (PyCFunction) BeamPyBand_getSpectralBandIndex, METH_VARARGS, "Gets the (zero-based) spectral band index.\nReturns the (zero-based) spectral band index or -1 if it is unknown"},
    {"setSpectralBandIndex", (PyCFunction) BeamPyBand_setSpectralBandIndex, METH_VARARGS, "Sets the (zero-based) spectral band index.\nReturns Parameter spectralBandIndex: the (zero-based) spectral band index or -1 if it is unknown"},
    {"getSpectralWavelength", (PyCFunction) BeamPyBand_getSpectralWavelength, METH_VARARGS, "Gets the spectral wavelength in nm (nanomater) units.\nReturns the wave length in nanometers of this band, or zero if this is not a spectral band or the wave length is\nnot known."},
    {"setSpectralWavelength", (PyCFunction) BeamPyBand_setSpectralWavelength, METH_VARARGS, "Sets the spectral wavelength in nm (nanomater) units.\nReturns Parameter spectralWavelength: the wavelength in nanometers of this band, or zero if this is not a spectral band or\nthe wavelength is not known."},
    {"getSpectralBandwidth", (PyCFunction) BeamPyBand_getSpectralBandwidth, METH_VARARGS, "Gets the spectral bandwidth in nm (nanomater) units.\nReturns the bandwidth in nanometers of this band, or zero if this is not a spectral band or the bandwidth is not\nknown."},
    {"setSpectralBandwidth", (PyCFunction) BeamPyBand_setSpectralBandwidth, METH_VARARGS, "Sets the spectral bandwidth in nm (nanomater) units.\nReturns Parameter spectralBandwidth: the spectral bandwidth in nanometers of this band, or zero if this is not a spectral band\nor the spectral bandwidth is not known."},
    {"getSolarFlux", (PyCFunction) BeamPyBand_getSolarFlux, METH_VARARGS, "Gets the solar flux in mW/(m^2 nm) (milli-watts per square metre per nanometer)\nunits for the wavelength of this band.\nReturns the solar flux for the wavelength of this band, or zero if this is not a spectral band or the solar flux\nis not known."},
    {"setSolarFlux", (PyCFunction) BeamPyBand_setSolarFlux, METH_VARARGS, "Sets the solar flux in mW/(m^2 nm) (milli-watts per square metre per nanometer)\nunits for the wavelength of this band.\nReturns Parameter solarFlux: the solar flux for the wavelength of this band, or zero if this is not a spectral band or the\nsolar flux is not known."},
    {"acceptVisitor", (PyCFunction) BeamPyBand_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls visitor.visit(this).\nReturns Parameter visitor: the visitor, must not be null"},
    {"toString", (PyCFunction) BeamPyBand_toString, METH_VARARGS, "Creates a string defining this band object."},
    {"removeFromFile", (PyCFunction) BeamPyBand_removeFromFile, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyBand_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"getViewModeId", (PyCFunction) BeamPyBand_getViewModeId, METH_VARARGS, ""},
    {"computeBand", (PyCFunction) BeamPyBand_computeBand, METH_VARARGS, "(Re-)Computes this band's data using the given arithmetic expression.\nReturns Parameter expression: the arithmetic expression string, e.g. \"1 + log(radiance_5 / radiance_13)\"\nReturns Parameter validMaskExpression: the arithmetic expression identifying valid source pixels, e.g. \"radiance_5 > 0.0 && radiance_13 > 0.0\"\nReturns Parameter sourceProducts: the list of source products possibly referenced in the expression\nReturns Parameter defaultProductIndex: the index of the product for which also symbols without the\nproduct prefix $ref-no are registered in the namespace\nReturns Parameter checkInvalids: if true, the method recognizes numerically invalid values (NaN, Infinity)\nReturns Parameter useInvalidValue: if true, numerically invalid values (NaN, Infinity) are set to invalidValue,\nignored if checkInvalids = false\nReturns Parameter noDataValue: the value used in place of  numerically invalid values if useInvalidValue =\ntrue, ignored if  checkInvalids = false\nReturns Parameter pm: a monitor to inform the user about progress\nReturns the number of invalid pixels, zero if  checkInvalids = false\n@throws IOException    if an I/O error occurs\n@throws ParseException if the expression syntax is invalid\n@deprecated Since BEAM 4.10. Use {@link VirtualBand} or {@link org.esa.beam.jai.VirtualBandOpImage}."},
    {"getSceneRasterData", (PyCFunction) BeamPyBand_getSceneRasterData, METH_VARARGS, "Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so\nfar the method returns null.\n\nIn opposite to the getRasterData method, this method returns raster data that has at least\ngetBandOutputRasterWidth()*getBandOutputRasterHeight() elements of the given data type to store the\nscene's pixels.\nReturns raster data covering the pixels for a complete scene\n@see #getRasterData\n@see RasterDataNode#getSceneRasterWidth\n@see RasterDataNode#getSceneRasterHeight\n@deprecated since BEAM 4.11, use {@link #getSourceImage()} instead."},
    {"getPixelInt", (PyCFunction) BeamPyBand_getPixelInt, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as an integer value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleInt(int, int)} instead."},
    {"getPixelFloat", (PyCFunction) BeamPyBand_getPixelFloat, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as a float value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead."},
    {"getPixelDouble", (PyCFunction) BeamPyBand_getPixelDouble, METH_VARARGS, "Gets the sample for the pixel located at (x,y) as a double value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\n@throws NullPointerException if this band has no raster data\n@throws java.lang.ArrayIndexOutOfBoundsException\nif the co-ordinates are not in bounds\n@deprecated since BEAM 4.11, use {@link #getSampleFloat(int, int)} instead."},
    {"setPixelInt", (PyCFunction) BeamPyBand_setPixelInt, METH_VARARGS, "Sets the pixel at the given pixel co-ordinate to the given pixel value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\nReturns Parameter pixelValue: the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelFloat", (PyCFunction) BeamPyBand_setPixelFloat, METH_VARARGS, "Sets the pixel at the given pixel coordinate to the given pixel value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\nReturns Parameter pixelValue: the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelDouble", (PyCFunction) BeamPyBand_setPixelDouble, METH_VARARGS, "Sets the pixel value at the given pixel coordinate to the given pixel value.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\nReturns Parameter pixelValue: the new pixel value\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. No replacement."},
    {"setPixelsInt", (PyCFunction) BeamPyBand_setPixelsInt, METH_VARARGS, "Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of\ndata at the specified location. Throws exception when the target buffer is not in memory.\nReturns Parameter x: x offset into the band\nReturns Parameter y: y offset into the band\nReturns Parameter w: width of the pixel array to be written\nReturns Parameter h: height of the pixel array to be written.\nReturns Parameter pixels: integer array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"setPixelsFloat", (PyCFunction) BeamPyBand_setPixelsFloat, METH_VARARGS, "Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data\nat the specified location. Throws exception when the target buffer is not in memory.\nReturns Parameter x: x offset into the band\nReturns Parameter y: y offset into the band\nReturns Parameter w: width of the pixel array to be written\nReturns Parameter h: height of the pixel array to be written.\nReturns Parameter pixels: float array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"setPixelsDouble", (PyCFunction) BeamPyBand_setPixelsDouble, METH_VARARGS, "Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data\nat the specified location. Throws exception when the target buffer is not in memory.\nReturns Parameter x: x offset into the band\nReturns Parameter y: y offset into the band\nReturns Parameter w: width of the pixel array to be written\nReturns Parameter h: height of the pixel array to be written.\nReturns Parameter pixels: double array to be written\n@throws NullPointerException if this band has no raster data\n@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"ensureRasterData", (PyCFunction) BeamPyBand_ensureRasterData, METH_VARARGS, "Ensures that raster data exists\n@deprecated since BEAM 4.11. No replacement."},
    {"unloadRasterData", (PyCFunction) BeamPyBand_unloadRasterData, METH_VARARGS, "Un-loads the raster data for this band.\n\nAfter this method has been called successfully, the hasRasterData() method returns\nfalse and getRasterData() returns null.\n\n@see #loadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"getSceneRasterWidth", (PyCFunction) BeamPyBand_getSceneRasterWidth, METH_VARARGS, "Returns the width in pixels of the scene represented by this product raster. By default, the method simply\nreturns getRasterWidth().\nReturns the scene width in pixels"},
    {"getSceneRasterHeight", (PyCFunction) BeamPyBand_getSceneRasterHeight, METH_VARARGS, "Returns the height in pixels of the scene represented by this product raster. By default, the method simply\nreturns getRasterHeight().\nReturns the scene height in pixels"},
    {"getRasterWidth", (PyCFunction) BeamPyBand_getRasterWidth, METH_VARARGS, "Returns the width of the raster used by this product raster.\nReturns the width of the raster"},
    {"getRasterHeight", (PyCFunction) BeamPyBand_getRasterHeight, METH_VARARGS, "Returns the height of the raster used by this product raster.\nReturns the height of the raster"},
    {"setModified", (PyCFunction) BeamPyBand_setModified, METH_VARARGS, ""},
    {"getGeoCoding", (PyCFunction) BeamPyBand_getGeoCoding, METH_VARARGS, "Returns the geo-coding of this {@link RasterDataNode}.\nReturns the geo-coding"},
    {"setGeoCoding", (PyCFunction) BeamPyBand_setGeoCoding, METH_VARARGS, "Sets the geo-coding for this {@link RasterDataNode}.\nAlso sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_GEOCODING}.\nReturns Parameter geoCoding: the new geo-coding\n@see Product#setGeoCoding(GeoCoding)"},
    {"getPointing", (PyCFunction) BeamPyBand_getPointing, METH_VARARGS, "Gets a {@link Pointing} if one is available for this raster.\nThe methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\nsince the last creation of this raster's {@link Pointing} instance.\nReturns the pointing object, or null if a pointing is not available"},
    {"canBeOrthorectified", (PyCFunction) BeamPyBand_canBeOrthorectified, METH_VARARGS, "Tests if this raster data node can be orthorectified.\nReturns true, if so"},
    {"isFloatingPointType", (PyCFunction) BeamPyBand_isFloatingPointType, METH_VARARGS, "Returns true if the pixel data contained in this band is \"naturally\" a floating point number type.\nReturns true, if so"},
    {"getGeophysicalDataType", (PyCFunction) BeamPyBand_getGeophysicalDataType, METH_VARARGS, "Returns the geophysical data type of this RasterDataNode. The value returned is always one of the\nProductData.TYPE_XXX constants.\nReturns the geophysical data type\n@see ProductData\n@see #isScalingApplied()"},
    {"getScalingFactor", (PyCFunction) BeamPyBand_getScalingFactor, METH_VARARGS, "Gets the scaling factor which is applied to raw {@link ProductData}. The default value is\n1.0 (no factor).\nReturns the scaling factor\n@see #isScalingApplied()"},
    {"setScalingFactor", (PyCFunction) BeamPyBand_setScalingFactor, METH_VARARGS, "Sets the scaling factor which is applied to raw {@link ProductData}.\nReturns Parameter scalingFactor: the scaling factor\n@see #isScalingApplied()"},
    {"getScalingOffset", (PyCFunction) BeamPyBand_getScalingOffset, METH_VARARGS, "Gets the scaling offset which is applied to raw {@link ProductData}. The default value is\n0.0 (no offset).\nReturns the scaling offset\n@see #isScalingApplied()"},
    {"setScalingOffset", (PyCFunction) BeamPyBand_setScalingOffset, METH_VARARGS, "Sets the scaling offset which is applied to raw {@link ProductData}.\nReturns Parameter scalingOffset: the scaling offset\n@see #isScalingApplied()"},
    {"isLog10Scaled", (PyCFunction) BeamPyBand_isLog10Scaled, METH_VARARGS, "Gets whether or not the {@link ProductData} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data. The default value is\nfalse.\nReturns whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"setLog10Scaled", (PyCFunction) BeamPyBand_setLog10Scaled, METH_VARARGS, "Sets whether or not the {@link ProductData} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data.\nReturns Parameter log10Scaled: whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"isScalingApplied", (PyCFunction) BeamPyBand_isScalingApplied, METH_VARARGS, "Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\npixel values. The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n{@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n{@link #writePixels(int, int, int, int, int[])} methods as well as the getPixel&lt;Type&gt; and\nsetPixel&lt;Type&gt; methods such as  {@link #getPixelFloat(int, int)} * and\n{@link #setPixelFloat(int, int, float)}.\nReturns true if a conversion is applyied to raw data samples before the are retuned.\n@see #getScalingOffset\n@see #getScalingFactor\n@see #isLog10Scaled"},
    {"isValidMaskProperty", (PyCFunction) BeamPyBand_isValidMaskProperty, METH_VARARGS | METH_STATIC, "Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\nReturns Parameter propertyName: the  name to test\nReturns {@code true}, if so.\nSince version:  BEAM 4.2"},
    {"isNoDataValueSet", (PyCFunction) BeamPyBand_isNoDataValueSet, METH_VARARGS, "Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n{@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\nReturns true, if so\n@see #isNoDataValueUsed()\n@see #setNoDataValue(double)"},
    {"clearNoDataValue", (PyCFunction) BeamPyBand_clearNoDataValue, METH_VARARGS, "Clears the no-data value, so that {@link #isNoDataValueSet()} will return false."},
    {"isNoDataValueUsed", (PyCFunction) BeamPyBand_isNoDataValueUsed, METH_VARARGS, "Tests whether or not the no-data value is used.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns true, if so\n@see #setNoDataValueUsed(boolean)\n@see #isNoDataValueSet()"},
    {"setNoDataValueUsed", (PyCFunction) BeamPyBand_setNoDataValueUsed, METH_VARARGS, "Sets whether or not the no-data value is used.\nIf the no-data value is enabled and the no-data value has not been set so far,\na default no-data value it is set with a value of to zero.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\nReturns Parameter noDataValueUsed: true, if so\n@see #isNoDataValueUsed()"},
    {"getNoDataValue", (PyCFunction) BeamPyBand_getNoDataValue, METH_VARARGS, "Gets the no-data value as a primitive double.\nNote that the value returned is NOT necessarily the same as the value returned by\n{@link #getGeophysicalNoDataValue()} because no scaling is applied.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nThe method returns 0.0, if no no-data value has been specified so far.\nReturns the no-data value. It is returned as a double in order to cover all other numeric types.\n@see #setNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"setNoDataValue", (PyCFunction) BeamPyBand_setNoDataValue, METH_VARARGS, "Sets the no-data value as a primitive double.\nNote that the given value is related to the \"raw\", un-scaled raster data.\nIn order to set the geophysical, scaled no-data value use the method\n{@link #setGeophysicalNoDataValue(double)}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\nReturns Parameter noDataValue: the no-data value. It is passed as a double in order to cover all other numeric types.\n@see #getNoDataValue()\n@see #isNoDataValueSet()"},
    {"getGeophysicalNoDataValue", (PyCFunction) BeamPyBand_getGeophysicalNoDataValue, METH_VARARGS, "Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns the geophysical no-data value\n@see #setGeophysicalNoDataValue(double)"},
    {"setGeophysicalNoDataValue", (PyCFunction) BeamPyBand_setGeophysicalNoDataValue, METH_VARARGS, "Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\nReturns Parameter noDataValue: the new geophysical no-data value\n@see #setGeophysicalNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"getValidPixelExpression", (PyCFunction) BeamPyBand_getValidPixelExpression, METH_VARARGS, "Gets the expression that is used to determine whether a pixel is valid or not.\nFor more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns the valid mask expression."},
    {"setValidPixelExpression", (PyCFunction) BeamPyBand_setValidPixelExpression, METH_VARARGS, "Sets the expression that is used to determine whether a pixel is valid or not.\nThe valid-pixel expression is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\nReturns Parameter validPixelExpression: the valid mask expression, can be null"},
    {"isValidMaskUsed", (PyCFunction) BeamPyBand_isValidMaskUsed, METH_VARARGS, "Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\ntrue if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\nThe data-mask is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns true, if so"},
    {"resetValidMask", (PyCFunction) BeamPyBand_resetValidMask, METH_VARARGS, "Resets the valid mask of this raster.\nThe mask will be lazily regenerated when requested the next time."},
    {"getValidMaskExpression", (PyCFunction) BeamPyBand_getValidMaskExpression, METH_VARARGS, "Gets the expression used for the computation of the mask which identifies valid pixel values.\nIt recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n{@link #getValidPixelExpression() validPixelExpression} properties, if any.\nThe method returns {@code null},  if none of these properties are set.\nReturns the expression used for the computation of the mask which identifies valid pixel values,\nor {@code null}.\n@see #getValidPixelExpression()\n@see #getNoDataValue()\nSince version:  BEAM 4.2"},
    {"updateExpression", (PyCFunction) BeamPyBand_updateExpression, METH_VARARGS, "{@inheritDoc}"},
    {"hasRasterData", (PyCFunction) BeamPyBand_hasRasterData, METH_VARARGS, "Returns true if the raster data of this RasterDataNode is loaded or elsewhere available, otherwise\nfalse.\nReturns true, if so.\n@deprecated since BEAM 4.11. No replacement."},
    {"getRasterData", (PyCFunction) BeamPyBand_getRasterData, METH_VARARGS, "Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\nnull.\nReturns the raster data for this band, or null if data has not been loaded\n@deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\nmethod variants to retrieve or read raster data."},
    {"setRasterData", (PyCFunction) BeamPyBand_setRasterData, METH_VARARGS, "Sets the raster data of this dataset.\n\n Note that this method does not copy data at all. If the supplied raster data is compatible with this product\nraster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\ndataset's data!\nReturns Parameter rasterData: the raster data for this dataset\n@see #getRasterData()\n@deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"loadRasterData", (PyCFunction) BeamPyBand_loadRasterData, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. No replacement."},
    {"isPixelValid", (PyCFunction) BeamPyBand_isPixelValid, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\n\nNote: Implementation changed by Norman (2011-08-09) in order to increase performance since\na synchronised block was used due to problem with the JAI ROI class that has been used in\nthe former implementation.\nReturns Parameter x: the X co-ordinate of the pixel location\nReturns Parameter y: the Y co-ordinate of the pixel location\nReturns true if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getSampleInt", (PyCFunction) BeamPyBand_getSampleInt, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n\nNote: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.\nReturns Parameter x: pixel X coordinate\nReturns Parameter y: pixel Y coordinate\nReturns the geo-physical sample value."},
    {"getSampleFloat", (PyCFunction) BeamPyBand_getSampleFloat, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n\nNote: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.\nReturns Parameter x: pixel X coordinate\nReturns Parameter y: pixel Y coordinate\nReturns the geo-physical sample value."},
    {"getPixelsInt", (PyCFunction) BeamPyBand_getPixelsInt, METH_VARARGS, "@see #getPixels(int, int, int, int, int[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixelsFloat", (PyCFunction) BeamPyBand_getPixelsFloat, METH_VARARGS, "@see #getPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixelsDouble", (PyCFunction) BeamPyBand_getPixelsDouble, METH_VARARGS, "@see #getPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixelsInt", (PyCFunction) BeamPyBand_readPixelsInt, METH_VARARGS, "@see #readPixels(int, int, int, int, int[], ProgressMonitor)"},
    {"readPixelsFloat", (PyCFunction) BeamPyBand_readPixelsFloat, METH_VARARGS, "@see #readPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixelsDouble", (PyCFunction) BeamPyBand_readPixelsDouble, METH_VARARGS, "@see #readPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writePixelsInt", (PyCFunction) BeamPyBand_writePixelsInt, METH_VARARGS, "@see #writePixels(int, int, int, int, int[], ProgressMonitor)"},
    {"writePixelsFloat", (PyCFunction) BeamPyBand_writePixelsFloat, METH_VARARGS, "@see #writePixels(int, int, int, int, float[], ProgressMonitor)"},
    {"writePixelsDouble", (PyCFunction) BeamPyBand_writePixelsDouble, METH_VARARGS, "@see #writePixels(int, int, int, int, double[], ProgressMonitor)"},
    {"readValidMask", (PyCFunction) BeamPyBand_readValidMask, METH_VARARGS, ""},
    {"writeRasterDataFully", (PyCFunction) BeamPyBand_writeRasterDataFully, METH_VARARGS, ""},
    {"writeRasterData", (PyCFunction) BeamPyBand_writeRasterData, METH_VARARGS, "@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\nreadPixels()} method variants to set or write raster data."},
    {"createCompatibleRasterData", (PyCFunction) BeamPyBand_createCompatibleRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\ngetRasterWidth()*getRasterHeight() elements of a compatible data type.\nReturns raster data compatible with this product raster\n@see #createCompatibleSceneRasterData"},
    {"createCompatibleSceneRasterData", (PyCFunction) BeamPyBand_createCompatibleSceneRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\ngetBandOutputRasterWidth()*getBandOutputRasterHeight() elements of a compatible data type.\nReturns raster data compatible with this product raster\n@see #createCompatibleRasterData"},
    {"createCompatibleRasterDataForRect", (PyCFunction) BeamPyBand_createCompatibleRasterDataForRect, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\nwidth*height elements of a compatible data type.\nReturns Parameter width: the width of the raster data to be created\nReturns Parameter height: the height of the raster data to be created\nReturns raster data compatible with this product raster\n@see #createCompatibleRasterData\n@see #createCompatibleSceneRasterData"},
    {"isCompatibleRasterData", (PyCFunction) BeamPyBand_isCompatibleRasterData, METH_VARARGS, "Tests whether the given parameters specify a compatible raster or not.\nReturns Parameter rasterData: the raster data\nReturns Parameter w: the raster width\nReturns Parameter h: the raster height\nReturns {@code true} if so\n@deprecated since BEAM 4.11. No replacement."},
    {"checkCompatibleRasterData", (PyCFunction) BeamPyBand_checkCompatibleRasterData, METH_VARARGS, "Throws an IllegalArgumentException if the given parameters dont specify a compatible raster.\nReturns Parameter rasterData: the raster data\nReturns Parameter w: the raster width\nReturns Parameter h: the raster height\n@deprecated since BEAM 4.11. No replacement."},
    {"hasIntPixels", (PyCFunction) BeamPyBand_hasIntPixels, METH_VARARGS, "Determines whether this raster data node contains integer samples.\nReturns true if this raster data node contains integer samples."},
    {"createTransectProfileData", (PyCFunction) BeamPyBand_createTransectProfileData, METH_VARARGS, "Creates a transect profile for the given shape (-outline).\nReturns Parameter shape: the shape\nReturns the profile data\n@throws IOException if an I/O error occurs"},
    {"getImageInfo", (PyCFunction) BeamPyBand_getImageInfo, METH_VARARGS, "Gets the image information for image display.\nReturns the image info or null"},
    {"setImageInfo", (PyCFunction) BeamPyBand_setImageInfo, METH_VARARGS, "Sets the image information for image display.\nReturns Parameter imageInfo: the image info, can be null"},
    {"fireImageInfoChanged", (PyCFunction) BeamPyBand_fireImageInfoChanged, METH_VARARGS, "Notifies listeners that the image (display) information has changed.\nSince version:  BEAM 4.7"},
    {"createDefaultImageInfo", (PyCFunction) BeamPyBand_createDefaultImageInfo, METH_VARARGS, "Creates an instance of a default image information.\n\nAn IllegalStateException is thrown in the case that this raster data node has no raster data.\nReturns Parameter histoSkipAreas: the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be null, in this case {0.01, 0.04} resp. 5% of\nthe entire area is skipped.\nReturns Parameter histogram: the histogram to create the image information.\nReturns a valid image information instance, never null."},
    {"getOverlayMaskGroup", (PyCFunction) BeamPyBand_getOverlayMaskGroup, METH_VARARGS, "Returns the overlay mask group."},
    {"createColorIndexedImage", (PyCFunction) BeamPyBand_createColorIndexedImage, METH_VARARGS, "Creates an image for this raster data node. The method simply returns ProductUtils.createColorIndexedImage(this,\nnull).\nReturns Parameter pm: a monitor to inform the user about progress\nReturns a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createRgbImage", (PyCFunction) BeamPyBand_createRgbImage, METH_VARARGS, "Creates an RGB image for this raster data node.\nReturns Parameter pm: a monitor to inform the user about progress\nReturns a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createPixelValidator", (PyCFunction) BeamPyBand_createPixelValidator, METH_VARARGS, "Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\nReturns Parameter lineOffset: the absolute line offset, zero based\nReturns Parameter roi: an optional ROI\nReturns a new validator instance, never null\n@throws IOException if an I/O error occurs"},
    {"scale", (PyCFunction) BeamPyBand_scale, METH_VARARGS, "Applies the scaling v * scalingFactor + scalingOffset the the given input value. If the\nlog10Scaled property is true, the result is taken to the power of 10 after the actual\nscaling.\nReturns Parameter v: the input value\nReturns the scaled value"},
    {"scaleInverse", (PyCFunction) BeamPyBand_scaleInverse, METH_VARARGS, "Applies the inverse scaling (v - scalingOffset) / scalingFactor the the given input value. If the\nlog10Scaled property is true, the common logarithm is applied to the input before the actual\nscaling.\nReturns Parameter v: the input value\nReturns the scaled value"},
    {"getPixelString", (PyCFunction) BeamPyBand_getPixelString, METH_VARARGS, "Returns the pixel located at (x,y) as a string value.\nReturns Parameter x: the X co-ordinate of the pixel location\nReturns Parameter y: the Y co-ordinate of the pixel location\nReturns the pixel value at (x,y) as string or an error message text"},
    {"isSourceImageSet", (PyCFunction) BeamPyBand_isSourceImageSet, METH_VARARGS, "Returns whether the source image is set on this {@code RasterDataNode}.\nReturns whether the source image is set.\n@see #getSourceImage()\n@see #setSourceImage(java.awt.image.RenderedImage)\n@see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n@see #createSourceImage()\nSince version:  BEAM 4.5"},
    {"getSourceImage", (PyCFunction) BeamPyBand_getSourceImage, METH_VARARGS, "Gets the source image associated with this {@code RasterDataNode}.\nReturns the source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\nthe method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n@see #createSourceImage()\n@see #isSourceImageSet()\nSince version:  BEAM 4.2"},
    {"isGeophysicalImageSet", (PyCFunction) BeamPyBand_isGeophysicalImageSet, METH_VARARGS, "Returns whether the geophysical image is set on this {@code RasterDataNode}.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns whether the geophysical image is set.\nSince version:  BEAM 4.6"},
    {"getGeophysicalImage", (PyCFunction) BeamPyBand_getGeophysicalImage, METH_VARARGS, "Returns the geophysical source image.\nSince version:  BEAM 4.5"},
    {"isValidMaskImageSet", (PyCFunction) BeamPyBand_isValidMaskImageSet, METH_VARARGS, "Returns wether the valid mask image is set on this {@code RasterDataNode}.\nReturns wether the source image is set.\nSince version:  BEAM 4.5"},
    {"getValidMaskImage", (PyCFunction) BeamPyBand_getValidMaskImage, METH_VARARGS, "Gets the valid-mask image associated with this {@code RasterDataNode}.\nReturns the rendered image.\nSince version:  BEAM 4.2"},
    {"isStxSet", (PyCFunction) BeamPyBand_isStxSet, METH_VARARGS, ""},
    {"getStx", (PyCFunction) BeamPyBand_getStx, METH_VARARGS, "Gets the statistics. If statistcs are not yet available,\nthe method will compute (possibly inaccurate) statistics and return those.\n\nIf accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\nshall be used instead.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns the statistics.\n@see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n@see #setStx(Stx)\nSince version:  BEAM 4.2, revised in BEAM 4.5"},
    {"setStx", (PyCFunction) BeamPyBand_setStx, METH_VARARGS, "Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\nare really related to this {@code RasterDataNode}'s raster data.\nThe method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns Parameter stx: The statistics.\nSince version:  BEAM 4.2, revised in BEAM 4.5"},
    {"getValidShape", (PyCFunction) BeamPyBand_getValidShape, METH_VARARGS, "Gets the shape of the area where this raster data contains valid samples.\nThe method returns null, if the entire raster contains valid samples.\nReturns the shape of the area where the raster data has samples, can be {@code null}.\nSince version:  BEAM 4.7"},
    {"getRoiMaskGroup", (PyCFunction) BeamPyBand_getRoiMaskGroup, METH_VARARGS, "Returns the roi mask group.\n@deprecated since BEAM 4.10 (no replacement)"},
    {"getDataType", (PyCFunction) BeamPyBand_getDataType, METH_VARARGS, "Gets the data type of this data node.\nReturns the data type which is always one of the multiple ProductData.TYPE_X constants"},
    {"getNumDataElems", (PyCFunction) BeamPyBand_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyBand_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyBand_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyBand_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyBand_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyBand_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyBand_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyBand_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyBand_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyBand_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyBand_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyBand_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyBand_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"createCompatibleProductData", (PyCFunction) BeamPyBand_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\nnumElems elements of a compatible data type.\nReturns Parameter numElems: the number of elements, must not be less than one\nReturns product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyBand_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyBand_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyBand_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyBand_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyBand_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyBand_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"isValidNodeName", (PyCFunction) BeamPyBand_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyBand_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyBand_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyBand_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyBand_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyBand_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"getExtension", (PyCFunction) BeamPyBand_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Band_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Band",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A band contains the data for geophysical parameter in remote sensing data products. Bands are two-dimensional images\nwhich hold their pixel values (samples) in a buffer of the type {@link ProductData}. The band class is just a\ncontainer for attached metadata of the band, currently: <ul> <li>the flag coding {@link FlagCoding}</li> <li>the band\nindex at which position the band is stored in the associated product</li> <li>the center wavelength of the band</li>\n<li>the bandwidth of the band</li> <li>the solar spectral flux of the band</li> <li>the width and height of the\nband</li> </ul> The band can contain a buffer to the real data, but this buffer must be read explicitely, to keep the\nmemory fingerprint small, the data is not read automatically.\n\n\nThe several getPixel and readPixel methods of this class do not necessarily return the\nvalues contained in the data buffer of type {@link ProductData}. If the scalingFactor,\nscalingOffset or log10Scaled are set a conversion of the form scalingFactor *\nrawSample + scalingOffset is applied to the raw samples before the getPixel and @\nreadPixel methods return the actual pixel values. If the log10Scaled property is true then\nthe conversion is pow(10, scalingFactor * rawSample + scalingOffset). The several setPixel\nand writePixel perform the inverse operations in this case.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see ProductData",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Band_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ColorPaletteDef_Point_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ColorPaletteDef_Point_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ColorPaletteDef_Point",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ColorPaletteDef_Point_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Placemark_methods[] = {
    {"newPlacemark", (PyCFunction) BeamPyPlacemark_newPlacemark, METH_VARARGS | METH_STATIC, "Constructor.\nReturns Parameter descriptor: The placemark descriptor that created this placemark.\nReturns Parameter feature: The wrapped feature."},
    {"createPointPlacemark", (PyCFunction) BeamPyPlacemark_createPointPlacemark, METH_VARARGS | METH_STATIC, "Creates a point placemark.\nReturns Parameter descriptor: The placemark descriptor that created this placemark.\nReturns Parameter name: The placemark's name.\nReturns Parameter label: The placemark's label. May be {@code null}.\nReturns Parameter text: The placemark's (XHTML) text. May be {@code null}.\nReturns Parameter pixelPos: The placemark's pixel position. May be {@code null}, if {@code geoPos} is given.\nReturns Parameter geoPos: The placemark's pixel position. May be {@code null}, if {@code pixelPos} is given.\nReturns Parameter geoCoding: The placemark's geo-coding. Used to compute {@code pixelPos} from {@code geoPos}, if {@code pixelPos} is {@code null}.\nReturns a new point placemark."},
    {"getDescriptor", (PyCFunction) BeamPyPlacemark_getDescriptor, METH_VARARGS, "Returns the placemark descriptor that created this placemark.\nSince version:  BEAM 4.10"},
    {"getFeature", (PyCFunction) BeamPyPlacemark_getFeature, METH_VARARGS, "Returns the wrapped {@link SimpleFeature} underlying this placemark.\nSince version:  BEAM 4.7"},
    {"getAttributeValue", (PyCFunction) BeamPyPlacemark_getAttributeValue, METH_VARARGS, "Gets the attribute value of the underlying feature.\nReturns Parameter attributeName: The feature's attribute name.\nReturns the feature's attribute value, may be {@code null}."},
    {"setAttributeValue", (PyCFunction) BeamPyPlacemark_setAttributeValue, METH_VARARGS, "Sets the attribute value of the underlying feature.\nReturns Parameter attributeName: The feature's attribute name.\nReturns Parameter attributeValue: The feature's attribute value, may be {@code null}."},
    {"setLabel", (PyCFunction) BeamPyPlacemark_setLabel, METH_VARARGS, "Sets this placemark's label.\nReturns Parameter label: the label, if {@code null} an empty label is set."},
    {"getLabel", (PyCFunction) BeamPyPlacemark_getLabel, METH_VARARGS, "Returns this placemark's label, cannot be {@code null}."},
    {"setText", (PyCFunction) BeamPyPlacemark_setText, METH_VARARGS, "Sets this placemark's (XHTML) text.\nReturns Parameter text: The text, if {@code null} an empty text is set."},
    {"getText", (PyCFunction) BeamPyPlacemark_getText, METH_VARARGS, "Returns this placemark's (XHTML) text, cannot be {@code null}."},
    {"setStyleCss", (PyCFunction) BeamPyPlacemark_setStyleCss, METH_VARARGS, "Sets this placemark's CSS style.\nReturns Parameter styleCss: The text, if {@code null} an empty text is set.\nSince version:  BEAM 4.10"},
    {"getStyleCss", (PyCFunction) BeamPyPlacemark_getStyleCss, METH_VARARGS, "Returns this placemark's CSS style, cannot be {@code null}.\nSince version:  BEAM 4.10"},
    {"acceptVisitor", (PyCFunction) BeamPyPlacemark_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\nReturns Parameter visitor: the visitor"},
    {"getPixelPos", (PyCFunction) BeamPyPlacemark_getPixelPos, METH_VARARGS, ""},
    {"setPixelPos", (PyCFunction) BeamPyPlacemark_setPixelPos, METH_VARARGS, ""},
    {"getGeoPos", (PyCFunction) BeamPyPlacemark_getGeoPos, METH_VARARGS, ""},
    {"setGeoPos", (PyCFunction) BeamPyPlacemark_setGeoPos, METH_VARARGS, ""},
    {"updatePositions", (PyCFunction) BeamPyPlacemark_updatePositions, METH_VARARGS, "Updates pixel and geo position according to the current geometry (model coordinates)."},
    {"createPinFeatureType", (PyCFunction) BeamPyPlacemark_createPinFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createGcpFeatureType", (PyCFunction) BeamPyPlacemark_createGcpFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createGeometryFeatureType", (PyCFunction) BeamPyPlacemark_createGeometryFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"createPointFeatureType", (PyCFunction) BeamPyPlacemark_createPointFeatureType, METH_VARARGS | METH_STATIC, ""},
    {"getOwner", (PyCFunction) BeamPyPlacemark_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyPlacemark_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyPlacemark_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyPlacemark_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyPlacemark_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyPlacemark_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"setModified", (PyCFunction) BeamPyPlacemark_setModified, METH_VARARGS, "Sets this node's modified flag.\n\nIf the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\ntrue.\nReturns Parameter modified: whether or not this node is beeing marked as modified.\n@see Product#fireNodeChanged"},
    {"toString", (PyCFunction) BeamPyPlacemark_toString, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyPlacemark_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"isValidNodeName", (PyCFunction) BeamPyPlacemark_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyPlacemark_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyPlacemark_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyPlacemark_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyPlacemark_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyPlacemark_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyPlacemark_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyPlacemark_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyPlacemark_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Placemark_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Placemark",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Placemarks are displayed as symbols at the image's pixel position corresponding to their geographical position. The name is\ndisplayed as label next to the symbol. If the user moves the mouse over a placemark, the textual description property shall\nappear as tool-tip text. Single placemarks can be selected either by mouse-click or by the ? Prev./Next Placemark tool.\nPlacemarks are contained in the active product and stored in CSV format. To share placemarks between products,\nthe placemarks of a product can be imported and exported.\nAuthor:  Norman Fomferra\nVersion:  2.0\nSince version:  BEAM 2.0 (full revision since BEAM 4.10)",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Placemark_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef IndexValidator_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexValidator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.IndexValidator",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "An interface used as parameter to several methods which perform some actions on data arrays.\nIt is used to decide whether or not an array value shall be taken into account for a particular\ncomputation.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexValidator_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Area_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Area_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Area",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Area_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ComponentColorModel_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ComponentColorModel_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ComponentColorModel",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ComponentColorModel_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MathTransform_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MathTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MathTransform",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MathTransform_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef CoordinateReferenceSystem_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject CoordinateReferenceSystem_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.CoordinateReferenceSystem",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    CoordinateReferenceSystem_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductWriterPlugIn_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductWriterPlugIn_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductWriterPlugIn",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductWriterPlugIn interface is implemented by data product writer plug-ins.\n\nXMLCoder plug-ins are used to provide meta-information about a particular data format and to create instances of\nthe actual writer objects.\n\n A plug-in can register itself in the ProductIO plug-in registry or it is automatically found during\na classpath scan.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see ProductReaderPlugIn",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductWriterPlugIn_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef IndexColorModel_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject IndexColorModel_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.IndexColorModel",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    IndexColorModel_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductNodeListener_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNodeListener_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductNodeListener",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A listener which listens to internal data product changes.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNodeListener_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MetadataElement_methods[] = {
    {"newMetadataElement", (PyCFunction) BeamPyMetadataElement_newMetadataElement, METH_VARARGS | METH_STATIC, "Constructs a new metadata element.\nReturns Parameter name: the element name"},
    {"getElementGroup", (PyCFunction) BeamPyMetadataElement_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\nReturns the child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyMetadataElement_getParentElement, METH_VARARGS, ""},
    {"addElement", (PyCFunction) BeamPyMetadataElement_addElement, METH_VARARGS, "Adds the given element to this element.\nReturns Parameter element: the element to added, ignored if null"},
    {"addElementAt", (PyCFunction) BeamPyMetadataElement_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\nReturns Parameter element: the element to added, ignored if null\nReturns Parameter index: where to put it"},
    {"removeElement", (PyCFunction) BeamPyMetadataElement_removeElement, METH_VARARGS, "Removes the given element from this element.\nReturns Parameter element: the element to be removed, ignored if null\nReturns true, if so"},
    {"getNumElements", (PyCFunction) BeamPyMetadataElement_getNumElements, METH_VARARGS, "Returns the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyMetadataElement_getElementAt, METH_VARARGS, "Returns the element at the given index.\nReturns Parameter index: the element index\nReturns the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyMetadataElement_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\nReturns a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyMetadataElement_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\nReturns an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyMetadataElement_getElement, METH_VARARGS, "Returns the element with the given name.\nReturns Parameter name: the element name\nReturns the element with the given name or null if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyMetadataElement_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\nReturns Parameter name: the name, must not be null\nReturns true if a element with the given name is contained in this element, false\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyMetadataElement_getElementIndex, METH_VARARGS, "Gets the index of the given element.\nReturns Parameter element: The element .\nReturns the element's index, or -1.\nSince version:  BEAM 4.7"},
    {"addAttribute", (PyCFunction) BeamPyMetadataElement_addAttribute, METH_VARARGS, "Adds an attribute to this node.\nReturns Parameter attribute: the attribute to be added, null is ignored"},
    {"removeAttribute", (PyCFunction) BeamPyMetadataElement_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\nReturns Parameter attribute: the attribute to be removed, null is ignored\nReturns true if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyMetadataElement_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\nReturns the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyMetadataElement_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\nReturns Parameter index: the attribute index\nReturns the attribute, or null if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyMetadataElement_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\nReturns the attribute name array, never null"},
    {"getAttributes", (PyCFunction) BeamPyMetadataElement_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\nReturns an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyMetadataElement_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute with the given name or null if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyMetadataElement_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\nReturns Parameter name: the attribute name\nReturns true if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyMetadataElement_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\nReturns Parameter attribute: The attribute.\nReturns the attribute's index, or -1.\nSince version:  BEAM 4.7"},
    {"getAttributeDouble", (PyCFunction) BeamPyMetadataElement_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC2", (PyCFunction) BeamPyMetadataElement_getAttributeUTC2, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as UTC."},
    {"getAttributeUTC1", (PyCFunction) BeamPyMetadataElement_getAttributeUTC1, METH_VARARGS, "Returns the UTC value of the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute value as UTC.\n@throws IllegalArgumentException if an attribute with the given name could not be found"},
    {"getAttributeInt", (PyCFunction) BeamPyMetadataElement_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyMetadataElement_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\nProductData.TYPE_INT32 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyMetadataElement_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\nProductData.TYPE_FLOAT64 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyMetadataElement_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\nProductData.UTC is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"getAttributeString", (PyCFunction) BeamPyMetadataElement_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyMetadataElement_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\nProductData.TYPE_ASCII is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setModified", (PyCFunction) BeamPyMetadataElement_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyMetadataElement_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method first visits (calls acceptVisitor for) all elements contained in this element and then\nvisits all attributes. Finally the method calls visitor.visit(this).\nReturns Parameter visitor: the visitor"},
    {"createDeepClone", (PyCFunction) BeamPyMetadataElement_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyMetadataElement_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyMetadataElement_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyMetadataElement_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyMetadataElement_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyMetadataElement_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyMetadataElement_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyMetadataElement_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyMetadataElement_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyMetadataElement_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyMetadataElement_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyMetadataElement_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyMetadataElement_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyMetadataElement_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyMetadataElement_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyMetadataElement_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyMetadataElement_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyMetadataElement_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MetadataElement_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MetadataElement",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A MetadataElement is a data node used to store metadata. Metadata elements can have any number of\nmetadata attributes of the type {@link MetadataAttribute} and any number of inner MetadataElements.\nAuthor:  Norman Fomferra\nAuthor:  Sabine Embacher\nVersion:  $Revision: 6651 $ $Date: 2009-10-27 12:59:39 +0100 (Di, 27 Okt 2009) $",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MetadataElement_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Color_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Color_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Color",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Color_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef TransectProfileData_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject TransectProfileData_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.TransectProfileData",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A container for data which fully describes a transect profile. Use {@link TransectProfileDataBuilder} to create\ninstances.\nAuthor:  Thomas Storm\nAuthor:  Norman Fomferra",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    TransectProfileData_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef PlacemarkGroup_methods[] = {
    {"getVectorDataNode", (PyCFunction) BeamPyPlacemarkGroup_getVectorDataNode, METH_VARARGS, ""},
    {"getPlacemark", (PyCFunction) BeamPyPlacemarkGroup_getPlacemark, METH_VARARGS, ""},
    {"add3", (PyCFunction) BeamPyPlacemarkGroup_add3, METH_VARARGS, ""},
    {"add1", (PyCFunction) BeamPyPlacemarkGroup_add1, METH_VARARGS, ""},
    {"remove1", (PyCFunction) BeamPyPlacemarkGroup_remove1, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyPlacemarkGroup_dispose, METH_VARARGS, ""},
    {"isTakingOverNodeOwnership", (PyCFunction) BeamPyPlacemarkGroup_isTakingOverNodeOwnership, METH_VARARGS, "Returns {@code true}, if child nodes will have this group as owner after adding."},
    {"getNodeCount", (PyCFunction) BeamPyPlacemarkGroup_getNodeCount, METH_VARARGS, "Returns the number of product nodes in this product group."},
    {"get1", (PyCFunction) BeamPyPlacemarkGroup_get1, METH_VARARGS, "Returns Parameter index: The node index.\nReturns the product node at the given index."},
    {"getNodeDisplayNames", (PyCFunction) BeamPyPlacemarkGroup_getNodeDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\nReturns an array containing the display names, never null, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getNodeNames", (PyCFunction) BeamPyPlacemarkGroup_getNodeNames, METH_VARARGS, "Returns the names of all products currently managed.\nReturns an array containing the names, never null, but the array can have zero length"},
    {"toArray1", (PyCFunction) BeamPyPlacemarkGroup_toArray1, METH_VARARGS, "Returns an array of all products currently managed.\nReturns an array containing the products, never null, but the array can have zero length"},
    {"toArray2", (PyCFunction) BeamPyPlacemarkGroup_toArray2, METH_VARARGS, "Returns Parameter array: the array into which the elements of the list are to be stored, if it is big enough; otherwise, a\nnew array of the same runtime type is allocated for this purpose.\nReturns an array containing the product nodes, never null, but the array can have zero length"},
    {"indexOf1", (PyCFunction) BeamPyPlacemarkGroup_indexOf1, METH_VARARGS, ""},
    {"indexOf2", (PyCFunction) BeamPyPlacemarkGroup_indexOf2, METH_VARARGS, ""},
    {"getByDisplayName", (PyCFunction) BeamPyPlacemarkGroup_getByDisplayName, METH_VARARGS, "Returns Parameter displayName: the display name\nReturns the product node with the given display name."},
    {"get2", (PyCFunction) BeamPyPlacemarkGroup_get2, METH_VARARGS, "Returns Parameter name: the name\nReturns the product node with the given name."},
    {"contains1", (PyCFunction) BeamPyPlacemarkGroup_contains1, METH_VARARGS, "Tests whether a node with the given name is contained in this group.\nReturns Parameter name: the name\nReturns true, if so"},
    {"contains2", (PyCFunction) BeamPyPlacemarkGroup_contains2, METH_VARARGS, "Tests whether the given product is contained in this list.\nReturns Parameter node: the node\nReturns true, if so"},
    {"add4", (PyCFunction) BeamPyPlacemarkGroup_add4, METH_VARARGS, "Adds the given node to this group.\nReturns Parameter node: the node to be added, ignored if null\nReturns true, if the node has been added"},
    {"add2", (PyCFunction) BeamPyPlacemarkGroup_add2, METH_VARARGS, "Adds the given node to this group.\nReturns Parameter index: the index.\nReturns Parameter node: the node to be added, ignored if null"},
    {"remove2", (PyCFunction) BeamPyPlacemarkGroup_remove2, METH_VARARGS, "Removes the given node from this group.\nReturns Parameter node: the node to be removed\nReturns true, if the node was removed"},
    {"removeAll", (PyCFunction) BeamPyPlacemarkGroup_removeAll, METH_VARARGS, "Removes all nodes from this group."},
    {"clearRemovedList", (PyCFunction) BeamPyPlacemarkGroup_clearRemovedList, METH_VARARGS, ""},
    {"getRemovedNodes", (PyCFunction) BeamPyPlacemarkGroup_getRemovedNodes, METH_VARARGS, "Gets all removed node nodes.\nReturns a collection of all removed node nodes."},
    {"getRawStorageSize2", (PyCFunction) BeamPyPlacemarkGroup_getRawStorageSize2, METH_VARARGS, ""},
    {"setModified", (PyCFunction) BeamPyPlacemarkGroup_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyPlacemarkGroup_acceptVisitor, METH_VARARGS, ""},
    {"updateExpression", (PyCFunction) BeamPyPlacemarkGroup_updateExpression, METH_VARARGS, ""},
    {"getOwner", (PyCFunction) BeamPyPlacemarkGroup_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyPlacemarkGroup_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyPlacemarkGroup_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyPlacemarkGroup_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyPlacemarkGroup_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyPlacemarkGroup_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyPlacemarkGroup_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyPlacemarkGroup_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyPlacemarkGroup_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyPlacemarkGroup_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyPlacemarkGroup_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyPlacemarkGroup_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyPlacemarkGroup_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"getRawStorageSize1", (PyCFunction) BeamPyPlacemarkGroup_getRawStorageSize1, METH_VARARGS, "Gets an estimated, raw storage size in bytes of this product node.\nReturns the size in bytes."},
    {"fireProductNodeChanged1", (PyCFunction) BeamPyPlacemarkGroup_fireProductNodeChanged1, METH_VARARGS, ""},
    {"fireProductNodeChanged2", (PyCFunction) BeamPyPlacemarkGroup_fireProductNodeChanged2, METH_VARARGS, ""},
    {"removeFromFile", (PyCFunction) BeamPyPlacemarkGroup_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyPlacemarkGroup_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PlacemarkGroup_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.PlacemarkGroup",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PlacemarkGroup_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Product_methods[] = {
    {"newProduct", (PyCFunction) BeamPyProduct_newProduct, METH_VARARGS | METH_STATIC, "Creates a new product without any reader (in-memory product)\nReturns Parameter name: the product name\nReturns Parameter type: the product type\nReturns Parameter sceneRasterWidth: the scene width in pixels for this data product\nReturns Parameter sceneRasterHeight: the scene height in pixels for this data product"},
    {"getFileLocation", (PyCFunction) BeamPyProduct_getFileLocation, METH_VARARGS, "Retrieves the disk location of this product. The return value can be null when the product has no\ndisk location (pure virtual memory product)\nReturns the file location, may be null"},
    {"setFileLocation", (PyCFunction) BeamPyProduct_setFileLocation, METH_VARARGS, "Sets the file location for this product.\nReturns Parameter fileLocation: the file location, may be null"},
    {"getProductType", (PyCFunction) BeamPyProduct_getProductType, METH_VARARGS, "Gets the product type string.\nReturns the product type string"},
    {"setProductType", (PyCFunction) BeamPyProduct_setProductType, METH_VARARGS, "Sets the product type of this product.\nReturns Parameter productType: the product type."},
    {"setProductReader", (PyCFunction) BeamPyProduct_setProductReader, METH_VARARGS, "Sets the product reader which will be used to create this product in-memory represention from an external source\nand which will be used to (re-)load band rasters.\nReturns Parameter reader: the product reader.\n@throws IllegalArgumentException if the given reader is null."},
    {"getProductReader", (PyCFunction) BeamPyProduct_getProductReader, METH_VARARGS, "Returns the reader which was used to create this product in-memory represention from an external source and which\nwill be used to (re-)load band rasters.\nReturns the product reader, can be null"},
    {"setProductWriter", (PyCFunction) BeamPyProduct_setProductWriter, METH_VARARGS, "Sets the writer which will be used to write modifications of this product's in-memory represention to an external\ndestination.\nReturns Parameter writer: the product writer, can be null"},
    {"getProductWriter", (PyCFunction) BeamPyProduct_getProductWriter, METH_VARARGS, "Returns the writer which will be used to write modifications of this product's in-memory represention to an\nexternal destination.\nReturns the product writer, can be null"},
    {"writeHeader", (PyCFunction) BeamPyProduct_writeHeader, METH_VARARGS, "Writes the header of a data product.\nReturns Parameter output: an object representing a valid output for this writer, might be a ImageOutputStream\nor a File or other Object to use for future decoding.\n@throws IllegalArgumentException if output is null or it's type is none of the\nsupported output types.\n@throws IOException              if an I/O error occurs"},
    {"closeProductReader", (PyCFunction) BeamPyProduct_closeProductReader, METH_VARARGS, "Closes and clears this product's reader (if any).\n@throws IOException if an I/O error occurs\n@see #closeIO"},
    {"closeProductWriter", (PyCFunction) BeamPyProduct_closeProductWriter, METH_VARARGS, "Closes and clears this product's writer (if any).\n@throws IOException if an I/O error occurs\n@see #closeIO"},
    {"closeIO", (PyCFunction) BeamPyProduct_closeIO, METH_VARARGS, "Closes the file I/O for this product. Calls in sequence {@link #closeProductReader}  and\n{@link #closeProductWriter}. The {@link #dispose} method is not called, but\nshould be called if the product instance is no longer in use.\n@throws IOException if an I/O error occurs\n@see #closeProductReader\n@see #closeProductWriter\n@see #dispose"},
    {"dispose", (PyCFunction) BeamPyProduct_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance.\n\nThis implementation also calls the closeIO in order to release all open I/O resources."},
    {"getPointingFactory", (PyCFunction) BeamPyProduct_getPointingFactory, METH_VARARGS, "Gets the pointing factory associated with this data product.\nReturns the pointing factory or null, if none"},
    {"setPointingFactory", (PyCFunction) BeamPyProduct_setPointingFactory, METH_VARARGS, "Sets the pointing factory for this data product.\nReturns Parameter pointingFactory: the pointing factory"},
    {"setGeoCoding", (PyCFunction) BeamPyProduct_setGeoCoding, METH_VARARGS, "Geo-codes this data product.\nReturns Parameter geoCoding: the geo-coding, if null geo-coding is removed\n@throws IllegalArgumentException <br>- if the given GeoCoding is a TiePointGeoCoding\nand latGrid or lonGrid are not instances of tie point\ngrids in this product. <br>- if the given GeoCoding is a\nMapGeoCoding and its MapInfo is null\n<br>- if the given GeoCoding is a MapGeoCoding and the\nsceneWith or sceneHeight of its MapInfo\nis not equal to this products sceneRasterWidth or\nsceneRasterHeight"},
    {"getGeoCoding", (PyCFunction) BeamPyProduct_getGeoCoding, METH_VARARGS, "Returns the geo-coding used for this data product.\nReturns the geo-coding, can be null if this product is not geo-coded."},
    {"isUsingSingleGeoCoding", (PyCFunction) BeamPyProduct_isUsingSingleGeoCoding, METH_VARARGS, "Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing\nthe band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.\nIf this product does not have a geo-coding, the method returns false.\nReturns true, if so"},
    {"transferGeoCodingTo", (PyCFunction) BeamPyProduct_transferGeoCodingTo, METH_VARARGS, "Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to\nthe given {@link ProductSubsetDef subsetDef}.\nReturns Parameter destProduct: the destination product\nReturns Parameter subsetDef: the definition of the subset, may be null\nReturns true, if the geo-coding could be transferred."},
    {"getSceneRasterWidth", (PyCFunction) BeamPyProduct_getSceneRasterWidth, METH_VARARGS, "Returns the scene width in pixels for this data product.\nReturns the scene width in pixels for this data product."},
    {"getSceneRasterHeight", (PyCFunction) BeamPyProduct_getSceneRasterHeight, METH_VARARGS, "Returns the scene height in pixels for this data product.\nReturns the scene height in pixels for this data product."},
    {"getStartTime", (PyCFunction) BeamPyProduct_getStartTime, METH_VARARGS, "Gets the (sensing) start time associated with the first raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the first raster data line.\nFor Level-3 products, this could be the start time of first input product\ncontributing data.\nReturns the sensing start time, can be null e.g. for non-swath products"},
    {"setStartTime", (PyCFunction) BeamPyProduct_setStartTime, METH_VARARGS, "Sets the (sensing) start time of this product.\n\nFor Level-1/2 products this is\nthe data-take time associated with the first raster data line.\nFor Level-3 products, this could be the start time of first input product\ncontributing data.\nReturns Parameter startTime: the sensing start time, can be null"},
    {"getEndTime", (PyCFunction) BeamPyProduct_getEndTime, METH_VARARGS, "Gets the (sensing) stop time associated with the last raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the last raster data line.\nFor Level-3 products, this could be the end time of last input product\ncontributing data.\nReturns the stop time , can be null e.g. for non-swath products"},
    {"setEndTime", (PyCFunction) BeamPyProduct_setEndTime, METH_VARARGS, "Sets the (sensing) stop time associated with the first raster data line.\n\nFor Level-1/2 products this is\nthe data-take time associated with the last raster data line.\nFor Level-3 products, this could be the end time of last input product\ncontributing data.\nReturns Parameter endTime: the sensing stop time, can be null"},
    {"getMetadataRoot", (PyCFunction) BeamPyProduct_getMetadataRoot, METH_VARARGS, "Gets the root element of the associated metadata.\nReturns the metadata root element"},
    {"getBandGroup", (PyCFunction) BeamPyProduct_getBandGroup, METH_VARARGS, "Gets the band group of this product.\nReturns the group of all bands.\nSince version:  BEAM 4.7"},
    {"getTiePointGridGroup", (PyCFunction) BeamPyProduct_getTiePointGridGroup, METH_VARARGS, "Gets the tie-point grid group of this product.\nReturns the group of all tie-point grids.\nSince version:  BEAM 4.7"},
    {"addTiePointGrid", (PyCFunction) BeamPyProduct_addTiePointGrid, METH_VARARGS, "Adds the given tie-point grid to this product.\nReturns Parameter tiePointGrid: the tie-point grid to added, ignored if null"},
    {"removeTiePointGrid", (PyCFunction) BeamPyProduct_removeTiePointGrid, METH_VARARGS, "Removes the tie-point grid from this product.\nReturns Parameter tiePointGrid: the tie-point grid to be removed, ignored if null\nReturns true if node could be removed"},
    {"getNumTiePointGrids", (PyCFunction) BeamPyProduct_getNumTiePointGrids, METH_VARARGS, "Returns the number of tie-point grids contained in this product\nReturns the number of tie-point grids"},
    {"getTiePointGridAt", (PyCFunction) BeamPyProduct_getTiePointGridAt, METH_VARARGS, "Returns the tie-point grid at the given index.\nReturns Parameter index: the tie-point grid index\nReturns the tie-point grid at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getTiePointGridNames", (PyCFunction) BeamPyProduct_getTiePointGridNames, METH_VARARGS, "Returns a string array containing the names of the tie-point grids contained in this product\nReturns a string array containing the names of the tie-point grids contained in this product. If this product has\nno tie-point grids a zero-length-array is returned."},
    {"getTiePointGrids", (PyCFunction) BeamPyProduct_getTiePointGrids, METH_VARARGS, "Returns an array of tie-point grids contained in this product\nReturns an array of tie-point grids contained in this product. If this product has no  tie-point grids a\nzero-length-array is returned."},
    {"getTiePointGrid", (PyCFunction) BeamPyProduct_getTiePointGrid, METH_VARARGS, "Returns the tie-point grid with the given name.\nReturns Parameter name: the tie-point grid name\nReturns the tie-point grid with the given name or null if a tie-point grid with the given name is\nnot contained in this product."},
    {"containsTiePointGrid", (PyCFunction) BeamPyProduct_containsTiePointGrid, METH_VARARGS, "Tests if a tie-point grid with the given name is contained in this product.\nReturns Parameter name: the name, must not be null\nReturns true if a tie-point grid with the given name is contained in this product,\nfalse otherwise"},
    {"addBand", (PyCFunction) BeamPyProduct_addBand, METH_VARARGS, "Adds the given band to this product.\nReturns Parameter band: the band to added, must not be null"},
    {"addNewBand", (PyCFunction) BeamPyProduct_addNewBand, METH_VARARGS, "Creates a new band with the given name and data type and adds it to this product and returns it.\nReturns Parameter bandName: the new band's name\nReturns Parameter dataType: the raster data type, must be one of the multiple ProductData.TYPE_X\nconstants\nReturns the new band which has just been added"},
    {"addComputedBand", (PyCFunction) BeamPyProduct_addComputedBand, METH_VARARGS, "Creates a new band with the given name and adds it to this product and returns it.\nThe new band's data type is {@code float} and it's samples are computed from the given band maths expression.\nReturns Parameter bandName: the new band's name\nReturns Parameter expression: the band maths expression\nReturns the new band which has just been added\nSince version:  BEAM 4.9"},
    {"removeBand", (PyCFunction) BeamPyProduct_removeBand, METH_VARARGS, "Removes the given band from this product.\nReturns Parameter band: the band to be removed, ignored if null\nReturns {@code true} if removed succesfully, otherwise {@code false}"},
    {"getNumBands", (PyCFunction) BeamPyProduct_getNumBands, METH_VARARGS, "Returns the number of bands contained in this product."},
    {"getBandAt", (PyCFunction) BeamPyProduct_getBandAt, METH_VARARGS, "Returns the band at the given index.\nReturns Parameter index: the band index\nReturns the band at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getBandNames", (PyCFunction) BeamPyProduct_getBandNames, METH_VARARGS, "Returns a string array containing the names of the bands contained in this product\nReturns a string array containing the names of the bands contained in this product. If this product has no bands\na zero-length-array is returned."},
    {"getBands", (PyCFunction) BeamPyProduct_getBands, METH_VARARGS, "Returns an array of bands contained in this product\nReturns an array of bands contained in this product. If this product has no bands a zero-length-array is\nreturned."},
    {"getBand", (PyCFunction) BeamPyProduct_getBand, METH_VARARGS, "Returns the band with the given name.\nReturns Parameter name: the band name\nReturns the band with the given name or null if a band with the given name is not contained in this\nproduct.\n@throws IllegalArgumentException if the given name is null or empty."},
    {"getBandIndex", (PyCFunction) BeamPyProduct_getBandIndex, METH_VARARGS, "Returns the index for the band with the given name.\nReturns Parameter name: the band name\nReturns the band index or -1 if a band with the given name is not contained in this product.\n@throws IllegalArgumentException if the given name is null or empty."},
    {"containsBand", (PyCFunction) BeamPyProduct_containsBand, METH_VARARGS, "Tests if a band with the given name is contained in this product.\nReturns Parameter name: the name, must not be null\nReturns true if a band with the given name is contained in this product, false\notherwise\n@throws IllegalArgumentException if the given name is null or empty."},
    {"containsRasterDataNode", (PyCFunction) BeamPyProduct_containsRasterDataNode, METH_VARARGS, "Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or\ntie-point grids.\nReturns Parameter name: the name, must not be null\nReturns true if a raster data node with the given name is contained in this product,\nfalse otherwise"},
    {"getRasterDataNode", (PyCFunction) BeamPyProduct_getRasterDataNode, METH_VARARGS, "Gets the raster data node with the given name. The method first searches for bands with the given name, then for\ntie-point grids. If neither bands nor tie-point grids exist with the given name, null is returned.\nReturns Parameter name: the name, must not be null\nReturns the raster data node with the given name or null if a raster data node with the given name\nis not contained in this product."},
    {"getMaskGroup", (PyCFunction) BeamPyProduct_getMaskGroup, METH_VARARGS, ""},
    {"getVectorDataGroup", (PyCFunction) BeamPyProduct_getVectorDataGroup, METH_VARARGS, ""},
    {"getFlagCodingGroup", (PyCFunction) BeamPyProduct_getFlagCodingGroup, METH_VARARGS, ""},
    {"getIndexCodingGroup", (PyCFunction) BeamPyProduct_getIndexCodingGroup, METH_VARARGS, ""},
    {"containsPixel", (PyCFunction) BeamPyProduct_containsPixel, METH_VARARGS, "Tests if the given pixel position is within the product pixel bounds.\nReturns Parameter x: the x coordinate of the pixel position\nReturns Parameter y: the y coordinate of the pixel position\nReturns true, if so\n@see #containsPixel(PixelPos)"},
    {"getGcpGroup", (PyCFunction) BeamPyProduct_getGcpGroup, METH_VARARGS, "Gets the group of ground-control points (GCPs).\nNote that this method will create the group, if none exists already.\nReturns the GCP group."},
    {"getPinGroup", (PyCFunction) BeamPyProduct_getPinGroup, METH_VARARGS, "Gets the group of pins.\nNote that this method will create the group, if none exists already.\nReturns the pin group."},
    {"isCompatibleProduct", (PyCFunction) BeamPyProduct_isCompatibleProduct, METH_VARARGS, "Checks whether or not the given product is compatible with this product.\nReturns Parameter product: the product to compare with\nReturns Parameter eps: the maximum lat/lon error in degree\nReturns false if the scene dimensions or geocoding are different, true otherwise."},
    {"parseExpression", (PyCFunction) BeamPyProduct_parseExpression, METH_VARARGS, "Parses a mathematical expression given as a text string.\nReturns Parameter expression: a expression given as a text string, e.g. \"radiance_4 / (1.0 + radiance_11)\".\nReturns a term parsed from the given expression string\n@throws ParseException if the expression could not successfully be parsed"},
    {"acceptVisitor", (PyCFunction) BeamPyProduct_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method subsequentially visits (calls acceptVisitor for) all bands, tie-point grids and flag\ncodings. Finally it visits product metadata root element and calls visitor.visit(this).\nReturns Parameter visitor: the visitor, must not be null"},
    {"addProductNodeListener", (PyCFunction) BeamPyProduct_addProductNodeListener, METH_VARARGS, "Adds a ProductNodeListener to this product. The ProductNodeListener is informed each\ntime a node in this product changes.\nReturns Parameter listener: the listener to be added\nReturns boolean if listener was added or not"},
    {"removeProductNodeListener", (PyCFunction) BeamPyProduct_removeProductNodeListener, METH_VARARGS, "Removes a ProductNodeListener from this product.\nReturns Parameter listener: the listener to be removed."},
    {"getProductNodeListeners", (PyCFunction) BeamPyProduct_getProductNodeListeners, METH_VARARGS, ""},
    {"getRefNo", (PyCFunction) BeamPyProduct_getRefNo, METH_VARARGS, "Returns the reference number of this product."},
    {"setRefNo", (PyCFunction) BeamPyProduct_setRefNo, METH_VARARGS, "Sets the reference number.\nReturns Parameter refNo: the reference number to set must be in the range 1 .. Integer.MAX_VALUE\n@throws IllegalArgumentException if the refNo is out of range\n@throws IllegalStateException"},
    {"resetRefNo", (PyCFunction) BeamPyProduct_resetRefNo, METH_VARARGS, ""},
    {"getProductManager", (PyCFunction) BeamPyProduct_getProductManager, METH_VARARGS, "Returns the product manager for this product.\nReturns this product's manager, can be null"},
    {"createBandArithmeticParser", (PyCFunction) BeamPyProduct_createBandArithmeticParser, METH_VARARGS, "Creates a parser for band arithmetic expressions.\nThe parser created will use a namespace comprising all tie-point grids, bands and flags of this product.\nReturns a parser for band arithmetic expressions for this product, never null"},
    {"createBandArithmeticDefaultNamespace", (PyCFunction) BeamPyProduct_createBandArithmeticDefaultNamespace, METH_VARARGS, "Creates a namespace to be used by parsers for band arithmetic expressions.\nThe namespace created comprises all tie-point grids, bands and flags of this product.\nReturns a namespace, never null"},
    {"createSubset", (PyCFunction) BeamPyProduct_createSubset, METH_VARARGS, "Creates a subset of this product. The returned product represents a true spatial and spectral subset of this\nproduct, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the\ndescription from this product was used.\nReturns Parameter subsetDef: the product subset definition\nReturns Parameter name: the name for the new product\nReturns Parameter desc: the description for the new product\nReturns the product subset, or null if the product/subset combination is not valid\n@throws IOException if an I/O error occurs"},
    {"createFlippedProduct", (PyCFunction) BeamPyProduct_createFlippedProduct, METH_VARARGS, "Creates flipped raster-data version of this product.\nReturns Parameter flipType: the flip type, see {@link ProductFlipper}\nReturns Parameter name: the name for the new product\nReturns Parameter desc: the description for the new product\nReturns the product subset, or null if the product/subset combination is not valid\n@throws IOException if an I/O error occurs"},
    {"setModified", (PyCFunction) BeamPyProduct_setModified, METH_VARARGS, ""},
    {"getQuicklookBandName", (PyCFunction) BeamPyProduct_getQuicklookBandName, METH_VARARGS, "Gets the name of the band suitable for quicklook generation.\nReturns the name of the quicklook band, or null if none has been defined"},
    {"setQuicklookBandName", (PyCFunction) BeamPyProduct_setQuicklookBandName, METH_VARARGS, "Sets the name of the band suitable for quicklook generation.\nReturns Parameter quicklookBandName: the name of the quicklook band, or null"},
    {"createPixelInfoString", (PyCFunction) BeamPyProduct_createPixelInfoString, METH_VARARGS, "Creates a string containing all available information at the given pixel position. The string returned is a line\nseparated text with each line containing a key/value pair.\nReturns Parameter pixelX: the pixel X co-ordinate\nReturns Parameter pixelY: the pixel Y co-ordinate\nReturns the info string at the given position"},
    {"getRemovedChildNodes", (PyCFunction) BeamPyProduct_getRemovedChildNodes, METH_VARARGS, "Returns all removed child nodes. Array may be empty."},
    {"canBeOrthorectified", (PyCFunction) BeamPyProduct_canBeOrthorectified, METH_VARARGS, "Checks whether or not this product can be ortorectified.\nReturns true if {@link Band#canBeOrthorectified()} returns true for all bands, false otherwise"},
    {"getPreferredTileSize", (PyCFunction) BeamPyProduct_getPreferredTileSize, METH_VARARGS, "Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\ncreated for a {@link RasterDataNode} of this product.\nReturns the preferred tile size, may be null</null> if not specified\n@see RasterDataNode#getSourceImage()\n@see RasterDataNode# setSourceImage (java.awt.image.RenderedImage)"},
    {"setPreferredTileSize", (PyCFunction) BeamPyProduct_setPreferredTileSize, METH_VARARGS, "Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\ncreated for a {@link RasterDataNode} of this product.\nReturns Parameter tileWidth: the preferred tile width\nReturns Parameter tileHeight: the preferred tile height\n@see #setPreferredTileSize(java.awt.Dimension)"},
    {"getAllFlagNames", (PyCFunction) BeamPyProduct_getAllFlagNames, METH_VARARGS, "Returns the names of all flags of all flag datasets contained this product.\n\nA flag name contains the dataset (a band of this product) and the actual flag name as defined in the\nflag-coding associated with the dataset. The general format for the flag name strings returned is therefore\n\"dataset.flag_name\".\n\nThe method is used to find out which flags a product has in order to use them in bit-mask expressions.\nReturns the array of all flag names. If this product does not support flags, an empty array is returned, but\nnever null.\n@see #parseExpression(String)"},
    {"getAutoGrouping", (PyCFunction) BeamPyProduct_getAutoGrouping, METH_VARARGS, "Gets the auto-grouping applicable to product nodes contained in this product.\nReturns the auto-grouping or {@code null}.\nSince version:  BEAM 4.8"},
    {"setAutoGrouping2", (PyCFunction) BeamPyProduct_setAutoGrouping2, METH_VARARGS, "Sets the auto-grouping applicable to product nodes contained in this product.\nReturns Parameter autoGrouping: The auto-grouping or {@code null}.\nSince version:  BEAM 4.8"},
    {"setAutoGrouping1", (PyCFunction) BeamPyProduct_setAutoGrouping1, METH_VARARGS, "Sets the auto-grouping applicable to product nodes contained in this product.\nA given {@code pattern} parameter is a textual representation of the auto-grouping.\nThe syntax for the pattern is:\n<pre>\npattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | \"\" (empty string)\ngroupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}\ngroupName  :=  any non-empty string without characters ':' and '/'\n</pre>\nAn example for {@code pattern} applicable to Envisat AATSR data is\n<pre>\nnadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward\n</pre>\nReturns Parameter pattern: The auto-grouping pattern.\nSince version:  BEAM 4.8"},
    {"addMask", (PyCFunction) BeamPyProduct_addMask, METH_VARARGS, "Creates a new mask with the given name and image type and adds it to this product and returns it.\nThe new mask's samples are computed from the given image type.\nReturns Parameter maskName: the new mask's name\nReturns Parameter imageType: the image data type used to compute the mask samples\nReturns the new mask which has just been added\nSince version:  BEAM 4.10"},
    {"addComputedMask", (PyCFunction) BeamPyProduct_addComputedMask, METH_VARARGS, "Creates a new mask using a band arithmetic expression\nand adds it to this product and returns it.\nReturns Parameter maskName: the new mask's name\nReturns Parameter expression: the band arithmetic expression\nReturns Parameter description: the mask's description\nReturns Parameter color: the display color\nReturns Parameter transparency: the display transparency\nReturns the new mask which has just been added\nSince version:  BEAM 4.10"},
    {"addBitmaskDef", (PyCFunction) BeamPyProduct_addBitmaskDef, METH_VARARGS, "Adds the given bitmask definition to this product.\nReturns Parameter bitmaskDef: the bitmask definition to added, ignored if null\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getBitmaskDefNames", (PyCFunction) BeamPyProduct_getBitmaskDefNames, METH_VARARGS, "Returns a string array containing the names of the bitmask definitions contained in this product.\nReturns a string array containing the names of the bitmask definitions contained in this product. If this product\nhas no bitmask definitions a zero-length-array is returned.\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getBitmaskDef", (PyCFunction) BeamPyProduct_getBitmaskDef, METH_VARARGS, "Returns the bitmask definition with the given name.\nReturns Parameter name: the bitmask definition name\nReturns the bitmask definition with the given name or null if a bitmask definition with the given\nname is not contained in this product.\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getValidMask", (PyCFunction) BeamPyProduct_getValidMask, METH_VARARGS, "Gets a valid-mask for the given ID.\nReturns Parameter id: the ID\nReturns a cached valid mask for the given ID or null\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"setValidMask", (PyCFunction) BeamPyProduct_setValidMask, METH_VARARGS, "Sets a valid-mask for the given ID.\nReturns Parameter id: the ID\nReturns Parameter validMask: the pixel mask\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"createValidMask2", (PyCFunction) BeamPyProduct_createValidMask2, METH_VARARGS, "Creates a bit-packed valid-mask for all pixels of the scene covered by this product.\nThe given expression is considered to be boolean, if it evaluates to true\nthe related bit in the mask is set.\nReturns Parameter expression: the boolean expression, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\nReturns Parameter pm: a progress monitor\nReturns a bit-packed mask for all pixels of the scene, never null\n@throws IOException if an I/O error occurs\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"createValidMask1", (PyCFunction) BeamPyProduct_createValidMask1, METH_VARARGS, "Creates a bit-packed mask for all pixels of the scene covered by this product.\nThe given term is considered to be boolean, if it evaluates to true\nthe related bit in the mask is set.\nReturns Parameter term: the boolean term, e.g. \"l2_flags.LAND && reflec_10 >= 0.0\"\nReturns Parameter pm: a progress monitor\nReturns a bit-packed mask for all pixels of the scene, never null\n@throws IOException if an I/O error occurs\n@see #createValidMask(String, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"readBitmask2", (PyCFunction) BeamPyProduct_readBitmask2, METH_VARARGS, "Creates a bit-mask by evaluating the given bit-mask term.\n The method first creates an evaluation context for the given bit-mask term and the specified region and then\nevaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\nthe resulting bitmask - is stored in the given boolean array buffer bitmask in the same order as\npixels appear in the given region. The buffer must at least have a length equal to width * height\nelements.\n\n If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\nloaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n\n The {@link #parseExpression(String)} method can be used to create a bit-mask\nterm from a textual bit-mask expression.\n\nReturns Parameter offsetX: the X-offset of the spatial subset in pixel co-ordinates\nReturns Parameter offsetY: the Y-offset of the spatial subset in pixel co-ordinates\nReturns Parameter width: the width of the spatial subset in pixel co-ordinates\nReturns Parameter height: the height of the spatial subset in pixel co-ordinates\nReturns Parameter bitmaskTerm: a bit-mask term, as returned by the {@link #parseExpression(String)} method\nReturns Parameter bitmask: a buffer used to hold the results of the bit-mask evaluations for each pixel in the given\nspatial subset\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"readBitmask1", (PyCFunction) BeamPyProduct_readBitmask1, METH_VARARGS, "Creates a bit-mask by evaluating the given bit-mask term.\n\n The method first creates an evaluation context for the given bit-mask term and the specified region and then\nevaluates the term for each pixel in the subset (line-by-line, X varies fastest). The result of each evaluation -\nthe resulting bitmask - is stored in the given boolean array buffer bitmask in the same order as\npixels appear in the given region. The buffer must at least have a length equal to width * height\nelements.\n\n If flag providing datasets are referenced in the given bit-mask expression which are currently not completely\nloaded, the method reloads the spatial subset from the data source in order to create the evaluation context.\n\n The {@link #parseExpression(String)} method can be used to create a bit-mask\nterm from a textual bit-mask expression.\nReturns Parameter offsetX: the X-offset of the spatial subset in pixel co-ordinates\nReturns Parameter offsetY: the Y-offset of the spatial subset in pixel co-ordinates\nReturns Parameter width: the width of the spatial subset in pixel co-ordinates\nReturns Parameter height: the height of the spatial subset in pixel co-ordinates\nReturns Parameter bitmaskTerm: a bit-mask term, as returned by the {@link #parseExpression(String)}\nmethod\nReturns Parameter bitmask: a byte buffer used to hold the results of the bit-mask evaluations for each pixel in the given\nspatial subset\nReturns Parameter trueValue: the byte value to be set if the bitmask-term evauates to true\nReturns Parameter falseValue: the byte value to be set if the bitmask-term evauates to false\n@throws IOException if an I/O error occurs, when referenced flag datasets are reloaded\n@see #parseExpression(String)\n@deprecated since BEAM 4.7, use {@link #getMaskGroup()} instead"},
    {"getOwner", (PyCFunction) BeamPyProduct_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyProduct_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyProduct_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyProduct_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyProduct_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyProduct_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyProduct_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyProduct_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyProduct_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getDisplayName", (PyCFunction) BeamPyProduct_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyProduct_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyProduct_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyProduct_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyProduct_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Product_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Product",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Product instances are an in-memory representation of a remote sensing data product. The product is more\nan abstract hull containing references to the data of the product or readers to retrieve the data on demant. The\nproduct itself does not hold the remote sensing data. Data products can contain multiple geophysical parameters\nstored as bands and can also have multiple metadata attributes. Also, a Product can contain any number\nof TiePointGrids holding the tie point data.\n\nEvery product can also have a product reader and writer assigned to it. The reader represents the data source from\nwhich a product was created, whereas the writer represents the data sink. Both, the source and the sink must not\nnecessarily store data in the same format. Furthermore, it is not mandatory for a product to have both of them.\nAuthor:  Norman Fomferra\nVersion:  $Revision: 8401 $ $Date: 2010-02-12 17:17:06 +0100 (Fr, 12 Feb 2010) $",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Product_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductVisitor_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductVisitor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductVisitor",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A visitor for a product and all other product nodes. This interface is part of the visitor pattern used to\nvisit all nodes of a data product. Implementations of this interface can be passed to the acceptVisitor\nmethod of an Product (or any other ProductNode).\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see Product#acceptVisitor(ProductVisitor)\n@see ProductNode#acceptVisitor(ProductVisitor)",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductVisitor_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef WritableNamespace_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject WritableNamespace_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.WritableNamespace",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    WritableNamespace_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Set_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Set_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Set",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Set_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MultiLevelImage_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MultiLevelImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MultiLevelImage",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MultiLevelImage_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef RenderingHints_Key_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderingHints_Key_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.RenderingHints_Key",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderingHints_Key_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ROI_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ROI_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ROI",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ROI_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductManager_Listener_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductManager_Listener_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductManager_Listener",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A listener for the product manager.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductManager_Listener_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ColorPaletteDef_methods[] = {
    {"newColorPaletteDefFromRange", (PyCFunction) BeamPyColorPaletteDef_newColorPaletteDefFromRange, METH_VARARGS | METH_STATIC, ""},
    {"newColorPaletteDef1", (PyCFunction) BeamPyColorPaletteDef_newColorPaletteDef1, METH_VARARGS | METH_STATIC, ""},
    {"newColorPaletteDef2", (PyCFunction) BeamPyColorPaletteDef_newColorPaletteDef2, METH_VARARGS | METH_STATIC, ""},
    {"isDiscrete", (PyCFunction) BeamPyColorPaletteDef_isDiscrete, METH_VARARGS, ""},
    {"setDiscrete", (PyCFunction) BeamPyColorPaletteDef_setDiscrete, METH_VARARGS, ""},
    {"getNumColors", (PyCFunction) BeamPyColorPaletteDef_getNumColors, METH_VARARGS, ""},
    {"setNumColors", (PyCFunction) BeamPyColorPaletteDef_setNumColors, METH_VARARGS, ""},
    {"getNumPoints", (PyCFunction) BeamPyColorPaletteDef_getNumPoints, METH_VARARGS, ""},
    {"setNumPoints", (PyCFunction) BeamPyColorPaletteDef_setNumPoints, METH_VARARGS, ""},
    {"isAutoDistribute", (PyCFunction) BeamPyColorPaletteDef_isAutoDistribute, METH_VARARGS, ""},
    {"setAutoDistribute", (PyCFunction) BeamPyColorPaletteDef_setAutoDistribute, METH_VARARGS, ""},
    {"getPointAt", (PyCFunction) BeamPyColorPaletteDef_getPointAt, METH_VARARGS, ""},
    {"getFirstPoint", (PyCFunction) BeamPyColorPaletteDef_getFirstPoint, METH_VARARGS, ""},
    {"getLastPoint", (PyCFunction) BeamPyColorPaletteDef_getLastPoint, METH_VARARGS, ""},
    {"getMinDisplaySample", (PyCFunction) BeamPyColorPaletteDef_getMinDisplaySample, METH_VARARGS, ""},
    {"getMaxDisplaySample", (PyCFunction) BeamPyColorPaletteDef_getMaxDisplaySample, METH_VARARGS, ""},
    {"insertPointAfter", (PyCFunction) BeamPyColorPaletteDef_insertPointAfter, METH_VARARGS, ""},
    {"createPointAfter", (PyCFunction) BeamPyColorPaletteDef_createPointAfter, METH_VARARGS, "creates a new point between the point at the given index\nReturns Parameter index: the index\nReturns Parameter scaling: the scaling\nReturns true, if a point has been inserted"},
    {"getCenterColor", (PyCFunction) BeamPyColorPaletteDef_getCenterColor, METH_VARARGS | METH_STATIC, "Creates the center color between the given two colors.\nReturns Parameter c1: 1st color\nReturns Parameter c2: 2nd color\nReturns the center color"},
    {"removePointAt", (PyCFunction) BeamPyColorPaletteDef_removePointAt, METH_VARARGS, ""},
    {"addPoint", (PyCFunction) BeamPyColorPaletteDef_addPoint, METH_VARARGS, ""},
    {"getPoints", (PyCFunction) BeamPyColorPaletteDef_getPoints, METH_VARARGS, ""},
    {"setPoints", (PyCFunction) BeamPyColorPaletteDef_setPoints, METH_VARARGS, ""},
    {"getIterator", (PyCFunction) BeamPyColorPaletteDef_getIterator, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyColorPaletteDef_clone, METH_VARARGS, ""},
    {"createDeepCopy", (PyCFunction) BeamPyColorPaletteDef_createDeepCopy, METH_VARARGS, ""},
    {"loadColorPaletteDef", (PyCFunction) BeamPyColorPaletteDef_loadColorPaletteDef, METH_VARARGS | METH_STATIC, "Loads a color palette definition from the given file\nReturns Parameter file: the file\nReturns the color palette definition, never null\n@throws IOException if an I/O error occurs"},
    {"storeColorPaletteDef", (PyCFunction) BeamPyColorPaletteDef_storeColorPaletteDef, METH_VARARGS | METH_STATIC, "Stores this color palette definition in the given file\nReturns Parameter colorPaletteDef: thje color palette definition\nReturns Parameter file: the file\n@throws IOException if an I/O error occurs"},
    {"dispose", (PyCFunction) BeamPyColorPaletteDef_dispose, METH_VARARGS, "Releases all of the resources used by this color palette definition and all of its owned children. Its primary\nuse is to allow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"getColors", (PyCFunction) BeamPyColorPaletteDef_getColors, METH_VARARGS, ""},
    {"createColorPalette", (PyCFunction) BeamPyColorPaletteDef_createColorPalette, METH_VARARGS, ""},
    {"computeColor", (PyCFunction) BeamPyColorPaletteDef_computeColor, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ColorPaletteDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ColorPaletteDef",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ColorPaletteDef class represents a curve that is used to transform the sample values of a\ngeo-physical band into color palette indexes.\n\n This special implemnentation of a gradation curve also provides separate color values for each of the tie points\ncontained in the curve. This allows a better image interpretation because certain colors correspond to certain sample\nvalues even if the curve points are used to create color gradient palettes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ColorPaletteDef_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Geometry_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Geometry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Geometry",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Geometry_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ImageInfo_methods[] = {
    {"newImageInfoPalette", (PyCFunction) BeamPyImageInfo_newImageInfoPalette, METH_VARARGS | METH_STATIC, "Constructs a new image information instance.\nReturns Parameter colorPaletteDef: the color palette definition"},
    {"newImageInfoRGB", (PyCFunction) BeamPyImageInfo_newImageInfoRGB, METH_VARARGS | METH_STATIC, "Constructs a new RGB image information instance.\nReturns Parameter rgbChannelDef: the RGB channel definition"},
    {"getColorPaletteDef", (PyCFunction) BeamPyImageInfo_getColorPaletteDef, METH_VARARGS, "Gets the color palette definition as used for images created from single bands.\nReturns the color palette definition. Can be {@code null}.\nIn this case {@link #getRgbChannelDef()} is non-null."},
    {"getRgbChannelDef", (PyCFunction) BeamPyImageInfo_getRgbChannelDef, METH_VARARGS, "Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.\nReturns the RGB(A) channel definition.\nCan be {@code null}. In this case {@link #getColorPaletteDef()} is non-null."},
    {"getNoDataColor", (PyCFunction) BeamPyImageInfo_getNoDataColor, METH_VARARGS, ""},
    {"setNoDataColor", (PyCFunction) BeamPyImageInfo_setNoDataColor, METH_VARARGS, ""},
    {"getHistogramMatching1", (PyCFunction) BeamPyImageInfo_getHistogramMatching1, METH_VARARGS, ""},
    {"setHistogramMatching", (PyCFunction) BeamPyImageInfo_setHistogramMatching, METH_VARARGS, ""},
    {"isLogScaled", (PyCFunction) BeamPyImageInfo_isLogScaled, METH_VARARGS, ""},
    {"setLogScaled", (PyCFunction) BeamPyImageInfo_setLogScaled, METH_VARARGS, ""},
    {"getColors", (PyCFunction) BeamPyImageInfo_getColors, METH_VARARGS, ""},
    {"getColorComponentCount", (PyCFunction) BeamPyImageInfo_getColorComponentCount, METH_VARARGS, "Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.\nReturns {@code 3} for RGB images, {@code 4} for RGB images with an alpha channel (transparency)"},
    {"createIndexColorModel", (PyCFunction) BeamPyImageInfo_createIndexColorModel, METH_VARARGS, ""},
    {"createComponentColorModel", (PyCFunction) BeamPyImageInfo_createComponentColorModel, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyImageInfo_clone, METH_VARARGS, "Creates and returns a copy of this object.\nReturns a copy of this object"},
    {"createDeepCopy", (PyCFunction) BeamPyImageInfo_createDeepCopy, METH_VARARGS, "Creates and returns a \"deep\" copy of this object. The method simply returns the value of\n{@link #clone()}.\nReturns a copy of this object"},
    {"dispose", (PyCFunction) BeamPyImageInfo_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"setColors", (PyCFunction) BeamPyImageInfo_setColors, METH_VARARGS, "Sets the colours of the colour palette of this image info.\nReturns Parameter colors: the new colours"},
    {"setColorPaletteDef", (PyCFunction) BeamPyImageInfo_setColorPaletteDef, METH_VARARGS, "Transfers the colour palette into this image info.\nReturns Parameter colorPaletteDef: another colour palette\nReturns Parameter minSample: the minium allowed sample value in the new colour palette\nReturns Parameter maxSample: the maximum allowed sample value in the new colour palette\nReturns Parameter autoDistribute: if true, points are distributed between minSample/maxSample."},
    {"getHistogramMatching2", (PyCFunction) BeamPyImageInfo_getHistogramMatching2, METH_VARARGS | METH_STATIC, "Converts a string to a histogram matching.\nReturns Parameter mode: the histogram matching string\nReturns the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\"."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ImageInfo",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "This class contains information about how a product's raster data node is displayed as an image.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInfo_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef String_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject String_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.String",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    String_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Histogram_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Histogram_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Histogram",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Instances of the Histogram class store histogram data.\nAuthor:  Norman Fomferra",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Histogram_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef TiePointGrid_methods[] = {
    {"newTiePointGrid1", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid1, METH_VARARGS | METH_STATIC, "Constructs a new TiePointGrid with the given tie point grid properties.\nReturns Parameter name: the name of the new object\nReturns Parameter gridWidth: the width of the tie-point grid in pixels\nReturns Parameter gridHeight: the height of the tie-point grid in pixels\nReturns Parameter offsetX: the X co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter offsetY: the Y co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter subSamplingX: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter subSamplingY: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter tiePoints: the tie-point data values, must be an array of the size gridWidth * gridHeight"},
    {"newTiePointGrid2", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid2, METH_VARARGS | METH_STATIC, "Constructs a new TiePointGrid with the given tie point grid properties.\nReturns Parameter name: the name of the new object\nReturns Parameter gridWidth: the width of the tie-point grid in pixels\nReturns Parameter gridHeight: the height of the tie-point grid in pixels\nReturns Parameter offsetX: the X co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter offsetY: the Y co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter subSamplingX: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter subSamplingY: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter tiePoints: the tie-point data values, must be an array of the size gridWidth * gridHeight\nReturns Parameter discontinuity: the discontinuity mode, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180}\n{@link #DISCONT_AT_360}"},
    {"newTiePointGrid3", (PyCFunction) BeamPyTiePointGrid_newTiePointGrid3, METH_VARARGS | METH_STATIC, "Constructs a new TiePointGrid with the given tie point grid properties.\nReturns Parameter name: the name of the new object\nReturns Parameter gridWidth: the width of the tie-point grid in pixels\nReturns Parameter gridHeight: the height of the tie-point grid in pixels\nReturns Parameter offsetX: the X co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter offsetY: the Y co-ordinate of the first (upper-left) tie-point in pixels\nReturns Parameter subSamplingX: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter subSamplingY: the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to. Must not be less than one.\nReturns Parameter tiePoints: the tie-point data values, must be an array of the size gridWidth * gridHeight\nReturns Parameter containsAngles: if true, the {@link #getDiscontinuity() angular discontinuity} is derived from the provided tie-point data values"},
    {"getDiscontinuity2", (PyCFunction) BeamPyTiePointGrid_getDiscontinuity2, METH_VARARGS | METH_STATIC, "Determines the angular discontinuity of the given tie point values.\nReturns the angular discontinuity, will always be either {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"getDiscontinuity1", (PyCFunction) BeamPyTiePointGrid_getDiscontinuity1, METH_VARARGS, "Gets the angular discontinuity.\nReturns the angular discontinuity, will always be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"setDiscontinuity", (PyCFunction) BeamPyTiePointGrid_setDiscontinuity, METH_VARARGS, "Sets the angular discontinuity.\nReturns Parameter discontinuity: angular discontinuity, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n{@link #DISCONT_AT_360}"},
    {"isFloatingPointType", (PyCFunction) BeamPyTiePointGrid_isFloatingPointType, METH_VARARGS, "Returns true\nReturns true"},
    {"getGeophysicalDataType", (PyCFunction) BeamPyTiePointGrid_getGeophysicalDataType, METH_VARARGS, "Returns the geophysical data type of this RasterDataNode. The value retuned is always one of the\nProductData.TYPE_XXX constants.\nReturns the geophysical data type\n@see ProductData"},
    {"getSceneRasterData", (PyCFunction) BeamPyTiePointGrid_getSceneRasterData, METH_VARARGS, "Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. \n\nIn opposite to the getRasterData method, this method returns raster data that has at least\ngetBandOutputRasterWidth()*getBandOutputRasterHeight() elements of the given data type to store\nthe scene's pixels.\nReturns raster data covering the pixels for a complete scene\n@see #getRasterData\n@see #getRasterWidth\n@see #getRasterHeight\n@see #getSceneRasterWidth\n@see #getSceneRasterHeight"},
    {"getSceneRasterWidth", (PyCFunction) BeamPyTiePointGrid_getSceneRasterWidth, METH_VARARGS, "Returns the width in pixels of the scene represented by this tie-point grid. The value returned is\n(getRasterWidth() - 1) * getSubSamplingX() + 1\nReturns the scene width in pixels"},
    {"getSceneRasterHeight", (PyCFunction) BeamPyTiePointGrid_getSceneRasterHeight, METH_VARARGS, "Returns the height in pixels of the scene represented by this tie-point grid. The value returned is\n(getRasterHeight() - 1) * getSubSamplingY() + 1\nReturns the scene height in pixels"},
    {"getOffsetX", (PyCFunction) BeamPyTiePointGrid_getOffsetX, METH_VARARGS, "Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels."},
    {"getOffsetY", (PyCFunction) BeamPyTiePointGrid_getOffsetY, METH_VARARGS, "Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels."},
    {"getSubSamplingX", (PyCFunction) BeamPyTiePointGrid_getSubSamplingX, METH_VARARGS, "Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this\ntie-pint grid belongs to.\nReturns the sub-sampling in X-direction, never less than one."},
    {"getSubSamplingY", (PyCFunction) BeamPyTiePointGrid_getSubSamplingY, METH_VARARGS, "Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this\ntie-pint grid belongs to.\nReturns the sub-sampling in Y-direction, never less than one."},
    {"getTiePoints", (PyCFunction) BeamPyTiePointGrid_getTiePoints, METH_VARARGS, "Gets the data array holding this band's pixel samples.\nReturns the data array for this band, or null if no data has been loaded\n@see ProductData#getElems"},
    {"getPixelInt", (PyCFunction) BeamPyTiePointGrid_getPixelInt, METH_VARARGS, "Gets the interpolated sample for the pixel located at (x,y) as an integer value. \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\nReturns Parameter x: The X co-ordinate of the pixel location\nReturns Parameter y: The Y co-ordinate of the pixel location\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"dispose", (PyCFunction) BeamPyTiePointGrid_dispose, METH_VARARGS, ""},
    {"getPixelFloat2", (PyCFunction) BeamPyTiePointGrid_getPixelFloat2, METH_VARARGS, "Computes the interpolated sample for the pixel located at (x,y). \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\nReturns Parameter x: The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\nReturns Parameter y: The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"getPixelFloat1", (PyCFunction) BeamPyTiePointGrid_getPixelFloat1, METH_VARARGS, "Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. \n\nIf the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\nReturns Parameter x: The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\nReturns Parameter y: The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"getPixelDouble", (PyCFunction) BeamPyTiePointGrid_getPixelDouble, METH_VARARGS, "Gets the interpolated sample for the pixel located at (x,y) as a double value. \n\nIf the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\nReturns Parameter x: The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\nReturns Parameter y: The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\nthis tie-pint grid belongs to.\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds"},
    {"setPixelInt", (PyCFunction) BeamPyTiePointGrid_setPixelInt, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixelFloat", (PyCFunction) BeamPyTiePointGrid_setPixelFloat, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixelDouble", (PyCFunction) BeamPyTiePointGrid_setPixelDouble, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"getPixels6", (PyCFunction) BeamPyTiePointGrid_getPixels6, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given\narray is null a new one was created and returned.\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the integer array to be filled with data\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"getPixels4", (PyCFunction) BeamPyTiePointGrid_getPixels4, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product width and height as float array. If the given\narray is null a new one is created and returned.\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the float array to be filled with data\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"getPixels2", (PyCFunction) BeamPyTiePointGrid_getPixels2, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\narray is null a new one was created and returned.\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the double array to be filled with data\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"setPixels3", (PyCFunction) BeamPyTiePointGrid_setPixels3, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixels2", (PyCFunction) BeamPyTiePointGrid_setPixels2, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"setPixels1", (PyCFunction) BeamPyTiePointGrid_setPixels1, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"readPixels6", (PyCFunction) BeamPyTiePointGrid_readPixels6, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\narray is null a new one was created and returned.\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the integer array to be filled with data\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"readPixels4", (PyCFunction) BeamPyTiePointGrid_readPixels4, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\narray is null a new one was created and returned. *\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the float array to be filled with data\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"readPixels2", (PyCFunction) BeamPyTiePointGrid_readPixels2, METH_VARARGS, "Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\narray is null a new one was created and returned.\nReturns Parameter x: the x coordinate of the array to be read\nReturns Parameter y: the y coordinate of the array to be read\nReturns Parameter w: the width of the array to be read\nReturns Parameter h: the height of the array to be read\nReturns Parameter pixels: the double array to be filled with data\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IllegalArgumentException if the length of the given array is less than w*h."},
    {"writePixels6", (PyCFunction) BeamPyTiePointGrid_writePixels6, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"writePixels4", (PyCFunction) BeamPyTiePointGrid_writePixels4, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"writePixels2", (PyCFunction) BeamPyTiePointGrid_writePixels2, METH_VARARGS, "This method is not implemented because pixels are read-only in tie-point grids."},
    {"readRasterData2", (PyCFunction) BeamPyTiePointGrid_readRasterData2, METH_VARARGS, "Reads raster data from this dataset into the user-supplied raster data buffer. \n\nThis method always directly (re-)reads this band's data from its associated data source into the given data\nbuffer.\nReturns Parameter offsetX: the X-offset in the raster co-ordinates where reading starts\nReturns Parameter offsetY: the Y-offset in the raster co-ordinates where reading starts\nReturns Parameter width: the width of the raster data buffer\nReturns Parameter height: the height of the raster data buffer\nReturns Parameter rasterData: a raster data buffer receiving the pixels to be read\nReturns Parameter pm: a monitor to inform the user about progress\n@throws java.io.IOException      if an I/O error occurs\n@throws IllegalArgumentException if the raster is null\n@throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\nwhich this product raster belongs to, has no associated product reader\n@see ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)"},
    {"readRasterDataFully2", (PyCFunction) BeamPyTiePointGrid_readRasterDataFully2, METH_VARARGS, "{@inheritDoc}"},
    {"writeRasterData2", (PyCFunction) BeamPyTiePointGrid_writeRasterData2, METH_VARARGS, "{@inheritDoc}"},
    {"writeRasterDataFully2", (PyCFunction) BeamPyTiePointGrid_writeRasterDataFully2, METH_VARARGS, "{@inheritDoc}"},
    {"acceptVisitor", (PyCFunction) BeamPyTiePointGrid_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor. \n\nThe method simply calls visitor.visit(this).\nReturns Parameter visitor: the visitor"},
    {"cloneTiePointGrid", (PyCFunction) BeamPyTiePointGrid_cloneTiePointGrid, METH_VARARGS, ""},
    {"createZenithFromElevationAngleTiePointGrid", (PyCFunction) BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid, METH_VARARGS | METH_STATIC, ""},
    {"createSubset", (PyCFunction) BeamPyTiePointGrid_createSubset, METH_VARARGS | METH_STATIC, ""},
    {"getRasterWidth", (PyCFunction) BeamPyTiePointGrid_getRasterWidth, METH_VARARGS, "Returns the width of the raster used by this product raster.\nReturns the width of the raster"},
    {"getRasterHeight", (PyCFunction) BeamPyTiePointGrid_getRasterHeight, METH_VARARGS, "Returns the height of the raster used by this product raster.\nReturns the height of the raster"},
    {"setModified", (PyCFunction) BeamPyTiePointGrid_setModified, METH_VARARGS, ""},
    {"getGeoCoding", (PyCFunction) BeamPyTiePointGrid_getGeoCoding, METH_VARARGS, "Returns the geo-coding of this {@link RasterDataNode}.\nReturns the geo-coding"},
    {"setGeoCoding", (PyCFunction) BeamPyTiePointGrid_setGeoCoding, METH_VARARGS, "Sets the geo-coding for this {@link RasterDataNode}.\nAlso sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_GEOCODING}.\nReturns Parameter geoCoding: the new geo-coding\n@see Product#setGeoCoding(GeoCoding)"},
    {"getPointing", (PyCFunction) BeamPyTiePointGrid_getPointing, METH_VARARGS, "Gets a {@link Pointing} if one is available for this raster.\nThe methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\nsince the last creation of this raster's {@link Pointing} instance.\nReturns the pointing object, or null if a pointing is not available"},
    {"canBeOrthorectified", (PyCFunction) BeamPyTiePointGrid_canBeOrthorectified, METH_VARARGS, "Tests if this raster data node can be orthorectified.\nReturns true, if so"},
    {"getScalingFactor", (PyCFunction) BeamPyTiePointGrid_getScalingFactor, METH_VARARGS, "Gets the scaling factor which is applied to raw {@link ProductData}. The default value is\n1.0 (no factor).\nReturns the scaling factor\n@see #isScalingApplied()"},
    {"setScalingFactor", (PyCFunction) BeamPyTiePointGrid_setScalingFactor, METH_VARARGS, "Sets the scaling factor which is applied to raw {@link ProductData}.\nReturns Parameter scalingFactor: the scaling factor\n@see #isScalingApplied()"},
    {"getScalingOffset", (PyCFunction) BeamPyTiePointGrid_getScalingOffset, METH_VARARGS, "Gets the scaling offset which is applied to raw {@link ProductData}. The default value is\n0.0 (no offset).\nReturns the scaling offset\n@see #isScalingApplied()"},
    {"setScalingOffset", (PyCFunction) BeamPyTiePointGrid_setScalingOffset, METH_VARARGS, "Sets the scaling offset which is applied to raw {@link ProductData}.\nReturns Parameter scalingOffset: the scaling offset\n@see #isScalingApplied()"},
    {"isLog10Scaled", (PyCFunction) BeamPyTiePointGrid_isLog10Scaled, METH_VARARGS, "Gets whether or not the {@link ProductData} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data. The default value is\nfalse.\nReturns whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"setLog10Scaled", (PyCFunction) BeamPyTiePointGrid_setLog10Scaled, METH_VARARGS, "Sets whether or not the {@link ProductData} of this band has a negative binominal distribution and\nthus the common logarithm (base 10) of the values is stored in the raw data.\nReturns Parameter log10Scaled: whether or not the data is logging-10 scaled\n@see #isScalingApplied()"},
    {"isScalingApplied", (PyCFunction) BeamPyTiePointGrid_isScalingApplied, METH_VARARGS, "Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\npixel values. The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n{@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n{@link #writePixels(int, int, int, int, int[])} methods as well as the getPixel&lt;Type&gt; and\nsetPixel&lt;Type&gt; methods such as  {@link #getPixelFloat(int, int)} * and\n{@link #setPixelFloat(int, int, float)}.\nReturns true if a conversion is applyied to raw data samples before the are retuned.\n@see #getScalingOffset\n@see #getScalingFactor\n@see #isLog10Scaled"},
    {"isValidMaskProperty", (PyCFunction) BeamPyTiePointGrid_isValidMaskProperty, METH_VARARGS | METH_STATIC, "Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\nReturns Parameter propertyName: the  name to test\nReturns {@code true}, if so.\nSince version:  BEAM 4.2"},
    {"isNoDataValueSet", (PyCFunction) BeamPyTiePointGrid_isNoDataValueSet, METH_VARARGS, "Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n{@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\nReturns true, if so\n@see #isNoDataValueUsed()\n@see #setNoDataValue(double)"},
    {"clearNoDataValue", (PyCFunction) BeamPyTiePointGrid_clearNoDataValue, METH_VARARGS, "Clears the no-data value, so that {@link #isNoDataValueSet()} will return false."},
    {"isNoDataValueUsed", (PyCFunction) BeamPyTiePointGrid_isNoDataValueUsed, METH_VARARGS, "Tests whether or not the no-data value is used.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns true, if so\n@see #setNoDataValueUsed(boolean)\n@see #isNoDataValueSet()"},
    {"setNoDataValueUsed", (PyCFunction) BeamPyTiePointGrid_setNoDataValueUsed, METH_VARARGS, "Sets whether or not the no-data value is used.\nIf the no-data value is enabled and the no-data value has not been set so far,\na default no-data value it is set with a value of to zero.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\nReturns Parameter noDataValueUsed: true, if so\n@see #isNoDataValueUsed()"},
    {"getNoDataValue", (PyCFunction) BeamPyTiePointGrid_getNoDataValue, METH_VARARGS, "Gets the no-data value as a primitive double.\nNote that the value returned is NOT necessarily the same as the value returned by\n{@link #getGeophysicalNoDataValue()} because no scaling is applied.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nThe method returns 0.0, if no no-data value has been specified so far.\nReturns the no-data value. It is returned as a double in order to cover all other numeric types.\n@see #setNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"setNoDataValue", (PyCFunction) BeamPyTiePointGrid_setNoDataValue, METH_VARARGS, "Sets the no-data value as a primitive double.\nNote that the given value is related to the \"raw\", un-scaled raster data.\nIn order to set the geophysical, scaled no-data value use the method\n{@link #setGeophysicalNoDataValue(double)}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\nReturns Parameter noDataValue: the no-data value. It is passed as a double in order to cover all other numeric types.\n@see #getNoDataValue()\n@see #isNoDataValueSet()"},
    {"getGeophysicalNoDataValue", (PyCFunction) BeamPyTiePointGrid_getGeophysicalNoDataValue, METH_VARARGS, "Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns the geophysical no-data value\n@see #setGeophysicalNoDataValue(double)"},
    {"setGeophysicalNoDataValue", (PyCFunction) BeamPyTiePointGrid_setGeophysicalNoDataValue, METH_VARARGS, "Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\nreturned by {@link #getNoDataValue()}.\nThe no-data value is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_NO_DATA_VALUE}.\nReturns Parameter noDataValue: the new geophysical no-data value\n@see #setGeophysicalNoDataValue(double)\n@see #isNoDataValueSet()"},
    {"getValidPixelExpression", (PyCFunction) BeamPyTiePointGrid_getValidPixelExpression, METH_VARARGS, "Gets the expression that is used to determine whether a pixel is valid or not.\nFor more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns the valid mask expression."},
    {"setValidPixelExpression", (PyCFunction) BeamPyTiePointGrid_setValidPixelExpression, METH_VARARGS, "Sets the expression that is used to determine whether a pixel is valid or not.\nThe valid-pixel expression is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nOn property change, the method calls {@link #fireProductNodeChanged(String)} with the property\nname {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\nReturns Parameter validPixelExpression: the valid mask expression, can be null"},
    {"isValidMaskUsed", (PyCFunction) BeamPyTiePointGrid_isValidMaskUsed, METH_VARARGS, "Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\ntrue if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\nThe data-mask is used to determine valid pixels. For more information\non valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\nmethod.\nReturns true, if so"},
    {"resetValidMask", (PyCFunction) BeamPyTiePointGrid_resetValidMask, METH_VARARGS, "Resets the valid mask of this raster.\nThe mask will be lazily regenerated when requested the next time."},
    {"getValidMaskExpression", (PyCFunction) BeamPyTiePointGrid_getValidMaskExpression, METH_VARARGS, "Gets the expression used for the computation of the mask which identifies valid pixel values.\nIt recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n{@link #getValidPixelExpression() validPixelExpression} properties, if any.\nThe method returns {@code null},  if none of these properties are set.\nReturns the expression used for the computation of the mask which identifies valid pixel values,\nor {@code null}.\n@see #getValidPixelExpression()\n@see #getNoDataValue()\nSince version:  BEAM 4.2"},
    {"updateExpression", (PyCFunction) BeamPyTiePointGrid_updateExpression, METH_VARARGS, "{@inheritDoc}"},
    {"hasRasterData", (PyCFunction) BeamPyTiePointGrid_hasRasterData, METH_VARARGS, "Returns true if the raster data of this RasterDataNode is loaded or elsewhere available, otherwise\nfalse.\nReturns true, if so.\n@deprecated since BEAM 4.11. No replacement."},
    {"getRasterData", (PyCFunction) BeamPyTiePointGrid_getRasterData, METH_VARARGS, "Gets the raster data for this dataset. If the data hasn't been loaded so far the method returns\nnull.\nReturns the raster data for this band, or null if data has not been loaded\n@deprecated Since BEAM 4.11. Use {@link #getSourceImage()} or the various {@link #readPixels readPixels()}\nmethod variants to retrieve or read raster data."},
    {"setRasterData", (PyCFunction) BeamPyTiePointGrid_setRasterData, METH_VARARGS, "Sets the raster data of this dataset.\n\n Note that this method does not copy data at all. If the supplied raster data is compatible with this product\nraster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\ndataset's data!\nReturns Parameter rasterData: the raster data for this dataset\n@see #getRasterData()\n@deprecated Since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels readPixels()}\nmethod variants to set or write raster data."},
    {"loadRasterData1", (PyCFunction) BeamPyTiePointGrid_loadRasterData1, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. No replacement."},
    {"loadRasterData2", (PyCFunction) BeamPyTiePointGrid_loadRasterData2, METH_VARARGS, "Loads the raster data for this RasterDataNode. After this method has been called successfully,\nhasRasterData() should always return true and getRasterData() should\nalways return a valid ProductData instance with at least getRasterWidth()*getRasterHeight()\nelements (samples).\n\nThe default implementation of this method does nothing.\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IOException if an I/O error occurs\n@see #unloadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"unloadRasterData", (PyCFunction) BeamPyTiePointGrid_unloadRasterData, METH_VARARGS, "Un-loads the raster data for this RasterDataNode.\n\nIt is up to the implementation whether after this method has been called successfully, the\nhasRasterData() method returns false or true.\n\nThe default implementation of this method does nothing.\n@see #loadRasterData()\n@deprecated since BEAM 4.11. No replacement."},
    {"isPixelValid2", (PyCFunction) BeamPyTiePointGrid_isPixelValid2, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\n\nNote: Implementation changed by Norman (2011-08-09) in order to increase performance since\na synchronised block was used due to problem with the JAI ROI class that has been used in\nthe former implementation.\nReturns Parameter x: the X co-ordinate of the pixel location\nReturns Parameter y: the Y co-ordinate of the pixel location\nReturns true if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getSampleInt", (PyCFunction) BeamPyTiePointGrid_getSampleInt, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n\nNote: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.\nReturns Parameter x: pixel X coordinate\nReturns Parameter y: pixel Y coordinate\nReturns the geo-physical sample value."},
    {"getSampleFloat", (PyCFunction) BeamPyTiePointGrid_getSampleFloat, METH_VARARGS, "Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n\nNote: This method does not belong to the public API.\nIt has been added by Norman (2011-08-09) in order to perform performance tests.\nReturns Parameter x: pixel X coordinate\nReturns Parameter y: pixel Y coordinate\nReturns the geo-physical sample value."},
    {"isPixelValid1", (PyCFunction) BeamPyTiePointGrid_isPixelValid1, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nA pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\nor if the bit corresponding to (x,y) is set within the returned mask image.\nReturns Parameter pixelIndex: the linear pixel index in the range 0 to width * height - 1\nReturns true if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int, javax.media.jai.ROI)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)\nSince version:  4.1"},
    {"isPixelValid3", (PyCFunction) BeamPyTiePointGrid_isPixelValid3, METH_VARARGS, "Checks whether or not the pixel located at (x,y) is valid.\nThe method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,\nand secondly, if the pixel is within the ROI (if any).\nReturns Parameter x: the X co-ordinate of the pixel location\nReturns Parameter y: the Y co-ordinate of the pixel location\nReturns Parameter roi: the ROI, if null the method returns {@link #isPixelValid(int, int)}\nReturns true if the pixel is valid\n@throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n@see #isPixelValid(int, int)\n@see #setNoDataValueUsed(boolean)\n@see #setNoDataValue(double)\n@see #setValidPixelExpression(String)"},
    {"getPixels5", (PyCFunction) BeamPyTiePointGrid_getPixels5, METH_VARARGS, "@see #getPixels(int, int, int, int, int[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixels3", (PyCFunction) BeamPyTiePointGrid_getPixels3, METH_VARARGS, "@see #getPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"getPixels1", (PyCFunction) BeamPyTiePointGrid_getPixels1, METH_VARARGS, "@see #getPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixels5", (PyCFunction) BeamPyTiePointGrid_readPixels5, METH_VARARGS, "@see #readPixels(int, int, int, int, int[], ProgressMonitor)"},
    {"readPixels3", (PyCFunction) BeamPyTiePointGrid_readPixels3, METH_VARARGS, "@see #readPixels(int, int, int, int, float[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readPixels1", (PyCFunction) BeamPyTiePointGrid_readPixels1, METH_VARARGS, "@see #readPixels(int, int, int, int, double[], ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writePixels5", (PyCFunction) BeamPyTiePointGrid_writePixels5, METH_VARARGS, "@see #writePixels(int, int, int, int, int[], ProgressMonitor)"},
    {"writePixels3", (PyCFunction) BeamPyTiePointGrid_writePixels3, METH_VARARGS, "@see #writePixels(int, int, int, int, float[], ProgressMonitor)"},
    {"writePixels1", (PyCFunction) BeamPyTiePointGrid_writePixels1, METH_VARARGS, "@see #writePixels(int, int, int, int, double[], ProgressMonitor)"},
    {"readValidMask", (PyCFunction) BeamPyTiePointGrid_readValidMask, METH_VARARGS, ""},
    {"readRasterDataFully1", (PyCFunction) BeamPyTiePointGrid_readRasterDataFully1, METH_VARARGS, "@throws java.io.IOException if an I/O error occurs\n@see #readRasterDataFully(ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"readRasterData1", (PyCFunction) BeamPyTiePointGrid_readRasterData1, METH_VARARGS, "Reads raster data from the node's associated data source into the given data\nbuffer.\nReturns Parameter offsetX: the X-offset in the raster co-ordinates where reading starts\nReturns Parameter offsetY: the Y-offset in the raster co-ordinates where reading starts\nReturns Parameter width: the width of the raster data buffer\nReturns Parameter height: the height of the raster data buffer\nReturns Parameter rasterData: a raster data buffer receiving the pixels to be read\n@throws java.io.IOException      if an I/O error occurs\n@throws IllegalArgumentException if the raster is null\n@throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\nwhich this product raster belongs to, has no associated product reader\n@see ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)\n@deprecated since BEAM 4.11. Use {@link #getSourceImage()} instead."},
    {"writeRasterDataFully1", (PyCFunction) BeamPyTiePointGrid_writeRasterDataFully1, METH_VARARGS, ""},
    {"writeRasterData1", (PyCFunction) BeamPyTiePointGrid_writeRasterData1, METH_VARARGS, "@deprecated since BEAM 4.11. Use {@link #setSourceImage setSourceImage()} or the various {@link #writePixels\nreadPixels()} method variants to set or write raster data."},
    {"createCompatibleRasterData1", (PyCFunction) BeamPyTiePointGrid_createCompatibleRasterData1, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\ngetRasterWidth()*getRasterHeight() elements of a compatible data type.\nReturns raster data compatible with this product raster\n@see #createCompatibleSceneRasterData"},
    {"createCompatibleSceneRasterData", (PyCFunction) BeamPyTiePointGrid_createCompatibleSceneRasterData, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\ngetBandOutputRasterWidth()*getBandOutputRasterHeight() elements of a compatible data type.\nReturns raster data compatible with this product raster\n@see #createCompatibleRasterData"},
    {"createCompatibleRasterData2", (PyCFunction) BeamPyTiePointGrid_createCompatibleRasterData2, METH_VARARGS, "Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\nwidth*height elements of a compatible data type.\nReturns Parameter width: the width of the raster data to be created\nReturns Parameter height: the height of the raster data to be created\nReturns raster data compatible with this product raster\n@see #createCompatibleRasterData\n@see #createCompatibleSceneRasterData"},
    {"isCompatibleRasterData", (PyCFunction) BeamPyTiePointGrid_isCompatibleRasterData, METH_VARARGS, "Tests whether the given parameters specify a compatible raster or not.\nReturns Parameter rasterData: the raster data\nReturns Parameter w: the raster width\nReturns Parameter h: the raster height\nReturns {@code true} if so\n@deprecated since BEAM 4.11. No replacement."},
    {"checkCompatibleRasterData", (PyCFunction) BeamPyTiePointGrid_checkCompatibleRasterData, METH_VARARGS, "Throws an IllegalArgumentException if the given parameters dont specify a compatible raster.\nReturns Parameter rasterData: the raster data\nReturns Parameter w: the raster width\nReturns Parameter h: the raster height\n@deprecated since BEAM 4.11. No replacement."},
    {"hasIntPixels", (PyCFunction) BeamPyTiePointGrid_hasIntPixels, METH_VARARGS, "Determines whether this raster data node contains integer samples.\nReturns true if this raster data node contains integer samples."},
    {"createTransectProfileData", (PyCFunction) BeamPyTiePointGrid_createTransectProfileData, METH_VARARGS, "Creates a transect profile for the given shape (-outline).\nReturns Parameter shape: the shape\nReturns the profile data\n@throws IOException if an I/O error occurs"},
    {"getImageInfo1", (PyCFunction) BeamPyTiePointGrid_getImageInfo1, METH_VARARGS, "Gets the image information for image display.\nReturns the image info or null"},
    {"setImageInfo", (PyCFunction) BeamPyTiePointGrid_setImageInfo, METH_VARARGS, "Sets the image information for image display.\nReturns Parameter imageInfo: the image info, can be null"},
    {"fireImageInfoChanged", (PyCFunction) BeamPyTiePointGrid_fireImageInfoChanged, METH_VARARGS, "Notifies listeners that the image (display) information has changed.\nSince version:  BEAM 4.7"},
    {"getImageInfo2", (PyCFunction) BeamPyTiePointGrid_getImageInfo2, METH_VARARGS, "Returns the image information for this raster data node.\n\nThe method simply returns the value of ensureValidImageInfo(null, ProgressMonitor.NULL).\nReturns Parameter pm: A progress monitor.\nReturns a valid image information instance.\n@see #getImageInfo(double[], ProgressMonitor)\nSince version:  BEAM 4.2"},
    {"getImageInfo3", (PyCFunction) BeamPyTiePointGrid_getImageInfo3, METH_VARARGS, "Gets the image creation information.\n\nIf no image information has been assigned before, the {@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)} method is\ncalled with the given parameters passed to this method.\nReturns Parameter histoSkipAreas: Only used, if new image info is created (see {@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}\nmethod).\nReturns Parameter pm: A progress monitor.\nReturns the image creation information.\nSince version:  BEAM 4.2"},
    {"createDefaultImageInfo1", (PyCFunction) BeamPyTiePointGrid_createDefaultImageInfo1, METH_VARARGS, "Creates a default image information instance.\n\nAn IllegalStateException is thrown in the case that this raster data node has no raster data.\nReturns Parameter histoSkipAreas: the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be null, in this case {0.01, 0.04} resp. 5% of\nthe entire area is skipped.\nReturns Parameter pm: a monitor to inform the user about progress\nReturns a valid image information instance, never null."},
    {"createDefaultImageInfo2", (PyCFunction) BeamPyTiePointGrid_createDefaultImageInfo2, METH_VARARGS, "Creates an instance of a default image information.\n\nAn IllegalStateException is thrown in the case that this raster data node has no raster data.\nReturns Parameter histoSkipAreas: the left (at index 0) and right (at index 1) normalized areas of the raster data\nhistogram to be excluded when determining the value range for a linear constrast\nstretching. Can be null, in this case {0.01, 0.04} resp. 5% of\nthe entire area is skipped.\nReturns Parameter histogram: the histogram to create the image information.\nReturns a valid image information instance, never null."},
    {"getOverlayMaskGroup", (PyCFunction) BeamPyTiePointGrid_getOverlayMaskGroup, METH_VARARGS, "Returns the overlay mask group."},
    {"createColorIndexedImage", (PyCFunction) BeamPyTiePointGrid_createColorIndexedImage, METH_VARARGS, "Creates an image for this raster data node. The method simply returns ProductUtils.createColorIndexedImage(this,\nnull).\nReturns Parameter pm: a monitor to inform the user about progress\nReturns a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"createRgbImage", (PyCFunction) BeamPyTiePointGrid_createRgbImage, METH_VARARGS, "Creates an RGB image for this raster data node.\nReturns Parameter pm: a monitor to inform the user about progress\nReturns a greyscale/palette-based image for this raster data node\n@throws IOException if the raster data is not loaded so far and reload causes an I/O error\n@see #setImageInfo(ImageInfo)"},
    {"quantizeRasterData1", (PyCFunction) BeamPyTiePointGrid_quantizeRasterData1, METH_VARARGS, ""},
    {"quantizeRasterData2", (PyCFunction) BeamPyTiePointGrid_quantizeRasterData2, METH_VARARGS, ""},
    {"createPixelValidator", (PyCFunction) BeamPyTiePointGrid_createPixelValidator, METH_VARARGS, "Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\nReturns Parameter lineOffset: the absolute line offset, zero based\nReturns Parameter roi: an optional ROI\nReturns a new validator instance, never null\n@throws IOException if an I/O error occurs"},
    {"scale", (PyCFunction) BeamPyTiePointGrid_scale, METH_VARARGS, "Applies the scaling v * scalingFactor + scalingOffset the the given input value. If the\nlog10Scaled property is true, the result is taken to the power of 10 after the actual\nscaling.\nReturns Parameter v: the input value\nReturns the scaled value"},
    {"scaleInverse", (PyCFunction) BeamPyTiePointGrid_scaleInverse, METH_VARARGS, "Applies the inverse scaling (v - scalingOffset) / scalingFactor the the given input value. If the\nlog10Scaled property is true, the common logarithm is applied to the input before the actual\nscaling.\nReturns Parameter v: the input value\nReturns the scaled value"},
    {"getPixelString", (PyCFunction) BeamPyTiePointGrid_getPixelString, METH_VARARGS, "Returns the pixel located at (x,y) as a string value.\nReturns Parameter x: the X co-ordinate of the pixel location\nReturns Parameter y: the Y co-ordinate of the pixel location\nReturns the pixel value at (x,y) as string or an error message text"},
    {"isSourceImageSet", (PyCFunction) BeamPyTiePointGrid_isSourceImageSet, METH_VARARGS, "Returns whether the source image is set on this {@code RasterDataNode}.\nReturns whether the source image is set.\n@see #getSourceImage()\n@see #setSourceImage(java.awt.image.RenderedImage)\n@see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n@see #createSourceImage()\nSince version:  BEAM 4.5"},
    {"getSourceImage", (PyCFunction) BeamPyTiePointGrid_getSourceImage, METH_VARARGS, "Gets the source image associated with this {@code RasterDataNode}.\nReturns the source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\nthe method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n@see #createSourceImage()\n@see #isSourceImageSet()\nSince version:  BEAM 4.2"},
    {"setSourceImage2", (PyCFunction) BeamPyTiePointGrid_setSourceImage2, METH_VARARGS, "Sets the source image associated with this {@code RasterDataNode}.\nReturns Parameter sourceImage: The source image.\nCan be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\nSince version:  BEAM 4.2"},
    {"setSourceImage1", (PyCFunction) BeamPyTiePointGrid_setSourceImage1, METH_VARARGS, "Sets the source image associated with this {@code RasterDataNode}.\nReturns Parameter sourceImage: The source image.\nCan be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\nSince version:  BEAM 4.6"},
    {"isGeophysicalImageSet", (PyCFunction) BeamPyTiePointGrid_isGeophysicalImageSet, METH_VARARGS, "Returns whether the geophysical image is set on this {@code RasterDataNode}.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns whether the geophysical image is set.\nSince version:  BEAM 4.6"},
    {"getGeophysicalImage", (PyCFunction) BeamPyTiePointGrid_getGeophysicalImage, METH_VARARGS, "Returns the geophysical source image.\nSince version:  BEAM 4.5"},
    {"isValidMaskImageSet", (PyCFunction) BeamPyTiePointGrid_isValidMaskImageSet, METH_VARARGS, "Returns wether the valid mask image is set on this {@code RasterDataNode}.\nReturns wether the source image is set.\nSince version:  BEAM 4.5"},
    {"getValidMaskImage", (PyCFunction) BeamPyTiePointGrid_getValidMaskImage, METH_VARARGS, "Gets the valid-mask image associated with this {@code RasterDataNode}.\nReturns the rendered image.\nSince version:  BEAM 4.2"},
    {"isStxSet", (PyCFunction) BeamPyTiePointGrid_isStxSet, METH_VARARGS, ""},
    {"getStx1", (PyCFunction) BeamPyTiePointGrid_getStx1, METH_VARARGS, "Gets the statistics. If statistcs are not yet available,\nthe method will compute (possibly inaccurate) statistics and return those.\n\nIf accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\nshall be used instead.\n\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns the statistics.\n@see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n@see #setStx(Stx)\nSince version:  BEAM 4.2, revised in BEAM 4.5"},
    {"getStx2", (PyCFunction) BeamPyTiePointGrid_getStx2, METH_VARARGS, "Gets the statistics.\nIf the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns Parameter accurate: If true, accurate statistics are computed.\nReturns Parameter pm: A progress monitor which is used to compute the new statistics, if required.\nReturns the statistics.\nSince version:  since BEAM 4.5"},
    {"setStx", (PyCFunction) BeamPyTiePointGrid_setStx, METH_VARARGS, "Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\nare really related to this {@code RasterDataNode}'s raster data.\nThe method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\nThis method belongs to preliminary API and may be removed or changed in the future.\nReturns Parameter stx: The statistics.\nSince version:  BEAM 4.2, revised in BEAM 4.5"},
    {"getValidShape", (PyCFunction) BeamPyTiePointGrid_getValidShape, METH_VARARGS, "Gets the shape of the area where this raster data contains valid samples.\nThe method returns null, if the entire raster contains valid samples.\nReturns the shape of the area where the raster data has samples, can be {@code null}.\nSince version:  BEAM 4.7"},
    {"getRoiMaskGroup", (PyCFunction) BeamPyTiePointGrid_getRoiMaskGroup, METH_VARARGS, "Returns the roi mask group.\n@deprecated since BEAM 4.10 (no replacement)"},
    {"getDataType", (PyCFunction) BeamPyTiePointGrid_getDataType, METH_VARARGS, "Gets the data type of this data node.\nReturns the data type which is always one of the multiple ProductData.TYPE_X constants"},
    {"getNumDataElems", (PyCFunction) BeamPyTiePointGrid_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyTiePointGrid_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyTiePointGrid_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyTiePointGrid_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyTiePointGrid_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyTiePointGrid_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyTiePointGrid_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyTiePointGrid_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyTiePointGrid_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyTiePointGrid_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyTiePointGrid_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyTiePointGrid_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyTiePointGrid_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"getRawStorageSize2", (PyCFunction) BeamPyTiePointGrid_getRawStorageSize2, METH_VARARGS, "Gets the estimated size in bytes of this product node.\nReturns Parameter subsetDef: if not null the subset may limit the size returned\nReturns the size in bytes."},
    {"createCompatibleProductData", (PyCFunction) BeamPyTiePointGrid_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\nnumElems elements of a compatible data type.\nReturns Parameter numElems: the number of elements, must not be less than one\nReturns product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyTiePointGrid_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyTiePointGrid_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyTiePointGrid_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyTiePointGrid_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyTiePointGrid_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyTiePointGrid_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyTiePointGrid_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyTiePointGrid_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyTiePointGrid_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyTiePointGrid_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyTiePointGrid_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyTiePointGrid_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyTiePointGrid_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"getRawStorageSize1", (PyCFunction) BeamPyTiePointGrid_getRawStorageSize1, METH_VARARGS, "Gets an estimated, raw storage size in bytes of this product node.\nReturns the size in bytes."},
    {"fireProductNodeChanged1", (PyCFunction) BeamPyTiePointGrid_fireProductNodeChanged1, METH_VARARGS, ""},
    {"fireProductNodeChanged2", (PyCFunction) BeamPyTiePointGrid_fireProductNodeChanged2, METH_VARARGS, ""},
    {"removeFromFile", (PyCFunction) BeamPyTiePointGrid_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyTiePointGrid_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject TiePointGrid_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.TiePointGrid",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A tie-point grid contains the data for geophysical parameter in remote sensing data products. Tie-point grid are\ntwo-dimensional images which hold their pixel values (samples) in a float array. \n\nUsually, tie-point grids are a sub-sampling of a data product's scene resolution.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    TiePointGrid_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef RGBChannelDef_methods[] = {
    {"newRGBChannelDef", (PyCFunction) BeamPyRGBChannelDef_newRGBChannelDef, METH_VARARGS | METH_STATIC, ""},
    {"getSourceName", (PyCFunction) BeamPyRGBChannelDef_getSourceName, METH_VARARGS, ""},
    {"setSourceName", (PyCFunction) BeamPyRGBChannelDef_setSourceName, METH_VARARGS, ""},
    {"getSourceNames", (PyCFunction) BeamPyRGBChannelDef_getSourceNames, METH_VARARGS, ""},
    {"setSourceNames", (PyCFunction) BeamPyRGBChannelDef_setSourceNames, METH_VARARGS, ""},
    {"isAlphaUsed", (PyCFunction) BeamPyRGBChannelDef_isAlphaUsed, METH_VARARGS, ""},
    {"isGammaUsed", (PyCFunction) BeamPyRGBChannelDef_isGammaUsed, METH_VARARGS, ""},
    {"getGamma", (PyCFunction) BeamPyRGBChannelDef_getGamma, METH_VARARGS, ""},
    {"setGamma", (PyCFunction) BeamPyRGBChannelDef_setGamma, METH_VARARGS, ""},
    {"getMinDisplaySample", (PyCFunction) BeamPyRGBChannelDef_getMinDisplaySample, METH_VARARGS, ""},
    {"setMinDisplaySample", (PyCFunction) BeamPyRGBChannelDef_setMinDisplaySample, METH_VARARGS, ""},
    {"getMaxDisplaySample", (PyCFunction) BeamPyRGBChannelDef_getMaxDisplaySample, METH_VARARGS, ""},
    {"setMaxDisplaySample", (PyCFunction) BeamPyRGBChannelDef_setMaxDisplaySample, METH_VARARGS, ""},
    {"clone", (PyCFunction) BeamPyRGBChannelDef_clone, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RGBChannelDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.RGBChannelDef",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RGBChannelDef_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef VectorDataNode_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject VectorDataNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.VectorDataNode",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A container which allows to store vector data in the BEAM product model.\n\nThis is a preliminary API under construction for BEAM 4.7. Not intended for public use.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@see Product#getVectorDataGroup()\nSince version:  BEAM 4.7",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    VectorDataNode_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ImageInputStream_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInputStream_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ImageInputStream",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInputStream_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef RenderingHints_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderingHints_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.RenderingHints",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderingHints_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Shape_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Shape_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Shape",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Shape_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MapTransform_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapTransform_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MapTransform",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides a parameterized, mathematical algorithm for a map transformation.\n\n@deprecated since BEAM 4.7, use geotools {@link org.geotools.referencing.operation.projection.MapProjection} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapTransform_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Parser_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Parser_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Parser",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Instances of the Parser interface are used to convert a code\nstring representing an arithmetic expression in a tree of terms\nwhich can then be executed by using one of the evaluation methods of\nthe {@link Term} class.\nAuthor:  Norman Fomferra (norman.fomferra@brockmann-consult.de)\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Parser_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductData_methods[] = {
    {"createInstance1", (PyCFunction) BeamPyProductData_createInstance1, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with exactly one element.\nReturns Parameter type: the value's type\nReturns a new value instance, null if the given type is not known"},
    {"createInstance2", (PyCFunction) BeamPyProductData_createInstance2, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with the specified number of elements.\nReturns Parameter type: the value's type\nReturns Parameter numElems: the number of elements, must be greater than zero if type is not {@link ProductData#TYPE_UTC}\nReturns a new value instance, null if the given type is not known\n@throws IllegalArgumentException if one of the arguments is invalid"},
    {"createInstance3", (PyCFunction) BeamPyProductData_createInstance3, METH_VARARGS | METH_STATIC, "Factory method which creates a value instance of the given type and with the specified number of elements.\nReturns Parameter type: the value's type\nReturns Parameter data: if type is TYPE_ASCII the String, otherwise the primitive array type corresponding to type\nReturns a new value instance, null if the given type is not known\n@throws IllegalArgumentException if one of the arguments is invalid"},
    {"createInstance5", (PyCFunction) BeamPyProductData_createInstance5, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance1", (PyCFunction) BeamPyProductData_createUnsignedInstance1, METH_VARARGS | METH_STATIC, ""},
    {"createInstance10", (PyCFunction) BeamPyProductData_createInstance10, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance3", (PyCFunction) BeamPyProductData_createUnsignedInstance3, METH_VARARGS | METH_STATIC, ""},
    {"createInstance8", (PyCFunction) BeamPyProductData_createInstance8, METH_VARARGS | METH_STATIC, ""},
    {"createUnsignedInstance2", (PyCFunction) BeamPyProductData_createUnsignedInstance2, METH_VARARGS | METH_STATIC, ""},
    {"createInstance9", (PyCFunction) BeamPyProductData_createInstance9, METH_VARARGS | METH_STATIC, ""},
    {"createInstance4", (PyCFunction) BeamPyProductData_createInstance4, METH_VARARGS | METH_STATIC, ""},
    {"createInstance7", (PyCFunction) BeamPyProductData_createInstance7, METH_VARARGS | METH_STATIC, ""},
    {"createInstance6", (PyCFunction) BeamPyProductData_createInstance6, METH_VARARGS | METH_STATIC, ""},
    {"getType1", (PyCFunction) BeamPyProductData_getType1, METH_VARARGS, "Returns this value's type ID."},
    {"getElemSize2", (PyCFunction) BeamPyProductData_getElemSize2, METH_VARARGS | METH_STATIC, "Gets the element size of an element of the given type in bytes.\nReturns Parameter type: the element type\nReturns the size of a single element in bytes.\n@throws IllegalArgumentException if the type is not supported."},
    {"getElemSize1", (PyCFunction) BeamPyProductData_getElemSize1, METH_VARARGS, "Gets the element size of an element of this product data in bytes.\nReturns the size of a single element in bytes"},
    {"getTypeString2", (PyCFunction) BeamPyProductData_getTypeString2, METH_VARARGS | METH_STATIC, "Returns a textual representation of the given data type.\nReturns a data type string, null if the type is unknown"},
    {"getType2", (PyCFunction) BeamPyProductData_getType2, METH_VARARGS | METH_STATIC, "Returns a integer representation of the given data type string.\nReturns a data type integer, null if the type is unknown"},
    {"getTypeString1", (PyCFunction) BeamPyProductData_getTypeString1, METH_VARARGS, "Returns this value's data type String."},
    {"isInt", (PyCFunction) BeamPyProductData_isInt, METH_VARARGS, "Tests whether this value has an integer.\nReturns true, if so"},
    {"isIntType", (PyCFunction) BeamPyProductData_isIntType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is a signed or unsigned integer type.\nReturns true, if so"},
    {"isSigned", (PyCFunction) BeamPyProductData_isSigned, METH_VARARGS, "Tests whether the actual instance is an signed data type.\nReturns true, if so"},
    {"isUnsigned", (PyCFunction) BeamPyProductData_isUnsigned, METH_VARARGS, "Tests whether the actual instance is an unsigned data type.\nReturns true, if so"},
    {"isUIntType", (PyCFunction) BeamPyProductData_isUIntType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is an unsigned integer type.\nReturns true, if so"},
    {"isFloatingPointType", (PyCFunction) BeamPyProductData_isFloatingPointType, METH_VARARGS | METH_STATIC, "Tests whether the given value type is a floating point type.\nReturns true, if so"},
    {"isScalar", (PyCFunction) BeamPyProductData_isScalar, METH_VARARGS, "Tests if this value is a scalar.\nReturns true, if so"},
    {"getNumElems", (PyCFunction) BeamPyProductData_getNumElems, METH_VARARGS, "Returns the number of data elements this value has."},
    {"getElemInt", (PyCFunction) BeamPyProductData_getElemInt, METH_VARARGS, "Returns the value as an int. The method assumes that this value is a scalar and therefore simply\nreturns getElemIntAt(0).\n@see #getElemIntAt(int index)"},
    {"getElemUInt", (PyCFunction) BeamPyProductData_getElemUInt, METH_VARARGS, "Returns the value as an unsigned int given as a long. The method assumes that this\nvalue is a scalar and therefore simply returns getElemUIntAt(0).\n@see #getElemUIntAt(int index)"},
    {"getElemFloat", (PyCFunction) BeamPyProductData_getElemFloat, METH_VARARGS, "Returns the value as an float. The method assumes that this value is a scalar and therefore\nsimply returns getElemFloatAt(0).\n@see #getElemFloatAt(int index)"},
    {"getElemDouble", (PyCFunction) BeamPyProductData_getElemDouble, METH_VARARGS, "Returns the value as an double. The method assumes that this value is a scalar and therefore\nsimply returns getElemDoubleAt(0).\n@see #getElemDoubleAt(int index)"},
    {"getElemString", (PyCFunction) BeamPyProductData_getElemString, METH_VARARGS, "Returns the value as a String. The text returned is the comma-separated list of elements contained\nin this value.\nReturns a text representing this fields value, never null"},
    {"getElemBoolean", (PyCFunction) BeamPyProductData_getElemBoolean, METH_VARARGS, "Returns the value as an boolean. The method assumes that this value is a scalar and therefore\nsimply returns getElemBooleanAt(0).\n@see #getElemBooleanAt(int index)"},
    {"getElemIntAt", (PyCFunction) BeamPyProductData_getElemIntAt, METH_VARARGS, "Gets the value element with the given index as an int.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemUIntAt", (PyCFunction) BeamPyProductData_getElemUIntAt, METH_VARARGS, "Gets the value element with the given index as a long.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemFloatAt", (PyCFunction) BeamPyProductData_getElemFloatAt, METH_VARARGS, "Gets the value element with the given index as a float.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemDoubleAt", (PyCFunction) BeamPyProductData_getElemDoubleAt, METH_VARARGS, "Gets the value element with the given index as a double.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemStringAt", (PyCFunction) BeamPyProductData_getElemStringAt, METH_VARARGS, "Gets the value element with the given index as a String.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElemBooleanAt", (PyCFunction) BeamPyProductData_getElemBooleanAt, METH_VARARGS, "Gets the value element with the given index as a boolean.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemInt", (PyCFunction) BeamPyProductData_setElemInt, METH_VARARGS, "Sets the value as an int. The method assumes that this value is a scalar and therefore simply\ncalls setElemInt(0, value).\nReturns Parameter value: the value to be set\n@see #setElemIntAt(int index, int value)"},
    {"setElemUInt", (PyCFunction) BeamPyProductData_setElemUInt, METH_VARARGS, "Sets the value as an unsigned int given as a long. The method assumes that this\nvalue is a scalar and therefore simply calls setElemUInt(0, value).\nReturns Parameter value: the value to be set\n@see #setElemUIntAt(int index, long value)"},
    {"setElemFloat", (PyCFunction) BeamPyProductData_setElemFloat, METH_VARARGS, "Sets the value as a float. The method assumes that this value is a scalar and therefore simply\ncalls setElemFloatAt(0, value).\nReturns Parameter value: the value to be set\n@see #setElemFloatAt(int index, float value)"},
    {"setElemDouble", (PyCFunction) BeamPyProductData_setElemDouble, METH_VARARGS, "Sets the value as a double. The method assumes that this value is a scalar and therefore simply\ncalls setElemDoubleAt(0).\nReturns Parameter value: the value to be set\n@see #setElemDoubleAt(int index, double value)"},
    {"setElemString", (PyCFunction) BeamPyProductData_setElemString, METH_VARARGS, "Sets the value as a String. The method assumes that this value is a scalar and therefore simply\ncalls setElemStringAt(0).\nReturns Parameter value: the value to be set\n@see #setElemStringAt"},
    {"setElemBoolean", (PyCFunction) BeamPyProductData_setElemBoolean, METH_VARARGS, "Sets the value as a boolean. The method assumes that this value is a scalar and therefore simply\ncalls setElemDoubleAt(0).\nReturns Parameter value: the value to be set\n@see #setElemBooleanAt(int index, boolean value)"},
    {"setElemIntAt", (PyCFunction) BeamPyProductData_setElemIntAt, METH_VARARGS, "Sets the value at the specified index as an int.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemUIntAt", (PyCFunction) BeamPyProductData_setElemUIntAt, METH_VARARGS, "Sets the value at the specified index as an unsigned int given as a long.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemFloatAt", (PyCFunction) BeamPyProductData_setElemFloatAt, METH_VARARGS, "Sets the value at the specified index as a float.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemDoubleAt", (PyCFunction) BeamPyProductData_setElemDoubleAt, METH_VARARGS, "Sets the value at the specified index as a double.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemStringAt", (PyCFunction) BeamPyProductData_setElemStringAt, METH_VARARGS, "Sets the value at the specified index as a String.\n\nTHE METHOD IS CURRENTLY NOT IMPLEMENTED.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"setElemBooleanAt", (PyCFunction) BeamPyProductData_setElemBooleanAt, METH_VARARGS, "Sets the value at the specified index as a boolean.\nReturns Parameter index: the value index, must be &gt;=0 and &lt;getNumDataElems()\nReturns Parameter value: the value to be set\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElems", (PyCFunction) BeamPyProductData_getElems, METH_VARARGS, "Returns the internal value. The actual type of the returned object should only be one of <ol>\n<li>byte[] - for signed/unsigned 8-bit integer fields</li> <li>short[] - for\nsigned/unsigned 16-bit integer fields</li> <li>int[] - for signed/unsigned 32-bit integer\nfields</li> <li>float[] - for signed 32-bit floating point fields</li> <li>double[] -\nfor signed 64-bit floating point fields</li> </ol>\nReturns an array of one of the described types"},
    {"setElems", (PyCFunction) BeamPyProductData_setElems, METH_VARARGS, "Sets the internal value. The actual type of the given data object should only be one of <ol>\n<li>byte[] - for signed/unsigned 8-bit integer fields</li> <li>short[] - for\nsigned/unsigned 16-bit integer fields</li> <li>int[] - for signed/unsigned 32-bit integer\nfields</li> <li>float[] - for signed 32-bit floating point fields</li> <li>double[] -\nfor signed 64-bit floating point fields</li> <li>String[] - for all field types</li> </ol>\nReturns Parameter data: an array of one of the described types"},
    {"readFrom4", (PyCFunction) BeamPyProductData_readFrom4, METH_VARARGS, "Reads all elements of this ProductData instance from to the given input stream.\n\n The method subsequentially reads the elements at 0 to getNumElems()-1 of this\nProductData instance from the given input stream.<br> Reading starts at the current seek position\nwithin the input stream.\nReturns Parameter input: a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom3", (PyCFunction) BeamPyProductData_readFrom3, METH_VARARGS, "Reads a single element of this ProductData instance from to the given output stream.\n\n The method reads the element at pos of this ProductData instance from the given\noutput stream.<br> Reading starts at the current seek position within the output stream.\nReturns Parameter pos: the destination position (zero-based)\nReturns Parameter input: a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom1", (PyCFunction) BeamPyProductData_readFrom1, METH_VARARGS, "Reads elements of this ProductData instance from the given output stream.\n\n The method subsequentially reads the elements at startPos to startPos+numElems-1 of\nthis ProductData instance from the given input stream.<br> Reading starts at the current seek\nposition of the input stream.\nReturns Parameter startPos: the destination start position (zero-based)\nReturns Parameter numElems: the number of elements to read\nReturns Parameter input: a seekable data input stream\n@throws IOException if an I/O error occurs"},
    {"readFrom2", (PyCFunction) BeamPyProductData_readFrom2, METH_VARARGS, "Reads elements into this ProductData instance from the given input stream.\n\n The method subsequentially reads the elements at startPos to startPos+numElems-1 of\nthis ProductData instance from the given input stream.<br> Reading starts at inputPos\nwithin the output stream. The method multiplies this position with the value returned by\ngetElemSize() in order to find the correct stream offset in bytes.\nReturns Parameter startPos: the destination start position (zero-based)\nReturns Parameter numElems: the number of elements to read\nReturns Parameter input: a seekable data input stream\nReturns Parameter inputPos: the (zero-based) position in the data output stream where reading starts\n@throws IOException if an I/O error occurs"},
    {"writeTo4", (PyCFunction) BeamPyProductData_writeTo4, METH_VARARGS, "Writes all elements of this ProductData instance to to the given output stream.\n\n The method subsequentially writes the elements at 0 to getNumElems()-1 of this\nProductData instance to the given output stream.<br> Writing starts at the current seek position\nwithin the output stream.\nReturns Parameter output: a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo3", (PyCFunction) BeamPyProductData_writeTo3, METH_VARARGS, "Writes a single element of this ProductData instance to to the given output stream.\n\n The method writes the element at pos of this ProductData instance to the given\noutput stream.<br> Writing starts at the current seek position within the output stream.\nReturns Parameter pos: the source position (zero-based)\nReturns Parameter output: a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo1", (PyCFunction) BeamPyProductData_writeTo1, METH_VARARGS, "Writes elements of this ProductData instance to to the given output stream.\n\n The method subsequentially writes the elements at startPos to startPos+numElems-1\nof this ProductData instance to the given output stream.<br> Writing starts at the current seek\nposition within the output stream.\nReturns Parameter startPos: the source start position (zero-based)\nReturns Parameter numElems: the number of elements to be written\nReturns Parameter output: a seekable data output stream\n@throws IOException if an I/O error occurs"},
    {"writeTo2", (PyCFunction) BeamPyProductData_writeTo2, METH_VARARGS, "Writes elements of this ProductData instance to to the given output stream.\n\n The method subsequentially writes the elements at startPos to startPos+numElems-1\nof this ProductData instance to the given output stream.<br> Writing starts at\noutputPos within the output stream. The method multiplies this position with the value returned by\ngetElemSize() in order to find the correct stream offset in bytes.\nReturns Parameter startPos: the source start position (zero-based)\nReturns Parameter numElems: the number of elements to be written\nReturns Parameter output: a seekable data output stream\nReturns Parameter outputPos: the position in the data output stream where writing starts\n@throws IOException if an I/O error occurs"},
    {"toString", (PyCFunction) BeamPyProductData_toString, METH_VARARGS, "Returns a string representation of this value which can be used for debugging purposes."},
    {"hashCode", (PyCFunction) BeamPyProductData_hashCode, METH_VARARGS, "Returns {@link Object#hashCode()}."},
    {"equals", (PyCFunction) BeamPyProductData_equals, METH_VARARGS, "Returns {@link Object#equals(Object)}.\nUse {@link #equalElems} in order to perform an element-wise comparision."},
    {"equalElems", (PyCFunction) BeamPyProductData_equalElems, METH_VARARGS, "Tests whether this ProductData is equal to another one.\nPerforms an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.\nOtherwise the method behaves like {@link Object#equals(Object)}.\nReturns Parameter other: the other one"},
    {"dispose", (PyCFunction) BeamPyProductData_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductData_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductData",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract ProductData class represents a generic data buffer used to hold the actual data values\nstored in remote sensing data products.\n\n A single ProductData instance can have one or more elements of a primitive type. The primitive types\nare: <ld> <li> {@link ProductData.Byte signed 8-bit integer} </li> <li> {@link ProductData.UByte unsigned 16-bit\ninteger} </li> <li> {@link ProductData.Short signed 32-bit integer} </li> <li> {@link ProductData.UShort unsigned\n16-bit integer} </li> <li> {@link ProductData.Int signed 32-bit integer} </li> <li> {@link ProductData.UInt unsigned\n32-bit integer} </li> <li> {@link ProductData.Float 32-bit floating point} </li> <li> {@link ProductData.Double\n64-bit floating point} </li> <li> {@link ProductData.ASCII a character string (8-bit ASCII encoding)} </li> <li>\n{@link ProductData.UTC a MJD-2000 encoded data/time value} </li> </ld>\n\nThe number of elements is an inmutable property of a ProductData instance.\n\nIn order to access the data in a ProductData instance, multiple setters and getters are provided\nwhich use generic transfer data types in order to make the data transfer in and out of a\nProductData instance easy for programmers.<br> For scalar (one-element) values the prototypes are\n<pre>\nvoid setElemType(Type elem);\nType getElemType();\n</pre>\nFor vector (multiple-element) values the prototypes are\n<pre>\nvoid setElemTypeAt(int index, Type elem);\nType getElemTypeAt(int index);\n</pre>\nWhere the transfer data type Type is one of int, long,\nfloat, double and String.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductData_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef OperatorSpi_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject OperatorSpi_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.OperatorSpi",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The OperatorSpi class is the service provider interface (SPI) for {@link Operator}s.\nTherefore this abstract class is intended to be derived by clients.\nThe SPI is both a descriptor for the operator type and a factory for new {@link Operator} instances.\nAn SPI is required for your operator if you want to make it accessible via an alias name in\nthe various {@link GPF}{@code .create} methods or within GPF Graph XML code.\nSPI are registered either programmatically using the\n{@link GPF#getOperatorSpiRegistry() OperatorSpiRegistry} or\nautomatically via standard Java services lookup mechanism. For the services approach, place a\nfile {@code META-INF/services/OperatorSpi}\nin the JAR file containing your operators and associated SPIs.\nFor each SPI to be automatically registered, place a text line in the file containing the SPI's\nfully qualified class name.\nAuthor:  Norman Fomferra\nAuthor:  Marco Peters\nSince version:  4.1",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    OperatorSpi_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef JtsGeometryConverter_methods[] = {
    {"newJtsGeometryConverter", (PyCFunction) BeamPyJtsGeometryConverter_newJtsGeometryConverter, METH_VARARGS | METH_STATIC, ""},
    {"getValueType", (PyCFunction) BeamPyJtsGeometryConverter_getValueType, METH_VARARGS, ""},
    {"parse", (PyCFunction) BeamPyJtsGeometryConverter_parse, METH_VARARGS, ""},
    {"format", (PyCFunction) BeamPyJtsGeometryConverter_format, METH_VARARGS, ""},
    {"registerConverter", (PyCFunction) BeamPyJtsGeometryConverter_registerConverter, METH_VARARGS | METH_STATIC, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject JtsGeometryConverter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.JtsGeometryConverter",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    JtsGeometryConverter_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Double_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Double_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Double",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Double_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Term_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Term_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Term",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract Term class is an in-memory representation of an\nelement within an arbitrary expression tree. The class defines a number of\nconcrete Term implementations each representing either an\nan atomic leave (number constant, symbol reference) or a node\n(e.g. binary operator, function call) within an expression tree.\n\n Instances of this class are normally created using an expression parser\nwhich implements the {@link com.bc.jexp.Parser} interface.\nThe {@link com.bc.jexp.impl.ParserImpl} class provides a default\nimplementation of such a parser.\nAuthor:  Norman Fomferra (norman.fomferra@brockmann-consult.de)\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Term_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef RasterDataNode_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RasterDataNode_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.RasterDataNode",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The RasterDataNode class ist the abstract base class for all objects in the product package that contain\nrasterized data. i.e. Band and TiePointGrid. It unifies the access to raster data in the\nproduct model. A raster is considered as a rectangular raw data array with a fixed width and height. A raster data\nnode can scale its raw raster data samples in order to return geophysically meaningful pixel values.\nAuthor:  Norman Fomferra\n@see #getRasterData()\n@see #getRasterWidth()\n@see #getRasterHeight()\n@see #isScalingApplied()\n@see #isLog10Scaled()\n@see #getScalingFactor()\n@see #getScalingOffset()",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RasterDataNode_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Product_AutoGrouping_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Product_AutoGrouping_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Product_AutoGrouping",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "AutoGrouping can be used by an application to auto-group a long list of product nodes (e.g. bands)\nas a tree of product nodes.\nSince version:  BEAM 4.8",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Product_AutoGrouping_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Dimension_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Dimension_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Dimension",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Dimension_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Stx_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Stx_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Stx",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides statistic information for a raster data node at a given image resolution level.\nInstances of the Stx class are created using the {@link StxFactory}.\n\nImportant note: This class has been revised in BEAM 4.10. All behaviour has been moved to {@link StxFactory}\nleaving behind this class as a pure data container. Statistics are now furthermore derived upon\ngeo-physically interpreted image data (before it operated on the raw, unscaled data). Thus, it is\nnot required to scale the returned statistical properties, e.g. we used to write\n{@code band.scale(stx.getMean())}. This is not required anymore.\nAuthor:  Norman Fomferra\nAuthor:  Marco Peters\nAuthor:  Ralf Quast\nSince version:  BEAM 4.2, full revision in 4.10",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Stx_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ImageOutputStream_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageOutputStream_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ImageOutputStream",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageOutputStream_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef AngularDirection_methods[] = {
    {"newAngularDirection", (PyCFunction) BeamPyAngularDirection_newAngularDirection, METH_VARARGS | METH_STATIC, ""},
    {"equals", (PyCFunction) BeamPyAngularDirection_equals, METH_VARARGS, ""},
    {"toString", (PyCFunction) BeamPyAngularDirection_toString, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject AngularDirection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.AngularDirection",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    AngularDirection_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef SimpleFeatureType_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SimpleFeatureType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.SimpleFeatureType",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SimpleFeatureType_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductData_UTC_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductData_UTC_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductData_UTC",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductData.UTC class is a ProductData.UInt specialisation for UTC date/time\nvalues.\n\n Internally, data is stored in an int[3] array which represents a Modified Julian Day 2000\n({@link ProductData.UTC#getMJD() MJD}) as a {@link\nProductData.UTC#getDaysFraction() days}, a {@link\nProductData.UTC#getSecondsFraction() seconds} and a {@link\nProductData.UTC#getMicroSecondsFraction() micro-seconds} fraction.\n@see ProductData.UTC#getMJD()\n@see ProductData.UTC#getDaysFraction()\n@see ProductData.UTC#getSecondsFraction()\n@see ProductData.UTC#getMicroSecondsFraction()",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductData_UTC_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Integer_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Integer_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Integer",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Integer_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef RenderedImage_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject RenderedImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.RenderedImage",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    RenderedImage_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Iterator_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Iterator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Iterator",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Iterator_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Mask_ImageType_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Mask_ImageType_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Mask_ImageType",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Specifies a factory for the {@link RasterDataNode#getSourceImage() source image} used by a {@link Mask}.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Mask_ImageType_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef File_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject File_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.File",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    File_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef GeoPos_methods[] = {
    {"newGeoPos", (PyCFunction) BeamPyGeoPos_newGeoPos, METH_VARARGS | METH_STATIC, "Constructs a new geo-position with the given latitude and longitude values.\nReturns Parameter lat: the geographical latitude in decimal degree, valid range is -90 to +90\nReturns Parameter lon: the geographical longitude in decimal degree, valid range is -180 to +180"},
    {"getLat", (PyCFunction) BeamPyGeoPos_getLat, METH_VARARGS, "Gets the latitude value.\nReturns the geographical latitude in decimal degree"},
    {"getLon", (PyCFunction) BeamPyGeoPos_getLon, METH_VARARGS, "Gets the longitude value.\nReturns the geographical longitude in decimal degree"},
    {"setLocation", (PyCFunction) BeamPyGeoPos_setLocation, METH_VARARGS, "Sets the geographical location of this point.\nReturns Parameter lat: the geographical latitude in decimal degree, valid range is -90 to +90\nReturns Parameter lon: the geographical longitude in decimal degree, valid range is -180 to +180"},
    {"isValid", (PyCFunction) BeamPyGeoPos_isValid, METH_VARARGS, "Tests whether or not this geo-position is valid.\nReturns true, if so"},
    {"areValid", (PyCFunction) BeamPyGeoPos_areValid, METH_VARARGS | METH_STATIC, "Tests whether or not all given geo-positions are valid.\nReturns true, if so"},
    {"setInvalid", (PyCFunction) BeamPyGeoPos_setInvalid, METH_VARARGS, "Sets the lat/lon fields so that {@link #isValid()} will return false."},
    {"equals", (PyCFunction) BeamPyGeoPos_equals, METH_VARARGS, "Indicates whether some other object is \"equal to\" this one.\nReturns Parameter obj: the reference object with which to compare.\nReturns true if this object is the same as the obj argument; false otherwise."},
    {"hashCode", (PyCFunction) BeamPyGeoPos_hashCode, METH_VARARGS, "Returns a hash code value for the object.\nReturns a hash code value for this object."},
    {"toString", (PyCFunction) BeamPyGeoPos_toString, METH_VARARGS, "Returns a string representation of the object. In general, the toString method returns a string that\n\"textually represents\" this object.\nReturns a string representation of the object."},
    {"normalize", (PyCFunction) BeamPyGeoPos_normalize, METH_VARARGS, "Normalizes this position so that its longitude is in the range -180 to +180 degree."},
    {"normalizeLon", (PyCFunction) BeamPyGeoPos_normalizeLon, METH_VARARGS | METH_STATIC, "Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.\nNote that -180 will remain as is, although -180 is equivalent to +180 degrees.\nReturns Parameter lon: the longitude in degree\nReturns the normalized longitude in the range"},
    {"getLatString", (PyCFunction) BeamPyGeoPos_getLatString, METH_VARARGS, "Returns a string representation of the latitude value.\nReturns a string of the form DDD°[MM'[SS\"]] [N|S]."},
    {"getLonString", (PyCFunction) BeamPyGeoPos_getLonString, METH_VARARGS, "Returns a string representation of the latitude value.\nReturns a string of the form DDD°[MM'[SS\"]] [W|E]."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoPos_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.GeoPos",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The GeoPos class represents a geographical position measured in longitudes and latitudes.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoPos_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductNodeGroup_methods[] = {
    {"newProductNodeGroup", (PyCFunction) BeamPyProductNodeGroup_newProductNodeGroup, METH_VARARGS | METH_STATIC, "Constructs a node group with no owner and which will not take ownership of added children.\nReturns Parameter name: The group name.\nSince version:  BEAM 4.8"},
    {"isTakingOverNodeOwnership", (PyCFunction) BeamPyProductNodeGroup_isTakingOverNodeOwnership, METH_VARARGS, "Returns {@code true}, if child nodes will have this group as owner after adding."},
    {"getNodeCount", (PyCFunction) BeamPyProductNodeGroup_getNodeCount, METH_VARARGS, "Returns the number of product nodes in this product group."},
    {"getAt", (PyCFunction) BeamPyProductNodeGroup_getAt, METH_VARARGS, "Returns Parameter index: The node index.\nReturns the product node at the given index."},
    {"getNodeDisplayNames", (PyCFunction) BeamPyProductNodeGroup_getNodeDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\nReturns an array containing the display names, never null, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getNodeNames", (PyCFunction) BeamPyProductNodeGroup_getNodeNames, METH_VARARGS, "Returns the names of all products currently managed.\nReturns an array containing the names, never null, but the array can have zero length"},
    {"indexOfName", (PyCFunction) BeamPyProductNodeGroup_indexOfName, METH_VARARGS, ""},
    {"indexOf", (PyCFunction) BeamPyProductNodeGroup_indexOf, METH_VARARGS, ""},
    {"getByDisplayName", (PyCFunction) BeamPyProductNodeGroup_getByDisplayName, METH_VARARGS, "Returns Parameter displayName: the display name\nReturns the product node with the given display name."},
    {"get", (PyCFunction) BeamPyProductNodeGroup_get, METH_VARARGS, "Returns Parameter name: the name\nReturns the product node with the given name."},
    {"containsName", (PyCFunction) BeamPyProductNodeGroup_containsName, METH_VARARGS, "Tests whether a node with the given name is contained in this group.\nReturns Parameter name: the name\nReturns true, if so"},
    {"contains", (PyCFunction) BeamPyProductNodeGroup_contains, METH_VARARGS, "Tests whether the given product is contained in this list.\nReturns Parameter node: the node\nReturns true, if so"},
    {"add", (PyCFunction) BeamPyProductNodeGroup_add, METH_VARARGS, "Adds the given node to this group.\nReturns Parameter node: the node to be added, ignored if null\nReturns true, if the node has been added"},
    {"addAt", (PyCFunction) BeamPyProductNodeGroup_addAt, METH_VARARGS, "Adds the given node to this group.\nReturns Parameter index: the index.\nReturns Parameter node: the node to be added, ignored if null"},
    {"remove", (PyCFunction) BeamPyProductNodeGroup_remove, METH_VARARGS, "Removes the given node from this group.\nReturns Parameter node: the node to be removed\nReturns true, if the node was removed"},
    {"removeAll", (PyCFunction) BeamPyProductNodeGroup_removeAll, METH_VARARGS, "Removes all nodes from this group."},
    {"clearRemovedList", (PyCFunction) BeamPyProductNodeGroup_clearRemovedList, METH_VARARGS, ""},
    {"getRemovedNodes", (PyCFunction) BeamPyProductNodeGroup_getRemovedNodes, METH_VARARGS, "Gets all removed node nodes.\nReturns a collection of all removed node nodes."},
    {"setModified", (PyCFunction) BeamPyProductNodeGroup_setModified, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyProductNodeGroup_acceptVisitor, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyProductNodeGroup_dispose, METH_VARARGS, ""},
    {"updateExpression", (PyCFunction) BeamPyProductNodeGroup_updateExpression, METH_VARARGS, ""},
    {"getOwner", (PyCFunction) BeamPyProductNodeGroup_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyProductNodeGroup_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyProductNodeGroup_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyProductNodeGroup_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyProductNodeGroup_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyProductNodeGroup_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyProductNodeGroup_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyProductNodeGroup_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyProductNodeGroup_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyProductNodeGroup_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyProductNodeGroup_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyProductNodeGroup_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyProductNodeGroup_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"removeFromFile", (PyCFunction) BeamPyProductNodeGroup_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyProductNodeGroup_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductNodeGroup_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductNodeGroup",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A type-safe container for elements of the type ProductNode.\nAuthor:  Norman Fomferra",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductNodeGroup_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductManager_methods[] = {
    {"newProductManager", (PyCFunction) BeamPyProductManager_newProductManager, METH_VARARGS | METH_STATIC, "Constructs an product manager with an empty list of products."},
    {"getProductCount", (PyCFunction) BeamPyProductManager_getProductCount, METH_VARARGS, "Returns the number of products in this product manager."},
    {"getProduct", (PyCFunction) BeamPyProductManager_getProduct, METH_VARARGS, "Gets the product at the given index.\nReturns Parameter index: the index\nReturns the product at the given index."},
    {"getProductDisplayNames", (PyCFunction) BeamPyProductManager_getProductDisplayNames, METH_VARARGS, "Returns the display names of all products currently managed.\nReturns an array containing the display names, never null, but the array can have zero length\n@see ProductNode#getDisplayName()"},
    {"getProductNames", (PyCFunction) BeamPyProductManager_getProductNames, METH_VARARGS, "Returns the names of all products currently managed.\nReturns an array containing the names, never null, but the array can have zero length"},
    {"getProducts", (PyCFunction) BeamPyProductManager_getProducts, METH_VARARGS, "Returns an array of all products currently managed.\nReturns an array containing the products, never null, but the array can have zero length"},
    {"getProductByDisplayName", (PyCFunction) BeamPyProductManager_getProductByDisplayName, METH_VARARGS, "Returns Parameter displayName: The product's display name.\nReturns the product with the given display name."},
    {"getProductByRefNo", (PyCFunction) BeamPyProductManager_getProductByRefNo, METH_VARARGS, "Returns Parameter refNo: The reference number.\nReturns the product with the given reference number."},
    {"getProductByName", (PyCFunction) BeamPyProductManager_getProductByName, METH_VARARGS, "Returns Parameter name: The product name.\nReturns the product with the given name."},
    {"getProductIndex", (PyCFunction) BeamPyProductManager_getProductIndex, METH_VARARGS, ""},
    {"containsProduct", (PyCFunction) BeamPyProductManager_containsProduct, METH_VARARGS, "Tests whether a product with the given name is contained in this list.\nReturns Parameter name: the product name\nReturns true, if so"},
    {"contains", (PyCFunction) BeamPyProductManager_contains, METH_VARARGS, "Tests whether the given product is contained in this list.\nReturns Parameter product: The product.\nReturns {@code true} if so."},
    {"addProduct", (PyCFunction) BeamPyProductManager_addProduct, METH_VARARGS, "Adds the given product to this product manager if it does not already exists and sets it's reference number one\nbiger than the greatest reference number in this product manager.\nReturns Parameter product: the product to be added, ignored if null"},
    {"removeProduct", (PyCFunction) BeamPyProductManager_removeProduct, METH_VARARGS, "Removes the given product from this product manager if it exists.\nReturns Parameter product: the product to be removed, ignored if null\nReturns true, if the product was removed"},
    {"removeAllProducts", (PyCFunction) BeamPyProductManager_removeAllProducts, METH_VARARGS, "Removes all product from this list."},
    {"addListener", (PyCFunction) BeamPyProductManager_addListener, METH_VARARGS, "Adds a ProductManagerListener to this product manager. The ProductManagerListener is\ninformed each time a product was added or removed.\nReturns Parameter listener: the listener to be added.\nReturns true if the listener was added, otherwise false."},
    {"removeListener", (PyCFunction) BeamPyProductManager_removeListener, METH_VARARGS, "Removes a ProductManagerListener from this product manager.\nReturns Parameter listener: The listener.\nReturns true, if the listener was removed, otherwise false."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductManager_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductManager",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A type-safe container for elements of the type Product. ProductListeners can be added to inform if a\nProduct was added or removed.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductManager_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MapProjection_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapProjection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MapProjection",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A map projection is a mathematical model for the transformation of locations from a three-dimensional earth surface\nto a two-dimensional map representation.\n\n@deprecated since BEAM 4.7, use geotools {@link org.geotools.referencing.operation.projection.MapProjection} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapProjection_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef FlagCoding_methods[] = {
    {"newFlagCoding", (PyCFunction) BeamPyFlagCoding_newFlagCoding, METH_VARARGS | METH_STATIC, "Constructs a new flag coding object with the given name.\nReturns Parameter name: the name"},
    {"getFlag", (PyCFunction) BeamPyFlagCoding_getFlag, METH_VARARGS, "Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to\ngetPropertyValue(String).\nReturns Parameter name: the flag name\nReturns a metadata attribute wich is the representation of the flag with the given name"},
    {"getFlagNames", (PyCFunction) BeamPyFlagCoding_getFlagNames, METH_VARARGS, "Returns a string array which contains the names of all flags contained in this FlagCoding object.\nReturns a string array which contains all names of this FlagCoding.<br> If this\nFlagCoding does not contain any flag, null is returned"},
    {"addFlag", (PyCFunction) BeamPyFlagCoding_addFlag, METH_VARARGS, "Adds a new flag definition to this flags coding.\nReturns Parameter name: the flag name\nReturns Parameter flagMask: the flag's bit mask\nReturns Parameter description: the description text\n@throws IllegalArgumentException if name is null\nReturns a new attribute representing the flag."},
    {"getFlagMask", (PyCFunction) BeamPyFlagCoding_getFlagMask, METH_VARARGS, "Returns the flag mask value for the specified flag name.\nReturns Parameter name: the flag name\nReturns flagMask the flag's bit mask as a 32 bit integer\n@throws IllegalArgumentException if name is null, or a flag with the name does not exist"},
    {"acceptVisitor", (PyCFunction) BeamPyFlagCoding_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls visitor.visit(this).\nReturns Parameter visitor: the visitor, must not be null"},
    {"addElement", (PyCFunction) BeamPyFlagCoding_addElement, METH_VARARGS, "Overrides the base class addElement in order to not add an element to this flag coding\nbecause flag codings do not support inner elements.\nReturns Parameter element: the element to be added, always ignored"},
    {"addAttribute", (PyCFunction) BeamPyFlagCoding_addAttribute, METH_VARARGS, "Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\nReturns Parameter attribute: the attribute to be added\n@throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value"},
    {"addSample", (PyCFunction) BeamPyFlagCoding_addSample, METH_VARARGS, "Adds a new coding value to this sample coding.\nReturns Parameter name: the coding name\nReturns Parameter value: the value\nReturns Parameter description: the description text\n@throws IllegalArgumentException if name is null\nReturns a new attribute representing the coded sample."},
    {"getSampleCount", (PyCFunction) BeamPyFlagCoding_getSampleCount, METH_VARARGS, "Gets the number of coded sample values.\nReturns the number of coded sample values"},
    {"getSampleName", (PyCFunction) BeamPyFlagCoding_getSampleName, METH_VARARGS, "Gets the sample name at the specified attribute index.\nReturns Parameter index: the attribute index.\nReturns the sample name."},
    {"getSampleValue", (PyCFunction) BeamPyFlagCoding_getSampleValue, METH_VARARGS, "Gets the sample value at the specified attribute index.\nReturns Parameter index: the attribute index.\nReturns the sample value."},
    {"getElementGroup", (PyCFunction) BeamPyFlagCoding_getElementGroup, METH_VARARGS, "Gets the group of child elements. The method returns null, if this element has no children.\nReturns the child element group, may be null."},
    {"getParentElement", (PyCFunction) BeamPyFlagCoding_getParentElement, METH_VARARGS, ""},
    {"addElementAt", (PyCFunction) BeamPyFlagCoding_addElementAt, METH_VARARGS, "Adds the given element to this element at index.\nReturns Parameter element: the element to added, ignored if null\nReturns Parameter index: where to put it"},
    {"removeElement", (PyCFunction) BeamPyFlagCoding_removeElement, METH_VARARGS, "Removes the given element from this element.\nReturns Parameter element: the element to be removed, ignored if null\nReturns true, if so"},
    {"getNumElements", (PyCFunction) BeamPyFlagCoding_getNumElements, METH_VARARGS, "Returns the number of elements contained in this element."},
    {"getElementAt", (PyCFunction) BeamPyFlagCoding_getElementAt, METH_VARARGS, "Returns the element at the given index.\nReturns Parameter index: the element index\nReturns the element at the given index\n@throws IndexOutOfBoundsException if the index is out of bounds"},
    {"getElementNames", (PyCFunction) BeamPyFlagCoding_getElementNames, METH_VARARGS, "Returns a string array containing the names of the groups contained in this element\nReturns a string array containing the names of the groups contained in this element. If this element has no\ngroups a zero-length-array is returned."},
    {"getElements", (PyCFunction) BeamPyFlagCoding_getElements, METH_VARARGS, "Returns an array of elements contained in this element.\nReturns an array of elements contained in this product. If this element has no elements a zero-length-array is\nreturned."},
    {"getElement", (PyCFunction) BeamPyFlagCoding_getElement, METH_VARARGS, "Returns the element with the given name.\nReturns Parameter name: the element name\nReturns the element with the given name or null if a element with the given name is not contained in\nthis element."},
    {"containsElement", (PyCFunction) BeamPyFlagCoding_containsElement, METH_VARARGS, "Tests if a element with the given name is contained in this element.\nReturns Parameter name: the name, must not be null\nReturns true if a element with the given name is contained in this element, false\notherwise"},
    {"getElementIndex", (PyCFunction) BeamPyFlagCoding_getElementIndex, METH_VARARGS, "Gets the index of the given element.\nReturns Parameter element: The element .\nReturns the element's index, or -1.\nSince version:  BEAM 4.7"},
    {"removeAttribute", (PyCFunction) BeamPyFlagCoding_removeAttribute, METH_VARARGS, "Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\ndoes nothing.\nReturns Parameter attribute: the attribute to be removed, null is ignored\nReturns true if it was removed"},
    {"getNumAttributes", (PyCFunction) BeamPyFlagCoding_getNumAttributes, METH_VARARGS, "Returns the number of attributes attaached to this node.\nReturns the number of attributes"},
    {"getAttributeAt", (PyCFunction) BeamPyFlagCoding_getAttributeAt, METH_VARARGS, "Returns the attribute at the given index.\nReturns Parameter index: the attribute index\nReturns the attribute, or null if this node does not contain attributes\n@throws IndexOutOfBoundsException"},
    {"getAttributeNames", (PyCFunction) BeamPyFlagCoding_getAttributeNames, METH_VARARGS, "Returns the names of all attributes of this node.\nReturns the attribute name array, never null"},
    {"getAttributes", (PyCFunction) BeamPyFlagCoding_getAttributes, METH_VARARGS, "Returns an array of attributes contained in this element.\nReturns an array of attributes contained in this product. If this element has no attributes a zero-length-array\nis returned."},
    {"getAttribute", (PyCFunction) BeamPyFlagCoding_getAttribute, METH_VARARGS, "Returns the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute with the given name or null if it could not be found"},
    {"containsAttribute", (PyCFunction) BeamPyFlagCoding_containsAttribute, METH_VARARGS, "Checks whether this node has an element with the given name.\nReturns Parameter name: the attribute name\nReturns true if so"},
    {"getAttributeIndex", (PyCFunction) BeamPyFlagCoding_getAttributeIndex, METH_VARARGS, "Gets the index of the given attribute.\nReturns Parameter attribute: The attribute.\nReturns the attribute's index, or -1.\nSince version:  BEAM 4.7"},
    {"getAttributeDouble", (PyCFunction) BeamPyFlagCoding_getAttributeDouble, METH_VARARGS, "Returns the double value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as double.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"getAttributeUTC2", (PyCFunction) BeamPyFlagCoding_getAttributeUTC2, METH_VARARGS, "Returns the UTC value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as UTC."},
    {"getAttributeUTC1", (PyCFunction) BeamPyFlagCoding_getAttributeUTC1, METH_VARARGS, "Returns the UTC value of the attribute with the given name.\nReturns Parameter name: the attribute name\nReturns the attribute value as UTC.\n@throws IllegalArgumentException if an attribute with the given name could not be found"},
    {"getAttributeInt", (PyCFunction) BeamPyFlagCoding_getAttributeInt, METH_VARARGS, "Returns the integer value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer.\n@throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number"},
    {"setAttributeInt", (PyCFunction) BeamPyFlagCoding_setAttributeInt, METH_VARARGS, "Sets the attribute with the given name to the given integer value. A new attribute with\nProductData.TYPE_INT32 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeDouble", (PyCFunction) BeamPyFlagCoding_setAttributeDouble, METH_VARARGS, "Sets the attribute with the given name to the given double value. A new attribute with\nProductData.TYPE_FLOAT64 is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setAttributeUTC", (PyCFunction) BeamPyFlagCoding_setAttributeUTC, METH_VARARGS, "Sets the attribute with the given name to the given utc value. A new attribute with\nProductData.UTC is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"getAttributeString", (PyCFunction) BeamPyFlagCoding_getAttributeString, METH_VARARGS, "Returns the string value of the attribute with the given name. The given default value is returned if an\nattribute with the given name could not be found in this node.\nReturns Parameter name: the attribute name\nReturns Parameter defaultValue: the default value\nReturns the attribute value as integer."},
    {"setAttributeString", (PyCFunction) BeamPyFlagCoding_setAttributeString, METH_VARARGS, "Sets the attribute with the given name to the given string value. A new attribute with\nProductData.TYPE_ASCII is added to this node if an attribute with the given name could not be found\nin this node.\nReturns Parameter name: the attribute name\nReturns Parameter value: the new value"},
    {"setModified", (PyCFunction) BeamPyFlagCoding_setModified, METH_VARARGS, ""},
    {"createDeepClone", (PyCFunction) BeamPyFlagCoding_createDeepClone, METH_VARARGS, ""},
    {"dispose", (PyCFunction) BeamPyFlagCoding_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"getOwner", (PyCFunction) BeamPyFlagCoding_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyFlagCoding_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyFlagCoding_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyFlagCoding_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyFlagCoding_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyFlagCoding_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"toString", (PyCFunction) BeamPyFlagCoding_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyFlagCoding_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyFlagCoding_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyFlagCoding_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyFlagCoding_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyFlagCoding_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyFlagCoding_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyFlagCoding_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyFlagCoding_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyFlagCoding_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject FlagCoding_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.FlagCoding",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Provides the information required to decode integer sample values that\nare combined of single flags (bit indexes).",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    FlagCoding_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Operator_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Operator_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Operator",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The abstract base class for all operators intended to be extended by clients.\nThe following methods are intended to be implemented or overridden:\n<ld>\n<li>{@link #initialize()}: must be implemented in order to initialise the operator and create the target\nproduct.</li>\n<li>{@link #computeTile(Band, Tile, com.bc.ceres.core.ProgressMonitor) computeTile()}: implemented to compute the tile\nfor a single band.</li>\n<li>{@link #computeTileStack(java.util.Map, java.awt.Rectangle, com.bc.ceres.core.ProgressMonitor)}: implemented to compute the tiles\nfor multiple bands.</li>\n<li>{@link #dispose()}: can be overridden in order to free all resources previously allocated by the operator.</li>\n</ld>\n\nGenerally, only one {@code computeTile} method needs to be implemented. It depends on the type of algorithm which\nof both operations is most advantageous to implement:\n<ol>\n<li>If bands can be computed independently of each other, then it is\nbeneficial to implement the {@code computeTile()} method. This is the case for sub-sampling, map-projections,\nband arithmetic, band filtering and statistic analyses.</li>\n<li>{@code computeTileStack()} should be overridden in cases where the bands of a product cannot be computed independently, e.g.\nbecause they are a simultaneous output. This is often the case for algorithms based on neural network, cluster analyses,\nmodel inversion methods or spectral unmixing.</li>\n</ol>\n\nThe framework execute either the {@code computeTile()} or the {@code computeTileStack()} method\nbased on the current use case or request.\nIf tiles for single bands are requested, e.g. for image display, it will always prefer an implementation of\nthe {@code computeTile()} method and call it.\nIf all tiles are requested at once, e.g. writing a product to disk, it will attempt to use the {@code computeTileStack()}\nmethod. If the framework cannot use its preferred operation, it will use the one implemented by the operator.\n\ntodo - Explain the role of operator annotations (nf - 15.10.2007)\ntodo - Explain the role of the SPI (nf - 15.10.2007)\nAuthor:  Norman Fomferra\nAuthor:  Marco Peters\nAuthor:  Marco Zühlke\n@see OperatorSpi\n@see annotations.OperatorMetadata\n@see annotations.Parameter\n@see annotations.TargetProduct\n@see annotations.TargetProperty\n@see annotations.SourceProduct\n@see annotations.SourceProducts\nSince version:  4.1",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Operator_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef OperatorSpiRegistry_methods[] = {
    {"loadOperatorSpis", (PyCFunction) BeamPyOperatorSpiRegistry_loadOperatorSpis, METH_VARARGS, "Loads the SPI's defined in {@code META-INF/services}."},
    {"getServiceRegistry", (PyCFunction) BeamPyOperatorSpiRegistry_getServiceRegistry, METH_VARARGS, "Gets the {@link ServiceRegistry ServiceRegistry}\nReturns the {@link ServiceRegistry service registry}"},
    {"getOperatorSpi", (PyCFunction) BeamPyOperatorSpiRegistry_getOperatorSpi, METH_VARARGS, "Gets a registrered operator SPI. The given operatorName can be\neither the fully qualified class name of the {@link OperatorSpi}\nor an alias name.\nReturns Parameter operatorName: a name identifying the operator SPI.\nReturns the operator SPI, or null"},
    {"addOperatorSpi", (PyCFunction) BeamPyOperatorSpiRegistry_addOperatorSpi, METH_VARARGS, "Adds the given {@link OperatorSpi operatorSpi} to this registry.\nReturns Parameter operatorSpi: the SPI to add\nReturns {@code true}, if the {@link OperatorSpi} could be succesfully added, otherwise {@code false}"},
    {"removeOperatorSpi", (PyCFunction) BeamPyOperatorSpiRegistry_removeOperatorSpi, METH_VARARGS, "Removes the given {@link OperatorSpi operatorSpi} this registry.\nReturns Parameter operatorSpi: the SPI to remove\nReturns {@code true}, if the SPI could be removed, otherwise {@code false}"},
    {"setAlias", (PyCFunction) BeamPyOperatorSpiRegistry_setAlias, METH_VARARGS, "Sets an alias for the given SPI class name.\nReturns Parameter aliasName: the alias\nReturns Parameter spiClassName: the name of the SPI class"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject OperatorSpiRegistry_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.OperatorSpiRegistry",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A registry for operator SPI instances.\nAuthor:  Norman Fomferra\nAuthor:  Marco Zühlke\nSince version:  4.1",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    OperatorSpiRegistry_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef BitmaskDef_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BitmaskDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.BitmaskDef",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Represents a bitmask definition comprising the bitmask properties name, description, flag expression color and\ntransparancy.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$\n@deprecated since BEAM 4.7, use {@code Mask} with {@code Mask.BandMathType} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BitmaskDef_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ImageInfo_HistogramMatching_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ImageInfo_HistogramMatching_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ImageInfo_HistogramMatching",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Enumerates the possible histogram matching modes.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ImageInfo_HistogramMatching_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Datum_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Datum_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Datum",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Represents a geodetic datum. Geodetic datums define the size and shape of the earth and the origin and orientation of\nthe coordinate systems used to map the earth.\n\n@deprecated since BEAM 4.7, use {@link org.opengis.referencing.datum.GeodeticDatum} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Datum_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductUtils_methods[] = {
    {"newProductUtils", (PyCFunction) BeamPyProductUtils_newProductUtils, METH_VARARGS | METH_STATIC, ""},
    {"createImageInfo", (PyCFunction) BeamPyProductUtils_createImageInfo, METH_VARARGS | METH_STATIC, "Creates image creation information.\nReturns Parameter rasters: The raster data nodes.\nReturns Parameter assignMissingImageInfos: if {@code true}, it is ensured that to all {@code RasterDataNode}s a valid {@code ImageInfo} will be assigned.\nReturns Parameter pm: The progress monitor.\nReturns image information\n@throws IOException if an I/O error occurs\nSince version:  BEAM 4.2"},
    {"createRgbImage", (PyCFunction) BeamPyProductUtils_createRgbImage, METH_VARARGS | METH_STATIC, "Creates a RGB image from the given array of {@link RasterDataNode}s.\nThe given array rasters containing one or three raster data nodes. If three rasters are given\nRGB image is created, if only one raster is provided a gray scale image created.\nReturns Parameter rasters: an array of one or three raster nodes.\nReturns Parameter imageInfo: the image info provides the information how to create the image\nReturns Parameter pm: a monitor to inform the user about progress\nReturns the created image\n@throws IOException if the given raster data is not loaded and reload causes an I/O error\n@see RasterDataNode#setImageInfo(ImageInfo)"},
    {"createColorIndexedImage", (PyCFunction) BeamPyProductUtils_createColorIndexedImage, METH_VARARGS | METH_STATIC, "Creates a greyscale image from the given {@link RasterDataNode}.\n\nThe method uses the given raster data node's image information (an instance of {@link\nImageInfo}) to create the image.\nReturns Parameter rasterDataNode: the raster data node, must not be null\nReturns Parameter pm: a monitor to inform the user about progress\nReturns the color indexed image\n@throws IOException if the given raster data is not loaded and reload causes an I/O error\n@see RasterDataNode#getImageInfo()"},
    {"createSuitableMapInfo1", (PyCFunction) BeamPyProductUtils_createSuitableMapInfo1, METH_VARARGS | METH_STATIC, "Retuns a suitable MapInfo instance for the given (geo-coded) product which includes the entire or a\nsubset of the product's scene region for the given map projection. The position of the reference pixel will be\nthe upper left pixel's center (0.5, 0.5).\nReturns Parameter product: the product, must not be null\nReturns Parameter rect: the rectangle in pixel coordinates of the product, if null the entire region is\nconsidered\nReturns Parameter mapProjection: the map projection, must not be null\nReturns the map information instance"},
    {"createSuitableMapInfo2", (PyCFunction) BeamPyProductUtils_createSuitableMapInfo2, METH_VARARGS | METH_STATIC, "Retuns a suitable MapInfo instance for the given (geo-coded) product which includes the entire or a\nsubset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.\nReturns Parameter product: the product, must not be null\nReturns Parameter mapProjection: the map projection, must not be null\nReturns Parameter orientation: the orientation angle\nReturns Parameter noDataValue: the no-data value to be used\nReturns the map information instance"},
    {"getOutputRasterSize", (PyCFunction) BeamPyProductUtils_getOutputRasterSize, METH_VARARGS | METH_STATIC, ""},
    {"createMapEnvelope2", (PyCFunction) BeamPyProductUtils_createMapEnvelope2, METH_VARARGS | METH_STATIC, "Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)\nand the given map transfromation. The method delegates to {@link #createMapEnvelope(Product,\njava.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,\nstep, mapTransform)} where step is the half of the minimum of the product scene raster width and\nheight.\nReturns Parameter product: The product.\nReturns Parameter rect: The rectangle in pixel coordinates.\nReturns Parameter mapTransform: The map transformation.\nReturns the boundary in map coordinates for the given product."},
    {"createMapEnvelope1", (PyCFunction) BeamPyProductUtils_createMapEnvelope1, METH_VARARGS | METH_STATIC, "Creates the boundary in map coordinates for the given product, source rectangle (in product\npixel coordinates) and the given map transfromation. The method delegates to\n{@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,\nstep, mapTransform)} where step is the half of the minimum of the product scene\nraster width and height.\nReturns Parameter product: The product.\nReturns Parameter rect: The rectangle in pixel coordinates.\nReturns Parameter step: The step size in pixels.\nReturns Parameter mapTransform: The map transformation.\nReturns the boundary in map coordinates for the given product."},
    {"getMinMax", (PyCFunction) BeamPyProductUtils_getMinMax, METH_VARARGS | METH_STATIC, ""},
    {"createMapBoundary", (PyCFunction) BeamPyProductUtils_createMapBoundary, METH_VARARGS | METH_STATIC, ""},
    {"createGeoBoundary1", (PyCFunction) BeamPyProductUtils_createGeoBoundary1, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.\nReturns Parameter product: the input product, must not be null\nReturns Parameter step: the step given in pixels\nReturns an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null"},
    {"createGeoBoundary2", (PyCFunction) BeamPyProductUtils_createGeoBoundary2, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given product and returns it as a list of\ngeographical coordinates.\n This method delegates to {@link #createGeoBoundary(Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}\nand the additional boolean parameter usePixelCenter is true.\nReturns Parameter product: the input product, must not be null\nReturns Parameter region: the region rectangle in product pixel coordinates, can be null for entire product\nReturns Parameter step: the step given in pixels\nReturns an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createPixelBoundary(RasterDataNode, java.awt.Rectangle, int)"},
    {"createGeoBoundary3", (PyCFunction) BeamPyProductUtils_createGeoBoundary3, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given product and returns it as a list of\ngeographical coordinates.\nReturns Parameter product: the input product, must not be null\nReturns Parameter region: the region rectangle in product pixel coordinates, can be null for entire product\nReturns Parameter step: the step given in pixels\nReturns Parameter usePixelCenter: true if the pixel center should be used to create the boundary\nReturns an array of geographical coordinates\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createPixelBoundary(Product, java.awt.Rectangle, int, boolean)"},
    {"createGeoBoundary4", (PyCFunction) BeamPyProductUtils_createGeoBoundary4, METH_VARARGS | METH_STATIC, "Creates the geographical boundary of the given region within the given raster and returns it as a list of\ngeographical coordinates.\nReturns Parameter raster: the input raster, must not be null\nReturns Parameter region: the region rectangle in raster pixel coordinates, can be null for entire raster\nReturns Parameter step: the step given in pixels\nReturns an array of geographical coordinates\n@throws IllegalArgumentException if raster is null or if the raster has no {@link GeoCoding} is null\n@see #createPixelBoundary(RasterDataNode, java.awt.Rectangle, int)"},
    {"createGeoBoundaryPaths1", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths1, METH_VARARGS | METH_STATIC, "Converts the geographic boundary entire product into one, two or three shape objects. If the product does not\nintersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created\nand returned in the order from west to east.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\nReturns Parameter product: the input product\nReturns an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, int)"},
    {"createGeoBoundaryPaths2", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths2, METH_VARARGS | METH_STATIC, "Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\nthe product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\nshapes are created and returned in the order from west to east.\n\nThis method delegates to {@link #createGeoBoundaryPaths(Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}\nand the additional parameter usePixelCenter is true.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\nReturns Parameter product: the input product\nReturns Parameter region: the region rectangle in product pixel coordinates, can be null for entire product\nReturns Parameter step: the step given in pixels\nReturns an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, java.awt.Rectangle, int)"},
    {"createGeoBoundaryPaths3", (PyCFunction) BeamPyProductUtils_createGeoBoundaryPaths3, METH_VARARGS | METH_STATIC, "Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\nthe product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\nshapes are created and returned in the order from west to east.\n\nThe geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\nReturns Parameter product: the input product\nReturns Parameter region: the region rectangle in product pixel coordinates, can be null for entire product\nReturns Parameter step: the step given in pixels\nReturns Parameter usePixelCenter: true if the pixel center should be used to create the pathes\nReturns an array of shape objects\n@throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n@see #createGeoBoundary(Product, java.awt.Rectangle, int, boolean)"},
    {"createPixelBoundary1", (PyCFunction) BeamPyProductUtils_createPixelBoundary1, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\nrect is 100 x 50 pixels and step is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n This method delegates to {@link #createPixelBoundary(Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}\nand the additional boolean parameter usePixelCenter is true.\nReturns Parameter product: the product\nReturns Parameter rect: the source rectangle\nReturns Parameter step: the mean distance from one pixel position to the other in the returned array\nReturns the rectangular boundary"},
    {"createPixelBoundary2", (PyCFunction) BeamPyProductUtils_createPixelBoundary2, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\nrect is 100 x 50 pixels and step is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\nReturns Parameter product: the product\nReturns Parameter rect: the source rectangle\nReturns Parameter step: the mean distance from one pixel position to the other in the returned array\nReturns Parameter usePixelCenter: true if the pixel center should be used to create the boundary\nReturns the rectangular boundary"},
    {"createPixelBoundary3", (PyCFunction) BeamPyProductUtils_createPixelBoundary3, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\nrect is 100 x 50 pixels and step is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a raster boundary expressed in geographical\nco-ordinates.\nReturns Parameter raster: the raster\nReturns Parameter rect: the source rectangle\nReturns Parameter step: the mean distance from one pixel position to the other in the returned array\nReturns the rectangular boundary"},
    {"createRectBoundary1", (PyCFunction) BeamPyProductUtils_createRectBoundary1, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\nrect is 100 x 50 pixels and step is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}\nand the additional boolean parameter usePixelCenter is true.\nReturns Parameter rect: the source rectangle\nReturns Parameter step: the mean distance from one pixel position to the other in the returned array\nReturns the rectangular boundary"},
    {"createRectBoundary2", (PyCFunction) BeamPyProductUtils_createRectBoundary2, METH_VARARGS | METH_STATIC, "Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\nrect is 100 x 50 pixels and step is 10 the returned array will countain exactly 2 * 10\n+ 2 * (5 - 2) = 26 pixel positions.\n\nThis method is used for an intermediate step when determining a product boundary expressed in geographical\nco-ordinates.\n\nReturns Parameter rect: the source rectangle\nReturns Parameter step: the mean distance from one pixel position to the other in the returned array\nReturns Parameter usePixelCenter: true if the pixel center should be used\nReturns the rectangular boundary"},
    {"copyFlagCodings", (PyCFunction) BeamPyProductUtils_copyFlagCodings, METH_VARARGS | METH_STATIC, "Copies the flag codings from the source product to the target.\nReturns Parameter source: the source product\nReturns Parameter target: the target product"},
    {"copyFlagCoding", (PyCFunction) BeamPyProductUtils_copyFlagCoding, METH_VARARGS | METH_STATIC, "Copies the given source flag coding to the target product.\nIf it exists already, the method simply returns the existing instance.\nReturns Parameter sourceFlagCoding: the source flag coding\nReturns Parameter target: the target product\nReturns the flag coding."},
    {"copyIndexCoding", (PyCFunction) BeamPyProductUtils_copyIndexCoding, METH_VARARGS | METH_STATIC, "Copies the given source index coding to the target product\nIf it exists already, the method simply returns the existing instance.\nReturns Parameter sourceIndexCoding: the source index coding\nReturns Parameter target: the target product\nReturns the index coding."},
    {"copyMasks", (PyCFunction) BeamPyProductUtils_copyMasks, METH_VARARGS | METH_STATIC, "Copies the {@link Mask}s from the source product to the target product.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy overlay masks from the source bands to the target bands. Also\nnote that a source mask is not copied to the target product, when there already\nis a mask in the target product with the same name as the source mask.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product"},
    {"copyOverlayMasks", (PyCFunction) BeamPyProductUtils_copyOverlayMasks, METH_VARARGS | METH_STATIC, "Copies the overlay {@link Mask}s from the source product's raster data nodes to\nthe target product's raster data nodes.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy overlay masks, which are not contained in the target product's\nmask group.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product"},
    {"copyRoiMasks", (PyCFunction) BeamPyProductUtils_copyRoiMasks, METH_VARARGS | METH_STATIC, "Copies the ROI {@link Mask}s from the source product's raster data nodes to\nthe target product's raster data nodes.\n\nIMPORTANT NOTE: This method should only be used, if it is known that all masks\nin the source product will also be valid in the target product. This method does\n<em>not</em> copy ROI masks, which are not contained in the target product's\nmask group.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product\n@deprecated since BEAM 4.10 (no replacement)"},
    {"copyFlagBands2", (PyCFunction) BeamPyProductUtils_copyFlagBands2, METH_VARARGS | METH_STATIC, "Copies all bands which contain a flagcoding from the source product to the target product.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product\nReturns Parameter copySourceImage: whether the source image of the source band should be copied.\nSince version:  BEAM 4.10"},
    {"copyFlagBands1", (PyCFunction) BeamPyProductUtils_copyFlagBands1, METH_VARARGS | METH_STATIC, "Copies all bands which contain a flagcoding from the source product to the target product.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product\n@deprecated since BEAM 4.10, use {@link #copyFlagBands(Product, Product, boolean)} instead."},
    {"copyTiePointGrid", (PyCFunction) BeamPyProductUtils_copyTiePointGrid, METH_VARARGS | METH_STATIC, "Copies the named tie-point grid from the source product to the target product.\nReturns Parameter gridName: the name of the tie-point grid to be copied.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product\nReturns the copied tie-point grid, or null if the sourceProduct does not contain a tie-point grid with the given name."},
    {"copyBand4", (PyCFunction) BeamPyProductUtils_copyBand4, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\nReturns Parameter sourceBandName: the name of the band to be copied.\nReturns Parameter sourceProduct: the source product.\nReturns Parameter targetProduct: the target product.\nReturns Parameter copySourceImage: whether the source image of the source band should be copied.\nReturns the copy of the band, or null if the sourceProduct does not contain a band with the given name.\nSince version:  BEAM 4.10"},
    {"copyBand2", (PyCFunction) BeamPyProductUtils_copyBand2, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\nReturns Parameter sourceBandName: the name of the band to be copied.\nReturns Parameter sourceProduct: the source product.\nReturns Parameter targetBandName: the name of the band copied.\nReturns Parameter targetProduct: the target product.\nReturns Parameter copySourceImage: whether the source image of the source band should be copied.\nReturns the copy of the band, or null if the sourceProduct does not contain a band with the given name.\nSince version:  BEAM 4.10"},
    {"copyRasterDataNodeProperties", (PyCFunction) BeamPyProductUtils_copyRasterDataNodeProperties, METH_VARARGS | METH_STATIC, "Copies all properties from source band to the target band.\nReturns Parameter sourceRaster: the source band\nReturns Parameter targetRaster: the target band\n@see #copySpectralBandProperties(Band, Band)"},
    {"copyBand3", (PyCFunction) BeamPyProductUtils_copyBand3, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\nReturns Parameter sourceBandName: the name of the band to be copied.\nReturns Parameter sourceProduct: the source product.\nReturns Parameter targetProduct: the target product.\nReturns the copy of the band, or null if the sourceProduct does not contain a band with the given name.\n@deprecated since BEAM 4.10, use {@link #copyBand(String, Product, Product, boolean)} instead."},
    {"copyBand1", (PyCFunction) BeamPyProductUtils_copyBand1, METH_VARARGS | METH_STATIC, "Copies the named band from the source product to the target product.\nReturns Parameter sourceBandName: the name of the band to be copied.\nReturns Parameter sourceProduct: the source product.\nReturns Parameter targetBandName: the name of the band copied.\nReturns Parameter targetProduct: the target product.\nReturns the copy of the band, or null if the sourceProduct does not contain a band with the given name.\n@deprecated since BEAM 4.10, use {@link #copyBand(String, Product, String, Product, boolean)} instead."},
    {"copySpectralBandProperties", (PyCFunction) BeamPyProductUtils_copySpectralBandProperties, METH_VARARGS | METH_STATIC, "Copies the spectral properties from source band to target band. These properties are:\n<ul>\n<li>{@link Band#getSpectralBandIndex() spectral band index},</li>\n<li>{@link Band#getSpectralWavelength() the central wavelength},</li>\n<li>{@link Band#getSpectralBandwidth() the spectral bandwidth} and</li>\n<li>{@link Band#getSolarFlux() the solar spectral flux}.</li>\n</ul>\nReturns Parameter sourceBand: the source band\nReturns Parameter targetBand: the target band\n@see #copyRasterDataNodeProperties(RasterDataNode, RasterDataNode)"},
    {"copyGeoCoding", (PyCFunction) BeamPyProductUtils_copyGeoCoding, METH_VARARGS | METH_STATIC, "Copies the geocoding from the source product to target product.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product\n@throws IllegalArgumentException if one of the params is null."},
    {"copyTiePointGrids", (PyCFunction) BeamPyProductUtils_copyTiePointGrids, METH_VARARGS | METH_STATIC, "Copies all tie point grids from one product to another.\nReturns Parameter sourceProduct: the source product\nReturns Parameter targetProduct: the target product"},
    {"copyVectorData", (PyCFunction) BeamPyProductUtils_copyVectorData, METH_VARARGS | METH_STATIC, ""},
    {"canGetPixelPos1", (PyCFunction) BeamPyProductUtils_canGetPixelPos1, METH_VARARGS | METH_STATIC, "Returns whether or not a product can return a pixel position from a given geographical position.\nReturns Parameter product: the product to be checked\nReturns true if the given product can return a pixel position"},
    {"canGetPixelPos2", (PyCFunction) BeamPyProductUtils_canGetPixelPos2, METH_VARARGS | METH_STATIC, "Returns whether or not a raster can return a pixel position from a given geographical position.\nReturns Parameter raster: the raster to be checked\nReturns true if the given raster can return a pixel position"},
    {"createDensityPlotImage", (PyCFunction) BeamPyProductUtils_createDensityPlotImage, METH_VARARGS | METH_STATIC, "Creates a density plot image from two raster data nodes.\nReturns Parameter raster1: the first raster data node\nReturns Parameter sampleMin1: the minimum sample value to be considered in the first raster\nReturns Parameter sampleMax1: the maximum sample value to be considered in the first raster\nReturns Parameter raster2: the second raster data node\nReturns Parameter sampleMin2: the minimum sample value to be considered in the second raster\nReturns Parameter sampleMax2: the maximum sample value to be considered in the second raster\nReturns Parameter roiMask: an optional mask to be used as a ROI for the computation\nReturns Parameter width: the width of the output image\nReturns Parameter height: the height of the output image\nReturns Parameter background: the background color of the output image\nReturns Parameter image: an image to be used as output image, if null a new image is created\nReturns Parameter pm: the progress monitor\nReturns the density plot image\n@throws java.io.IOException when an error occurred."},
    {"overlayMasks", (PyCFunction) BeamPyProductUtils_overlayMasks, METH_VARARGS | METH_STATIC, "Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.\nReturns Parameter raster: the raster data node which contains all the activated bitmask definitions\nReturns Parameter overlayBIm: the source image which is used as base image for all the overlays.\nReturns Parameter pm: a monitor to inform the user about progress\nReturns the modified given overlayBImm which contains all the activated masks.\n@see RasterDataNode#getOverlayMaskGroup()"},
    {"getCenterGeoPos", (PyCFunction) BeamPyProductUtils_getCenterGeoPos, METH_VARARGS | METH_STATIC, ""},
    {"normalizeGeoPolygon", (PyCFunction) BeamPyProductUtils_normalizeGeoPolygon, METH_VARARGS | METH_STATIC, "Normalizes the given geographical polygon so that maximum longitude differences between two points are 180\ndegrees. The method operates only on the longitude values of the given polygon.\nReturns Parameter polygon: a geographical, closed polygon\nReturns 0 if normalizing has not been applied , -1 if negative normalizing has been applied, 1 if positive\nnormalizing has been applied, 2 if positive and negative normalising has been applied\n@see #denormalizeGeoPolygon(GeoPos[])"},
    {"normalizeGeoPolygon_old", (PyCFunction) BeamPyProductUtils_normalizeGeoPolygon_old, METH_VARARGS | METH_STATIC, ""},
    {"denormalizeGeoPolygon", (PyCFunction) BeamPyProductUtils_denormalizeGeoPolygon, METH_VARARGS | METH_STATIC, "Denormalizes the longitude values which have been normalized using the\n{@link #normalizeGeoPolygon(GeoPos[])} method. The\nmethod operates only on the longitude values of the given polygon.\nReturns Parameter polygon: a geographical, closed polygon"},
    {"denormalizeGeoPos", (PyCFunction) BeamPyProductUtils_denormalizeGeoPos, METH_VARARGS | METH_STATIC, ""},
    {"denormalizeGeoPos_old", (PyCFunction) BeamPyProductUtils_denormalizeGeoPos_old, METH_VARARGS | METH_STATIC, ""},
    {"getRotationDirection", (PyCFunction) BeamPyProductUtils_getRotationDirection, METH_VARARGS | METH_STATIC, ""},
    {"getAngleSum", (PyCFunction) BeamPyProductUtils_getAngleSum, METH_VARARGS | METH_STATIC, ""},
    {"convertToPixelPath", (PyCFunction) BeamPyProductUtils_convertToPixelPath, METH_VARARGS | METH_STATIC, "Converts a GeneralPath given in geographic lon/lat coordinates into a GeneralPath in\npixel coordinates using the supplied geo coding.\nReturns Parameter geoPath: a GeneralPath given in geographic lon/lat coordinates, as returned by the {@link\n#convertToGeoPath(Shape, GeoCoding)} method\nReturns Parameter geoCoding: the geocoding used to convert the geographic coordinates into pixel coordinates.\nReturns a GeneralPath given in pixel coordinates.\n@throws IllegalArgumentException if one of the given parameter is null.\n@throws IllegalStateException    if the given geoPath is not a geo referenced GeneralPath wich\ncontains only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n@see #convertToGeoPath(Shape, GeoCoding)"},
    {"convertToGeoPath", (PyCFunction) BeamPyProductUtils_convertToGeoPath, METH_VARARGS | METH_STATIC, "Converts a Shape given in pixel X/Y coordinates into a GeneralPath in geografic\ncoordinates using the supplied geo coding.\nReturns Parameter shape: a Shape given in pixel X/Y coordinates\nReturns Parameter geoCoding: the geo coding used to convert the pixel coordinates into geografic coordinates.\nReturns a GeneralPath given in geografic coordinates\n@throws IllegalArgumentException if one of the given parameter is null or the given geo coding can\nnot get geografic coordinates.\n@throws IllegalStateException    if this method was used with a java runtime version in which it is not guaranted\nthat a PathIterator returned by {@link Shape#getPathIterator(java.awt.geom.AffineTransform,\ndouble)} returnes only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n@see GeoCoding#canGetGeoPos()"},
    {"copyMetadata2", (PyCFunction) BeamPyProductUtils_copyMetadata2, METH_VARARGS | METH_STATIC, "Copies all metadata elements and attributes of the source product to the target product.\nThe copied elements and attributes are deeply cloned.\nReturns Parameter source: the source product.\nReturns Parameter target: the target product.\n@throws NullPointerException if the source or the target product is {@code null}."},
    {"copyMetadata1", (PyCFunction) BeamPyProductUtils_copyMetadata1, METH_VARARGS | METH_STATIC, "Copies all metadata elements and attributes of the source element to the target element.\nThe copied elements and attributes are deeply cloned.\nReturns Parameter source: the source element.\nReturns Parameter target: the target element.\n@throws NullPointerException if the source or the target element is {@code null}."},
    {"copyPreferredTileSize", (PyCFunction) BeamPyProductUtils_copyPreferredTileSize, METH_VARARGS | METH_STATIC, "Copies the source product's preferred tile size (if any) to the target product.\nReturns Parameter sourceProduct: The source product.\nReturns Parameter targetProduct: The target product."},
    {"createGeoTIFFMetadata2", (PyCFunction) BeamPyProductUtils_createGeoTIFFMetadata2, METH_VARARGS | METH_STATIC, ""},
    {"createGeoTIFFMetadata1", (PyCFunction) BeamPyProductUtils_createGeoTIFFMetadata1, METH_VARARGS | METH_STATIC, ""},
    {"areaToPath", (PyCFunction) BeamPyProductUtils_areaToPath, METH_VARARGS | METH_STATIC, ""},
    {"addElementToHistory", (PyCFunction) BeamPyProductUtils_addElementToHistory, METH_VARARGS | METH_STATIC, "Adds a given elem to the history of the given product. If the products metadata root\ndoes not contain a history entry a new one will be created.\nReturns Parameter product: the product to add the history element.\nReturns Parameter elem: the element to add to the products history. If null nothing will be added."},
    {"removeInvalidExpressions", (PyCFunction) BeamPyProductUtils_removeInvalidExpressions, METH_VARARGS | METH_STATIC, "Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given\nproduct, the related element is removed.\nReturns Parameter product: the (output) product to be cleaned up\nReturns an array of messages which changes are done to the given product."},
    {"findSuitableQuicklookBandName", (PyCFunction) BeamPyProductUtils_findSuitableQuicklookBandName, METH_VARARGS | METH_STATIC, "Finds the name of a band in the given product which is suitable to product a good quicklook.\nThe method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.\nReturns Parameter product: the product to be searched\nReturns the name of a suitable band or null if the given product does not contain any bands"},
    {"computeSourcePixelCoordinates", (PyCFunction) BeamPyProductUtils_computeSourcePixelCoordinates, METH_VARARGS | METH_STATIC, ""},
    {"computeMinMaxY", (PyCFunction) BeamPyProductUtils_computeMinMaxY, METH_VARARGS | METH_STATIC, "Computes the minimum and maximum y value of the given {@link PixelPos} array.\nReturns Parameter pixelPositions: the {@link PixelPos} array\nReturns an int array which containes the minimum and maximum y value of the given {@link PixelPos} array in the\norder:<br> &nbsp;&nbsp;&nbsp;&nbsp;[0] - the minimum value<br>&nbsp;&nbsp;&nbsp;&nbsp;[1] - the maximum\nvalue<br><br>or null if no minimum or maximum can be retrieved because there given array is\nempty.\n@throws IllegalArgumentException if the given pixelPositions are null."},
    {"copyBandsForGeomTransform1", (PyCFunction) BeamPyProductUtils_copyBandsForGeomTransform1, METH_VARARGS | METH_STATIC, "Copies only the bands from source to target.\n@see #copyBandsForGeomTransform(Product, Product, boolean, double, java.util.Map)"},
    {"copyBandsForGeomTransform2", (PyCFunction) BeamPyProductUtils_copyBandsForGeomTransform2, METH_VARARGS | METH_STATIC, "Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target\nproduct is a geometric transformation (e.g. map-projection) of the source product.\nIf\n{@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,\nthis method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},\nregardless which raw data type the source band has.\nIn this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}\nwill always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}\nwill always be 0.0 and\n{@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.\nThis ensures that source pixel resampling methods operating on floating point\ndata can be stored without loss in accuracy in the target band.\n\nFurthermore, the\n{@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}\nand {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}\nproperties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},\nwill be either the one from the source band, if any, or otherwise the one passed into this method.\nReturns Parameter sourceProduct: the source product as the source for the band specifications. Must be not\nnull.\nReturns Parameter targetProduct: the destination product to receive the bands created. Must be not null.\nReturns Parameter includeTiePointGrids: if {@code true}, tie-point grids of source product will be included as bands in target product\nReturns Parameter defaultNoDataValue: the default, geophysical no-data value to be used if no no-data value is used by the source band.\nReturns Parameter targetToSourceMap: a mapping from a target band to a source raster data node, can be {@code null}"},
    {"getScanLineTime", (PyCFunction) BeamPyProductUtils_getScanLineTime, METH_VARARGS | METH_STATIC, ""},
    {"getGeophysicalSampleDouble", (PyCFunction) BeamPyProductUtils_getGeophysicalSampleDouble, METH_VARARGS | METH_STATIC, ""},
    {"getGeophysicalSampleLong", (PyCFunction) BeamPyProductUtils_getGeophysicalSampleLong, METH_VARARGS | METH_STATIC, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductUtils_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductUtils",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "This class provides many static factory methods to be used in conjunction with data products.\n@see Product",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductUtils_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Map_methods[] = {
    {"size", (PyCFunction) BeamPyMap_size, METH_VARARGS, ""},
    {"isEmpty", (PyCFunction) BeamPyMap_isEmpty, METH_VARARGS, ""},
    {"containsKey", (PyCFunction) BeamPyMap_containsKey, METH_VARARGS, ""},
    {"containsValue", (PyCFunction) BeamPyMap_containsValue, METH_VARARGS, ""},
    {"get", (PyCFunction) BeamPyMap_get, METH_VARARGS, ""},
    {"put", (PyCFunction) BeamPyMap_put, METH_VARARGS, ""},
    {"remove", (PyCFunction) BeamPyMap_remove, METH_VARARGS, ""},
    {"putAll", (PyCFunction) BeamPyMap_putAll, METH_VARARGS, ""},
    {"clear", (PyCFunction) BeamPyMap_clear, METH_VARARGS, ""},
    {"keySet", (PyCFunction) BeamPyMap_keySet, METH_VARARGS, ""},
    {"values", (PyCFunction) BeamPyMap_values, METH_VARARGS, ""},
    {"entrySet", (PyCFunction) BeamPyMap_entrySet, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyMap_equals, METH_VARARGS, ""},
    {"hashCode", (PyCFunction) BeamPyMap_hashCode, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Map_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Map",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Map_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef SubsetOp_methods[] = {
    {"newSubsetOp", (PyCFunction) BeamPySubsetOp_newSubsetOp, METH_VARARGS | METH_STATIC, ""},
    {"getTiePointGridNames", (PyCFunction) BeamPySubsetOp_getTiePointGridNames, METH_VARARGS, ""},
    {"setTiePointGridNames", (PyCFunction) BeamPySubsetOp_setTiePointGridNames, METH_VARARGS, ""},
    {"getBandNames", (PyCFunction) BeamPySubsetOp_getBandNames, METH_VARARGS, ""},
    {"setBandNames", (PyCFunction) BeamPySubsetOp_setBandNames, METH_VARARGS, ""},
    {"setCopyMetadata", (PyCFunction) BeamPySubsetOp_setCopyMetadata, METH_VARARGS, ""},
    {"getRegion", (PyCFunction) BeamPySubsetOp_getRegion, METH_VARARGS, ""},
    {"setRegion", (PyCFunction) BeamPySubsetOp_setRegion, METH_VARARGS, ""},
    {"setSubSamplingX", (PyCFunction) BeamPySubsetOp_setSubSamplingX, METH_VARARGS, ""},
    {"setSubSamplingY", (PyCFunction) BeamPySubsetOp_setSubSamplingY, METH_VARARGS, ""},
    {"getGeoRegion", (PyCFunction) BeamPySubsetOp_getGeoRegion, METH_VARARGS, ""},
    {"setGeoRegion", (PyCFunction) BeamPySubsetOp_setGeoRegion, METH_VARARGS, ""},
    {"update", (PyCFunction) BeamPySubsetOp_update, METH_VARARGS, "Updates this operator forcing it to recreate the target product.\nWarning: Experimental API added by nf (25.02.2010)<br/>\nSince version:  BEAM 4.8"},
    {"dispose", (PyCFunction) BeamPySubsetOp_dispose, METH_VARARGS, "Releases the resources the operator has acquired during its lifetime.\nThe default implementation does nothing.\n\nOverrides should make sure to call {@code super.dispose()} as well."},
    {"getId", (PyCFunction) BeamPySubsetOp_getId, METH_VARARGS, "Returns the operator's runtime identifier assigned by the framework."},
    {"getSourceProducts", (PyCFunction) BeamPySubsetOp_getSourceProducts, METH_VARARGS, "Gets the source products in the order they have been declared.\nReturns the array source products."},
    {"setSourceProducts", (PyCFunction) BeamPySubsetOp_setSourceProducts, METH_VARARGS, "Sets the source products.\nReturns Parameter products: The source products.\nSince version:  BEAM 4.2"},
    {"getSourceProduct", (PyCFunction) BeamPySubsetOp_getSourceProduct, METH_VARARGS, "Gets a single source product. This method is a shortcut for\n{@code getSourceProduct(\"sourceProduct\")}.\nReturns the source product, or {@code null} if not set.\nSince version:  BEAM 4.2"},
    {"setSourceProduct", (PyCFunction) BeamPySubsetOp_setSourceProduct, METH_VARARGS, "Sets a single source product. This method is a shortcut for\n{@code setSourceProduct(\"sourceProduct\", sourceProduct)}.\nReturns Parameter sourceProduct: the source product to be set\nSince version:  BEAM 4.2"},
    {"getSourceProductById", (PyCFunction) BeamPySubsetOp_getSourceProductById, METH_VARARGS, "Gets the source product using the specified name.\nReturns Parameter id: the identifier\nReturns the source product, or {@code null} if not found\n@see #getSourceProductId(Product)"},
    {"setSourceProductById", (PyCFunction) BeamPySubsetOp_setSourceProductById, METH_VARARGS, "Sets a source product.\nOne product instance can be registered with different identifiers, e.g. \"source\", \"source1\" and \"input\"\nin consecutive calls.\nReturns Parameter id: a source product identifier\nReturns Parameter product: the source product to be set\nSince version:  BEAM 4.2"},
    {"getSourceProductId", (PyCFunction) BeamPySubsetOp_getSourceProductId, METH_VARARGS, "Gets the identifier for the given source product.\nReturns Parameter product: The source product.\nReturns the identifier, or {@code null} if no such exists.\n@see #getSourceProduct(String)"},
    {"getTargetProduct", (PyCFunction) BeamPySubsetOp_getTargetProduct, METH_VARARGS, "Gets the target product for the operator.\n\nIf the target product is not set, calling this method results in a\ncall to {@link #initialize()}.\nReturns the target product.\n@throws OperatorException May be caused by {@link #initialize()}, if the operator is not initialised,\nor if the target product is not set."},
    {"getTargetProperty", (PyCFunction) BeamPySubsetOp_getTargetProperty, METH_VARARGS, "Gets a target property of the operator.\n\nIf the requested target property is not set, calling this method results in a\ncall to {@link #initialize()}.\nReturns Parameter name: the name of the property requested.\nReturns the target property requested.\n@throws OperatorException May be caused by {@link #initialize()}, if the operator is not initialised,\nor if the target product is not been set."},
    {"getParameter", (PyCFunction) BeamPySubsetOp_getParameter, METH_VARARGS, "Gets the value for the parameter with the given name.\nReturns Parameter name: The parameter name.\nReturns the parameter value, which may be {@code null}.\nSince version:  BEAM 4.7"},
    {"setParameter", (PyCFunction) BeamPySubsetOp_setParameter, METH_VARARGS, "Sets the value for the parameter with the given name.\nReturns Parameter name: The parameter name.\nReturns Parameter value: The parameter value, which may be {@code null}.\nSince version:  BEAM 4.7"},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SubsetOp_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.SubsetOp",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "This operator is used to create either spatial and/or spectral subsets of a data product.\nSpatial subset may be given by pixel positions (parameter region)\nor a geographical polygon (parameter geoRegion). Subsets of band and tie-point grid\nare given by name lists (parameters bandNames and  tiePointGridNames).\nAuthor:  Marco Zuehlke\nAuthor:  Norman Fomferra\nAuthor:  Marco Peters\nSince version:  BEAM 4.9",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SubsetOp_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Pointing_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Pointing_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Pointing",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The interface Pointing wraps a {@link GeoCoding} and optionally provides more geometry\ninformation such as sun direction, satellite (view) direction and elevation at a given pixel position.\n\nAll Pointing implementations should override\nthe {@link Object#equals(Object) equals()} and  {@link Object#hashCode() hashCode()} methods.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Pointing_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef PlacemarkDescriptor_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PlacemarkDescriptor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.PlacemarkDescriptor",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "Placemark descriptors are used to describe and create {@link Placemark}s.\n\nNew placemark descriptors can be added by using the Service Provider Interface\n{@code META-INF/services/PlacemarkDescriptor}.\n\nSince this interface is likely to change, clients should not directly implement it.\nInstead they should derive their implementation from {@link AbstractPlacemarkDescriptor}.\nAuthor:  Norman Fomferra\nAuthor:  Thomas Storm\nVersion:  2.0\nSince version:  BEAM 2.0 (full revision since BEAM 4.10)",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PlacemarkDescriptor_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef PointingFactory_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject PointingFactory_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.PointingFactory",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A factory which creates instances of a {@link Pointing} for a given raster data node.\nA PointingFactory is usually assigned to data {@link Product} by its {@link ProductReader ProductReader}",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    PointingFactory_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Point2D_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Point2D_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Point2D",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Point2D_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Scaling_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Scaling_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Scaling",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The scaling method used for geophysical value transformation in a {@link Band}.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Scaling_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef Collection_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject Collection_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.Collection",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    Collection_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef GeoTIFFMetadata_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeoTIFFMetadata_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.GeoTIFFMetadata",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeoTIFFMetadata_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MapInfo_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MapInfo_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MapInfo",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The MapInfo class holds information required to bring the cartographic map co-ordinate system to a\nraster co-ordinate system and back.\nAuthor:  Norman Fomferra (norman.fomferra@brockmann-consult.de)\nVersion:  $Revision$ $Date$\n\n@deprecated since BEAM 4.7, use geotools and {@link CrsGeoCoding} instead.",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MapInfo_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef BufferedImage_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject BufferedImage_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.BufferedImage",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    BufferedImage_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef SimpleFeature_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject SimpleFeature_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.SimpleFeature",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    SimpleFeature_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductSubsetDef_methods[] = {
    {"newProductSubsetDef1", (PyCFunction) BeamPyProductSubsetDef_newProductSubsetDef1, METH_VARARGS | METH_STATIC, "Constructs a new and empty subset info."},
    {"newProductSubsetDef2", (PyCFunction) BeamPyProductSubsetDef_newProductSubsetDef2, METH_VARARGS | METH_STATIC, "Constructs a new and empty subset info.\nReturns Parameter subsetName: The name of the subset to be created."},
    {"getSubsetName", (PyCFunction) BeamPyProductSubsetDef_getSubsetName, METH_VARARGS, ""},
    {"setSubsetName", (PyCFunction) BeamPyProductSubsetDef_setSubsetName, METH_VARARGS, ""},
    {"setTreatVirtualBandsAsRealBands", (PyCFunction) BeamPyProductSubsetDef_setTreatVirtualBandsAsRealBands, METH_VARARGS, ""},
    {"getTreatVirtualBandsAsRealBands", (PyCFunction) BeamPyProductSubsetDef_getTreatVirtualBandsAsRealBands, METH_VARARGS, ""},
    {"getNodeNames", (PyCFunction) BeamPyProductSubsetDef_getNodeNames, METH_VARARGS, "Gets the names of all product nodes contained in this subset. A return value of null means all nodes\nare selected.\nReturns an array of names, or null if the no node subset is given"},
    {"setNodeNames", (PyCFunction) BeamPyProductSubsetDef_setNodeNames, METH_VARARGS, "Sets the names of all product nodes contained in this subset. A value of null means all nodes are\nselected.\nReturns Parameter names: the band names, can be null in order to reset the node subset"},
    {"addNodeName", (PyCFunction) BeamPyProductSubsetDef_addNodeName, METH_VARARGS, "Adds a new product node name to this subset.\nReturns Parameter name: the node's name, must not be empty or null"},
    {"addNodeNames", (PyCFunction) BeamPyProductSubsetDef_addNodeNames, METH_VARARGS, "Adds the given product node names to this subset.\nReturns Parameter names: the nodename's to be added"},
    {"removeNodeName", (PyCFunction) BeamPyProductSubsetDef_removeNodeName, METH_VARARGS, "Removes a band from the spectral subset. If the band is not contained in this subset, the method returns\nfalse.\nReturns Parameter name: the band's name\nReturns true for success, false otherwise"},
    {"containsNodeName", (PyCFunction) BeamPyProductSubsetDef_containsNodeName, METH_VARARGS, "Checks whether or not a node name is already contained in this subset.\nReturns Parameter name: the node name\nReturns true if so"},
    {"isNodeAccepted", (PyCFunction) BeamPyProductSubsetDef_isNodeAccepted, METH_VARARGS, "Checks whether or not a node (a band, a tie-point grid or metadata element) with the given name will be part of\nthe product subset.\nReturns Parameter name: the node name\nReturns true if so"},
    {"getRegion", (PyCFunction) BeamPyProductSubsetDef_getRegion, METH_VARARGS, "Gets the spatial subset as a rectangular region. Creates a new rectangle each time it is called. This prevents\nfrom modifying this subset by modifying the returned region.\nReturns the spatial subset as a rectangular region, or null if no spatial region was defined"},
    {"setRegion2", (PyCFunction) BeamPyProductSubsetDef_setRegion2, METH_VARARGS, "Sets the spatial subset as a rectangular region.\nReturns Parameter region: the spatial subset as a rectangular region, null if no spatial region shall be\ndefined"},
    {"setRegion1", (PyCFunction) BeamPyProductSubsetDef_setRegion1, METH_VARARGS, "Sets the spatial subset as a rectangular region.\nReturns Parameter x: the X-offset in pixels\nReturns Parameter y: the Y-offset in pixels\nReturns Parameter w: the width of the subset in pixels\nReturns Parameter h: the height of the subset in pixels"},
    {"setSubSampling", (PyCFunction) BeamPyProductSubsetDef_setSubSampling, METH_VARARGS, "Gets the sub-sampling in X- and Y-direction (vertical and horizontal).\nReturns Parameter subSamplingX: sub-sampling in X-direction, must always be greater than zero\nReturns Parameter subSamplingY: sub-sampling in Y-direction, must always be greater than zero"},
    {"getSubSamplingX", (PyCFunction) BeamPyProductSubsetDef_getSubSamplingX, METH_VARARGS, "Gets the sub-sampling in X-direction (horizontal).\nReturns the sub-sampling in X-direction which is always greater than zero"},
    {"getSubSamplingY", (PyCFunction) BeamPyProductSubsetDef_getSubSamplingY, METH_VARARGS, "Gets the sub-sampling in Y-direction (vertical).\nReturns the sub-sampling in Y-direction which is always greater than zero"},
    {"getSceneRasterSize", (PyCFunction) BeamPyProductSubsetDef_getSceneRasterSize, METH_VARARGS, "Gets the required size for a raster required to hold all pixels for the spatial subset for the given maximum\nraster width and height.\nReturns Parameter maxWidth: the maximum raster width\nReturns Parameter maxHeight: the maximum raster height\nReturns the required raster size, never null"},
    {"setIgnoreMetadata", (PyCFunction) BeamPyProductSubsetDef_setIgnoreMetadata, METH_VARARGS, "Sets the ignore metadata information\nReturns Parameter ignoreMetadata: if true, metadata may be ignored during write or read a product."},
    {"isIgnoreMetadata", (PyCFunction) BeamPyProductSubsetDef_isIgnoreMetadata, METH_VARARGS, "Gets the ignore metadata information"},
    {"isEntireProductSelected", (PyCFunction) BeamPyProductSubsetDef_isEntireProductSelected, METH_VARARGS, "Checks whether or not this subset definition select the entire product."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductSubsetDef_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductSubsetDef",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "The ProductSubsetDef class describes a subset or portion of a remote sensing data product.\n\n Subsets can be spatial or spectral or both. A spatial subset is given through a rectangular region in pixels. The\nspectral subset as a list of band (or channel) names.\nAuthor:  Norman Fomferra\nAuthor:  Sabine Embacher\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductSubsetDef_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProductWriter_methods[] = {
    {"getWriterPlugIn", (PyCFunction) BeamPyProductWriter_getWriterPlugIn, METH_VARARGS, "Returns the plug-in which created this product writer.\nReturns the product writer plug-in, should never be null"},
    {"getOutput", (PyCFunction) BeamPyProductWriter_getOutput, METH_VARARGS, "Retrives the current output destination object. Thie return value might be null if the\nsetOutput has not been called so far.\nReturns the output"},
    {"writeProductNodes", (PyCFunction) BeamPyProductWriter_writeProductNodes, METH_VARARGS, "Writes the in-memory representation of a data product.\n\n Whether the band data - the actual pixel values - is written out immediately or later when pixels are\nflushed, is up to the implementation.\nReturns Parameter product: the in-memory representation of the data product\nReturns Parameter output: an object representing a valid output for this writer, might be a ImageInputStream or\nother Object to use for future decoding.\n@throws IllegalArgumentException if output is null or it's type is not one of the\nsupported output sources.\n@throws IOException              if an I/O error occurs"},
    {"writeBandRasterData", (PyCFunction) BeamPyProductWriter_writeBandRasterData, METH_VARARGS, "Writes raster data from the given in-memory source buffer into the data sink specified by the given source band\nand region.\n\n<h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample\nvalues given in the source buffer. The method does not modify the pixel data of the given source band at all.\n\n<h3>Source buffer</h3> The first element of the source buffer corresponds to the given sourceOffsetX\nand sourceOffsetY of the source region. These parameters are an offset within the band's raster data\nand not an offset within the source buffer.<br> The number of elements in the buffer must be exactly be\nsourceWidth * sourceHeight. The pixel values to be writte are considered to be stored in\nline-by-line order, so the raster X co-ordinate varies faster than the Y.\n\n<h3>Source region</h3> The given destination region specified by the sourceOffsetX,\nsourceOffsetY, sourceWidth and sourceHeight parameters is given in the\nsource band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates\nsince product writers do not support spectral or spatial subsets.\nReturns Parameter sourceBand: the source band which identifies the data sink to which to write the sample values\nReturns Parameter sourceOffsetX: the X-offset in the band's raster co-ordinates\nReturns Parameter sourceOffsetY: the Y-offset in the band's raster co-ordinates\nReturns Parameter sourceWidth: the width of region to be written given in the band's raster co-ordinates\nReturns Parameter sourceHeight: the height of region to be written given in the band's raster co-ordinates\nReturns Parameter sourceBuffer: the source buffer which provides the sample values to be written\nReturns Parameter pm: a monitor to inform the user about progress\n@throws IOException              if an I/O error occurs\n@throws IllegalArgumentException if the number of elements source buffer not equals sourceWidth *\nsourceHeight or the source region is out of the band's raster\n@see Band#getRasterWidth()\n@see Band#getRasterHeight()"},
    {"flush", (PyCFunction) BeamPyProductWriter_flush, METH_VARARGS, "Writes all data in memory to the data sink(s) associated with this writer.\n@throws IOException if an I/O error occurs"},
    {"close", (PyCFunction) BeamPyProductWriter_close, METH_VARARGS, "Closes all output streams currently open. A concrete implementation should call flush before\nperforming the actual close-operation.\n@throws IOException if an I/O error occurs"},
    {"shouldWrite", (PyCFunction) BeamPyProductWriter_shouldWrite, METH_VARARGS, "Returns wether the given product node is to be written.\nReturns Parameter node: the product node\nReturns true if so"},
    {"isIncrementalMode", (PyCFunction) BeamPyProductWriter_isIncrementalMode, METH_VARARGS, "Returns whether this product writer writes only modified product nodes.\nReturns true if so"},
    {"setIncrementalMode", (PyCFunction) BeamPyProductWriter_setIncrementalMode, METH_VARARGS, "Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress\nlistening.\nReturns Parameter enabled: enables or disables progress listening."},
    {"deleteOutput", (PyCFunction) BeamPyProductWriter_deleteOutput, METH_VARARGS, "Complete deletes the physical representation of the given product from the file system.\n@throws IOException if an I/O error occurs"},
    {"removeBand", (PyCFunction) BeamPyProductWriter_removeBand, METH_VARARGS, "Physically deletes a Band in a product writer's output.\nReturns Parameter band: The band to delete."},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProductWriter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProductWriter",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "An interface that supports writing a complete data product tree and single band rasters.\nAuthor:  Norman Fomferra\nAuthor:  Sabine Embacher\nVersion:  $Revision$ $Date$\n@see ProductReader",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProductWriter_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef ProgressMonitor_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject ProgressMonitor_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.ProgressMonitor",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    ProgressMonitor_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef MetadataAttribute_methods[] = {
    {"newMetadataAttribute", (PyCFunction) BeamPyMetadataAttribute_newMetadataAttribute, METH_VARARGS | METH_STATIC, ""},
    {"getParentElement", (PyCFunction) BeamPyMetadataAttribute_getParentElement, METH_VARARGS, ""},
    {"equals", (PyCFunction) BeamPyMetadataAttribute_equals, METH_VARARGS, ""},
    {"acceptVisitor", (PyCFunction) BeamPyMetadataAttribute_acceptVisitor, METH_VARARGS, "Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\nThe visitor pattern allows to define new operations on the product data model without the need to add more code\nto it. The new operation is implemented by the visitor.\n\nThe method simply calls visitor.visit(this).\nReturns Parameter visitor: the visitor"},
    {"createDeepClone", (PyCFunction) BeamPyMetadataAttribute_createDeepClone, METH_VARARGS, ""},
    {"getDataType", (PyCFunction) BeamPyMetadataAttribute_getDataType, METH_VARARGS, "Gets the data type of this data node.\nReturns the data type which is always one of the multiple ProductData.TYPE_X constants"},
    {"isFloatingPointType", (PyCFunction) BeamPyMetadataAttribute_isFloatingPointType, METH_VARARGS, "Tests whether the data type of this node is a floating point type.\nReturns true, if so"},
    {"getNumDataElems", (PyCFunction) BeamPyMetadataAttribute_getNumDataElems, METH_VARARGS, "Gets the number of data elements in this data node."},
    {"setData", (PyCFunction) BeamPyMetadataAttribute_setData, METH_VARARGS, "Sets the data of this data node."},
    {"getData", (PyCFunction) BeamPyMetadataAttribute_getData, METH_VARARGS, "Gets the data of this data node."},
    {"setDataElems", (PyCFunction) BeamPyMetadataAttribute_setDataElems, METH_VARARGS, "Sets the data elements of this data node.\n@see ProductData#setElems(Object)"},
    {"getDataElems", (PyCFunction) BeamPyMetadataAttribute_getDataElems, METH_VARARGS, "Gets the data elements of this data node.\n@see ProductData#getElems()"},
    {"getDataElemSize", (PyCFunction) BeamPyMetadataAttribute_getDataElemSize, METH_VARARGS, "Gets the data element size in bytes.\n@see ProductData#getElemSize(int)"},
    {"setReadOnly", (PyCFunction) BeamPyMetadataAttribute_setReadOnly, METH_VARARGS, ""},
    {"isReadOnly", (PyCFunction) BeamPyMetadataAttribute_isReadOnly, METH_VARARGS, ""},
    {"setUnit", (PyCFunction) BeamPyMetadataAttribute_setUnit, METH_VARARGS, ""},
    {"getUnit", (PyCFunction) BeamPyMetadataAttribute_getUnit, METH_VARARGS, ""},
    {"isSynthetic", (PyCFunction) BeamPyMetadataAttribute_isSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"setSynthetic", (PyCFunction) BeamPyMetadataAttribute_setSynthetic, METH_VARARGS, "@deprecated since BEAM 4.10 (not used, no replacement)"},
    {"fireProductNodeDataChanged", (PyCFunction) BeamPyMetadataAttribute_fireProductNodeDataChanged, METH_VARARGS, "Fires a node data changed event. This method is called after the data of this data node changed."},
    {"dispose", (PyCFunction) BeamPyMetadataAttribute_dispose, METH_VARARGS, "Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\nallow the garbage collector to perform a vanilla job.\n\nThis method should be called only if it is for sure that this object instance will never be used again. The\nresults of referencing an instance of this class after a call to dispose() are undefined.\n\nOverrides of this method should always call super.dispose(); after disposing this instance."},
    {"createCompatibleProductData", (PyCFunction) BeamPyMetadataAttribute_createCompatibleProductData, METH_VARARGS, "Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\nnumElems elements of a compatible data type.\nReturns Parameter numElems: the number of elements, must not be less than one\nReturns product data compatible with this data node"},
    {"getOwner", (PyCFunction) BeamPyMetadataAttribute_getOwner, METH_VARARGS, "Returns the owner node of this node."},
    {"getName", (PyCFunction) BeamPyMetadataAttribute_getName, METH_VARARGS, "Returns this node's name."},
    {"setName", (PyCFunction) BeamPyMetadataAttribute_setName, METH_VARARGS, "Sets this product's name.\nReturns Parameter name: The name."},
    {"getDescription", (PyCFunction) BeamPyMetadataAttribute_getDescription, METH_VARARGS, "Returns a short textual description for this products node.\nReturns a description or null"},
    {"setDescription", (PyCFunction) BeamPyMetadataAttribute_setDescription, METH_VARARGS, "Sets a short textual description for this products node.\nReturns Parameter description: a description, can be null"},
    {"isModified", (PyCFunction) BeamPyMetadataAttribute_isModified, METH_VARARGS, "Returns whether or not this node is modified.\nReturns true if so"},
    {"setModified", (PyCFunction) BeamPyMetadataAttribute_setModified, METH_VARARGS, "Sets this node's modified flag.\n\nIf the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\ntrue.\nReturns Parameter modified: whether or not this node is beeing marked as modified.\n@see Product#fireNodeChanged"},
    {"toString", (PyCFunction) BeamPyMetadataAttribute_toString, METH_VARARGS, ""},
    {"isValidNodeName", (PyCFunction) BeamPyMetadataAttribute_isValidNodeName, METH_VARARGS | METH_STATIC, "Tests whether the given name is valid name for a node.\nA valid node name must not start with a dot. Also a valid node name must not contain\nany of the character  \\/:*?\"&lt;&gt;|\nReturns Parameter name: the name to test\nReturns true if the name is a valid node identifier, false otherwise"},
    {"getProduct", (PyCFunction) BeamPyMetadataAttribute_getProduct, METH_VARARGS, "Returns the product to which this node belongs to.\nReturns the product, or null if this node was not owned by a product at the time this method was\ncalled"},
    {"getProductReader", (PyCFunction) BeamPyMetadataAttribute_getProductReader, METH_VARARGS, "Returns the product reader for the product to which this node belongs to.\nReturns the product reader, or null if no such exists"},
    {"getProductWriter", (PyCFunction) BeamPyMetadataAttribute_getProductWriter, METH_VARARGS, "Returns the product writer for the product to which this node belongs to.\nReturns the product writer, or null if no such exists"},
    {"getDisplayName", (PyCFunction) BeamPyMetadataAttribute_getDisplayName, METH_VARARGS, "Returns this node's display name. The display name is the product reference string with the node name appended.\nExample: The string \"[2] node-name\" means node node-name of the\nproduct with the reference number 2.\nReturns this node's name with a product prefix <br>or this node's name only if this node's product prefix is\nnull\n@see #getProductRefString"},
    {"getProductRefString", (PyCFunction) BeamPyMetadataAttribute_getProductRefString, METH_VARARGS, "Gets the product reference string. The product reference string is the product reference number enclosed in\nsquare brackets. Example: The string \"[2]\" stands for a product with the reference number\n2.\nReturns the product reference string. <br>or null if this node has no product <br>or\nnull if its product reference number was inactive"},
    {"updateExpression", (PyCFunction) BeamPyMetadataAttribute_updateExpression, METH_VARARGS, "Asks a product node to replace all occurences of and references to the node name\ngiven by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\nin band arithmetic expressions.\nReturns Parameter oldExternalName: The old node name.\nReturns Parameter newExternalName: The new node name."},
    {"removeFromFile", (PyCFunction) BeamPyMetadataAttribute_removeFromFile, METH_VARARGS, "Physically remove this node from the file associated with the given product writer. The default implementation\ndoes nothing.\nReturns Parameter productWriter: the product writer to be used to remove this node from the underlying file."},
    {"getExtension", (PyCFunction) BeamPyMetadataAttribute_getExtension, METH_VARARGS, ""},
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject MetadataAttribute_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.MetadataAttribute",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "A MetadataAttribute is part of a {@link MetadataElement} and represents a key/value pair.\nAuthor:  Norman Fomferra\nVersion:  $Revision$ $Date$",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    MetadataAttribute_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

static PyMethodDef GeneralPath_methods[] = {
    {NULL, NULL, 0, NULL} /*Sentinel*/
};

// Note: this is unused, experimental code

/**
 * Implements the BeamPy_JObjectType class singleton.
 *
 * THIS TYPE IS NOT YET IN USE: we currently use
 * (<type_string>, <pointer>) tuples to represent Java JNI objects.
 */
PyTypeObject GeneralPath_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.GeneralPath",        /* tp_name */
    sizeof (JObject),             /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)JObject_dealloc,  /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "",                /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    GeneralPath_methods,         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc) JObject_init,      /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};


int BPy_RegisterJObjectSubtypes(PyObject* module)
{
    // Register ImageGeometry:
    ImageGeometry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageGeometry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageGeometry_Type);
    PyModule_AddObject(module, "ImageGeometry", (PyObject*) &ImageGeometry_Type);

    // Register GeoCoding:
    GeoCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoCoding_Type);
    PyModule_AddObject(module, "GeoCoding", (PyObject*) &GeoCoding_Type);

    // Register AffineTransform:
    AffineTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&AffineTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&AffineTransform_Type);
    PyModule_AddObject(module, "AffineTransform", (PyObject*) &AffineTransform_Type);

    // Register Mask:
    Mask_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Mask_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Mask_Type);
    PyModule_AddObject(module, "Mask", (PyObject*) &Mask_Type);

    // Register IndexCoding:
    IndexCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexCoding_Type);
    PyModule_AddObject(module, "IndexCoding", (PyObject*) &IndexCoding_Type);
    // Constants of class IndexCoding_Type:
    PyDict_SetItemString(IndexCoding_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(IndexCoding_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register GPF:
    GPF_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GPF_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GPF_Type);
    PyModule_AddObject(module, "GPF", (PyObject*) &GPF_Type);
    // Constants of class GPF_Type:
    PyDict_SetItemString(GPF_Type.tp_dict, "DISABLE_TILE_CACHE_PROPERTY", PyUnicode_FromString("beam.gpf.disableTileCache"));
    PyDict_SetItemString(GPF_Type.tp_dict, "USE_FILE_TILE_CACHE_PROPERTY", PyUnicode_FromString("beam.gpf.useFileTileCache"));
    PyDict_SetItemString(GPF_Type.tp_dict, "TILE_COMPUTATION_OBSERVER_PROPERTY", PyUnicode_FromString("beam.gpf.tileComputationObserver"));
    PyDict_SetItemString(GPF_Type.tp_dict, "SOURCE_PRODUCT_FIELD_NAME", PyUnicode_FromString("sourceProduct"));
    PyDict_SetItemString(GPF_Type.tp_dict, "TARGET_PRODUCT_FIELD_NAME", PyUnicode_FromString("targetProduct"));
    PyDict_SetItemString(GPF_Type.tp_dict, "KEY_TILE_SIZE", Py_BuildValue(""));
    PyDict_SetItemString(GPF_Type.tp_dict, "NO_PARAMS", Py_BuildValue(""));
    PyDict_SetItemString(GPF_Type.tp_dict, "NO_SOURCES", Py_BuildValue(""));

    // Register Class:
    Class_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Class_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Class_Type);
    PyModule_AddObject(module, "Class", (PyObject*) &Class_Type);

    // Register ServiceRegistry:
    ServiceRegistry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ServiceRegistry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ServiceRegistry_Type);
    PyModule_AddObject(module, "ServiceRegistry", (PyObject*) &ServiceRegistry_Type);

    // Register PixelPos:
    PixelPos_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PixelPos_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PixelPos_Type);
    PyModule_AddObject(module, "PixelPos", (PyObject*) &PixelPos_Type);

    // Register BitRaster:
    BitRaster_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BitRaster_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BitRaster_Type);
    PyModule_AddObject(module, "BitRaster", (PyObject*) &BitRaster_Type);

    // Register ProductNode:
    ProductNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNode_Type);
    PyModule_AddObject(module, "ProductNode", (PyObject*) &ProductNode_Type);

    // Register Rectangle:
    Rectangle_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Rectangle_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Rectangle_Type);
    PyModule_AddObject(module, "Rectangle", (PyObject*) &Rectangle_Type);

    // Register ProductIO:
    ProductIO_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductIO_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductIO_Type);
    PyModule_AddObject(module, "ProductIO", (PyObject*) &ProductIO_Type);
    // Constants of class ProductIO_Type:
    PyDict_SetItemString(ProductIO_Type.tp_dict, "DEFAULT_FORMAT_NAME", PyUnicode_FromString("BEAM-DIMAP"));

    // Register SampleCoding:
    SampleCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SampleCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SampleCoding_Type);
    PyModule_AddObject(module, "SampleCoding", (PyObject*) &SampleCoding_Type);

    // Register Object:
    Object_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Object_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Object_Type);
    PyModule_AddObject(module, "Object", (PyObject*) &Object_Type);

    // Register ProductReader:
    ProductReader_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductReader_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductReader_Type);
    PyModule_AddObject(module, "ProductReader", (PyObject*) &ProductReader_Type);

    // Register ProductReaderPlugIn:
    ProductReaderPlugIn_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductReaderPlugIn_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductReaderPlugIn_Type);
    PyModule_AddObject(module, "ProductReaderPlugIn", (PyObject*) &ProductReaderPlugIn_Type);

    // Register Band:
    Band_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Band_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Band_Type);
    PyModule_AddObject(module, "Band", (PyObject*) &Band_Type);
    // Constants of class Band_Type:
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SAMPLE_CODING", PyUnicode_FromString("sampleCoding"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SOLAR_FLUX", PyUnicode_FromString("solarFlux"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SPECTRAL_BAND_INDEX", PyUnicode_FromString("spectralBandIndex"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SPECTRAL_BANDWIDTH", PyUnicode_FromString("spectralBandwidth"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SPECTRAL_WAVELENGTH", PyUnicode_FromString("spectralWavelength"));
    PyDict_SetItemString(Band_Type.tp_dict, "VIEW_MODE_ORTHO", PyUnicode_FromString("ORTHO"));
    PyDict_SetItemString(Band_Type.tp_dict, "VIEW_MODE_FORWARD", PyUnicode_FromString("FORWARD"));
    PyDict_SetItemString(Band_Type.tp_dict, "VIEW_MODE_NADIR", PyUnicode_FromString("NADIR"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_IMAGE_INFO", PyUnicode_FromString("imageInfo"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_LOG_10_SCALED", PyUnicode_FromString("log10Scaled"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_ROI_DEFINITION", PyUnicode_FromString("roiDefinition"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SCALING_FACTOR", PyUnicode_FromString("scalingFactor"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SCALING_OFFSET", PyUnicode_FromString("scalingOffset"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_NO_DATA_VALUE", PyUnicode_FromString("noDataValue"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_NO_DATA_VALUE_USED", PyUnicode_FromString("noDataValueUsed"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_VALID_PIXEL_EXPRESSION", PyUnicode_FromString("validPixelExpression"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_GEOCODING", PyUnicode_FromString("geoCoding"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_STX", PyUnicode_FromString("stx"));
    PyDict_SetItemString(Band_Type.tp_dict, "NO_DATA_TEXT", PyUnicode_FromString("NaN"));
    PyDict_SetItemString(Band_Type.tp_dict, "INVALID_POS_TEXT", PyUnicode_FromString("Invalid pos."));
    PyDict_SetItemString(Band_Type.tp_dict, "IO_ERROR_TEXT", PyUnicode_FromString("I/O error"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_DATA", PyUnicode_FromString("data"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_READ_ONLY", PyUnicode_FromString("readOnly"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_SYNTHETIC", PyUnicode_FromString("synthetic"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_UNIT", PyUnicode_FromString("unit"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(Band_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register ColorPaletteDef_Point:
    ColorPaletteDef_Point_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ColorPaletteDef_Point_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ColorPaletteDef_Point_Type);
    PyModule_AddObject(module, "ColorPaletteDef_Point", (PyObject*) &ColorPaletteDef_Point_Type);

    // Register Placemark:
    Placemark_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Placemark_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Placemark_Type);
    PyModule_AddObject(module, "Placemark", (PyObject*) &Placemark_Type);
    // Constants of class Placemark_Type:
    PyDict_SetItemString(Placemark_Type.tp_dict, "PLACEMARK_FEATURE_TYPE_NAME", PyUnicode_FromString("Placemark"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_LABEL", PyUnicode_FromString("label"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_TEXT", PyUnicode_FromString("text"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_PIXELPOS", PyUnicode_FromString("pixelPos"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_GEOPOS", PyUnicode_FromString("geoPos"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_DATETIME", PyUnicode_FromString("dateTime"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_STYLE_CSS", PyUnicode_FromString("style_css"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(Placemark_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register IndexValidator:
    IndexValidator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexValidator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexValidator_Type);
    PyModule_AddObject(module, "IndexValidator", (PyObject*) &IndexValidator_Type);

    // Register Area:
    Area_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Area_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Area_Type);
    PyModule_AddObject(module, "Area", (PyObject*) &Area_Type);

    // Register ComponentColorModel:
    ComponentColorModel_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ComponentColorModel_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ComponentColorModel_Type);
    PyModule_AddObject(module, "ComponentColorModel", (PyObject*) &ComponentColorModel_Type);

    // Register MathTransform:
    MathTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MathTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MathTransform_Type);
    PyModule_AddObject(module, "MathTransform", (PyObject*) &MathTransform_Type);

    // Register CoordinateReferenceSystem:
    CoordinateReferenceSystem_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&CoordinateReferenceSystem_Type) < 0) {
        return 0;
    }
    Py_INCREF(&CoordinateReferenceSystem_Type);
    PyModule_AddObject(module, "CoordinateReferenceSystem", (PyObject*) &CoordinateReferenceSystem_Type);

    // Register ProductWriterPlugIn:
    ProductWriterPlugIn_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductWriterPlugIn_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductWriterPlugIn_Type);
    PyModule_AddObject(module, "ProductWriterPlugIn", (PyObject*) &ProductWriterPlugIn_Type);

    // Register IndexColorModel:
    IndexColorModel_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&IndexColorModel_Type) < 0) {
        return 0;
    }
    Py_INCREF(&IndexColorModel_Type);
    PyModule_AddObject(module, "IndexColorModel", (PyObject*) &IndexColorModel_Type);

    // Register ProductNodeListener:
    ProductNodeListener_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNodeListener_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNodeListener_Type);
    PyModule_AddObject(module, "ProductNodeListener", (PyObject*) &ProductNodeListener_Type);

    // Register MetadataElement:
    MetadataElement_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MetadataElement_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MetadataElement_Type);
    PyModule_AddObject(module, "MetadataElement", (PyObject*) &MetadataElement_Type);
    // Constants of class MetadataElement_Type:
    PyDict_SetItemString(MetadataElement_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(MetadataElement_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register Color:
    Color_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Color_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Color_Type);
    PyModule_AddObject(module, "Color", (PyObject*) &Color_Type);

    // Register TransectProfileData:
    TransectProfileData_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&TransectProfileData_Type) < 0) {
        return 0;
    }
    Py_INCREF(&TransectProfileData_Type);
    PyModule_AddObject(module, "TransectProfileData", (PyObject*) &TransectProfileData_Type);

    // Register PlacemarkGroup:
    PlacemarkGroup_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PlacemarkGroup_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PlacemarkGroup_Type);
    PyModule_AddObject(module, "PlacemarkGroup", (PyObject*) &PlacemarkGroup_Type);
    // Constants of class PlacemarkGroup_Type:
    PyDict_SetItemString(PlacemarkGroup_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(PlacemarkGroup_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register Product:
    Product_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Product_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Product_Type);
    PyModule_AddObject(module, "Product", (PyObject*) &Product_Type);
    // Constants of class Product_Type:
    PyDict_SetItemString(Product_Type.tp_dict, "METADATA_ROOT_NAME", PyUnicode_FromString("metadata"));
    PyDict_SetItemString(Product_Type.tp_dict, "HISTORY_ROOT_NAME", PyUnicode_FromString("history"));
    PyDict_SetItemString(Product_Type.tp_dict, "PIN_MASK_NAME", PyUnicode_FromString("pins"));
    PyDict_SetItemString(Product_Type.tp_dict, "GCP_MASK_NAME", PyUnicode_FromString("ground_control_points"));
    PyDict_SetItemString(Product_Type.tp_dict, "PROPERTY_NAME_GEOCODING", PyUnicode_FromString("geoCoding"));
    PyDict_SetItemString(Product_Type.tp_dict, "PROPERTY_NAME_PRODUCT_TYPE", PyUnicode_FromString("productType"));
    PyDict_SetItemString(Product_Type.tp_dict, "GEOMETRY_FEATURE_TYPE_NAME", PyUnicode_FromString("org.esa.beam.Geometry"));
    PyDict_SetItemString(Product_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(Product_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register ProductVisitor:
    ProductVisitor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductVisitor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductVisitor_Type);
    PyModule_AddObject(module, "ProductVisitor", (PyObject*) &ProductVisitor_Type);

    // Register WritableNamespace:
    WritableNamespace_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&WritableNamespace_Type) < 0) {
        return 0;
    }
    Py_INCREF(&WritableNamespace_Type);
    PyModule_AddObject(module, "WritableNamespace", (PyObject*) &WritableNamespace_Type);

    // Register Set:
    Set_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Set_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Set_Type);
    PyModule_AddObject(module, "Set", (PyObject*) &Set_Type);

    // Register MultiLevelImage:
    MultiLevelImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MultiLevelImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MultiLevelImage_Type);
    PyModule_AddObject(module, "MultiLevelImage", (PyObject*) &MultiLevelImage_Type);

    // Register RenderingHints_Key:
    RenderingHints_Key_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderingHints_Key_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderingHints_Key_Type);
    PyModule_AddObject(module, "RenderingHints_Key", (PyObject*) &RenderingHints_Key_Type);

    // Register ROI:
    ROI_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ROI_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ROI_Type);
    PyModule_AddObject(module, "ROI", (PyObject*) &ROI_Type);

    // Register ProductManager_Listener:
    ProductManager_Listener_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductManager_Listener_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductManager_Listener_Type);
    PyModule_AddObject(module, "ProductManager_Listener", (PyObject*) &ProductManager_Listener_Type);

    // Register ColorPaletteDef:
    ColorPaletteDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ColorPaletteDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ColorPaletteDef_Type);
    PyModule_AddObject(module, "ColorPaletteDef", (PyObject*) &ColorPaletteDef_Type);

    // Register Geometry:
    Geometry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Geometry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Geometry_Type);
    PyModule_AddObject(module, "Geometry", (PyObject*) &Geometry_Type);

    // Register ImageInfo:
    ImageInfo_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInfo_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInfo_Type);
    PyModule_AddObject(module, "ImageInfo", (PyObject*) &ImageInfo_Type);
    // Constants of class ImageInfo_Type:
    PyDict_SetItemString(ImageInfo_Type.tp_dict, "NO_COLOR", Py_BuildValue(""));
    PyDict_SetItemString(ImageInfo_Type.tp_dict, "HISTOGRAM_MATCHING_OFF", PyUnicode_FromString("off"));
    PyDict_SetItemString(ImageInfo_Type.tp_dict, "HISTOGRAM_MATCHING_EQUALIZE", PyUnicode_FromString("equalize"));
    PyDict_SetItemString(ImageInfo_Type.tp_dict, "HISTOGRAM_MATCHING_NORMALIZE", PyUnicode_FromString("normalize"));

    // Register String:
    String_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&String_Type) < 0) {
        return 0;
    }
    Py_INCREF(&String_Type);
    PyModule_AddObject(module, "String", (PyObject*) &String_Type);

    // Register Histogram:
    Histogram_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Histogram_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Histogram_Type);
    PyModule_AddObject(module, "Histogram", (PyObject*) &Histogram_Type);

    // Register TiePointGrid:
    TiePointGrid_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&TiePointGrid_Type) < 0) {
        return 0;
    }
    Py_INCREF(&TiePointGrid_Type);
    PyModule_AddObject(module, "TiePointGrid", (PyObject*) &TiePointGrid_Type);
    // Constants of class TiePointGrid_Type:
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_IMAGE_INFO", PyUnicode_FromString("imageInfo"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_LOG_10_SCALED", PyUnicode_FromString("log10Scaled"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_ROI_DEFINITION", PyUnicode_FromString("roiDefinition"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_SCALING_FACTOR", PyUnicode_FromString("scalingFactor"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_SCALING_OFFSET", PyUnicode_FromString("scalingOffset"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_NO_DATA_VALUE", PyUnicode_FromString("noDataValue"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_NO_DATA_VALUE_USED", PyUnicode_FromString("noDataValueUsed"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_VALID_PIXEL_EXPRESSION", PyUnicode_FromString("validPixelExpression"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_GEOCODING", PyUnicode_FromString("geoCoding"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_STX", PyUnicode_FromString("stx"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "NO_DATA_TEXT", PyUnicode_FromString("NaN"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "INVALID_POS_TEXT", PyUnicode_FromString("Invalid pos."));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "IO_ERROR_TEXT", PyUnicode_FromString("I/O error"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_DATA", PyUnicode_FromString("data"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_READ_ONLY", PyUnicode_FromString("readOnly"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_SYNTHETIC", PyUnicode_FromString("synthetic"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_UNIT", PyUnicode_FromString("unit"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(TiePointGrid_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register RGBChannelDef:
    RGBChannelDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RGBChannelDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RGBChannelDef_Type);
    PyModule_AddObject(module, "RGBChannelDef", (PyObject*) &RGBChannelDef_Type);

    // Register VectorDataNode:
    VectorDataNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&VectorDataNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&VectorDataNode_Type);
    PyModule_AddObject(module, "VectorDataNode", (PyObject*) &VectorDataNode_Type);

    // Register ImageInputStream:
    ImageInputStream_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInputStream_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInputStream_Type);
    PyModule_AddObject(module, "ImageInputStream", (PyObject*) &ImageInputStream_Type);

    // Register RenderingHints:
    RenderingHints_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderingHints_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderingHints_Type);
    PyModule_AddObject(module, "RenderingHints", (PyObject*) &RenderingHints_Type);

    // Register Shape:
    Shape_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Shape_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Shape_Type);
    PyModule_AddObject(module, "Shape", (PyObject*) &Shape_Type);

    // Register MapTransform:
    MapTransform_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapTransform_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapTransform_Type);
    PyModule_AddObject(module, "MapTransform", (PyObject*) &MapTransform_Type);

    // Register Parser:
    Parser_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Parser_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Parser_Type);
    PyModule_AddObject(module, "Parser", (PyObject*) &Parser_Type);

    // Register ProductData:
    ProductData_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductData_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductData_Type);
    PyModule_AddObject(module, "ProductData", (PyObject*) &ProductData_Type);
    // Constants of class ProductData_Type:
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_UNDEFINED", PyLong_FromLong(0));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_INT8", PyLong_FromLong(10));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_INT16", PyLong_FromLong(11));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_INT32", PyLong_FromLong(12));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_UINT8", PyLong_FromLong(20));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_UINT16", PyLong_FromLong(21));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_UINT32", PyLong_FromLong(22));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_FLOAT32", PyLong_FromLong(30));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_FLOAT64", PyLong_FromLong(31));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_ASCII", PyLong_FromLong(41));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPE_UTC", PyLong_FromLong(51));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_INT8", PyUnicode_FromString("int8"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_INT16", PyUnicode_FromString("int16"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_INT32", PyUnicode_FromString("int32"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_UINT8", PyUnicode_FromString("uint8"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_UINT16", PyUnicode_FromString("uint16"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_UINT32", PyUnicode_FromString("uint32"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_FLOAT32", PyUnicode_FromString("float32"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_FLOAT64", PyUnicode_FromString("float64"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_ASCII", PyUnicode_FromString("ascii"));
    PyDict_SetItemString(ProductData_Type.tp_dict, "TYPESTRING_UTC", PyUnicode_FromString("utc"));

    // Register OperatorSpi:
    OperatorSpi_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&OperatorSpi_Type) < 0) {
        return 0;
    }
    Py_INCREF(&OperatorSpi_Type);
    PyModule_AddObject(module, "OperatorSpi", (PyObject*) &OperatorSpi_Type);

    // Register JtsGeometryConverter:
    JtsGeometryConverter_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&JtsGeometryConverter_Type) < 0) {
        return 0;
    }
    Py_INCREF(&JtsGeometryConverter_Type);
    PyModule_AddObject(module, "JtsGeometryConverter", (PyObject*) &JtsGeometryConverter_Type);

    // Register Double:
    Double_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Double_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Double_Type);
    PyModule_AddObject(module, "Double", (PyObject*) &Double_Type);

    // Register Term:
    Term_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Term_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Term_Type);
    PyModule_AddObject(module, "Term", (PyObject*) &Term_Type);

    // Register RasterDataNode:
    RasterDataNode_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RasterDataNode_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RasterDataNode_Type);
    PyModule_AddObject(module, "RasterDataNode", (PyObject*) &RasterDataNode_Type);

    // Register Product_AutoGrouping:
    Product_AutoGrouping_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Product_AutoGrouping_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Product_AutoGrouping_Type);
    PyModule_AddObject(module, "Product_AutoGrouping", (PyObject*) &Product_AutoGrouping_Type);

    // Register Dimension:
    Dimension_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Dimension_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Dimension_Type);
    PyModule_AddObject(module, "Dimension", (PyObject*) &Dimension_Type);

    // Register Stx:
    Stx_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Stx_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Stx_Type);
    PyModule_AddObject(module, "Stx", (PyObject*) &Stx_Type);

    // Register ImageOutputStream:
    ImageOutputStream_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageOutputStream_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageOutputStream_Type);
    PyModule_AddObject(module, "ImageOutputStream", (PyObject*) &ImageOutputStream_Type);

    // Register AngularDirection:
    AngularDirection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&AngularDirection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&AngularDirection_Type);
    PyModule_AddObject(module, "AngularDirection", (PyObject*) &AngularDirection_Type);

    // Register SimpleFeatureType:
    SimpleFeatureType_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SimpleFeatureType_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SimpleFeatureType_Type);
    PyModule_AddObject(module, "SimpleFeatureType", (PyObject*) &SimpleFeatureType_Type);

    // Register ProductData_UTC:
    ProductData_UTC_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductData_UTC_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductData_UTC_Type);
    PyModule_AddObject(module, "ProductData_UTC", (PyObject*) &ProductData_UTC_Type);

    // Register Integer:
    Integer_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Integer_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Integer_Type);
    PyModule_AddObject(module, "Integer", (PyObject*) &Integer_Type);

    // Register RenderedImage:
    RenderedImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&RenderedImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&RenderedImage_Type);
    PyModule_AddObject(module, "RenderedImage", (PyObject*) &RenderedImage_Type);

    // Register Iterator:
    Iterator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Iterator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Iterator_Type);
    PyModule_AddObject(module, "Iterator", (PyObject*) &Iterator_Type);

    // Register Mask_ImageType:
    Mask_ImageType_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Mask_ImageType_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Mask_ImageType_Type);
    PyModule_AddObject(module, "Mask_ImageType", (PyObject*) &Mask_ImageType_Type);

    // Register File:
    File_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&File_Type) < 0) {
        return 0;
    }
    Py_INCREF(&File_Type);
    PyModule_AddObject(module, "File", (PyObject*) &File_Type);

    // Register GeoPos:
    GeoPos_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoPos_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoPos_Type);
    PyModule_AddObject(module, "GeoPos", (PyObject*) &GeoPos_Type);

    // Register ProductNodeGroup:
    ProductNodeGroup_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductNodeGroup_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductNodeGroup_Type);
    PyModule_AddObject(module, "ProductNodeGroup", (PyObject*) &ProductNodeGroup_Type);
    // Constants of class ProductNodeGroup_Type:
    PyDict_SetItemString(ProductNodeGroup_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(ProductNodeGroup_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register ProductManager:
    ProductManager_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductManager_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductManager_Type);
    PyModule_AddObject(module, "ProductManager", (PyObject*) &ProductManager_Type);

    // Register MapProjection:
    MapProjection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapProjection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapProjection_Type);
    PyModule_AddObject(module, "MapProjection", (PyObject*) &MapProjection_Type);

    // Register FlagCoding:
    FlagCoding_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&FlagCoding_Type) < 0) {
        return 0;
    }
    Py_INCREF(&FlagCoding_Type);
    PyModule_AddObject(module, "FlagCoding", (PyObject*) &FlagCoding_Type);
    // Constants of class FlagCoding_Type:
    PyDict_SetItemString(FlagCoding_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(FlagCoding_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register Operator:
    Operator_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Operator_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Operator_Type);
    PyModule_AddObject(module, "Operator", (PyObject*) &Operator_Type);

    // Register OperatorSpiRegistry:
    OperatorSpiRegistry_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&OperatorSpiRegistry_Type) < 0) {
        return 0;
    }
    Py_INCREF(&OperatorSpiRegistry_Type);
    PyModule_AddObject(module, "OperatorSpiRegistry", (PyObject*) &OperatorSpiRegistry_Type);

    // Register BitmaskDef:
    BitmaskDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BitmaskDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BitmaskDef_Type);
    PyModule_AddObject(module, "BitmaskDef", (PyObject*) &BitmaskDef_Type);

    // Register ImageInfo_HistogramMatching:
    ImageInfo_HistogramMatching_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ImageInfo_HistogramMatching_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ImageInfo_HistogramMatching_Type);
    PyModule_AddObject(module, "ImageInfo_HistogramMatching", (PyObject*) &ImageInfo_HistogramMatching_Type);

    // Register Datum:
    Datum_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Datum_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Datum_Type);
    PyModule_AddObject(module, "Datum", (PyObject*) &Datum_Type);

    // Register ProductUtils:
    ProductUtils_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductUtils_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductUtils_Type);
    PyModule_AddObject(module, "ProductUtils", (PyObject*) &ProductUtils_Type);

    // Register Map:
    Map_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Map_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Map_Type);
    PyModule_AddObject(module, "Map", (PyObject*) &Map_Type);

    // Register SubsetOp:
    SubsetOp_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SubsetOp_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SubsetOp_Type);
    PyModule_AddObject(module, "SubsetOp", (PyObject*) &SubsetOp_Type);

    // Register Pointing:
    Pointing_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Pointing_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Pointing_Type);
    PyModule_AddObject(module, "Pointing", (PyObject*) &Pointing_Type);

    // Register PlacemarkDescriptor:
    PlacemarkDescriptor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PlacemarkDescriptor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PlacemarkDescriptor_Type);
    PyModule_AddObject(module, "PlacemarkDescriptor", (PyObject*) &PlacemarkDescriptor_Type);

    // Register PointingFactory:
    PointingFactory_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&PointingFactory_Type) < 0) {
        return 0;
    }
    Py_INCREF(&PointingFactory_Type);
    PyModule_AddObject(module, "PointingFactory", (PyObject*) &PointingFactory_Type);

    // Register Point2D:
    Point2D_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Point2D_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Point2D_Type);
    PyModule_AddObject(module, "Point2D", (PyObject*) &Point2D_Type);

    // Register Scaling:
    Scaling_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Scaling_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Scaling_Type);
    PyModule_AddObject(module, "Scaling", (PyObject*) &Scaling_Type);

    // Register Collection:
    Collection_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&Collection_Type) < 0) {
        return 0;
    }
    Py_INCREF(&Collection_Type);
    PyModule_AddObject(module, "Collection", (PyObject*) &Collection_Type);

    // Register GeoTIFFMetadata:
    GeoTIFFMetadata_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeoTIFFMetadata_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeoTIFFMetadata_Type);
    PyModule_AddObject(module, "GeoTIFFMetadata", (PyObject*) &GeoTIFFMetadata_Type);

    // Register MapInfo:
    MapInfo_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MapInfo_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MapInfo_Type);
    PyModule_AddObject(module, "MapInfo", (PyObject*) &MapInfo_Type);

    // Register BufferedImage:
    BufferedImage_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&BufferedImage_Type) < 0) {
        return 0;
    }
    Py_INCREF(&BufferedImage_Type);
    PyModule_AddObject(module, "BufferedImage", (PyObject*) &BufferedImage_Type);

    // Register SimpleFeature:
    SimpleFeature_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&SimpleFeature_Type) < 0) {
        return 0;
    }
    Py_INCREF(&SimpleFeature_Type);
    PyModule_AddObject(module, "SimpleFeature", (PyObject*) &SimpleFeature_Type);

    // Register ProductSubsetDef:
    ProductSubsetDef_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductSubsetDef_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductSubsetDef_Type);
    PyModule_AddObject(module, "ProductSubsetDef", (PyObject*) &ProductSubsetDef_Type);

    // Register ProductWriter:
    ProductWriter_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProductWriter_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProductWriter_Type);
    PyModule_AddObject(module, "ProductWriter", (PyObject*) &ProductWriter_Type);

    // Register ProgressMonitor:
    ProgressMonitor_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&ProgressMonitor_Type) < 0) {
        return 0;
    }
    Py_INCREF(&ProgressMonitor_Type);
    PyModule_AddObject(module, "ProgressMonitor", (PyObject*) &ProgressMonitor_Type);

    // Register MetadataAttribute:
    MetadataAttribute_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&MetadataAttribute_Type) < 0) {
        return 0;
    }
    Py_INCREF(&MetadataAttribute_Type);
    PyModule_AddObject(module, "MetadataAttribute", (PyObject*) &MetadataAttribute_Type);
    // Constants of class MetadataAttribute_Type:
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_DATA", PyUnicode_FromString("data"));
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_READ_ONLY", PyUnicode_FromString("readOnly"));
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_SYNTHETIC", PyUnicode_FromString("synthetic"));
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_UNIT", PyUnicode_FromString("unit"));
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_NAME", PyUnicode_FromString("name"));
    PyDict_SetItemString(MetadataAttribute_Type.tp_dict, "PROPERTY_NAME_DESCRIPTION", PyUnicode_FromString("description"));

    // Register GeneralPath:
    GeneralPath_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&GeneralPath_Type) < 0) {
        return 0;
    }
    Py_INCREF(&GeneralPath_Type);
    PyModule_AddObject(module, "GeneralPath", (PyObject*) &GeneralPath_Type);

    return 1;
}

// <<<<<<<< Begin include from PyCModuleGenerator-stub-pymodule.c

/**
 * The BEAM/Python API module definition structure.
 * The variable 'BeamPy_Methods' is defined in the generated file 'beampy_module.c'.
 */
static struct PyModuleDef BeamPy_Module =
{
   PyModuleDef_HEAD_INIT,
   "beampy",           /* Name of the Python module */
   "BEAM Python API",  /* Module documentation */
   -1,                 /* Size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
   BeamPy_Functions,    /* Structure containing global beampy-functions */
   NULL,   // m_reload
   NULL,   // m_traverse
   NULL,   // m_clear
   NULL    // m_free
};

int BPy_RegisterJObjectSubtypes(PyObject* module);


/**
 * Called by the Python interpreter once immediately after the shared lib _beampy.pyk has been loaded.
 */
PyMODINIT_FUNC PyInit_beampy(void)
{
    PyObject* module;
    PyObject* version;

    fprintf(stdout, "beampy: enter PyInit_beampy()\n");

    /////////////////////////////////////////////////////////////////////////
    // Create BeamPy_Module

    module = PyModule_Create(&BeamPy_Module);
    if (module == NULL) {
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Define exception type BeamPy_Error ('beampy.error')

    BeamPy_Error = PyErr_NewException("beampy.BeamError", NULL, NULL);
    Py_INCREF(BeamPy_Error);
    PyModule_AddObject(module, "error", BeamPy_Error);

    /////////////////////////////////////////////////////////////////////////
    // Register API version info

    version = PyUnicode_FromString("0.1");
    Py_INCREF(version);
    PyModule_AddObject(module, "version", version);

    /////////////////////////////////////////////////////////////////////////
    // Register CArray_Type

    if (PyType_Ready(&CArray_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&CArray_Type);
    PyModule_AddObject(module, "CArray", (PyObject*) &CArray_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register JObject_Type ('JObject')
    //
    if (PyType_Ready(&JObject_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&JObject_Type);
    PyModule_AddObject(module, "JObject", (PyObject*) &JObject_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register JObjectArray_Type ('JObjectArray')
    //
    JObjectArray_Type.tp_base = &JObject_Type;
    if (PyType_Ready(&JObjectArray_Type) < 0) {
        return NULL;
    }
    Py_INCREF(&JObjectArray_Type);
    PyModule_AddObject(module, "JObjectArray", (PyObject*) &JObjectArray_Type);

    /////////////////////////////////////////////////////////////////////////
    // Register BEAM JObject Sub-types
    //
    if (!BPy_RegisterJObjectSubtypes(module)) {
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Create JVM

    if (!beam_createJvmWithDefaults()) {
        PyErr_SetString(BeamPy_Error, "Failed to create Java VM");
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////
    // Initialise JPyUtil

    if (!BPy_InitJPyUtil()) {
        return NULL;
    }

    fprintf(stdout, "beampy: exit PyInit_beampy()\n");

    return module;
}

// >>>>>>>> End include from PyCModuleGenerator-stub-pymodule.c

jboolean BPy_InitApi(void)
{
    static int initialized = 0;

    if (initialized) {
        return 1;
    }

    if (!beam_isJvmCreated() && !beam_createJvmWithDefaults()) {
        PyErr_SetString(PyExc_RuntimeError, "BPy_InitApi: failed to create Java VM");
        return 0;
    }

    if (!BPy_InitJClass(&BPy_Boolean_Class, "java/lang/Boolean")) return 0;
    if (!BPy_InitJClass(&BPy_Byte_Class, "java/lang/Byte")) return 0;
    if (!BPy_InitJClass(&BPy_Character_Class, "java/lang/Character")) return 0;
    if (!BPy_InitJClass(&BPy_Short_Class, "java/lang/Short")) return 0;
    if (!BPy_InitJClass(&BPy_Integer_Class, "java/lang/Integer")) return 0;
    if (!BPy_InitJClass(&BPy_Long_Class, "java/lang/Long")) return 0;
    if (!BPy_InitJClass(&BPy_Float_Class, "java/lang/Float")) return 0;
    if (!BPy_InitJClass(&BPy_Double_Class, "java/lang/Double")) return 0;
    if (!BPy_InitJClass(&BPy_String_Class, "java/lang/String")) return 0;

    if (!BPy_InitJClass(&BPy_HashMap_Class, "java/util/HashMap")) return 0;
    if (!BPy_InitJClass(&BPy_HashSet_Class, "java/util/HashSet")) return 0;
    if (!BPy_InitJClass(&BPy_ArrayList_Class, "java/util/ArrayList")) return 0;

    if (!BPy_InitJClass(&BPy_ImageGeometry_Class, "org/esa/beam/framework/datamodel/ImageGeometry")) return 0;
    if (!BPy_InitJClass(&BPy_GeoCoding_Class, "org/esa/beam/framework/datamodel/GeoCoding")) return 0;
    if (!BPy_InitJClass(&BPy_AffineTransform_Class, "java/awt/geom/AffineTransform")) return 0;
    if (!BPy_InitJClass(&BPy_Mask_Class, "org/esa/beam/framework/datamodel/Mask")) return 0;
    if (!BPy_InitJClass(&BPy_IndexCoding_Class, "org/esa/beam/framework/datamodel/IndexCoding")) return 0;
    if (!BPy_InitJClass(&BPy_GPF_Class, "org/esa/beam/framework/gpf/GPF")) return 0;
    if (!BPy_InitJClass(&BPy_Class_Class, "java/lang/Class")) return 0;
    if (!BPy_InitJClass(&BPy_ServiceRegistry_Class, "com/bc/ceres/core/ServiceRegistry")) return 0;
    if (!BPy_InitJClass(&BPy_PixelPos_Class, "org/esa/beam/framework/datamodel/PixelPos")) return 0;
    if (!BPy_InitJClass(&BPy_BitRaster_Class, "org/esa/beam/util/BitRaster")) return 0;
    if (!BPy_InitJClass(&BPy_ProductNode_Class, "org/esa/beam/framework/datamodel/ProductNode")) return 0;
    if (!BPy_InitJClass(&BPy_Rectangle_Class, "java/awt/Rectangle")) return 0;
    if (!BPy_InitJClass(&BPy_ProductIO_Class, "org/esa/beam/framework/dataio/ProductIO")) return 0;
    if (!BPy_InitJClass(&BPy_SampleCoding_Class, "org/esa/beam/framework/datamodel/SampleCoding")) return 0;
    if (!BPy_InitJClass(&BPy_Object_Class, "java/lang/Object")) return 0;
    if (!BPy_InitJClass(&BPy_ProductReader_Class, "org/esa/beam/framework/dataio/ProductReader")) return 0;
    if (!BPy_InitJClass(&BPy_ProductReaderPlugIn_Class, "org/esa/beam/framework/dataio/ProductReaderPlugIn")) return 0;
    if (!BPy_InitJClass(&BPy_Band_Class, "org/esa/beam/framework/datamodel/Band")) return 0;
    if (!BPy_InitJClass(&BPy_ColorPaletteDef_Point_Class, "org/esa/beam/framework/datamodel/ColorPaletteDef$Point")) return 0;
    if (!BPy_InitJClass(&BPy_Placemark_Class, "org/esa/beam/framework/datamodel/Placemark")) return 0;
    if (!BPy_InitJClass(&BPy_IndexValidator_Class, "org/esa/beam/util/math/IndexValidator")) return 0;
    if (!BPy_InitJClass(&BPy_Area_Class, "java/awt/geom/Area")) return 0;
    if (!BPy_InitJClass(&BPy_ComponentColorModel_Class, "java/awt/image/ComponentColorModel")) return 0;
    if (!BPy_InitJClass(&BPy_MathTransform_Class, "org/opengis/referencing/operation/MathTransform")) return 0;
    if (!BPy_InitJClass(&BPy_CoordinateReferenceSystem_Class, "org/opengis/referencing/crs/CoordinateReferenceSystem")) return 0;
    if (!BPy_InitJClass(&BPy_ProductWriterPlugIn_Class, "org/esa/beam/framework/dataio/ProductWriterPlugIn")) return 0;
    if (!BPy_InitJClass(&BPy_IndexColorModel_Class, "java/awt/image/IndexColorModel")) return 0;
    if (!BPy_InitJClass(&BPy_ProductNodeListener_Class, "org/esa/beam/framework/datamodel/ProductNodeListener")) return 0;
    if (!BPy_InitJClass(&BPy_MetadataElement_Class, "org/esa/beam/framework/datamodel/MetadataElement")) return 0;
    if (!BPy_InitJClass(&BPy_Color_Class, "java/awt/Color")) return 0;
    if (!BPy_InitJClass(&BPy_TransectProfileData_Class, "org/esa/beam/framework/datamodel/TransectProfileData")) return 0;
    if (!BPy_InitJClass(&BPy_PlacemarkGroup_Class, "org/esa/beam/framework/datamodel/PlacemarkGroup")) return 0;
    if (!BPy_InitJClass(&BPy_Product_Class, "org/esa/beam/framework/datamodel/Product")) return 0;
    if (!BPy_InitJClass(&BPy_ProductVisitor_Class, "org/esa/beam/framework/datamodel/ProductVisitor")) return 0;
    if (!BPy_InitJClass(&BPy_WritableNamespace_Class, "com/bc/jexp/WritableNamespace")) return 0;
    if (!BPy_InitJClass(&BPy_Set_Class, "java/util/Set")) return 0;
    if (!BPy_InitJClass(&BPy_MultiLevelImage_Class, "com/bc/ceres/glevel/MultiLevelImage")) return 0;
    if (!BPy_InitJClass(&BPy_RenderingHints_Key_Class, "java/awt/RenderingHints$Key")) return 0;
    if (!BPy_InitJClass(&BPy_ROI_Class, "javax/media/jai/ROI")) return 0;
    if (!BPy_InitJClass(&BPy_ProductManager_Listener_Class, "org/esa/beam/framework/datamodel/ProductManager$Listener")) return 0;
    if (!BPy_InitJClass(&BPy_ColorPaletteDef_Class, "org/esa/beam/framework/datamodel/ColorPaletteDef")) return 0;
    if (!BPy_InitJClass(&BPy_Geometry_Class, "com/vividsolutions/jts/geom/Geometry")) return 0;
    if (!BPy_InitJClass(&BPy_ImageInfo_Class, "org/esa/beam/framework/datamodel/ImageInfo")) return 0;
    if (!BPy_InitJClass(&BPy_Histogram_Class, "org/esa/beam/util/math/Histogram")) return 0;
    if (!BPy_InitJClass(&BPy_TiePointGrid_Class, "org/esa/beam/framework/datamodel/TiePointGrid")) return 0;
    if (!BPy_InitJClass(&BPy_RGBChannelDef_Class, "org/esa/beam/framework/datamodel/RGBChannelDef")) return 0;
    if (!BPy_InitJClass(&BPy_VectorDataNode_Class, "org/esa/beam/framework/datamodel/VectorDataNode")) return 0;
    if (!BPy_InitJClass(&BPy_ImageInputStream_Class, "javax/imageio/stream/ImageInputStream")) return 0;
    if (!BPy_InitJClass(&BPy_RenderingHints_Class, "java/awt/RenderingHints")) return 0;
    if (!BPy_InitJClass(&BPy_Shape_Class, "java/awt/Shape")) return 0;
    if (!BPy_InitJClass(&BPy_MapTransform_Class, "org/esa/beam/framework/dataop/maptransf/MapTransform")) return 0;
    if (!BPy_InitJClass(&BPy_Parser_Class, "com/bc/jexp/Parser")) return 0;
    if (!BPy_InitJClass(&BPy_ProductData_Class, "org/esa/beam/framework/datamodel/ProductData")) return 0;
    if (!BPy_InitJClass(&BPy_OperatorSpi_Class, "org/esa/beam/framework/gpf/OperatorSpi")) return 0;
    if (!BPy_InitJClass(&BPy_JtsGeometryConverter_Class, "org/esa/beam/util/converters/JtsGeometryConverter")) return 0;
    if (!BPy_InitJClass(&BPy_Term_Class, "com/bc/jexp/Term")) return 0;
    if (!BPy_InitJClass(&BPy_RasterDataNode_Class, "org/esa/beam/framework/datamodel/RasterDataNode")) return 0;
    if (!BPy_InitJClass(&BPy_Product_AutoGrouping_Class, "org/esa/beam/framework/datamodel/Product$AutoGrouping")) return 0;
    if (!BPy_InitJClass(&BPy_Dimension_Class, "java/awt/Dimension")) return 0;
    if (!BPy_InitJClass(&BPy_Stx_Class, "org/esa/beam/framework/datamodel/Stx")) return 0;
    if (!BPy_InitJClass(&BPy_ImageOutputStream_Class, "javax/imageio/stream/ImageOutputStream")) return 0;
    if (!BPy_InitJClass(&BPy_AngularDirection_Class, "org/esa/beam/framework/datamodel/AngularDirection")) return 0;
    if (!BPy_InitJClass(&BPy_SimpleFeatureType_Class, "org/opengis/feature/simple/SimpleFeatureType")) return 0;
    if (!BPy_InitJClass(&BPy_ProductData_UTC_Class, "org/esa/beam/framework/datamodel/ProductData$UTC")) return 0;
    if (!BPy_InitJClass(&BPy_RenderedImage_Class, "java/awt/image/RenderedImage")) return 0;
    if (!BPy_InitJClass(&BPy_Iterator_Class, "java/util/Iterator")) return 0;
    if (!BPy_InitJClass(&BPy_Mask_ImageType_Class, "org/esa/beam/framework/datamodel/Mask$ImageType")) return 0;
    if (!BPy_InitJClass(&BPy_File_Class, "java/io/File")) return 0;
    if (!BPy_InitJClass(&BPy_GeoPos_Class, "org/esa/beam/framework/datamodel/GeoPos")) return 0;
    if (!BPy_InitJClass(&BPy_ProductNodeGroup_Class, "org/esa/beam/framework/datamodel/ProductNodeGroup")) return 0;
    if (!BPy_InitJClass(&BPy_ProductManager_Class, "org/esa/beam/framework/datamodel/ProductManager")) return 0;
    if (!BPy_InitJClass(&BPy_MapProjection_Class, "org/esa/beam/framework/dataop/maptransf/MapProjection")) return 0;
    if (!BPy_InitJClass(&BPy_FlagCoding_Class, "org/esa/beam/framework/datamodel/FlagCoding")) return 0;
    if (!BPy_InitJClass(&BPy_Operator_Class, "org/esa/beam/framework/gpf/Operator")) return 0;
    if (!BPy_InitJClass(&BPy_OperatorSpiRegistry_Class, "org/esa/beam/framework/gpf/OperatorSpiRegistry")) return 0;
    if (!BPy_InitJClass(&BPy_BitmaskDef_Class, "org/esa/beam/framework/datamodel/BitmaskDef")) return 0;
    if (!BPy_InitJClass(&BPy_ImageInfo_HistogramMatching_Class, "org/esa/beam/framework/datamodel/ImageInfo$HistogramMatching")) return 0;
    if (!BPy_InitJClass(&BPy_Datum_Class, "org/esa/beam/framework/dataop/maptransf/Datum")) return 0;
    if (!BPy_InitJClass(&BPy_ProductUtils_Class, "org/esa/beam/util/ProductUtils")) return 0;
    if (!BPy_InitJClass(&BPy_Map_Class, "java/util/Map")) return 0;
    if (!BPy_InitJClass(&BPy_SubsetOp_Class, "org/esa/beam/gpf/operators/standard/SubsetOp")) return 0;
    if (!BPy_InitJClass(&BPy_Pointing_Class, "org/esa/beam/framework/datamodel/Pointing")) return 0;
    if (!BPy_InitJClass(&BPy_PlacemarkDescriptor_Class, "org/esa/beam/framework/datamodel/PlacemarkDescriptor")) return 0;
    if (!BPy_InitJClass(&BPy_PointingFactory_Class, "org/esa/beam/framework/datamodel/PointingFactory")) return 0;
    if (!BPy_InitJClass(&BPy_Point2D_Class, "java/awt/geom/Point2D")) return 0;
    if (!BPy_InitJClass(&BPy_Scaling_Class, "org/esa/beam/framework/datamodel/Scaling")) return 0;
    if (!BPy_InitJClass(&BPy_Collection_Class, "java/util/Collection")) return 0;
    if (!BPy_InitJClass(&BPy_GeoTIFFMetadata_Class, "org/esa/beam/util/geotiff/GeoTIFFMetadata")) return 0;
    if (!BPy_InitJClass(&BPy_MapInfo_Class, "org/esa/beam/framework/dataop/maptransf/MapInfo")) return 0;
    if (!BPy_InitJClass(&BPy_BufferedImage_Class, "java/awt/image/BufferedImage")) return 0;
    if (!BPy_InitJClass(&BPy_SimpleFeature_Class, "org/opengis/feature/simple/SimpleFeature")) return 0;
    if (!BPy_InitJClass(&BPy_ProductSubsetDef_Class, "org/esa/beam/framework/dataio/ProductSubsetDef")) return 0;
    if (!BPy_InitJClass(&BPy_ProductWriter_Class, "org/esa/beam/framework/dataio/ProductWriter")) return 0;
    if (!BPy_InitJClass(&BPy_ProgressMonitor_Class, "com/bc/ceres/core/ProgressMonitor")) return 0;
    if (!BPy_InitJClass(&BPy_MetadataAttribute_Class, "org/esa/beam/framework/datamodel/MetadataAttribute")) return 0;
    if (!BPy_InitJClass(&BPy_GeneralPath_Class, "java/awt/geom/GeneralPath")) return 0;

    initialized = 1;
    return 1;
}


PyObject* BeamPyGeoCoding_isCrossingMeridianAt180(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "isCrossingMeridianAt180", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#isCrossingMeridianAt180()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "canGetPixelPos", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#canGetPixelPos()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "canGetGeoPos", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#canGetGeoPos()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getPixelPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/PixelPos;)Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:getPixelPos", &geoPosPyObj, &pixelPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, BPy_PixelPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, geoPosJObj, pixelPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getPixelPos(Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/PixelPos;)Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;)Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:getGeoPos", &pixelPosPyObj, &geoPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, BPy_PixelPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelPosJObj, geoPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getGeoPos(Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;)Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getDatum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getDatum", "()Lorg/esa/beam/framework/dataop/maptransf/Datum;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getDatum()Lorg/esa/beam/framework/dataop/maptransf/Datum;");
    _resultPyObj = BPy_FromJObject(&Datum_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getImageCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getImageCRS()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;");
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getMapCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getMapCRS()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;");
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getGeoCRS", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getGeoCRS()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;");
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoCoding_Class, "org.esa.beam.framework.datamodel.GeoCoding", "getImageToMapTransform", "()Lorg/opengis/referencing/operation/MathTransform;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoCoding#getImageToMapTransform()Lorg/opengis/referencing/operation/MathTransform;");
    _resultPyObj = BPy_FromJObject(&MathTransform_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyJtsGeometryConverter_newJtsGeometryConverter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_JtsGeometryConverter_Class, "org.esa.beam.util.converters.JtsGeometryConverter", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_JtsGeometryConverter_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.converters.JtsGeometryConverter#<init>()V");
    _resultPyObj = BPy_FromJObject(&JtsGeometryConverter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyJtsGeometryConverter_getValueType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_JtsGeometryConverter_Class, "org.esa.beam.util.converters.JtsGeometryConverter", "getValueType", "()Ljava/lang/Class;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_JtsGeometryConverter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'JtsGeometryConverter' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.converters.JtsGeometryConverter#getValueType()Ljava/lang/Class;");
    _resultPyObj = BPy_FromJObject(&Class_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyJtsGeometryConverter_parse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_JtsGeometryConverter_Class, "org.esa.beam.util.converters.JtsGeometryConverter", "parse", "(Ljava/lang/String;)Lcom/vividsolutions/jts/geom/Geometry;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_JtsGeometryConverter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'JtsGeometryConverter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:parse", &text)) {
        return NULL;
    }
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, textJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.converters.JtsGeometryConverter#parse(Ljava/lang/String;)Lcom/vividsolutions/jts/geom/Geometry;");
    _resultPyObj = BPy_FromJObject(&Geometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyJtsGeometryConverter_format(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_JtsGeometryConverter_Class, "org.esa.beam.util.converters.JtsGeometryConverter", "format", "(Lcom/vividsolutions/jts/geom/Geometry;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_JtsGeometryConverter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'JtsGeometryConverter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:format", &valuePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        valueJObj = BPy_ToJObjectT(valuePyObj, BPy_Geometry_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.converters.JtsGeometryConverter#format(Lcom/vividsolutions/jts/geom/Geometry;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyJtsGeometryConverter_registerConverter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_JtsGeometryConverter_Class, "org.esa.beam.util.converters.JtsGeometryConverter", "registerConverter", "()V", 1)) {
        return NULL;
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_JtsGeometryConverter_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.converters.JtsGeometryConverter#registerConverter()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_newProductSubsetDef1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ProductSubsetDef_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#<init>()V");
    _resultPyObj = BPy_FromJObject(&ProductSubsetDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_newProductSubsetDef2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* subsetName = NULL;
    jstring subsetNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:<init>", &subsetName)) {
        return NULL;
    }
    subsetNameJObj =(*jenv)->NewStringUTF(jenv, subsetName);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ProductSubsetDef_Class, _method, subsetNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#<init>(Ljava/lang/String;)V");
    _resultPyObj = BPy_FromJObject(&ProductSubsetDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, subsetNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_getSubsetName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getSubsetName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getSubsetName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_setSubsetName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* subsetName = NULL;
    jstring subsetNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setSubsetName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setSubsetName", &subsetName)) {
        return NULL;
    }
    subsetNameJObj =(*jenv)->NewStringUTF(jenv, subsetName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, subsetNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setSubsetName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, subsetNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_setTreatVirtualBandsAsRealBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean flag = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setTreatVirtualBandsAsRealBands", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setTreatVirtualBandsAsRealBands", &flag)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, flag);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setTreatVirtualBandsAsRealBands(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_getTreatVirtualBandsAsRealBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getTreatVirtualBandsAsRealBands", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getTreatVirtualBandsAsRealBands()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getNodeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_setNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* namesPyObj = NULL;
    jarray namesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setNodeNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setNodeNames", &namesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        namesJObj = BPy_ToJStringArray(namesPyObj, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, namesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setNodeNames([Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, namesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_addNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "addNodeName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:addNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#addNodeName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_addNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* namesPyObj = NULL;
    jarray namesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "addNodeNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addNodeNames", &namesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        namesJObj = BPy_ToJStringArray(namesPyObj, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, namesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#addNodeNames([Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, namesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_removeNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "removeNodeName", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:removeNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#removeNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_containsNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "containsNodeName", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#containsNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_isNodeAccepted(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "isNodeAccepted", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isNodeAccepted", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#isNodeAccepted(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_getRegion(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getRegion", "()Ljava/awt/Rectangle;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getRegion()Ljava/awt/Rectangle;");
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_setRegion2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setRegion", "(Ljava/awt/Rectangle;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setRegion", &regionPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, regionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setRegion(Ljava/awt/Rectangle;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_setRegion1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setRegion", "(IIII)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiii:setRegion", &x, &y, &w, &h)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setRegion(IIII)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_setSubSampling(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint subSamplingX = (jint) 0;
    jint subSamplingY = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setSubSampling", "(II)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:setSubSampling", &subSamplingX, &subSamplingY)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, subSamplingX, subSamplingY);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setSubSampling(II)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_getSubSamplingX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getSubSamplingX", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getSubSamplingX()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_getSubSamplingY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getSubSamplingY", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getSubSamplingY()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_getSceneRasterSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint maxWidth = (jint) 0;
    jint maxHeight = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "getSceneRasterSize", "(II)Ljava/awt/Dimension;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getSceneRasterSize", &maxWidth, &maxHeight)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, maxWidth, maxHeight);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#getSceneRasterSize(II)Ljava/awt/Dimension;");
    _resultPyObj = BPy_FromJObject(&Dimension_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductSubsetDef_setIgnoreMetadata(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean ignoreMetadata = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "setIgnoreMetadata", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setIgnoreMetadata", &ignoreMetadata)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, ignoreMetadata);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#setIgnoreMetadata(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductSubsetDef_isIgnoreMetadata(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "isIgnoreMetadata", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#isIgnoreMetadata()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductSubsetDef_isEntireProductSelected(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductSubsetDef_Class, "org.esa.beam.framework.dataio.ProductSubsetDef", "isEntireProductSelected", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductSubsetDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductSubsetDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductSubsetDef#isEntireProductSelected()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "getWriterPlugIn", "()Lorg/esa/beam/framework/dataio/ProductWriterPlugIn;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#getWriterPlugIn()Lorg/esa/beam/framework/dataio/ProductWriterPlugIn;");
    _resultPyObj = BPy_FromJObject(&ProductWriterPlugIn_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "getOutput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#getOutput()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "writeProductNodes", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:writeProductNodes", &productPyObj, &outputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj, outputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#writeProductNodes(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* sourceBandPyObj = NULL;
    jobject sourceBandJObj = NULL;
    jint sourceOffsetX = (jint) 0;
    jint sourceOffsetY = (jint) 0;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    PyObject* sourceBufferPyObj = NULL;
    jobject sourceBufferJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "writeBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:writeBandRasterData", &sourceBandPyObj, &sourceOffsetX, &sourceOffsetY, &sourceWidth, &sourceHeight, &sourceBufferPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceBandJObj = BPy_ToJObjectT(sourceBandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceBufferJObj = BPy_ToJObjectT(sourceBufferPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceBandJObj, sourceOffsetX, sourceOffsetY, sourceWidth, sourceHeight, sourceBufferJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#writeBandRasterData(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "flush", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#flush()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "close", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#close()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "shouldWrite", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:shouldWrite", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#shouldWrite(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "isIncrementalMode", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#isIncrementalMode()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean enabled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "setIncrementalMode", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setIncrementalMode", &enabled)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, enabled);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#setIncrementalMode(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "deleteOutput", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#deleteOutput()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductWriter_Class, "org.esa.beam.framework.dataio.ProductWriter", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductWriter_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductWriter' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeBand", &bandPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandJObj = BPy_ToJObjectT(bandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductWriter#removeBand(Lorg/esa/beam/framework/datamodel/Band;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_createProductWithoutSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:createProduct", &operatorName, &parametersPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_GPF_Class, _method, operatorNameJObj, parametersJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createProduct(Ljava/lang/String;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:createProduct", &operatorName, &parametersPyObj, &sourceProductPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_GPF_Class, _method, operatorNameJObj, parametersJObj, sourceProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createProduct(Ljava/lang/String;Ljava/util/Map;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;[Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:createProduct", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceProductsJObj = BPy_ToJObjectArrayT(sourceProductsPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_GPF_Class, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createProduct(Ljava/lang/String;Ljava/util/Map;[Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductFromNamedSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createProduct", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:createProduct", &operatorName, &parametersPyObj, &sourceProductsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_GPF_Class, _method, operatorNameJObj, parametersJObj, sourceProductsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createProduct(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createProductNS(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* renderingHintsPyObj = NULL;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createProductNS", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GPF_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOOO:createProductNS", &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        renderingHintsJObj = BPy_ToJObjectT(renderingHintsPyObj, BPy_RenderingHints_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createProductNS(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_createOperator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* parametersPyObj = NULL;
    jobject parametersJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jobject sourceProductsJObj = NULL;
    PyObject* renderingHintsPyObj = NULL;
    jobject renderingHintsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "createOperator", "(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/gpf/Operator;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GPF_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOOO:createOperator", &operatorName, &parametersPyObj, &sourceProductsPyObj, &renderingHintsPyObj)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    {
        jboolean ok = 1;
        parametersJObj = BPy_ToJObjectT(parametersPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        sourceProductsJObj = BPy_ToJObjectT(sourceProductsPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        renderingHintsJObj = BPy_ToJObjectT(renderingHintsPyObj, BPy_RenderingHints_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj, parametersJObj, sourceProductsJObj, renderingHintsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#createOperator(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/awt/RenderingHints;)Lorg/esa/beam/framework/gpf/Operator;");
    _resultPyObj = BPy_FromJObject(&Operator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_getOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "getOperatorSpiRegistry", "()Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GPF_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#getOperatorSpiRegistry()Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;");
    _resultPyObj = BPy_FromJObject(&OperatorSpiRegistry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setOperatorSpiRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* spiRegistryPyObj = NULL;
    jobject spiRegistryJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "setOperatorSpiRegistry", "(Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GPF_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GPF' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setOperatorSpiRegistry", &spiRegistryPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        spiRegistryJObj = BPy_ToJObjectT(spiRegistryPyObj, BPy_OperatorSpiRegistry_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spiRegistryJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#setOperatorSpiRegistry(Lorg/esa/beam/framework/gpf/OperatorSpiRegistry;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_getDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "getDefaultInstance", "()Lorg/esa/beam/framework/gpf/GPF;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_GPF_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#getDefaultInstance()Lorg/esa/beam/framework/gpf/GPF;");
    _resultPyObj = BPy_FromJObject(&GPF_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGPF_setDefaultInstance(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* defaultInstancePyObj = NULL;
    jobject defaultInstanceJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "setDefaultInstance", "(Lorg/esa/beam/framework/gpf/GPF;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setDefaultInstance", &defaultInstancePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        defaultInstanceJObj = BPy_ToJObjectT(defaultInstancePyObj, BPy_GPF_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_GPF_Class, _method, defaultInstanceJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#setDefaultInstance(Lorg/esa/beam/framework/gpf/GPF;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyGPF_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    jboolean incremental = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GPF_Class, "org.esa.beam.framework.gpf.GPF", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/io/File;Ljava/lang/String;ZLcom/bc/ceres/core/ProgressMonitor;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOsbO:writeProduct", &productPyObj, &filePyObj, &formatName, &incremental, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        fileJObj = BPy_ToJObjectT(filePyObj, BPy_File_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_GPF_Class, _method, productJObj, fileJObj, formatNameJObj, incremental, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.GPF#writeProduct(Lorg/esa/beam/framework/datamodel/Product;Ljava/io/File;Ljava/lang/String;ZLcom/bc/ceres/core/ProgressMonitor;)V");
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:<init>", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_IndexCoding_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#<init>(Ljava/lang/String;)V");
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getIndex", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getIndex", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getIndex(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getIndexNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "addIndex", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sis:addIndex", &name, &value, &description)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#addIndex(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getIndexValue", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getIndexValue", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getIndexValue(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#addElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#addAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sis:addSample", &name, &value, &description)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#addSample(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getSampleCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getSampleName", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getSampleName(I)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getSampleValue", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getSampleValue(I)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElementGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getParentElement()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:addElementAt", &elementPyObj, &index)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#addElementAt(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#removeElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getNumElements()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElementAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElementAt(I)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElementNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElements()[Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElement(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#containsElement(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getElementIndex", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getElementIndex(Lorg/esa/beam/framework/datamodel/MetadataElement;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#removeAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getNumAttributes()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getAttributeAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeAt(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributes()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttribute(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#containsAttribute(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getAttributeIndex", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeIndex(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:getAttributeDouble", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeDouble(Ljava/lang/String;D)D");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyIndexCoding_getAttributeUTC2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:getAttributeUTC", &name, &defaultValuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeUTC1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeUTC", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttributeUTC", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeUTC(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:getAttributeInt", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeInt(Ljava/lang/String;I)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:setAttributeInt", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setAttributeInt(Ljava/lang/String;I)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:setAttributeDouble", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setAttributeDouble(Ljava/lang/String;D)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setAttributeUTC", &name, &valuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        valueJObj = BPy_ToJObjectT(valuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:getAttributeString", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getAttributeString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:setAttributeString", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setAttributeString(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#createDeepClone()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_IndexCoding_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_IndexCoding_Class, "org.esa.beam.framework.datamodel.IndexCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_IndexCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'IndexCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.IndexCoding#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_newPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:<init>", &x, &y)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_PixelPos_Class, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#<init>(FF)V");
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#isValid()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#setInvalid()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "getX", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#getX()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "getY", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#getY()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(DD)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:setLocation", &arg0, &arg1)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#setLocation(DD)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat arg0 = (jfloat) 0;
    jfloat arg1 = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:setLocation", &arg0, &arg1)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0, arg1);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#setLocation(FF)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "setLocation", "(Ljava/awt/geom/Point2D;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setLocation", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Point2D_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#setLocation(Ljava/awt/geom/Point2D;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:distanceSq", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, BPy_PixelPos_Class, _method, arg0, arg1, arg2, arg3);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distanceSq(DDDD)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble arg2 = (jdouble) 0;
    jdouble arg3 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DDDD)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddd:distance", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, BPy_PixelPos_Class, _method, arg0, arg1, arg2, arg3);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distance(DDDD)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(DD)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:distanceSq", &arg0, &arg1)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distanceSq(DD)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distanceSq", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:distanceSq", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Point2D_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distanceSq(Ljava/awt/geom/Point2D;)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble arg0 = (jdouble) 0;
    jdouble arg1 = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(DD)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:distance", &arg0, &arg1)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0, arg1);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distance(DD)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "distance", "(Ljava/awt/geom/Point2D;)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:distance", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Point2D_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#distance(Ljava/awt/geom/Point2D;)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#clone()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#hashCode()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PixelPos_Class, "org.esa.beam.framework.datamodel.PixelPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PixelPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PixelPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PixelPos#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "getProductReader", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getProductReader", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, formatNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#getProductReader(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "getProductWriterExtensions", "(Ljava/lang/String;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getProductWriterExtensions", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, formatNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#getProductWriterExtensions(Ljava/lang/String;)[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "getProductWriter", "(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductWriter;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getProductWriter", &formatName)) {
        return NULL;
    }
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, formatNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#getProductWriter(Ljava/lang/String;)Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "readProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:readProduct", &filePath)) {
        return NULL;
    }
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, filePathJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#readProduct(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForFile", "(Ljava/io/File;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getProductReaderForFile", &filePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        fileJObj = BPy_ToJObjectT(filePyObj, BPy_File_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, fileJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#getProductReaderForFile(Ljava/io/File;)Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "getProductReaderForInput", "(Ljava/lang/Object;)Lorg/esa/beam/framework/dataio/ProductReader;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getProductReaderForInput", &inputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductIO_Class, _method, inputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#getProductReaderForInput(Ljava/lang/Object;)Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    const char* filePath = NULL;
    jstring filePathJObj = NULL;
    const char* formatName = NULL;
    jstring formatNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductIO_Class, "org.esa.beam.framework.dataio.ProductIO", "writeProduct", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Ljava/lang/String;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:writeProduct", &productPyObj, &filePath, &formatName)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    filePathJObj =(*jenv)->NewStringUTF(jenv, filePath);
    formatNameJObj =(*jenv)->NewStringUTF(jenv, formatName);
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductIO_Class, _method, productJObj, filePathJObj, formatNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductIO#writeProduct(Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, filePathJObj);
    (*jenv)->DeleteLocalRef(jenv, formatNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* descriptorPyObj = NULL;
    jobject descriptorJObj = NULL;
    PyObject* featurePyObj = NULL;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "<init>", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Lorg/opengis/feature/simple/SimpleFeature;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:<init>", &descriptorPyObj, &featurePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        descriptorJObj = BPy_ToJObjectT(descriptorPyObj, BPy_PlacemarkDescriptor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        featureJObj = BPy_ToJObjectT(featurePyObj, BPy_SimpleFeature_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_Placemark_Class, _method, descriptorJObj, featureJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#<init>(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Lorg/opengis/feature/simple/SimpleFeature;)V");
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* descriptorPyObj = NULL;
    jobject descriptorJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "createPointPlacemark", "(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/GeoCoding;)Lorg/esa/beam/framework/datamodel/Placemark;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OsssOOO:createPointPlacemark", &descriptorPyObj, &name, &label, &text, &pixelPosPyObj, &geoPosPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        descriptorJObj = BPy_ToJObjectT(descriptorPyObj, BPy_PlacemarkDescriptor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    {
        jboolean ok = 1;
        pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, BPy_PixelPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_Placemark_Class, _method, descriptorJObj, nameJObj, labelJObj, textJObj, pixelPosJObj, geoPosJObj, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#createPointPlacemark(Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/PixelPos;Lorg/esa/beam/framework/datamodel/GeoPos;Lorg/esa/beam/framework/datamodel/GeoCoding;)Lorg/esa/beam/framework/datamodel/Placemark;");
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getDescriptor", "()Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getDescriptor()Lorg/esa/beam/framework/datamodel/PlacemarkDescriptor;");
    _resultPyObj = BPy_FromJObject(&PlacemarkDescriptor_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getFeature", "()Lorg/opengis/feature/simple/SimpleFeature;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getFeature()Lorg/opengis/feature/simple/SimpleFeature;");
    _resultPyObj = BPy_FromJObject(&SimpleFeature_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getAttributeValue", "(Ljava/lang/String;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttributeValue", &attributeName)) {
        return NULL;
    }
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, attributeNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getAttributeValue(Ljava/lang/String;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* attributeName = NULL;
    jstring attributeNameJObj = NULL;
    PyObject* attributeValuePyObj = NULL;
    jobject attributeValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setAttributeValue", "(Ljava/lang/String;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setAttributeValue", &attributeName, &attributeValuePyObj)) {
        return NULL;
    }
    attributeNameJObj =(*jenv)->NewStringUTF(jenv, attributeName);
    {
        jboolean ok = 1;
        attributeValueJObj = BPy_ToJObjectT(attributeValuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeNameJObj, attributeValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setAttributeValue(Ljava/lang/String;Ljava/lang/Object;)V");
    (*jenv)->DeleteLocalRef(jenv, attributeNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* label = NULL;
    jstring labelJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setLabel", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setLabel", &label)) {
        return NULL;
    }
    labelJObj =(*jenv)->NewStringUTF(jenv, label);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, labelJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setLabel(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, labelJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getLabel", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getLabel()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* text = NULL;
    jstring textJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setText", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setText", &text)) {
        return NULL;
    }
    textJObj =(*jenv)->NewStringUTF(jenv, text);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, textJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setText(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, textJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getText", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getText()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* styleCss = NULL;
    jstring styleCssJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setStyleCss", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setStyleCss", &styleCss)) {
        return NULL;
    }
    styleCssJObj =(*jenv)->NewStringUTF(jenv, styleCss);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, styleCssJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setStyleCss(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, styleCssJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getStyleCss", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getStyleCss()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getPixelPos", "()Lorg/esa/beam/framework/datamodel/PixelPos;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getPixelPos()Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObject(&PixelPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pixelPosPyObj = NULL;
    jobject pixelPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setPixelPos", "(Lorg/esa/beam/framework/datamodel/PixelPos;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setPixelPos", &pixelPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pixelPosJObj = BPy_ToJObjectT(pixelPosPyObj, BPy_PixelPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pixelPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setPixelPos(Lorg/esa/beam/framework/datamodel/PixelPos;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getGeoPos", "()Lorg/esa/beam/framework/datamodel/GeoPos;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getGeoPos()Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setGeoPos", &geoPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setGeoPos(Lorg/esa/beam/framework/datamodel/GeoPos;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "updatePositions", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#updatePositions()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "createPinFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_Placemark_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#createPinFeatureType()Lorg/opengis/feature/simple/SimpleFeatureType;");
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "createGcpFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_Placemark_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#createGcpFeatureType()Lorg/opengis/feature/simple/SimpleFeatureType;");
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "createGeometryFeatureType", "()Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_Placemark_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#createGeometryFeatureType()Lorg/opengis/feature/simple/SimpleFeatureType;");
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "createPointFeatureType", "(Ljava/lang/String;)Lorg/opengis/feature/simple/SimpleFeatureType;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:createPointFeatureType", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_Placemark_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#createPointFeatureType(Ljava/lang/String;)Lorg/opengis/feature/simple/SimpleFeatureType;");
    _resultPyObj = BPy_FromJObject(&SimpleFeatureType_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_Placemark_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Placemark_Class, "org.esa.beam.framework.datamodel.Placemark", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Placemark_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Placemark' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Placemark#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:<init>", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_MetadataElement_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#<init>(Ljava/lang/String;)V");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElementGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getParentElement()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#addElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:addElementAt", &elementPyObj, &index)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#addElementAt(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#removeElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getNumElements", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getNumElements()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElementAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElementAt(I)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElementNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElements()[Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElement(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#containsElement(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getElementIndex", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getElementIndex(Lorg/esa/beam/framework/datamodel/MetadataElement;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#addAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#removeAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getNumAttributes()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getAttributeAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeAt(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributes()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttribute(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#containsAttribute(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getAttributeIndex", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeIndex(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:getAttributeDouble", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeDouble(Ljava/lang/String;D)D");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyMetadataElement_getAttributeUTC2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:getAttributeUTC", &name, &defaultValuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeUTC1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeUTC", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttributeUTC", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeUTC(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:getAttributeInt", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeInt(Ljava/lang/String;I)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:setAttributeInt", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setAttributeInt(Ljava/lang/String;I)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:setAttributeDouble", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setAttributeDouble(Ljava/lang/String;D)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setAttributeUTC", &name, &valuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        valueJObj = BPy_ToJObjectT(valuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:getAttributeString", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getAttributeString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:setAttributeString", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setAttributeString(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#createDeepClone()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_MetadataElement_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataElement_Class, "org.esa.beam.framework.datamodel.MetadataElement", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataElement_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataElement' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataElement#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint sceneRasterWidth = (jint) 0;
    jint sceneRasterHeight = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "<init>", "(Ljava/lang/String;Ljava/lang/String;II)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ssii:<init>", &name, &type, &sceneRasterWidth, &sceneRasterHeight)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_Product_Class, _method, nameJObj, typeJObj, sceneRasterWidth, sceneRasterHeight);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#<init>(Ljava/lang/String;Ljava/lang/String;II)V");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getFileLocation", "()Ljava/io/File;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getFileLocation()Ljava/io/File;");
    _resultPyObj = BPy_FromJObject(&File_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* fileLocationPyObj = NULL;
    jobject fileLocationJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setFileLocation", "(Ljava/io/File;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setFileLocation", &fileLocationPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        fileLocationJObj = BPy_ToJObjectT(fileLocationPyObj, BPy_File_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, fileLocationJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setFileLocation(Ljava/io/File;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductType", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductType()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* productType = NULL;
    jstring productTypeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setProductType", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setProductType", &productType)) {
        return NULL;
    }
    productTypeJObj =(*jenv)->NewStringUTF(jenv, productType);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productTypeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setProductType(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, productTypeJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* readerPyObj = NULL;
    jobject readerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setProductReader", "(Lorg/esa/beam/framework/dataio/ProductReader;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setProductReader", &readerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        readerJObj = BPy_ToJObjectT(readerPyObj, BPy_ProductReader_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setProductReader(Lorg/esa/beam/framework/dataio/ProductReader;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* writerPyObj = NULL;
    jobject writerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setProductWriter", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setProductWriter", &writerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        writerJObj = BPy_ToJObjectT(writerPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, writerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setProductWriter(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "writeHeader", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:writeHeader", &outputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#writeHeader(Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "closeProductReader", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#closeProductReader()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "closeProductWriter", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#closeProductWriter()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "closeIO", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#closeIO()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getPointingFactory", "()Lorg/esa/beam/framework/datamodel/PointingFactory;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getPointingFactory()Lorg/esa/beam/framework/datamodel/PointingFactory;");
    _resultPyObj = BPy_FromJObject(&PointingFactory_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pointingFactoryPyObj = NULL;
    jobject pointingFactoryJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setPointingFactory", "(Lorg/esa/beam/framework/datamodel/PointingFactory;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setPointingFactory", &pointingFactoryPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointingFactoryJObj = BPy_ToJObjectT(pointingFactoryPyObj, BPy_PointingFactory_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointingFactoryJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setPointingFactory(Lorg/esa/beam/framework/datamodel/PointingFactory;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setGeoCoding", &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setGeoCoding(Lorg/esa/beam/framework/datamodel/GeoCoding;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getGeoCoding()Lorg/esa/beam/framework/datamodel/GeoCoding;");
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "isUsingSingleGeoCoding", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#isUsingSingleGeoCoding()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* destProductPyObj = NULL;
    jobject destProductJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "transferGeoCodingTo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:transferGeoCodingTo", &destProductPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        destProductJObj = BPy_ToJObjectT(destProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, destProductJObj, subsetDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#transferGeoCodingTo(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getSceneRasterWidth()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getSceneRasterHeight()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getStartTime", "()Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getStartTime()Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* startTimePyObj = NULL;
    jobject startTimeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setStartTime", "(Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setStartTime", &startTimePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        startTimeJObj = BPy_ToJObjectT(startTimePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startTimeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setStartTime(Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getEndTime", "()Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getEndTime()Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* endTimePyObj = NULL;
    jobject endTimeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setEndTime", "(Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setEndTime", &endTimePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        endTimeJObj = BPy_ToJObjectT(endTimePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, endTimeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setEndTime(Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getMetadataRoot", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getMetadataRoot()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBandGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBandGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getTiePointGridGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getTiePointGridGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* tiePointGridPyObj = NULL;
    jobject tiePointGridJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addTiePointGrid", &tiePointGridPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        tiePointGridJObj = BPy_ToJObjectT(tiePointGridPyObj, BPy_TiePointGrid_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addTiePointGrid(Lorg/esa/beam/framework/datamodel/TiePointGrid;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* tiePointGridPyObj = NULL;
    jobject tiePointGridJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "removeTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeTiePointGrid", &tiePointGridPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        tiePointGridJObj = BPy_ToJObjectT(tiePointGridPyObj, BPy_TiePointGrid_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, tiePointGridJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#removeTiePointGrid(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getNumTiePointGrids", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getNumTiePointGrids()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getTiePointGridAt", "(I)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getTiePointGridAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getTiePointGridAt(I)Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getTiePointGridNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getTiePointGridNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getTiePointGrids", "()[Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getTiePointGrids()[Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getTiePointGrid", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getTiePointGrid", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getTiePointGrid(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "containsTiePointGrid", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsTiePointGrid", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#containsTiePointGrid(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addBand", "(Lorg/esa/beam/framework/datamodel/Band;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addBand", &bandPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandJObj = BPy_ToJObjectT(bandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addBand(Lorg/esa/beam/framework/datamodel/Band;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    jint dataType = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:addBand", &bandName, &dataType)) {
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, dataType);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addBand(Ljava/lang/String;I)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addBand", "(Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:addBand", &bandName, &expression)) {
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj, expressionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addBand(Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "removeBand", "(Lorg/esa/beam/framework/datamodel/Band;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeBand", &bandPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandJObj = BPy_ToJObjectT(bandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, bandJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#removeBand(Lorg/esa/beam/framework/datamodel/Band;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getNumBands", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getNumBands()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBandAt", "(I)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getBandAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBandAt(I)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBandNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBandNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBands", "()[Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBands()[Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBand", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getBand", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBand(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBandIndex", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getBandIndex", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBandIndex(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "containsBand", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsBand", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#containsBand(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "containsRasterDataNode", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsRasterDataNode", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#containsRasterDataNode(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getRasterDataNode", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/RasterDataNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getRasterDataNode", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getRasterDataNode(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/RasterDataNode;");
    _resultPyObj = BPy_FromJObject(&RasterDataNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getMaskGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getVectorDataGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getVectorDataGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getFlagCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getFlagCodingGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getIndexCodingGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getIndexCodingGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "containsPixel", "(FF)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:containsPixel", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#containsPixel(FF)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getGcpGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getGcpGroup()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;");
    _resultPyObj = BPy_FromJObject(&PlacemarkGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getPinGroup", "()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getPinGroup()Lorg/esa/beam/framework/datamodel/PlacemarkGroup;");
    _resultPyObj = BPy_FromJObject(&PlacemarkGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jfloat eps = (jfloat) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "isCompatibleProduct", "(Lorg/esa/beam/framework/datamodel/Product;F)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Of:isCompatibleProduct", &productPyObj, &eps)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj, eps);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#isCompatibleProduct(Lorg/esa/beam/framework/datamodel/Product;F)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "parseExpression", "(Ljava/lang/String;)Lcom/bc/jexp/Term;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:parseExpression", &expression)) {
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#parseExpression(Ljava/lang/String;)Lcom/bc/jexp/Term;");
    _resultPyObj = BPy_FromJObject(&Term_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addProductNodeListener", &listenerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        listenerJObj = BPy_ToJObjectT(listenerPyObj, BPy_ProductNodeListener_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addProductNodeListener(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "removeProductNodeListener", "(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeProductNodeListener", &listenerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        listenerJObj = BPy_ToJObjectT(listenerPyObj, BPy_ProductNodeListener_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, listenerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#removeProductNodeListener(Lorg/esa/beam/framework/datamodel/ProductNodeListener;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductNodeListeners", "()[Lorg/esa/beam/framework/datamodel/ProductNodeListener;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductNodeListeners()[Lorg/esa/beam/framework/datamodel/ProductNodeListener;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getRefNo", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getRefNo()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setRefNo", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setRefNo", &refNo)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, refNo);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setRefNo(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "resetRefNo", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#resetRefNo()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductManager", "()Lorg/esa/beam/framework/datamodel/ProductManager;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductManager()Lorg/esa/beam/framework/datamodel/ProductManager;");
    _resultPyObj = BPy_FromJObject(&ProductManager_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticParser", "()Lcom/bc/jexp/Parser;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createBandArithmeticParser()Lcom/bc/jexp/Parser;");
    _resultPyObj = BPy_FromJObject(&Parser_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createBandArithmeticDefaultNamespace", "()Lcom/bc/jexp/WritableNamespace;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createBandArithmeticDefaultNamespace()Lcom/bc/jexp/WritableNamespace;");
    _resultPyObj = BPy_FromJObject(&WritableNamespace_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createSubset", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oss:createSubset", &subsetDefPyObj, &name, &desc)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, subsetDefJObj, nameJObj, descJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createSubset(Lorg/esa/beam/framework/dataio/ProductSubsetDef;Ljava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint flipType = (jint) 0;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* desc = NULL;
    jstring descJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createFlippedProduct", "(ILjava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iss:createFlippedProduct", &flipType, &name, &desc)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descJObj =(*jenv)->NewStringUTF(jenv, desc);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, flipType, nameJObj, descJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createFlippedProduct(ILjava/lang/String;Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getQuicklookBandName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getQuicklookBandName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* quicklookBandName = NULL;
    jstring quicklookBandNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setQuicklookBandName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setQuicklookBandName", &quicklookBandName)) {
        return NULL;
    }
    quicklookBandNameJObj =(*jenv)->NewStringUTF(jenv, quicklookBandName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, quicklookBandNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setQuicklookBandName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, quicklookBandNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createPixelInfoString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:createPixelInfoString", &pixelX, &pixelY)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pixelX, pixelY);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createPixelInfoString(II)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getRemovedChildNodes", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getRemovedChildNodes()[Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#canBeOrthorectified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getPreferredTileSize", "()Ljava/awt/Dimension;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getPreferredTileSize()Ljava/awt/Dimension;");
    _resultPyObj = BPy_FromJObject(&Dimension_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint tileWidth = (jint) 0;
    jint tileHeight = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setPreferredTileSize", "(II)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:setPreferredTileSize", &tileWidth, &tileHeight)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tileWidth, tileHeight);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setPreferredTileSize(II)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getAllFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getAllFlagNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getAutoGrouping", "()Lorg/esa/beam/framework/datamodel/Product$AutoGrouping;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getAutoGrouping()Lorg/esa/beam/framework/datamodel/Product$AutoGrouping;");
    _resultPyObj = BPy_FromJObject(&Product_AutoGrouping_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setAutoGrouping2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* autoGroupingPyObj = NULL;
    jobject autoGroupingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setAutoGrouping", "(Lorg/esa/beam/framework/datamodel/Product$AutoGrouping;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setAutoGrouping", &autoGroupingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        autoGroupingJObj = BPy_ToJObjectT(autoGroupingPyObj, BPy_Product_AutoGrouping_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, autoGroupingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setAutoGrouping(Lorg/esa/beam/framework/datamodel/Product$AutoGrouping;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setAutoGrouping1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* pattern = NULL;
    jstring patternJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setAutoGrouping", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setAutoGrouping", &pattern)) {
        return NULL;
    }
    patternJObj =(*jenv)->NewStringUTF(jenv, pattern);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, patternJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setAutoGrouping(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, patternJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* maskName = NULL;
    jstring maskNameJObj = NULL;
    PyObject* imageTypePyObj = NULL;
    jobject imageTypeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addMask", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Mask$ImageType;)Lorg/esa/beam/framework/datamodel/Mask;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:addMask", &maskName, &imageTypePyObj)) {
        return NULL;
    }
    maskNameJObj =(*jenv)->NewStringUTF(jenv, maskName);
    {
        jboolean ok = 1;
        imageTypeJObj = BPy_ToJObjectT(imageTypePyObj, BPy_Mask_ImageType_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, maskNameJObj, imageTypeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addMask(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Mask$ImageType;)Lorg/esa/beam/framework/datamodel/Mask;");
    _resultPyObj = BPy_FromJObject(&Mask_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, maskNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* maskName = NULL;
    jstring maskNameJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* colorPyObj = NULL;
    jobject colorJObj = NULL;
    jdouble transparency = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addMask", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/awt/Color;D)Lorg/esa/beam/framework/datamodel/Mask;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sssOd:addMask", &maskName, &expression, &description, &colorPyObj, &transparency)) {
        return NULL;
    }
    maskNameJObj =(*jenv)->NewStringUTF(jenv, maskName);
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    {
        jboolean ok = 1;
        colorJObj = BPy_ToJObjectT(colorPyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, maskNameJObj, expressionJObj, descriptionJObj, colorJObj, transparency);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addMask(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/awt/Color;D)Lorg/esa/beam/framework/datamodel/Mask;");
    _resultPyObj = BPy_FromJObject(&Mask_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, maskNameJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_addBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bitmaskDefPyObj = NULL;
    jobject bitmaskDefJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "addBitmaskDef", "(Lorg/esa/beam/framework/datamodel/BitmaskDef;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addBitmaskDef", &bitmaskDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bitmaskDefJObj = BPy_ToJObjectT(bitmaskDefPyObj, BPy_BitmaskDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bitmaskDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#addBitmaskDef(Lorg/esa/beam/framework/datamodel/BitmaskDef;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getBitmaskDefNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBitmaskDefNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBitmaskDefNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getBitmaskDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getBitmaskDef", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/BitmaskDef;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getBitmaskDef", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getBitmaskDef(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/BitmaskDef;");
    _resultPyObj = BPy_FromJObject(&BitmaskDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getValidMask", "(Ljava/lang/String;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getValidMask", &id)) {
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, idJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getValidMask(Ljava/lang/String;)Lorg/esa/beam/util/BitRaster;");
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* validMaskPyObj = NULL;
    jobject validMaskJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setValidMask", "(Ljava/lang/String;Lorg/esa/beam/util/BitRaster;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setValidMask", &id, &validMaskPyObj)) {
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    {
        jboolean ok = 1;
        validMaskJObj = BPy_ToJObjectT(validMaskPyObj, BPy_BitRaster_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, idJObj, validMaskJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setValidMask(Ljava/lang/String;Lorg/esa/beam/util/BitRaster;)V");
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createValidMask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Ljava/lang/String;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:createValidMask", &expression, &pmPyObj)) {
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, expressionJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createValidMask(Ljava/lang/String;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;");
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_createValidMask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* termPyObj = NULL;
    jobject termJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "createValidMask", "(Lcom/bc/jexp/Term;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createValidMask", &termPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        termJObj = BPy_ToJObjectT(termPyObj, BPy_Term_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, termJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#createValidMask(Lcom/bc/jexp/Term;Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/util/BitRaster;");
    _resultPyObj = BPy_FromJObject(&BitRaster_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_readBitmask2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* bitmaskTermPyObj = NULL;
    jobject bitmaskTermJObj = NULL;
    jboolean* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[ZLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOOO:readBitmask", &offsetX, &offsetY, &width, &height, &bitmaskTermPyObj, &bitmaskPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bitmaskTermJObj = BPy_ToJObjectT(bitmaskTermPyObj, BPy_Term_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    bitmaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jboolean*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = BPy_NewJBooleanArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#readBitmask(IIIILcom/bc/jexp/Term;[ZLcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_readBitmask1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* bitmaskTermPyObj = NULL;
    jobject bitmaskTermJObj = NULL;
    jbyte* bitmaskData = NULL;
    int bitmaskLength = 0;
    PyObject* bitmaskPyObj = NULL;
    Py_buffer bitmaskBuf;
    jarray bitmaskJObj = NULL;
    jbyte trueValue = (jbyte) 0;
    jbyte falseValue = (jbyte) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "readBitmask", "(IIIILcom/bc/jexp/Term;[BBBLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOObbO:readBitmask", &offsetX, &offsetY, &width, &height, &bitmaskTermPyObj, &bitmaskPyObj, &trueValue, &falseValue, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bitmaskTermJObj = BPy_ToJObjectT(bitmaskTermPyObj, BPy_Term_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    bitmaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(bitmaskPyObj, &bitmaskBuf, "b", -1);
    if (bitmaskPyObj == NULL) {
        return NULL;
    }
    bitmaskData = (jbyte*) bitmaskBuf.buf;
    bitmaskLength = bitmaskBuf.len / bitmaskBuf.itemsize;
    bitmaskJObj = BPy_NewJByteArrayFromBuffer(bitmaskData, bitmaskLength);
    if (bitmaskJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, bitmaskTermJObj, bitmaskJObj, trueValue, falseValue, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#readBitmask(IIIILcom/bc/jexp/Term;[BBBLcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&bitmaskBuf);
    (*jenv)->DeleteLocalRef(jenv, bitmaskJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_Product_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Product_Class, "org.esa.beam.framework.datamodel.Product", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Product_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Product' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Product#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:<init>", &minSample, &maxSample)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ColorPaletteDef_Class, _method, minSample, maxSample);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#<init>(DD)V");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDef1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:<init>", &pointsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointsJObj = BPy_ToJObjectArrayT(pointsPyObj, BPy_ColorPaletteDef_Point_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ColorPaletteDef_Class, _method, pointsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#<init>([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDef2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    jint numColors = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "<init>", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;I)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:<init>", &pointsPyObj, &numColors)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointsJObj = BPy_ToJObjectArrayT(pointsPyObj, BPy_ColorPaletteDef_Point_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ColorPaletteDef_Class, _method, pointsJObj, numColors);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#<init>([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;I)V");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isDiscrete", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#isDiscrete()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean discrete = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setDiscrete", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setDiscrete", &discrete)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discrete);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#setDiscrete(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumColors", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getNumColors()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint numColors = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumColors", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setNumColors", &numColors)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numColors);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#setNumColors(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getNumPoints", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getNumPoints()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint numPoints = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setNumPoints", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setNumPoints", &numPoints)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, numPoints);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#setNumPoints(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "isAutoDistribute", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#isAutoDistribute()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean autoDistribute = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setAutoDistribute", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setAutoDistribute", &autoDistribute)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, autoDistribute);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#setAutoDistribute(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPointAt", "(I)Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getPointAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getPointAt(I)Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getFirstPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getFirstPoint()Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getLastPoint", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getLastPoint()Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Point_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMinDisplaySample", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getMinDisplaySample()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getMaxDisplaySample", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getMaxDisplaySample()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* pointPyObj = NULL;
    jobject pointJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "insertPointAfter", "(ILorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:insertPointAfter", &index, &pointPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointJObj = BPy_ToJObjectT(pointPyObj, BPy_ColorPaletteDef_Point_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, pointJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#insertPointAfter(ILorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createPointAfter", "(ILorg/esa/beam/framework/datamodel/Scaling;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:createPointAfter", &index, &scalingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        scalingJObj = BPy_ToJObjectT(scalingPyObj, BPy_Scaling_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index, scalingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#createPointAfter(ILorg/esa/beam/framework/datamodel/Scaling;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* c1PyObj = NULL;
    jobject c1JObj = NULL;
    PyObject* c2PyObj = NULL;
    jobject c2JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getCenterColor", "(Ljava/awt/Color;Ljava/awt/Color;)Ljava/awt/Color;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:getCenterColor", &c1PyObj, &c2PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        c1JObj = BPy_ToJObjectT(c1PyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        c2JObj = BPy_ToJObjectT(c2PyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ColorPaletteDef_Class, _method, c1JObj, c2JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getCenterColor(Ljava/awt/Color;Ljava/awt/Color;)Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "removePointAt", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:removePointAt", &index)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#removePointAt(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pointPyObj = NULL;
    jobject pointJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "addPoint", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addPoint", &pointPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointJObj = BPy_ToJObjectT(pointPyObj, BPy_ColorPaletteDef_Point_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#addPoint(Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getPoints", "()[Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getPoints()[Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pointsPyObj = NULL;
    jarray pointsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "setPoints", "([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setPoints", &pointsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pointsJObj = BPy_ToJObjectArrayT(pointsPyObj, BPy_ColorPaletteDef_Point_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pointsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#setPoints([Lorg/esa/beam/framework/datamodel/ColorPaletteDef$Point;)V");
    (*jenv)->DeleteLocalRef(jenv, pointsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getIterator", "()Ljava/util/Iterator;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getIterator()Ljava/util/Iterator;");
    _resultPyObj = BPy_FromJObject(&Iterator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#clone()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#createDeepCopy()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "loadColorPaletteDef", "(Ljava/io/File;)Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:loadColorPaletteDef", &filePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        fileJObj = BPy_ToJObjectT(filePyObj, BPy_File_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ColorPaletteDef_Class, _method, fileJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#loadColorPaletteDef(Ljava/io/File;)Lorg/esa/beam/framework/datamodel/ColorPaletteDef;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    PyObject* filePyObj = NULL;
    jobject fileJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "storeColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;Ljava/io/File;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:storeColorPaletteDef", &colorPaletteDefPyObj, &filePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, BPy_ColorPaletteDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        fileJObj = BPy_ToJObjectT(filePyObj, BPy_File_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ColorPaletteDef_Class, _method, colorPaletteDefJObj, fileJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#storeColorPaletteDef(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;Ljava/io/File;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#getColors()[Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "createColorPalette", "(Lorg/esa/beam/framework/datamodel/Scaling;)[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createColorPalette", &scalingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        scalingJObj = BPy_ToJObjectT(scalingPyObj, BPy_Scaling_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#createColorPalette(Lorg/esa/beam/framework/datamodel/Scaling;)[Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    jdouble sample = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ColorPaletteDef_Class, "org.esa.beam.framework.datamodel.ColorPaletteDef", "computeColor", "(Lorg/esa/beam/framework/datamodel/Scaling;D)Ljava/awt/Color;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ColorPaletteDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ColorPaletteDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:computeColor", &scalingPyObj, &sample)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        scalingJObj = BPy_ToJObjectT(scalingPyObj, BPy_Scaling_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj, sample);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ColorPaletteDef#computeColor(Lorg/esa/beam/framework/datamodel/Scaling;D)Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:<init>", &colorPaletteDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, BPy_ColorPaletteDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ImageInfo_Class, _method, colorPaletteDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#<init>(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;)V");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rgbChannelDefPyObj = NULL;
    jobject rgbChannelDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "<init>", "(Lorg/esa/beam/framework/datamodel/RGBChannelDef;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:<init>", &rgbChannelDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rgbChannelDefJObj = BPy_ToJObjectT(rgbChannelDefPyObj, BPy_RGBChannelDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ImageInfo_Class, _method, rgbChannelDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#<init>(Lorg/esa/beam/framework/datamodel/RGBChannelDef;)V");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getColorPaletteDef", "()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getColorPaletteDef()Lorg/esa/beam/framework/datamodel/ColorPaletteDef;");
    _resultPyObj = BPy_FromJObject(&ColorPaletteDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getRgbChannelDef", "()Lorg/esa/beam/framework/datamodel/RGBChannelDef;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getRgbChannelDef()Lorg/esa/beam/framework/datamodel/RGBChannelDef;");
    _resultPyObj = BPy_FromJObject(&RGBChannelDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getNoDataColor", "()Ljava/awt/Color;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getNoDataColor()Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObject(&Color_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* noDataColorPyObj = NULL;
    jobject noDataColorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "setNoDataColor", "(Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setNoDataColor", &noDataColorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        noDataColorJObj = BPy_ToJObjectT(noDataColorPyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataColorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#setNoDataColor(Ljava/awt/Color;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getHistogramMatching1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getHistogramMatching", "()Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getHistogramMatching()Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_HistogramMatching_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* histogramMatchingPyObj = NULL;
    jobject histogramMatchingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "setHistogramMatching", "(Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setHistogramMatching", &histogramMatchingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        histogramMatchingJObj = BPy_ToJObjectT(histogramMatchingPyObj, BPy_ImageInfo_HistogramMatching_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, histogramMatchingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#setHistogramMatching(Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "isLogScaled", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#isLogScaled()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean logScaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "setLogScaled", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setLogScaled", &logScaled)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, logScaled);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#setLogScaled(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getColors", "()[Ljava/awt/Color;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getColors()[Ljava/awt/Color;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getColorComponentCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getColorComponentCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* scalingPyObj = NULL;
    jobject scalingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "createIndexColorModel", "(Lorg/esa/beam/framework/datamodel/Scaling;)Ljava/awt/image/IndexColorModel;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createIndexColorModel", &scalingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        scalingJObj = BPy_ToJObjectT(scalingPyObj, BPy_Scaling_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, scalingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#createIndexColorModel(Lorg/esa/beam/framework/datamodel/Scaling;)Ljava/awt/image/IndexColorModel;");
    _resultPyObj = BPy_FromJObject(&IndexColorModel_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "createComponentColorModel", "()Ljava/awt/image/ComponentColorModel;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#createComponentColorModel()Ljava/awt/image/ComponentColorModel;");
    _resultPyObj = BPy_FromJObject(&ComponentColorModel_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#clone()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "createDeepCopy", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#createDeepCopy()Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* colorsPyObj = NULL;
    jarray colorsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "setColors", "([Ljava/awt/Color;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setColors", &colorsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        colorsJObj = BPy_ToJObjectArrayT(colorsPyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#setColors([Ljava/awt/Color;)V");
    (*jenv)->DeleteLocalRef(jenv, colorsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* colorPaletteDefPyObj = NULL;
    jobject colorPaletteDefJObj = NULL;
    jdouble minSample = (jdouble) 0;
    jdouble maxSample = (jdouble) 0;
    jboolean autoDistribute = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "setColorPaletteDef", "(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;DDZ)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageInfo_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageInfo' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oddb:setColorPaletteDef", &colorPaletteDefPyObj, &minSample, &maxSample, &autoDistribute)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        colorPaletteDefJObj = BPy_ToJObjectT(colorPaletteDefPyObj, BPy_ColorPaletteDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, colorPaletteDefJObj, minSample, maxSample, autoDistribute);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#setColorPaletteDef(Lorg/esa/beam/framework/datamodel/ColorPaletteDef;DDZ)V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getHistogramMatching2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* mode = NULL;
    jstring modeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageInfo_Class, "org.esa.beam.framework.datamodel.ImageInfo", "getHistogramMatching", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getHistogramMatching", &mode)) {
        return NULL;
    }
    modeJObj =(*jenv)->NewStringUTF(jenv, mode);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ImageInfo_Class, _method, modeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageInfo#getHistogramMatching(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ImageInfo$HistogramMatching;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_HistogramMatching_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, modeJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ProductManager_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#<init>()V");
    _resultPyObj = BPy_FromJObject(&ProductManager_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getProduct", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProduct(I)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductDisplayNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProducts", "()[Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProducts()[Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getProductByDisplayName", &displayName)) {
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductByDisplayName(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint refNo = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductByRefNo", "(I)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getProductByRefNo", &refNo)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, refNo);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductByRefNo(I)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getProduct", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProduct(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "getProductIndex", "(Lorg/esa/beam/framework/datamodel/Product;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getProductIndex", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#getProductIndex(Lorg/esa/beam/framework/datamodel/Product;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "containsProduct", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsProduct", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#containsProduct(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "contains", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:contains", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#contains(Lorg/esa/beam/framework/datamodel/Product;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "addProduct", "(Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addProduct", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#addProduct(Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "removeProduct", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeProduct", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#removeProduct(Lorg/esa/beam/framework/datamodel/Product;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "removeAllProducts", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#removeAllProducts()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "addListener", "(Lorg/esa/beam/framework/datamodel/ProductManager$Listener;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addListener", &listenerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        listenerJObj = BPy_ToJObjectT(listenerPyObj, BPy_ProductManager_Listener_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#addListener(Lorg/esa/beam/framework/datamodel/ProductManager$Listener;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* listenerPyObj = NULL;
    jobject listenerJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductManager_Class, "org.esa.beam.framework.datamodel.ProductManager", "removeListener", "(Lorg/esa/beam/framework/datamodel/ProductManager$Listener;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductManager_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductManager' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeListener", &listenerPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        listenerJObj = BPy_ToJObjectT(listenerPyObj, BPy_ProductManager_Listener_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, listenerJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductManager#removeListener(Lorg/esa/beam/framework/datamodel/ProductManager$Listener;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyOperatorSpiRegistry_loadOperatorSpis(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "loadOperatorSpis", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#loadOperatorSpis()V");
    return Py_BuildValue("");
}

PyObject* BeamPyOperatorSpiRegistry_getServiceRegistry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "getServiceRegistry", "()Lcom/bc/ceres/core/ServiceRegistry;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#getServiceRegistry()Lcom/bc/ceres/core/ServiceRegistry;");
    _resultPyObj = BPy_FromJObject(&ServiceRegistry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyOperatorSpiRegistry_getOperatorSpi(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* operatorName = NULL;
    jstring operatorNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "getOperatorSpi", "(Ljava/lang/String;)Lorg/esa/beam/framework/gpf/OperatorSpi;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getOperatorSpi", &operatorName)) {
        return NULL;
    }
    operatorNameJObj =(*jenv)->NewStringUTF(jenv, operatorName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, operatorNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#getOperatorSpi(Ljava/lang/String;)Lorg/esa/beam/framework/gpf/OperatorSpi;");
    _resultPyObj = BPy_FromJObject(&OperatorSpi_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, operatorNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyOperatorSpiRegistry_addOperatorSpi(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* operatorSpiPyObj = NULL;
    jobject operatorSpiJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "addOperatorSpi", "(Lorg/esa/beam/framework/gpf/OperatorSpi;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addOperatorSpi", &operatorSpiPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        operatorSpiJObj = BPy_ToJObjectT(operatorSpiPyObj, BPy_OperatorSpi_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, operatorSpiJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#addOperatorSpi(Lorg/esa/beam/framework/gpf/OperatorSpi;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyOperatorSpiRegistry_removeOperatorSpi(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* operatorSpiPyObj = NULL;
    jobject operatorSpiJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "removeOperatorSpi", "(Lorg/esa/beam/framework/gpf/OperatorSpi;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeOperatorSpi", &operatorSpiPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        operatorSpiJObj = BPy_ToJObjectT(operatorSpiPyObj, BPy_OperatorSpi_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, operatorSpiJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#removeOperatorSpi(Lorg/esa/beam/framework/gpf/OperatorSpi;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyOperatorSpiRegistry_setAlias(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* aliasName = NULL;
    jstring aliasNameJObj = NULL;
    const char* spiClassName = NULL;
    jstring spiClassNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_OperatorSpiRegistry_Class, "org.esa.beam.framework.gpf.OperatorSpiRegistry", "setAlias", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_OperatorSpiRegistry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'OperatorSpiRegistry' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:setAlias", &aliasName, &spiClassName)) {
        return NULL;
    }
    aliasNameJObj =(*jenv)->NewStringUTF(jenv, aliasName);
    spiClassNameJObj =(*jenv)->NewStringUTF(jenv, spiClassName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, aliasNameJObj, spiClassNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.gpf.OperatorSpiRegistry#setAlias(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, aliasNameJObj);
    (*jenv)->DeleteLocalRef(jenv, spiClassNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* boundsPyObj = NULL;
    jobject boundsJObj = NULL;
    PyObject* mapCrsPyObj = NULL;
    jobject mapCrsJObj = NULL;
    PyObject* image2mapPyObj = NULL;
    jobject image2mapJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "<init>", "(Ljava/awt/Rectangle;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/awt/geom/AffineTransform;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:<init>", &boundsPyObj, &mapCrsPyObj, &image2mapPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        boundsJObj = BPy_ToJObjectT(boundsPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapCrsJObj = BPy_ToJObjectT(mapCrsPyObj, BPy_CoordinateReferenceSystem_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        image2mapJObj = BPy_ToJObjectT(image2mapPyObj, BPy_AffineTransform_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ImageGeometry_Class, _method, boundsJObj, mapCrsJObj, image2mapJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#<init>(Ljava/awt/Rectangle;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/awt/geom/AffineTransform;)V");
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "getImage2MapTransform", "()Ljava/awt/geom/AffineTransform;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageGeometry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#getImage2MapTransform()Ljava/awt/geom/AffineTransform;");
    _resultPyObj = BPy_FromJObject(&AffineTransform_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "getImageRect", "()Ljava/awt/Rectangle;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageGeometry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#getImageRect()Ljava/awt/Rectangle;");
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "getMapCrs", "()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageGeometry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#getMapCrs()Lorg/opengis/referencing/crs/CoordinateReferenceSystem;");
    _resultPyObj = BPy_FromJObject(&CoordinateReferenceSystem_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "changeYAxisDirection", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ImageGeometry_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ImageGeometry' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#changeYAxisDirection()V");
    return Py_BuildValue("");
}

PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    jdouble referencePixelX = (jdouble) 0;
    jdouble referencePixelY = (jdouble) 0;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateEastingNorthing", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DDDD)Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdddd:calculateEastingNorthing", &sourceProductPyObj, &targetCrsPyObj, &referencePixelX, &referencePixelY, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, BPy_CoordinateReferenceSystem_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ImageGeometry_Class, _method, sourceProductJObj, targetCrsJObj, referencePixelX, referencePixelY, pixelSizeX, pixelSizeY);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#calculateEastingNorthing(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DDDD)Ljava/awt/geom/Point2D;");
    _resultPyObj = BPy_FromJObject(&Point2D_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "calculateProductSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DD)Ljava/awt/Rectangle;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdd:calculateProductSize", &sourceProductPyObj, &targetCrsPyObj, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, BPy_CoordinateReferenceSystem_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ImageGeometry_Class, _method, sourceProductJObj, targetCrsJObj, pixelSizeX, pixelSizeY);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#calculateProductSize(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;DD)Ljava/awt/Rectangle;");
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetCrsPyObj = NULL;
    jobject targetCrsJObj = NULL;
    PyObject* pixelSizeXPyObj = NULL;
    jobject pixelSizeXJObj = NULL;
    PyObject* pixelSizeYPyObj = NULL;
    jobject pixelSizeYJObj = NULL;
    PyObject* widthPyObj = NULL;
    jobject widthJObj = NULL;
    PyObject* heightPyObj = NULL;
    jobject heightJObj = NULL;
    PyObject* orientationPyObj = NULL;
    jobject orientationJObj = NULL;
    PyObject* eastingPyObj = NULL;
    jobject eastingJObj = NULL;
    PyObject* northingPyObj = NULL;
    jobject northingJObj = NULL;
    PyObject* referencePixelXPyObj = NULL;
    jobject referencePixelXJObj = NULL;
    PyObject* referencePixelYPyObj = NULL;
    jobject referencePixelYJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "createTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOOOOOOOOOO:createTargetGeometry", &sourceProductPyObj, &targetCrsPyObj, &pixelSizeXPyObj, &pixelSizeYPyObj, &widthPyObj, &heightPyObj, &orientationPyObj, &eastingPyObj, &northingPyObj, &referencePixelXPyObj, &referencePixelYPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetCrsJObj = BPy_ToJObjectT(targetCrsPyObj, BPy_CoordinateReferenceSystem_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pixelSizeXJObj = BPy_ToJObjectT(pixelSizeXPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pixelSizeYJObj = BPy_ToJObjectT(pixelSizeYPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        widthJObj = BPy_ToJObjectT(widthPyObj, BPy_Integer_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        heightJObj = BPy_ToJObjectT(heightPyObj, BPy_Integer_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        orientationJObj = BPy_ToJObjectT(orientationPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        eastingJObj = BPy_ToJObjectT(eastingPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        northingJObj = BPy_ToJObjectT(northingPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        referencePixelXJObj = BPy_ToJObjectT(referencePixelXPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        referencePixelYJObj = BPy_ToJObjectT(referencePixelYPyObj, BPy_Double_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ImageGeometry_Class, _method, sourceProductJObj, targetCrsJObj, pixelSizeXJObj, pixelSizeYJObj, widthJObj, heightJObj, orientationJObj, eastingJObj, northingJObj, referencePixelXJObj, referencePixelYJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#createTargetGeometry(Lorg/esa/beam/framework/datamodel/Product;Lorg/opengis/referencing/crs/CoordinateReferenceSystem;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Integer;Ljava/lang/Integer;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;Ljava/lang/Double;)Lorg/esa/beam/framework/datamodel/ImageGeometry;");
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* collocationProductPyObj = NULL;
    jobject collocationProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ImageGeometry_Class, "org.esa.beam.framework.datamodel.ImageGeometry", "createCollocationTargetGeometry", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/ImageGeometry;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createCollocationTargetGeometry", &targetProductPyObj, &collocationProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        collocationProductJObj = BPy_ToJObjectT(collocationProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ImageGeometry_Class, _method, targetProductJObj, collocationProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ImageGeometry#createCollocationTargetGeometry(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/ImageGeometry;");
    _resultPyObj = BPy_FromJObject(&ImageGeometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint dataType = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "<init>", "(Ljava/lang/String;III)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siii:<init>", &name, &dataType, &width, &height)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_Band_Class, _method, nameJObj, dataType, width, height);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#<init>(Ljava/lang/String;III)V");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getFlagCoding", "()Lorg/esa/beam/framework/datamodel/FlagCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getFlagCoding()Lorg/esa/beam/framework/datamodel/FlagCoding;");
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isFlagBand", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isFlagBand()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getIndexCoding", "()Lorg/esa/beam/framework/datamodel/IndexCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getIndexCoding()Lorg/esa/beam/framework/datamodel/IndexCoding;");
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isIndexBand", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isIndexBand()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSampleCoding", "()Lorg/esa/beam/framework/datamodel/SampleCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSampleCoding()Lorg/esa/beam/framework/datamodel/SampleCoding;");
    _resultPyObj = BPy_FromJObject(&SampleCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* sampleCodingPyObj = NULL;
    jobject sampleCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSampleCoding", "(Lorg/esa/beam/framework/datamodel/SampleCoding;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSampleCoding", &sampleCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sampleCodingJObj = BPy_ToJObjectT(sampleCodingPyObj, BPy_SampleCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sampleCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSampleCoding(Lorg/esa/beam/framework/datamodel/SampleCoding;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSpectralBandIndex", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSpectralBandIndex()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint spectralBandIndex = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSpectralBandIndex", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setSpectralBandIndex", &spectralBandIndex)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandIndex);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSpectralBandIndex(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSpectralWavelength", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSpectralWavelength()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat spectralWavelength = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSpectralWavelength", "(F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:setSpectralWavelength", &spectralWavelength)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralWavelength);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSpectralWavelength(F)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSpectralBandwidth", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSpectralBandwidth()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat spectralBandwidth = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSpectralBandwidth", "(F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:setSpectralBandwidth", &spectralBandwidth)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, spectralBandwidth);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSpectralBandwidth(F)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSolarFlux", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSolarFlux()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat solarFlux = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSolarFlux", "(F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:setSolarFlux", &solarFlux)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, solarFlux);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSolarFlux(F)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* bandName = NULL;
    jstring bandNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getViewModeId", "(Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getViewModeId", &bandName)) {
        return NULL;
    }
    bandNameJObj =(*jenv)->NewStringUTF(jenv, bandName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, bandNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getViewModeId(Ljava/lang/String;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, bandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_computeBand(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* expression = NULL;
    jstring expressionJObj = NULL;
    const char* validMaskExpression = NULL;
    jstring validMaskExpressionJObj = NULL;
    PyObject* sourceProductsPyObj = NULL;
    jarray sourceProductsJObj = NULL;
    jint defaultProductIndex = (jint) 0;
    jboolean checkInvalids = (jboolean) 0;
    jboolean useInvalidValue = (jboolean) 0;
    jdouble noDataValue = (jdouble) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "computeBand", "(Ljava/lang/String;Ljava/lang/String;[Lorg/esa/beam/framework/datamodel/Product;IZZDLcom/bc/ceres/core/ProgressMonitor;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ssOibbdO:computeBand", &expression, &validMaskExpression, &sourceProductsPyObj, &defaultProductIndex, &checkInvalids, &useInvalidValue, &noDataValue, &pmPyObj)) {
        return NULL;
    }
    expressionJObj =(*jenv)->NewStringUTF(jenv, expression);
    validMaskExpressionJObj =(*jenv)->NewStringUTF(jenv, validMaskExpression);
    {
        jboolean ok = 1;
        sourceProductsJObj = BPy_ToJObjectArrayT(sourceProductsPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, expressionJObj, validMaskExpressionJObj, sourceProductsJObj, defaultProductIndex, checkInvalids, useInvalidValue, noDataValue, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#computeBand(Ljava/lang/String;Ljava/lang/String;[Lorg/esa/beam/framework/datamodel/Product;IZZDLcom/bc/ceres/core/ProgressMonitor;)I");
    (*jenv)->DeleteLocalRef(jenv, expressionJObj);
    (*jenv)->DeleteLocalRef(jenv, validMaskExpressionJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceProductsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSceneRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelInt", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixelInt(II)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelFloat", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixelFloat(II)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelDouble", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixelDouble(II)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iii:setPixelInt", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixelInt(III)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iif:setPixelFloat", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixelFloat(IIF)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iid:setPixelDouble", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixelDouble(IID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixels(IIII[I)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixels(IIII[F)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setPixels(IIII[D)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "ensureRasterData", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#ensureRasterData()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#unloadRasterData()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSceneRasterWidth()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSceneRasterHeight()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getRasterWidth()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getRasterHeight()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getGeoCoding()Lorg/esa/beam/framework/datamodel/GeoCoding;");
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setGeoCoding", &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setGeoCoding(Lorg/esa/beam/framework/datamodel/GeoCoding;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPointing()Lorg/esa/beam/framework/datamodel/Pointing;");
    _resultPyObj = BPy_FromJObject(&Pointing_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#canBeOrthorectified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isFloatingPointType()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getGeophysicalDataType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getScalingFactor()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setScalingFactor", &scalingFactor)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setScalingFactor(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getScalingOffset()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setScalingOffset", &scalingOffset)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setScalingOffset(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isLog10Scaled()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setLog10Scaled", &log10Scaled)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setLog10Scaled(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isScalingApplied()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_Band_Class, _method, propertyNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isValidMaskProperty(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isNoDataValueSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#clearNoDataValue()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isNoDataValueUsed()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setNoDataValueUsed", &noDataValueUsed)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setNoDataValueUsed(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getNoDataValue()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setNoDataValue", &noDataValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setNoDataValue(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getGeophysicalNoDataValue()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setGeophysicalNoDataValue", &noDataValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setGeophysicalNoDataValue(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getValidPixelExpression()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setValidPixelExpression", &validPixelExpression)) {
        return NULL;
    }
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setValidPixelExpression(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isValidMaskUsed()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#resetValidMask()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getValidMaskExpression()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#hasRasterData()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setRasterData", &rasterDataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setRasterData(Lorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#loadRasterData()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:isPixelValid", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isPixelValid(II)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getSampleInt", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSampleInt(II)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getSampleFloat", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSampleFloat(II)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "i", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixels(IIII[I)[I");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJIntArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJIntArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "f", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixels(IIII[F)[F");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJFloatArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJFloatArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "d", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixels(IIII[D)[D");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJDoubleArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJDoubleArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "i", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#readPixels(IIII[I)[I");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJIntArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJIntArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "f", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#readPixels(IIII[F)[F");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJFloatArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJFloatArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferWritable(pixelsPyObj, &pixelsBuf, "d", w*h);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#readPixels(IIII[D)[D");
    if (pixelsData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, pixelsJObj)) {
        _resultPyObj = BPy_CopyJDoubleArrayToBuffer((jarray) pixelsJObj, pixelsData, pixelsLength, pixelsPyObj);
    } else {
        _resultPyObj = BPy_FromJDoubleArray((jarray) pixelsJObj);
    }
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#writePixels(IIII[I)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#writePixels(IIII[F)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#writePixels(IIII[D)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readValidMask", &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    validMaskPyObj = BPy_ToPrimitiveArrayBufferWritable(validMaskPyObj, &validMaskBuf, "b", w*h);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = BPy_NewJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#readValidMask(IIII[Z)[Z");
    if (validMaskData != NULL && (*jenv)->IsSameObject(jenv, _resultJObj, validMaskJObj)) {
        _resultPyObj = BPy_CopyJBooleanArrayToBuffer((jarray) validMaskJObj, validMaskData, validMaskLength, validMaskPyObj);
    } else {
        _resultPyObj = BPy_FromJBooleanArray((jarray) validMaskJObj);
    }
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#writeRasterDataFully()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writeRasterData", &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#writeRasterData(IIIILorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createCompatibleRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createCompatibleSceneRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:createCompatibleRasterData", &width, &height)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createCompatibleRasterData(II)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:isCompatibleRasterData", &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isCompatibleRasterData(Lorg/esa/beam/framework/datamodel/ProductData;II)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:checkCompatibleRasterData", &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#checkCompatibleRasterData(Lorg/esa/beam/framework/datamodel/ProductData;II)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#hasIntPixels()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createTransectProfileData", &shapePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        shapeJObj = BPy_ToJObjectT(shapePyObj, BPy_Shape_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createTransectProfileData(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;");
    _resultPyObj = BPy_FromJObject(&TransectProfileData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getImageInfo()Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setImageInfo", &imageInfoPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, BPy_ImageInfo_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setImageInfo(Lorg/esa/beam/framework/datamodel/ImageInfo;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#fireImageInfoChanged()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* histogramPyObj = NULL;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createDefaultImageInfo", &histoSkipAreasPyObj, &histogramPyObj)) {
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        histogramJObj = BPy_ToJObjectT(histogramPyObj, BPy_Histogram_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createDefaultImageInfo([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getOverlayMaskGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createColorIndexedImage", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createColorIndexedImage(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createRgbImage", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createRgbImage(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:createPixelValidator", &lineOffset, &roiPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        roiJObj = BPy_ToJObjectT(roiPyObj, BPy_ROI_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createPixelValidator(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;");
    _resultPyObj = BPy_FromJObject(&IndexValidator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "scale", "(D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:scale", &v)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#scale(D)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:scaleInverse", &v)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#scaleInverse(D)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelString", &x, &y)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getPixelString(II)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isSourceImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getSourceImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isGeophysicalImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getGeophysicalImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isValidMaskImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getValidMaskImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isStxSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getStx()Lorg/esa/beam/framework/datamodel/Stx;");
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* stxPyObj = NULL;
    jobject stxJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setStx", &stxPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        stxJObj = BPy_ToJObjectT(stxPyObj, BPy_Stx_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setStx(Lorg/esa/beam/framework/datamodel/Stx;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getValidShape()Ljava/awt/Shape;");
    _resultPyObj = BPy_FromJObject(&Shape_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getRoiMaskGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getDataType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getDataType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getNumDataElems()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyBand_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setData", &dataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setData(Lorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setDataElems", &elemsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elemsJObj = BPy_ToJObjectT(elemsPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setDataElems(Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getDataElems()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getDataElemSize()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setReadOnly", &readOnly)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setReadOnly(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isReadOnly()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setUnit", &unit)) {
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setUnit(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getUnit()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isSynthetic()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setSynthetic", &synthetic)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setSynthetic(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#fireProductNodeDataChanged()V");
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:createCompatibleProductData", &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#createCompatibleProductData(I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_Band_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyBand_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Band_Class, "org.esa.beam.framework.datamodel.Band", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Band_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Band' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.Band#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getVectorDataNode", "()Lorg/esa/beam/framework/datamodel/VectorDataNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getVectorDataNode()Lorg/esa/beam/framework/datamodel/VectorDataNode;");
    _resultPyObj = BPy_FromJObject(&VectorDataNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* featurePyObj = NULL;
    jobject featureJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getPlacemark", "(Lorg/opengis/feature/simple/SimpleFeature;)Lorg/esa/beam/framework/datamodel/Placemark;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getPlacemark", &featurePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        featureJObj = BPy_ToJObjectT(featurePyObj, BPy_SimpleFeature_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, featureJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getPlacemark(Lorg/opengis/feature/simple/SimpleFeature;)Lorg/esa/beam/framework/datamodel/Placemark;");
    _resultPyObj = BPy_FromJObject(&Placemark_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:add", &placemarkPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        placemarkJObj = BPy_ToJObjectT(placemarkPyObj, BPy_Placemark_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#add(Lorg/esa/beam/framework/datamodel/Placemark;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/Placemark;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:add", &index, &placemarkPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        placemarkJObj = BPy_ToJObjectT(placemarkPyObj, BPy_Placemark_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, placemarkJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#add(ILorg/esa/beam/framework/datamodel/Placemark;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* placemarkPyObj = NULL;
    jobject placemarkJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/Placemark;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:remove", &placemarkPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        placemarkJObj = BPy_ToJObjectT(placemarkPyObj, BPy_Placemark_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, placemarkJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#remove(Lorg/esa/beam/framework/datamodel/Placemark;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#isTakingOverNodeOwnership()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getNodeCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:get", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#get(I)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getNodeDisplayNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getNodeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "()[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#toArray()[Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arrayPyObj = NULL;
    jarray arrayJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toArray", "([Lorg/esa/beam/framework/datamodel/ProductNode;)[Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:toArray", &arrayPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arrayJObj = BPy_ToJObjectArrayT(arrayPyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arrayJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#toArray([Lorg/esa/beam/framework/datamodel/ProductNode;)[Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, arrayJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:indexOf", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#indexOf(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:indexOf", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#indexOf(Lorg/esa/beam/framework/datamodel/ProductNode;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getByDisplayName", &displayName)) {
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getByDisplayName(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:get", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#get(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:contains", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#contains(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:contains", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#contains(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:add", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#add(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:add", &index, &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#add(ILorg/esa/beam/framework/datamodel/ProductNode;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:remove", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#remove(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#removeAll()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#clearRemovedList()V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getRemovedNodes()Ljava/util/Collection;");
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getRawStorageSize", &subsetDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getRawStorageSize(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_PlacemarkGroup_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getRawStorageSize()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:fireProductNodeChanged", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#fireProductNodeChanged(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    PyObject* oldValuePyObj = NULL;
    jobject oldValueJObj = NULL;
    PyObject* newValuePyObj = NULL;
    jobject newValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:fireProductNodeChanged", &propertyName, &oldValuePyObj, &newValuePyObj)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    {
        jboolean ok = 1;
        oldValueJObj = BPy_ToJObjectT(oldValuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        newValueJObj = BPy_ToJObjectT(newValuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#fireProductNodeChanged(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_PlacemarkGroup_Class, "org.esa.beam.framework.datamodel.PlacemarkGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_PlacemarkGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'PlacemarkGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.PlacemarkGroup#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[F)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffO:<init>", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_TiePointGrid_Class, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#<init>(Ljava/lang/String;IIFFFF[F)V");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint discontinuity = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FI)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOi:<init>", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &discontinuity)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_TiePointGrid_Class, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, discontinuity);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#<init>(Ljava/lang/String;IIFFFF[FI)V");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint gridWidth = (jint) 0;
    jint gridHeight = (jint) 0;
    jfloat offsetX = (jfloat) 0;
    jfloat offsetY = (jfloat) 0;
    jfloat subSamplingX = (jfloat) 0;
    jfloat subSamplingY = (jfloat) 0;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jboolean containsAngles = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "<init>", "(Ljava/lang/String;IIFFFF[FZ)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "siiffffOb:<init>", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsPyObj, &containsAngles)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_TiePointGrid_Class, _method, nameJObj, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePointsJObj, containsAngles);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#<init>(Ljava/lang/String;IIFFFF[FZ)V");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat* tiePointsData = NULL;
    int tiePointsLength = 0;
    PyObject* tiePointsPyObj = NULL;
    Py_buffer tiePointsBuf;
    jarray tiePointsJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "([F)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getDiscontinuity", &tiePointsPyObj)) {
        return NULL;
    }
    tiePointsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(tiePointsPyObj, &tiePointsBuf, "f", -1);
    if (tiePointsPyObj == NULL) {
        return NULL;
    }
    tiePointsData = (jfloat*) tiePointsBuf.buf;
    tiePointsLength = tiePointsBuf.len / tiePointsBuf.itemsize;
    tiePointsJObj = BPy_NewJFloatArrayFromBuffer(tiePointsData, tiePointsLength);
    if (tiePointsJObj == NULL) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_TiePointGrid_Class, _method, tiePointsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDiscontinuity([F)I");
    PyBuffer_Release(&tiePointsBuf);
    (*jenv)->DeleteLocalRef(jenv, tiePointsJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDiscontinuity", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDiscontinuity()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint discontinuity = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setDiscontinuity", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setDiscontinuity", &discontinuity)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, discontinuity);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setDiscontinuity(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isFloatingPointType()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalDataType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getGeophysicalDataType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSceneRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterWidth", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSceneRasterWidth()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSceneRasterHeight", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSceneRasterHeight()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetX", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getOffsetX()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getOffsetY", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getOffsetY()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingX", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSubSamplingX()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSubSamplingY", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSubSamplingY()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getTiePoints", "()[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getTiePoints()[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelInt", "(II)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelInt", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixelInt(II)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(II)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelFloat", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixelFloat(II)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat x = (jfloat) 0;
    jfloat y = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelFloat", "(FF)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:getPixelFloat", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixelFloat(FF)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelDouble", "(II)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelDouble", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixelDouble(II)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint pixelValue = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelInt", "(III)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iii:setPixelInt", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixelInt(III)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat pixelValue = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelFloat", "(IIF)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iif:setPixelFloat", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixelFloat(IIF)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jdouble pixelValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixelDouble", "(IID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iid:setPixelDouble", &x, &y, &pixelValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, pixelValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixelDouble(IID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:getPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I");
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:getPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:getPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D");
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixels(IIII[I)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixels(IIII[F)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setPixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:setPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setPixels(IIII[D)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:readPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[ILcom/bc/ceres/core/ProgressMonitor;)[I");
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:readPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[FLcom/bc/ceres/core/ProgressMonitor;)[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:readPixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[DLcom/bc/ceres/core/ProgressMonitor;)[D");
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[ILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:writePixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[ILcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[FLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:writePixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[FLcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[DLcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:writePixels", &x, &y, &w, &h, &pixelsPyObj, &pmPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[DLcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:readRasterData", &offsetX, &offsetY, &width, &height, &rasterDataPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readRasterData(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:readRasterDataFully", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readRasterDataFully(Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiOO:writeRasterData", &offsetX, &offsetY, &width, &height, &rasterDataPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writeRasterData(IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:writeRasterDataFully", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writeRasterDataFully(Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "cloneTiePointGrid", "()Lorg/esa/beam/framework/datamodel/TiePointGrid;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#cloneTiePointGrid()Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* elevationAngleGridPyObj = NULL;
    jobject elevationAngleGridJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createZenithFromElevationAngleTiePointGrid", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createZenithFromElevationAngleTiePointGrid", &elevationAngleGridPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elevationAngleGridJObj = BPy_ToJObjectT(elevationAngleGridPyObj, BPy_TiePointGrid_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_TiePointGrid_Class, _method, elevationAngleGridJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createZenithFromElevationAngleTiePointGrid(Lorg/esa/beam/framework/datamodel/TiePointGrid;)Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceTiePointGridPyObj = NULL;
    jobject sourceTiePointGridJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createSubset", "(Lorg/esa/beam/framework/datamodel/TiePointGrid;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createSubset", &sourceTiePointGridPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceTiePointGridJObj = BPy_ToJObjectT(sourceTiePointGridPyObj, BPy_TiePointGrid_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_TiePointGrid_Class, _method, sourceTiePointGridJObj, subsetDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createSubset(Lorg/esa/beam/framework/datamodel/TiePointGrid;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterWidth", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRasterWidth()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterHeight", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRasterHeight()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeoCoding", "()Lorg/esa/beam/framework/datamodel/GeoCoding;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getGeoCoding()Lorg/esa/beam/framework/datamodel/GeoCoding;");
    _resultPyObj = BPy_FromJObject(&GeoCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeoCoding", "(Lorg/esa/beam/framework/datamodel/GeoCoding;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setGeoCoding", &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setGeoCoding(Lorg/esa/beam/framework/datamodel/GeoCoding;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPointing", "()Lorg/esa/beam/framework/datamodel/Pointing;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPointing()Lorg/esa/beam/framework/datamodel/Pointing;");
    _resultPyObj = BPy_FromJObject(&Pointing_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "canBeOrthorectified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#canBeOrthorectified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingFactor", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getScalingFactor()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble scalingFactor = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingFactor", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setScalingFactor", &scalingFactor)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingFactor);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setScalingFactor(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getScalingOffset", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getScalingOffset()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble scalingOffset = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setScalingOffset", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setScalingOffset", &scalingOffset)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, scalingOffset);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setScalingOffset(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isLog10Scaled", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isLog10Scaled()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean log10Scaled = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setLog10Scaled", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setLog10Scaled", &log10Scaled)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, log10Scaled);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setLog10Scaled(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isScalingApplied", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isScalingApplied()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskProperty", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_TiePointGrid_Class, _method, propertyNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isValidMaskProperty(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isNoDataValueSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "clearNoDataValue", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#clearNoDataValue()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isNoDataValueUsed", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isNoDataValueUsed()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean noDataValueUsed = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValueUsed", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setNoDataValueUsed", &noDataValueUsed)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValueUsed);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setNoDataValueUsed(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getNoDataValue", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getNoDataValue()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setNoDataValue", &noDataValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setNoDataValue(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalNoDataValue", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getGeophysicalNoDataValue()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble noDataValue = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setGeophysicalNoDataValue", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setGeophysicalNoDataValue", &noDataValue)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, noDataValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setGeophysicalNoDataValue(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidPixelExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getValidPixelExpression()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* validPixelExpression = NULL;
    jstring validPixelExpressionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setValidPixelExpression", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setValidPixelExpression", &validPixelExpression)) {
        return NULL;
    }
    validPixelExpressionJObj =(*jenv)->NewStringUTF(jenv, validPixelExpression);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, validPixelExpressionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setValidPixelExpression(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, validPixelExpressionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskUsed", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isValidMaskUsed()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "resetValidMask", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#resetValidMask()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskExpression", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getValidMaskExpression()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "hasRasterData", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#hasRasterData()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setRasterData", &rasterDataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setRasterData(Lorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#loadRasterData()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "loadRasterData", "(Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:loadRasterData", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#loadRasterData(Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "unloadRasterData", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#unloadRasterData()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(II)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:isPixelValid", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isPixelValid(II)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleInt", "(II)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getSampleInt", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSampleInt(II)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSampleFloat", "(II)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getSampleFloat", &x, &y)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSampleFloat(II)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint pixelIndex = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(I)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:isPixelValid", &pixelIndex)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, pixelIndex);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isPixelValid(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isPixelValid", "(IILjavax/media/jai/ROI;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiO:isPixelValid", &x, &y, &roiPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        roiJObj = BPy_ToJObjectT(roiPyObj, BPy_ROI_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, x, y, roiJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isPixelValid(IILjavax/media/jai/ROI;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[I)[I");
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[F)[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:getPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixels(IIII[D)[D");
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[I)[I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[I)[I");
    _resultPyObj = BPy_FromJIntArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[F)[F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[F)[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readPixels", "(IIII[D)[D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readPixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readPixels(IIII[D)[D");
    _resultPyObj = BPy_FromJDoubleArray((jarray) _resultJObj);
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jint* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "i", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jint*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJIntArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[I)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jfloat* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "f", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jfloat*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJFloatArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[F)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jdouble* pixelsData = NULL;
    int pixelsLength = 0;
    PyObject* pixelsPyObj = NULL;
    Py_buffer pixelsBuf;
    jarray pixelsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writePixels", "(IIII[D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writePixels", &x, &y, &w, &h, &pixelsPyObj)) {
        return NULL;
    }
    pixelsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(pixelsPyObj, &pixelsBuf, "d", -1);
    if (pixelsPyObj == NULL) {
        return NULL;
    }
    pixelsData = (jdouble*) pixelsBuf.buf;
    pixelsLength = pixelsBuf.len / pixelsBuf.itemsize;
    pixelsJObj = BPy_NewJDoubleArrayFromBuffer(pixelsData, pixelsLength);
    if (pixelsJObj == NULL) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, x, y, w, h, pixelsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writePixels(IIII[D)V");
    PyBuffer_Release(&pixelsBuf);
    (*jenv)->DeleteLocalRef(jenv, pixelsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean* validMaskData = NULL;
    int validMaskLength = 0;
    PyObject* validMaskPyObj = NULL;
    Py_buffer validMaskBuf;
    jarray validMaskJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readValidMask", "(IIII[Z)[Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readValidMask", &x, &y, &w, &h, &validMaskPyObj)) {
        return NULL;
    }
    validMaskPyObj = BPy_ToPrimitiveArrayBufferReadOnly(validMaskPyObj, &validMaskBuf, "b", -1);
    if (validMaskPyObj == NULL) {
        return NULL;
    }
    validMaskData = (jboolean*) validMaskBuf.buf;
    validMaskLength = validMaskBuf.len / validMaskBuf.itemsize;
    validMaskJObj = BPy_NewJBooleanArrayFromBuffer(validMaskData, validMaskLength);
    if (validMaskJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y, w, h, validMaskJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readValidMask(IIII[Z)[Z");
    _resultPyObj = BPy_FromJBooleanArray((jarray) _resultJObj);
    PyBuffer_Release(&validMaskBuf);
    (*jenv)->DeleteLocalRef(jenv, validMaskJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterDataFully", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readRasterDataFully()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "readRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:readRasterData", &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#readRasterData(IIIILorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterDataFully", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writeRasterDataFully()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint offsetX = (jint) 0;
    jint offsetY = (jint) 0;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "writeRasterData", "(IIIILorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiiiO:writeRasterData", &offsetX, &offsetY, &width, &height, &rasterDataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, offsetX, offsetY, width, height, rasterDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#writeRasterData(IIIILorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createCompatibleRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleSceneRasterData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createCompatibleSceneRasterData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleRasterData", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:createCompatibleRasterData", &width, &height)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, width, height);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createCompatibleRasterData(II)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:isCompatibleRasterData", &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isCompatibleRasterData(Lorg/esa/beam/framework/datamodel/ProductData;II)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* rasterDataPyObj = NULL;
    jobject rasterDataJObj = NULL;
    jint w = (jint) 0;
    jint h = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "checkCompatibleRasterData", "(Lorg/esa/beam/framework/datamodel/ProductData;II)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:checkCompatibleRasterData", &rasterDataPyObj, &w, &h)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataJObj = BPy_ToJObjectT(rasterDataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, rasterDataJObj, w, h);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#checkCompatibleRasterData(Lorg/esa/beam/framework/datamodel/ProductData;II)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "hasIntPixels", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#hasIntPixels()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createTransectProfileData", "(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createTransectProfileData", &shapePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        shapeJObj = BPy_ToJObjectT(shapePyObj, BPy_Shape_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, shapeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createTransectProfileData(Ljava/awt/Shape;)Lorg/esa/beam/framework/datamodel/TransectProfileData;");
    _resultPyObj = BPy_FromJObject(&TransectProfileData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "()Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getImageInfo()Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setImageInfo", "(Lorg/esa/beam/framework/datamodel/ImageInfo;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setImageInfo", &imageInfoPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, BPy_ImageInfo_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, imageInfoJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setImageInfo(Lorg/esa/beam/framework/datamodel/ImageInfo;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "fireImageInfoChanged", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#fireImageInfoChanged()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "(Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getImageInfo", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getImageInfo(Lcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:getImageInfo", &histoSkipAreasPyObj, &pmPyObj)) {
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getImageInfo([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createDefaultImageInfo", &histoSkipAreasPyObj, &pmPyObj)) {
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createDefaultImageInfo([DLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble* histoSkipAreasData = NULL;
    int histoSkipAreasLength = 0;
    PyObject* histoSkipAreasPyObj = NULL;
    Py_buffer histoSkipAreasBuf;
    jarray histoSkipAreasJObj = NULL;
    PyObject* histogramPyObj = NULL;
    jobject histogramJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createDefaultImageInfo", "([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createDefaultImageInfo", &histoSkipAreasPyObj, &histogramPyObj)) {
        return NULL;
    }
    histoSkipAreasPyObj = BPy_ToPrimitiveArrayBufferReadOnly(histoSkipAreasPyObj, &histoSkipAreasBuf, "d", -1);
    if (histoSkipAreasPyObj == NULL) {
        return NULL;
    }
    histoSkipAreasData = (jdouble*) histoSkipAreasBuf.buf;
    histoSkipAreasLength = histoSkipAreasBuf.len / histoSkipAreasBuf.itemsize;
    histoSkipAreasJObj = BPy_NewJDoubleArrayFromBuffer(histoSkipAreasData, histoSkipAreasLength);
    if (histoSkipAreasJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        histogramJObj = BPy_ToJObjectT(histogramPyObj, BPy_Histogram_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, histoSkipAreasJObj, histogramJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createDefaultImageInfo([DLorg/esa/beam/util/math/Histogram;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    PyBuffer_Release(&histoSkipAreasBuf);
    (*jenv)->DeleteLocalRef(jenv, histoSkipAreasJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getOverlayMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getOverlayMaskGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createColorIndexedImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createColorIndexedImage", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createColorIndexedImage(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createRgbImage", "(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createRgbImage", &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createRgbImage(Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDDLcom/bc/ceres/core/ProgressMonitor;)[B", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddO:quantizeRasterData", &newMin, &newMax, &gamma, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#quantizeRasterData(DDDLcom/bc/ceres/core/ProgressMonitor;)[B");
    _resultPyObj = BPy_FromJByteArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble newMin = (jdouble) 0;
    jdouble newMax = (jdouble) 0;
    jdouble gamma = (jdouble) 0;
    jbyte* samplesData = NULL;
    int samplesLength = 0;
    PyObject* samplesPyObj = NULL;
    Py_buffer samplesBuf;
    jarray samplesJObj = NULL;
    jint offset = (jint) 0;
    jint stride = (jint) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "quantizeRasterData", "(DDD[BIILcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dddOiiO:quantizeRasterData", &newMin, &newMax, &gamma, &samplesPyObj, &offset, &stride, &pmPyObj)) {
        return NULL;
    }
    samplesPyObj = BPy_ToPrimitiveArrayBufferReadOnly(samplesPyObj, &samplesBuf, "b", -1);
    if (samplesPyObj == NULL) {
        return NULL;
    }
    samplesData = (jbyte*) samplesBuf.buf;
    samplesLength = samplesBuf.len / samplesBuf.itemsize;
    samplesJObj = BPy_NewJByteArrayFromBuffer(samplesData, samplesLength);
    if (samplesJObj == NULL) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, newMin, newMax, gamma, samplesJObj, offset, stride, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#quantizeRasterData(DDD[BIILcom/bc/ceres/core/ProgressMonitor;)V");
    PyBuffer_Release(&samplesBuf);
    (*jenv)->DeleteLocalRef(jenv, samplesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint lineOffset = (jint) 0;
    PyObject* roiPyObj = NULL;
    jobject roiJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createPixelValidator", "(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:createPixelValidator", &lineOffset, &roiPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        roiJObj = BPy_ToJObjectT(roiPyObj, BPy_ROI_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, lineOffset, roiJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createPixelValidator(ILjavax/media/jai/ROI;)Lorg/esa/beam/util/math/IndexValidator;");
    _resultPyObj = BPy_FromJObject(&IndexValidator_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "scale", "(D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:scale", &v)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#scale(D)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble v = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "scaleInverse", "(D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:scaleInverse", &v)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, v);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#scaleInverse(D)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint x = (jint) 0;
    jint y = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getPixelString", "(II)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:getPixelString", &x, &y)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, x, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getPixelString(II)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isSourceImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isSourceImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getSourceImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getSourceImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* sourceImagePyObj = NULL;
    jobject sourceImageJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Ljava/awt/image/RenderedImage;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSourceImage", &sourceImagePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceImageJObj = BPy_ToJObjectT(sourceImagePyObj, BPy_RenderedImage_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setSourceImage(Ljava/awt/image/RenderedImage;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* sourceImagePyObj = NULL;
    jobject sourceImageJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setSourceImage", "(Lcom/bc/ceres/glevel/MultiLevelImage;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSourceImage", &sourceImagePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceImageJObj = BPy_ToJObjectT(sourceImagePyObj, BPy_MultiLevelImage_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceImageJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setSourceImage(Lcom/bc/ceres/glevel/MultiLevelImage;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isGeophysicalImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isGeophysicalImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getGeophysicalImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getGeophysicalImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidMaskImageSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isValidMaskImageSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidMaskImage", "()Lcom/bc/ceres/glevel/MultiLevelImage;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getValidMaskImage()Lcom/bc/ceres/glevel/MultiLevelImage;");
    _resultPyObj = BPy_FromJObject(&MultiLevelImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isStxSet", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isStxSet()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "()Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getStx()Lorg/esa/beam/framework/datamodel/Stx;");
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean accurate = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getStx", "(ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/Stx;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "bO:getStx", &accurate, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, accurate, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getStx(ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/Stx;");
    _resultPyObj = BPy_FromJObject(&Stx_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* stxPyObj = NULL;
    jobject stxJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setStx", "(Lorg/esa/beam/framework/datamodel/Stx;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setStx", &stxPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        stxJObj = BPy_ToJObjectT(stxPyObj, BPy_Stx_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, stxJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setStx(Lorg/esa/beam/framework/datamodel/Stx;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getValidShape", "()Ljava/awt/Shape;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getValidShape()Ljava/awt/Shape;");
    _resultPyObj = BPy_FromJObject(&Shape_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRoiMaskGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRoiMaskGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRoiMaskGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDataType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getNumDataElems()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setData", &dataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setData(Lorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setDataElems", &elemsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elemsJObj = BPy_ToJObjectT(elemsPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setDataElems(Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDataElems()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDataElemSize()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setReadOnly", &readOnly)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setReadOnly(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isReadOnly()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setUnit", &unit)) {
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setUnit(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getUnit()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isSynthetic()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setSynthetic", &synthetic)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setSynthetic(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#fireProductNodeDataChanged()V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getRawStorageSize", &subsetDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, subsetDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRawStorageSize(Lorg/esa/beam/framework/dataio/ProductSubsetDef;)J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:createCompatibleProductData", &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#createCompatibleProductData(I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_TiePointGrid_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getRawStorageSize", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getRawStorageSize()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:fireProductNodeChanged", &propertyName)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#fireProductNodeChanged(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* propertyName = NULL;
    jstring propertyNameJObj = NULL;
    PyObject* oldValuePyObj = NULL;
    jobject oldValueJObj = NULL;
    PyObject* newValuePyObj = NULL;
    jobject newValueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "fireProductNodeChanged", "(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:fireProductNodeChanged", &propertyName, &oldValuePyObj, &newValuePyObj)) {
        return NULL;
    }
    propertyNameJObj =(*jenv)->NewStringUTF(jenv, propertyName);
    {
        jboolean ok = 1;
        oldValueJObj = BPy_ToJObjectT(oldValuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        newValueJObj = BPy_ToJObjectT(newValuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, propertyNameJObj, oldValueJObj, newValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#fireProductNodeChanged(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V");
    (*jenv)->DeleteLocalRef(jenv, propertyNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_TiePointGrid_Class, "org.esa.beam.framework.datamodel.TiePointGrid", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_TiePointGrid_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'TiePointGrid' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.TiePointGrid#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble azimuth = (jdouble) 0;
    jdouble zenith = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_AngularDirection_Class, "org.esa.beam.framework.datamodel.AngularDirection", "<init>", "(DD)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "dd:<init>", &azimuth, &zenith)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_AngularDirection_Class, _method, azimuth, zenith);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.AngularDirection#<init>(DD)V");
    _resultPyObj = BPy_FromJObject(&AngularDirection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* objPyObj = NULL;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_AngularDirection_Class, "org.esa.beam.framework.datamodel.AngularDirection", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_AngularDirection_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'AngularDirection' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &objPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        objJObj = BPy_ToJObjectT(objPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.AngularDirection#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_AngularDirection_Class, "org.esa.beam.framework.datamodel.AngularDirection", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_AngularDirection_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'AngularDirection' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.AngularDirection#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:<init>", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_FlagCoding_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#<init>(Ljava/lang/String;)V");
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getFlag", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getFlag", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getFlag(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getFlagNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint flagMask = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "addFlag", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sis:addFlag", &name, &flagMask, &description)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, flagMask, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#addFlag(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getFlagMask", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getFlagMask", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getFlagMask(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "addElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#addElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "addAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:addAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#addAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "addSample", "(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sis:addSample", &name, &value, &description)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, value, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#addSample(Ljava/lang/String;ILjava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getSampleCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getSampleName", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getSampleName(I)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getSampleValue", "(I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getSampleValue", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getSampleValue(I)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElementGroup", "()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElementGroup()Lorg/esa/beam/framework/datamodel/ProductNodeGroup;");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getParentElement()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint index = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "addElementAt", "(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:addElementAt", &elementPyObj, &index)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elementJObj, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#addElementAt(Lorg/esa/beam/framework/datamodel/MetadataElement;I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "removeElement", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeElement", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#removeElement(Lorg/esa/beam/framework/datamodel/MetadataElement;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getNumElements", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getNumElements()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElementAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElementAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElementAt(I)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElementNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElementNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElements", "()[Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElements()[Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElement", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElement(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "containsElement", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsElement", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#containsElement(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getElementIndex", "(Lorg/esa/beam/framework/datamodel/MetadataElement;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getElementIndex", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getElementIndex(Lorg/esa/beam/framework/datamodel/MetadataElement;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "removeAttribute", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeAttribute", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#removeAttribute(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getNumAttributes", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getNumAttributes()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeAt", "(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getAttributeAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeAt(I)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributes", "()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributes()[Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttribute", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttribute(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "containsAttribute", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:containsAttribute", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#containsAttribute(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* attributePyObj = NULL;
    jobject attributeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeIndex", "(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getAttributeIndex", &attributePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        attributeJObj = BPy_ToJObjectT(attributePyObj, BPy_MetadataAttribute_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, attributeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeIndex(Lorg/esa/beam/framework/datamodel/MetadataAttribute;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble defaultValue = (jdouble) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeDouble", "(Ljava/lang/String;D)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:getAttributeDouble", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeDouble(Ljava/lang/String;D)D");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyFlagCoding_getAttributeUTC2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* defaultValuePyObj = NULL;
    jobject defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:getAttributeUTC", &name, &defaultValuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        defaultValueJObj = BPy_ToJObjectT(defaultValuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeUTC1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeUTC", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getAttributeUTC", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeUTC(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint defaultValue = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeInt", "(Ljava/lang/String;I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:getAttributeInt", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj, defaultValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeInt(Ljava/lang/String;I)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeInt", "(Ljava/lang/String;I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "si:setAttributeInt", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setAttributeInt(Ljava/lang/String;I)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeDouble", "(Ljava/lang/String;D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sd:setAttributeDouble", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setAttributeDouble(Ljava/lang/String;D)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeUTC", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setAttributeUTC", &name, &valuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        valueJObj = BPy_ToJObjectT(valuePyObj, BPy_ProductData_UTC_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setAttributeUTC(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData$UTC;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* defaultValue = NULL;
    jstring defaultValueJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getAttributeString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:getAttributeString", &name, &defaultValue)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    defaultValueJObj =(*jenv)->NewStringUTF(jenv, defaultValue);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj, defaultValueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getAttributeString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, defaultValueJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setAttributeString", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:setAttributeString", &name, &value)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setAttributeString(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#createDeepClone()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_FlagCoding_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_FlagCoding_Class, "org.esa.beam.framework.datamodel.FlagCoding", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_FlagCoding_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'FlagCoding' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.FlagCoding#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_size(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "size", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#size()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMap_isEmpty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "isEmpty", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#isEmpty()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_containsKey(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "containsKey", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:containsKey", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#containsKey(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_containsValue(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "containsValue", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:containsValue", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#containsValue(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_get(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:get", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#get(Ljava/lang/Object;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_put(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* arg1PyObj = NULL;
    jobject arg1JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:put", &arg0PyObj, &arg1PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        arg1JObj = BPy_ToJObjectT(arg1PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj, arg1JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_remove(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "remove", "(Ljava/lang/Object;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:remove", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#remove(Ljava/lang/Object;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_putAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "putAll", "(Ljava/util/Map;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:putAll", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#putAll(Ljava/util/Map;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMap_clear(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "clear", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#clear()V");
    return Py_BuildValue("");
}

PyObject* BeamPyMap_keySet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "keySet", "()Ljava/util/Set;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#keySet()Ljava/util/Set;");
    _resultPyObj = BPy_FromJObject(&Set_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_values(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "values", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#values()Ljava/util/Collection;");
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_entrySet(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "entrySet", "()Ljava/util/Set;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#entrySet()Ljava/util/Set;");
    _resultPyObj = BPy_FromJObject(&Set_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMap_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("java.util.Map#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMap_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_Map_Class, "java.util.Map", "hashCode", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_Map_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'Map' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("java.util.Map#hashCode()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPySubsetOp_newSubsetOp(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_SubsetOp_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#<init>()V");
    _resultPyObj = BPy_FromJObject(&SubsetOp_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_getTiePointGridNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getTiePointGridNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getTiePointGridNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setTiePointGridNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* tiePointGridNamesPyObj = NULL;
    jarray tiePointGridNamesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setTiePointGridNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setTiePointGridNames", &tiePointGridNamesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        tiePointGridNamesJObj = BPy_ToJStringArray(tiePointGridNamesPyObj, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, tiePointGridNamesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setTiePointGridNames([Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, tiePointGridNamesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getBandNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getBandNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getBandNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setBandNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bandNamesPyObj = NULL;
    jarray bandNamesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setBandNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setBandNames", &bandNamesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandNamesJObj = BPy_ToJStringArray(bandNamesPyObj, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandNamesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setBandNames([Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, bandNamesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_setCopyMetadata(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean copyMetadata = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setCopyMetadata", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setCopyMetadata", &copyMetadata)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, copyMetadata);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setCopyMetadata(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getRegion(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getRegion", "()Ljava/awt/Rectangle;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getRegion()Ljava/awt/Rectangle;");
    _resultPyObj = BPy_FromJObject(&Rectangle_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setRegion(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setRegion", "(Ljava/awt/Rectangle;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setRegion", &regionPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, regionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setRegion(Ljava/awt/Rectangle;)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_setSubSamplingX(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint subSamplingX = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setSubSamplingX", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setSubSamplingX", &subSamplingX)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, subSamplingX);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setSubSamplingX(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_setSubSamplingY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint subSamplingY = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setSubSamplingY", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setSubSamplingY", &subSamplingY)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, subSamplingY);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setSubSamplingY(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getGeoRegion(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getGeoRegion", "()Lcom/vividsolutions/jts/geom/Geometry;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getGeoRegion()Lcom/vividsolutions/jts/geom/Geometry;");
    _resultPyObj = BPy_FromJObject(&Geometry_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setGeoRegion(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* geoRegionPyObj = NULL;
    jobject geoRegionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setGeoRegion", "(Lcom/vividsolutions/jts/geom/Geometry;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setGeoRegion", &geoRegionPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoRegionJObj = BPy_ToJObjectT(geoRegionPyObj, BPy_Geometry_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, geoRegionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setGeoRegion(Lcom/vividsolutions/jts/geom/Geometry;)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_update(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "update", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#update()V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getId(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getId", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getId()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_getSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getSourceProducts", "()[Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getSourceProducts()[Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setSourceProducts(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productsPyObj = NULL;
    jarray productsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setSourceProducts", "([Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSourceProducts", &productsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productsJObj = BPy_ToJObjectArrayT(productsPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setSourceProducts([Lorg/esa/beam/framework/datamodel/Product;)V");
    (*jenv)->DeleteLocalRef(jenv, productsJObj);
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getSourceProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getSourceProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getSourceProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setSourceProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setSourceProduct", "(Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSourceProduct", &sourceProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, sourceProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setSourceProduct(Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getSourceProductById(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getSourceProduct", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getSourceProduct", &id)) {
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, idJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getSourceProduct(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setSourceProductById(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* id = NULL;
    jstring idJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setSourceProduct", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setSourceProduct", &id, &productPyObj)) {
        return NULL;
    }
    idJObj =(*jenv)->NewStringUTF(jenv, id);
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, idJObj, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setSourceProduct(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)V");
    (*jenv)->DeleteLocalRef(jenv, idJObj);
    return Py_BuildValue("");
}

PyObject* BeamPySubsetOp_getSourceProductId(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getSourceProductId", "(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getSourceProductId", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getSourceProductId(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_getTargetProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getTargetProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getTargetProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_getTargetProperty(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getTargetProperty", "(Ljava/lang/String;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getTargetProperty", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getTargetProperty(Ljava/lang/String;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_getParameter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "getParameter", "(Ljava/lang/String;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getParameter", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#getParameter(Ljava/lang/String;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPySubsetOp_setParameter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* valuePyObj = NULL;
    jobject valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_SubsetOp_Class, "org.esa.beam.gpf.operators.standard.SubsetOp", "setParameter", "(Ljava/lang/String;Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_SubsetOp_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'SubsetOp' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sO:setParameter", &name, &valuePyObj)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        valueJObj = BPy_ToJObjectT(valuePyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.gpf.operators.standard.SubsetOp#setParameter(Ljava/lang/String;Ljava/lang/Object;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "getReaderPlugIn", "()Lorg/esa/beam/framework/dataio/ProductReaderPlugIn;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#getReaderPlugIn()Lorg/esa/beam/framework/dataio/ProductReaderPlugIn;");
    _resultPyObj = BPy_FromJObject(&ProductReaderPlugIn_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "getInput", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#getInput()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "getSubsetDef", "()Lorg/esa/beam/framework/dataio/ProductSubsetDef;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#getSubsetDef()Lorg/esa/beam/framework/dataio/ProductSubsetDef;");
    _resultPyObj = BPy_FromJObject(&ProductSubsetDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    PyObject* subsetDefPyObj = NULL;
    jobject subsetDefJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "readProductNodes", "(Ljava/lang/Object;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:readProductNodes", &inputPyObj, &subsetDefPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        subsetDefJObj = BPy_ToJObjectT(subsetDefPyObj, BPy_ProductSubsetDef_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, inputJObj, subsetDefJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#readProductNodes(Ljava/lang/Object;Lorg/esa/beam/framework/dataio/ProductSubsetDef;)Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* destBandPyObj = NULL;
    jobject destBandJObj = NULL;
    jint destOffsetX = (jint) 0;
    jint destOffsetY = (jint) 0;
    jint destWidth = (jint) 0;
    jint destHeight = (jint) 0;
    PyObject* destBufferPyObj = NULL;
    jobject destBufferJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "readBandRasterData", "(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiiiOO:readBandRasterData", &destBandPyObj, &destOffsetX, &destOffsetY, &destWidth, &destHeight, &destBufferPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        destBandJObj = BPy_ToJObjectT(destBandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        destBufferJObj = BPy_ToJObjectT(destBufferPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, destBandJObj, destOffsetX, destOffsetY, destWidth, destHeight, destBufferJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Lorg/esa/beam/framework/datamodel/Band;IIIILorg/esa/beam/framework/datamodel/ProductData;Lcom/bc/ceres/core/ProgressMonitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductReader_Class, "org.esa.beam.framework.dataio.ProductReader", "close", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductReader_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductReader' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.dataio.ProductReader#close()V");
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_RGBChannelDef_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#<init>()V");
    _resultPyObj = BPy_FromJObject(&RGBChannelDef_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceName", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getSourceName", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#getSourceName(I)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* sourceName = NULL;
    jstring sourceNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceName", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "is:setSourceName", &index, &sourceName)) {
        return NULL;
    }
    sourceNameJObj =(*jenv)->NewStringUTF(jenv, sourceName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, sourceNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#setSourceName(ILjava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, sourceNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "getSourceNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#getSourceNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* bandNamesPyObj = NULL;
    jarray bandNamesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "setSourceNames", "([Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setSourceNames", &bandNamesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandNamesJObj = BPy_ToJStringArray(bandNamesPyObj, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, bandNamesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#setSourceNames([Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, bandNamesJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "isAlphaUsed", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#isAlphaUsed()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "isGammaUsed", "(I)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:isGammaUsed", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#isGammaUsed(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "getGamma", "(I)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getGamma", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#getGamma(I)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble gamma = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "setGamma", "(ID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "id:setGamma", &index, &gamma)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, gamma);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#setGamma(ID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMinDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getMinDisplaySample", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#getMinDisplaySample(I)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble min = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMinDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "id:setMinDisplaySample", &index, &min)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, min);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#setMinDisplaySample(ID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "getMaxDisplaySample", "(I)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getMaxDisplaySample", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#getMaxDisplaySample(I)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble max = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "setMaxDisplaySample", "(ID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "id:setMaxDisplaySample", &index, &max)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, max);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#setMaxDisplaySample(ID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_RGBChannelDef_Class, "org.esa.beam.framework.datamodel.RGBChannelDef", "clone", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_RGBChannelDef_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'RGBChannelDef' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.RGBChannelDef#clone()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:createInstance", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance(I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(II)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:createInstance", &type, &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, type, numElems);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance(II)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(ILjava/lang/Object;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:createInstance", &type, &dataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, type, dataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance(ILjava/lang/Object;)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([B)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jbyte* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([B)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createUnsignedInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "b", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jbyte*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJByteArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createUnsignedInstance([B)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([S)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jshort* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([S)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createUnsignedInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "h", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jshort*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJShortArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createUnsignedInstance([S)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createUnsignedInstance", "([I)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createUnsignedInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "i", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jint*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJIntArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createUnsignedInstance([I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jlong* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([J)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "l", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jlong*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJLongArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([J)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* strData = NULL;
    jstring strDataJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:createInstance", &strData)) {
        return NULL;
    }
    strDataJObj =(*jenv)->NewStringUTF(jenv, strData);
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, strDataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, strDataJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([F)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "f", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jfloat*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJFloatArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([F)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jdouble* elemsData = NULL;
    int elemsLength = 0;
    PyObject* elemsPyObj = NULL;
    Py_buffer elemsBuf;
    jarray elemsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "createInstance", "([D)Lorg/esa/beam/framework/datamodel/ProductData;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createInstance", &elemsPyObj)) {
        return NULL;
    }
    elemsPyObj = BPy_ToPrimitiveArrayBufferReadOnly(elemsPyObj, &elemsBuf, "d", -1);
    if (elemsPyObj == NULL) {
        return NULL;
    }
    elemsData = (jdouble*) elemsBuf.buf;
    elemsLength = elemsBuf.len / elemsBuf.itemsize;
    elemsJObj = BPy_NewJDoubleArrayFromBuffer(elemsData, elemsLength);
    if (elemsJObj == NULL) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#createInstance([D)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    PyBuffer_Release(&elemsBuf);
    (*jenv)->DeleteLocalRef(jenv, elemsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "(I)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemSize", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemSize(I)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemSize", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemSize()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "(I)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getTypeString", &type)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getTypeString(I)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* type = NULL;
    jstring typeJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getType", "(Ljava/lang/String;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getType", &type)) {
        return NULL;
    }
    typeJObj =(*jenv)->NewStringUTF(jenv, type);
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_ProductData_Class, _method, typeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getType(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, typeJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getTypeString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getTypeString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isInt", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isInt()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:isIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isIntType(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isSigned", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isSigned()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isUnsigned", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isUnsigned()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isUIntType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:isUIntType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isUIntType(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jint type = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isFloatingPointType", "(I)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:isFloatingPointType", &type)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductData_Class, _method, type);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isFloatingPointType(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "isScalar", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#isScalar()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getNumElems", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getNumElems()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemInt", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemInt()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemUInt", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemUInt()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemFloat", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemFloat()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemDouble", "()D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemDouble()D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemBoolean", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemBoolean()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemIntAt", "(I)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemIntAt", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemIntAt(I)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemUIntAt", "(I)J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemUIntAt", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemUIntAt(I)J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemFloatAt", "(I)F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemFloatAt", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemFloatAt(I)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemDoubleAt", "(I)D", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemDoubleAt", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallDoubleMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemDoubleAt(I)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemStringAt", "(I)Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemStringAt", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemStringAt(I)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElemBooleanAt", "(I)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:getElemBooleanAt", &index)) {
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElemBooleanAt(I)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemInt", "(I)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:setElemInt", &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemInt(I)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong value = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemUInt", "(J)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "L:setElemUInt", &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemUInt(J)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat value = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemFloat", "(F)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:setElemFloat", &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemFloat(F)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemDouble", "(D)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "d:setElemDouble", &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemDouble(D)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemString", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setElemString", &value)) {
        return NULL;
    }
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemString(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean value = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemBoolean", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setElemBoolean", &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemBoolean(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jint value = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemIntAt", "(II)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ii:setElemIntAt", &index, &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemIntAt(II)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jlong value = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemUIntAt", "(IJ)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iL:setElemUIntAt", &index, &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemUIntAt(IJ)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jfloat value = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemFloatAt", "(IF)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "if:setElemFloatAt", &index, &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemFloatAt(IF)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jdouble value = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemDoubleAt", "(ID)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "id:setElemDoubleAt", &index, &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemDoubleAt(ID)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    const char* value = NULL;
    jstring valueJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemStringAt", "(ILjava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "is:setElemStringAt", &index, &value)) {
        return NULL;
    }
    valueJObj =(*jenv)->NewStringUTF(jenv, value);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, valueJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemStringAt(ILjava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, valueJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    jboolean value = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElemBooleanAt", "(IZ)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ib:setElemBooleanAt", &index, &value)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, value);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElemBooleanAt(IZ)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "getElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#getElems()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "setElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setElems", &dataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#setElems(Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(Ljavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:readFrom", &inputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_ImageInputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, inputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#readFrom(Ljavax/imageio/stream/ImageInputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(ILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:readFrom", &pos, &inputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_ImageInputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, inputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#readFrom(ILjavax/imageio/stream/ImageInputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiO:readFrom", &startPos, &numElems, &inputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_ImageInputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#readFrom(IILjavax/imageio/stream/ImageInputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* inputPyObj = NULL;
    jobject inputJObj = NULL;
    jlong inputPos = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "readFrom", "(IILjavax/imageio/stream/ImageInputStream;J)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiOL:readFrom", &startPos, &numElems, &inputPyObj, &inputPos)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        inputJObj = BPy_ToJObjectT(inputPyObj, BPy_ImageInputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, inputJObj, inputPos);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#readFrom(IILjavax/imageio/stream/ImageInputStream;J)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(Ljavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:writeTo", &outputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_ImageOutputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, outputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#writeTo(Ljavax/imageio/stream/ImageOutputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint pos = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(ILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:writeTo", &pos, &outputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_ImageOutputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, pos, outputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#writeTo(ILjavax/imageio/stream/ImageOutputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiO:writeTo", &startPos, &numElems, &outputPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_ImageOutputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#writeTo(IILjavax/imageio/stream/ImageOutputStream;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint startPos = (jint) 0;
    jint numElems = (jint) 0;
    PyObject* outputPyObj = NULL;
    jobject outputJObj = NULL;
    jlong outputPos = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "writeTo", "(IILjavax/imageio/stream/ImageOutputStream;J)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iiOL:writeTo", &startPos, &numElems, &outputPyObj, &outputPos)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        outputJObj = BPy_ToJObjectT(outputPyObj, BPy_ImageOutputStream_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, startPos, numElems, outputJObj, outputPos);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#writeTo(IILjavax/imageio/stream/ImageOutputStream;J)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "hashCode", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#hashCode()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* otherPyObj = NULL;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &otherPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        otherJObj = BPy_ToJObjectT(otherPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* otherPyObj = NULL;
    jobject otherJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "equalElems", "(Lorg/esa/beam/framework/datamodel/ProductData;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equalElems", &otherPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        otherJObj = BPy_ToJObjectT(otherPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, otherJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#equalElems(Lorg/esa/beam/framework/datamodel/ProductData;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductData_Class, "org.esa.beam.framework.datamodel.ProductData", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductData_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductData' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductData#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "<init>", "(FF)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:<init>", &lat, &lon)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_GeoPos_Class, _method, lat, lon);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#<init>(FF)V");
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "getLat", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#getLat()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "getLon", "()F", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallFloatMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#getLon()F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jfloat lat = (jfloat) 0;
    jfloat lon = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "setLocation", "(FF)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ff:setLocation", &lat, &lon)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, lat, lon);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#setLocation(FF)V");
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "isValid", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#isValid()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* aPyObj = NULL;
    jarray aJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "areValid", "([Lorg/esa/beam/framework/datamodel/GeoPos;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:areValid", &aPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        aJObj = BPy_ToJObjectArrayT(aPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_GeoPos_Class, _method, aJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#areValid([Lorg/esa/beam/framework/datamodel/GeoPos;)Z");
    (*jenv)->DeleteLocalRef(jenv, aJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "setInvalid", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#setInvalid()V");
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* objPyObj = NULL;
    jobject objJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &objPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        objJObj = BPy_ToJObjectT(objPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "hashCode", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#hashCode()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "normalize", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#normalize()V");
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    jfloat lon = (jfloat) 0;
    jfloat _result = (jfloat) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "normalizeLon", "(F)F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "f:normalizeLon", &lon)) {
        return NULL;
    }
    _result = (*jenv)->CallStaticFloatMethod(jenv, BPy_GeoPos_Class, _method, lon);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#normalizeLon(F)F");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "getLatString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#getLatString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_GeoPos_Class, "org.esa.beam.framework.datamodel.GeoPos", "getLonString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_GeoPos_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'GeoPos' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.GeoPos#getLonString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_newProductNodeGroup(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "<init>", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:<init>", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ProductNodeGroup_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#<init>(Ljava/lang/String;)V");
    _resultPyObj = BPy_FromJObject(&ProductNodeGroup_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isTakingOverNodeOwnership", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#isTakingOverNodeOwnership()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeCount", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getNodeCount()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(I)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:get", &index)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, index);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#get(I)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeDisplayNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getNodeDisplayNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getNodeNames", "()[Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getNodeNames()[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_indexOfName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Ljava/lang/String;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:indexOf", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#indexOf(Ljava/lang/String;)I");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_indexOf(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elementPyObj = NULL;
    jobject elementJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "indexOf", "(Lorg/esa/beam/framework/datamodel/ProductNode;)I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:indexOf", &elementPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elementJObj = BPy_ToJObjectT(elementPyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method, elementJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#indexOf(Lorg/esa/beam/framework/datamodel/ProductNode;)I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* displayName = NULL;
    jstring displayNameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getByDisplayName", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:getByDisplayName", &displayName)) {
        return NULL;
    }
    displayNameJObj =(*jenv)->NewStringUTF(jenv, displayName);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, displayNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getByDisplayName(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, displayNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_get(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "get", "(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:get", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#get(Ljava/lang/String;)Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_containsName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Ljava/lang/String;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:contains", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#contains(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_contains(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "contains", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:contains", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#contains(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_add(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:add", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#add(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_addAt(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint index = (jint) 0;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "add", "(ILorg/esa/beam/framework/datamodel/ProductNode;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "iO:add", &index, &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, index, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#add(ILorg/esa/beam/framework/datamodel/ProductNode;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* nodePyObj = NULL;
    jobject nodeJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "remove", "(Lorg/esa/beam/framework/datamodel/ProductNode;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:remove", &nodePyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        nodeJObj = BPy_ToJObjectT(nodePyObj, BPy_ProductNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, nodeJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#remove(Lorg/esa/beam/framework/datamodel/ProductNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeAll", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#removeAll()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "clearRemovedList", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#clearRemovedList()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getRemovedNodes", "()Ljava/util/Collection;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getRemovedNodes()Ljava/util/Collection;");
    _resultPyObj = BPy_FromJObject(&Collection_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductNodeGroup_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductNodeGroup_Class, "org.esa.beam.framework.datamodel.ProductNodeGroup", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_ProductNodeGroup_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'ProductNodeGroup' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.ProductNodeGroup#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "<init>", "()V", 0)) {
        return NULL;
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_ProductUtils_Class, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#<init>()V");
    _resultPyObj = BPy_FromJObject(&ProductUtils_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    jboolean assignMissingImageInfos = (jboolean) 0;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createImageInfo", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ObO:createImageInfo", &rastersPyObj, &assignMissingImageInfos, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rastersJObj = BPy_ToJObjectArrayT(rastersPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rastersJObj, assignMissingImageInfos, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createImageInfo([Lorg/esa/beam/framework/datamodel/RasterDataNode;ZLcom/bc/ceres/core/ProgressMonitor;)Lorg/esa/beam/framework/datamodel/ImageInfo;");
    _resultPyObj = BPy_FromJObject(&ImageInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rastersPyObj = NULL;
    jarray rastersJObj = NULL;
    PyObject* imageInfoPyObj = NULL;
    jobject imageInfoJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createRgbImage", "([Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/ImageInfo;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:createRgbImage", &rastersPyObj, &imageInfoPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rastersJObj = BPy_ToJObjectArrayT(rastersPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        imageInfoJObj = BPy_ToJObjectT(imageInfoPyObj, BPy_ImageInfo_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rastersJObj, imageInfoJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createRgbImage([Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/ImageInfo;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, rastersJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rasterDataNodePyObj = NULL;
    jobject rasterDataNodeJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createColorIndexedImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:createColorIndexedImage", &rasterDataNodePyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterDataNodeJObj = BPy_ToJObjectT(rasterDataNodePyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rasterDataNodeJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createColorIndexedImage(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapProjectionPyObj = NULL;
    jobject mapProjectionJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:createSuitableMapInfo", &productPyObj, &rectPyObj, &mapProjectionPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapProjectionJObj = BPy_ToJObjectT(mapProjectionPyObj, BPy_MapProjection_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, mapProjectionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createSuitableMapInfo(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;");
    _resultPyObj = BPy_FromJObject(&MapInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* mapProjectionPyObj = NULL;
    jobject mapProjectionJObj = NULL;
    jdouble orientation = (jdouble) 0;
    jdouble noDataValue = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createSuitableMapInfo", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;DD)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdd:createSuitableMapInfo", &productPyObj, &mapProjectionPyObj, &orientation, &noDataValue)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapProjectionJObj = BPy_ToJObjectT(mapProjectionPyObj, BPy_MapProjection_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, mapProjectionJObj, orientation, noDataValue);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createSuitableMapInfo(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/dataop/maptransf/MapProjection;DD)Lorg/esa/beam/framework/dataop/maptransf/MapInfo;");
    _resultPyObj = BPy_FromJObject(&MapInfo_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    jdouble pixelSizeX = (jdouble) 0;
    jdouble pixelSizeY = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getOutputRasterSize", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;DD)Ljava/awt/Dimension;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOOdd:getOutputRasterSize", &productPyObj, &rectPyObj, &mapTransformPyObj, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, BPy_MapTransform_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, mapTransformJObj, pixelSizeX, pixelSizeY);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getOutputRasterSize(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;DD)Ljava/awt/Dimension;");
    _resultPyObj = BPy_FromJObject(&Dimension_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:createMapEnvelope", &productPyObj, &rectPyObj, &mapTransformPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, BPy_MapTransform_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, mapTransformJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createMapEnvelope(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;Lorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createMapEnvelope", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiO:createMapEnvelope", &productPyObj, &rectPyObj, &step, &mapTransformPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, BPy_MapTransform_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, step, mapTransformJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createMapEnvelope(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* boundaryPyObj = NULL;
    jarray boundaryJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getMinMax", "([Ljava/awt/geom/Point2D;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getMinMax", &boundaryPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        boundaryJObj = BPy_ToJObjectArrayT(boundaryPyObj, BPy_Point2D_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, boundaryJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getMinMax([Ljava/awt/geom/Point2D;)[Ljava/awt/geom/Point2D;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, boundaryJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* mapTransformPyObj = NULL;
    jobject mapTransformJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createMapBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOiO:createMapBoundary", &productPyObj, &rectPyObj, &step, &mapTransformPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        mapTransformJObj = BPy_ToJObjectT(mapTransformPyObj, BPy_MapTransform_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, step, mapTransformJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createMapBoundary(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;ILorg/esa/beam/framework/dataop/maptransf/MapTransform;)[Ljava/awt/geom/Point2D;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:createGeoBoundary", &productPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundary(Lorg/esa/beam/framework/datamodel/Product;I)[Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:createGeoBoundary", &productPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, regionJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundary(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:createGeoBoundary", &productPyObj, &regionPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, regionJObj, step, usePixelCenter);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundary(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:createGeoBoundary", &rasterPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterJObj = BPy_ToJObjectT(rasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rasterJObj, regionJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundary(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createGeoBoundaryPaths", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundaryPaths(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:createGeoBoundaryPaths", &productPyObj, &regionPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, regionJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundaryPaths(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* regionPyObj = NULL;
    jobject regionJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoBoundaryPaths", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:createGeoBoundaryPaths", &productPyObj, &regionPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        regionJObj = BPy_ToJObjectT(regionPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, regionJObj, step, usePixelCenter);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoBoundaryPaths(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:createPixelBoundary", &productPyObj, &rectPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createPixelBoundary(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOib:createPixelBoundary", &productPyObj, &rectPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, rectJObj, step, usePixelCenter);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createPixelBoundary(Lorg/esa/beam/framework/datamodel/Product;Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createPixelBoundary", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOi:createPixelBoundary", &rasterPyObj, &rectPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterJObj = BPy_ToJObjectT(rasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rasterJObj, rectJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createPixelBoundary(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oi:createRectBoundary", &rectPyObj, &step)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rectJObj, step);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createRectBoundary(Ljava/awt/Rectangle;I)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rectPyObj = NULL;
    jobject rectJObj = NULL;
    jint step = (jint) 0;
    jboolean usePixelCenter = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createRectBoundary", "(Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oib:createRectBoundary", &rectPyObj, &step, &usePixelCenter)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rectJObj = BPy_ToJObjectT(rectPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rectJObj, step, usePixelCenter);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createRectBoundary(Ljava/awt/Rectangle;IZ)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyFlagCodings", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyFlagCodings", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceJObj = BPy_ToJObjectT(sourcePyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetJObj = BPy_ToJObjectT(targetPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceJObj, targetJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyFlagCodings(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceFlagCodingPyObj = NULL;
    jobject sourceFlagCodingJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyFlagCoding", "(Lorg/esa/beam/framework/datamodel/FlagCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/FlagCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyFlagCoding", &sourceFlagCodingPyObj, &targetPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceFlagCodingJObj = BPy_ToJObjectT(sourceFlagCodingPyObj, BPy_FlagCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetJObj = BPy_ToJObjectT(targetPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceFlagCodingJObj, targetJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyFlagCoding(Lorg/esa/beam/framework/datamodel/FlagCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/FlagCoding;");
    _resultPyObj = BPy_FromJObject(&FlagCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceIndexCodingPyObj = NULL;
    jobject sourceIndexCodingJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyIndexCoding", "(Lorg/esa/beam/framework/datamodel/IndexCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/IndexCoding;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyIndexCoding", &sourceIndexCodingPyObj, &targetPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceIndexCodingJObj = BPy_ToJObjectT(sourceIndexCodingPyObj, BPy_IndexCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetJObj = BPy_ToJObjectT(targetPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceIndexCodingJObj, targetJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyIndexCoding(Lorg/esa/beam/framework/datamodel/IndexCoding;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/IndexCoding;");
    _resultPyObj = BPy_FromJObject(&IndexCoding_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyMasks(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyOverlayMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyOverlayMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyOverlayMasks(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyRoiMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyRoiMasks", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyRoiMasks", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyRoiMasks(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOb:copyFlagBands", &sourceProductPyObj, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj, copySourceImage);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyFlagBands(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyFlagBands", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyFlagBands", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyFlagBands(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* gridName = NULL;
    jstring gridNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyTiePointGrid", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/TiePointGrid;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:copyTiePointGrid", &gridName, &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    gridNameJObj =(*jenv)->NewStringUTF(jenv, gridName);
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, gridNameJObj, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyTiePointGrid(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/TiePointGrid;");
    _resultPyObj = BPy_FromJObject(&TiePointGrid_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, gridNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand4(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOOb:copyBand", &sourceBandName, &sourceProductPyObj, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj, copySourceImage);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBand(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean copySourceImage = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOsOb:copyBand", &sourceBandName, &sourceProductPyObj, &targetBandName, &targetProductPyObj, &copySourceImage)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj, copySourceImage);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBand(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Z)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceRasterPyObj = NULL;
    jobject sourceRasterJObj = NULL;
    PyObject* targetRasterPyObj = NULL;
    jobject targetRasterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyRasterDataNodeProperties", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/RasterDataNode;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyRasterDataNodeProperties", &sourceRasterPyObj, &targetRasterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceRasterJObj = BPy_ToJObjectT(sourceRasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetRasterJObj = BPy_ToJObjectT(targetRasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceRasterJObj, targetRasterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyRasterDataNodeProperties(Lorg/esa/beam/framework/datamodel/RasterDataNode;Lorg/esa/beam/framework/datamodel/RasterDataNode;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBand3(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOO:copyBand", &sourceBandName, &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceBandNameJObj, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBand(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* sourceBandName = NULL;
    jstring sourceBandNameJObj = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    const char* targetBandName = NULL;
    jstring targetBandNameJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBand", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOsO:copyBand", &sourceBandName, &sourceProductPyObj, &targetBandName, &targetProductPyObj)) {
        return NULL;
    }
    sourceBandNameJObj =(*jenv)->NewStringUTF(jenv, sourceBandName);
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    targetBandNameJObj =(*jenv)->NewStringUTF(jenv, targetBandName);
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceBandNameJObj, sourceProductJObj, targetBandNameJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBand(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;Ljava/lang/String;Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/Band;");
    _resultPyObj = BPy_FromJObject(&Band_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, sourceBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, targetBandNameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceBandPyObj = NULL;
    jobject sourceBandJObj = NULL;
    PyObject* targetBandPyObj = NULL;
    jobject targetBandJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copySpectralBandProperties", "(Lorg/esa/beam/framework/datamodel/Band;Lorg/esa/beam/framework/datamodel/Band;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copySpectralBandProperties", &sourceBandPyObj, &targetBandPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceBandJObj = BPy_ToJObjectT(sourceBandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetBandJObj = BPy_ToJObjectT(targetBandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceBandJObj, targetBandJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copySpectralBandProperties(Lorg/esa/beam/framework/datamodel/Band;Lorg/esa/beam/framework/datamodel/Band;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyGeoCoding", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyGeoCoding", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyGeoCoding(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyTiePointGrids", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyTiePointGrids", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyTiePointGrids(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyVectorData", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyVectorData", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyVectorData(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/Product;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:canGetPixelPos", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#canGetPixelPos(Lorg/esa/beam/framework/datamodel/Product;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "canGetPixelPos", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:canGetPixelPos", &rasterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterJObj = BPy_ToJObjectT(rasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_ProductUtils_Class, _method, rasterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#canGetPixelPos(Lorg/esa/beam/framework/datamodel/RasterDataNode;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* raster1PyObj = NULL;
    jobject raster1JObj = NULL;
    jfloat sampleMin1 = (jfloat) 0;
    jfloat sampleMax1 = (jfloat) 0;
    PyObject* raster2PyObj = NULL;
    jobject raster2JObj = NULL;
    jfloat sampleMin2 = (jfloat) 0;
    jfloat sampleMax2 = (jfloat) 0;
    PyObject* roiMaskPyObj = NULL;
    jobject roiMaskJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* backgroundPyObj = NULL;
    jobject backgroundJObj = NULL;
    PyObject* imagePyObj = NULL;
    jobject imageJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createDensityPlotImage", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/Mask;IILjava/awt/Color;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OffOffOiiOOO:createDensityPlotImage", &raster1PyObj, &sampleMin1, &sampleMax1, &raster2PyObj, &sampleMin2, &sampleMax2, &roiMaskPyObj, &width, &height, &backgroundPyObj, &imagePyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        raster1JObj = BPy_ToJObjectT(raster1PyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        raster2JObj = BPy_ToJObjectT(raster2PyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        roiMaskJObj = BPy_ToJObjectT(roiMaskPyObj, BPy_Mask_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        backgroundJObj = BPy_ToJObjectT(backgroundPyObj, BPy_Color_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        imageJObj = BPy_ToJObjectT(imagePyObj, BPy_BufferedImage_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, raster1JObj, sampleMin1, sampleMax1, raster2JObj, sampleMin2, sampleMax2, roiMaskJObj, width, height, backgroundJObj, imageJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createDensityPlotImage(Lorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/RasterDataNode;FFLorg/esa/beam/framework/datamodel/Mask;IILjava/awt/Color;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* rasterPyObj = NULL;
    jobject rasterJObj = NULL;
    PyObject* overlayBImPyObj = NULL;
    jobject overlayBImJObj = NULL;
    PyObject* pmPyObj = NULL;
    jobject pmJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "overlayMasks", "(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOO:overlayMasks", &rasterPyObj, &overlayBImPyObj, &pmPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        rasterJObj = BPy_ToJObjectT(rasterPyObj, BPy_RasterDataNode_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        overlayBImJObj = BPy_ToJObjectT(overlayBImPyObj, BPy_BufferedImage_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        pmJObj = BPy_ToJObjectT(pmPyObj, BPy_ProgressMonitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, rasterJObj, overlayBImJObj, pmJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#overlayMasks(Lorg/esa/beam/framework/datamodel/RasterDataNode;Ljava/awt/image/BufferedImage;Lcom/bc/ceres/core/ProgressMonitor;)Ljava/awt/image/BufferedImage;");
    _resultPyObj = BPy_FromJObject(&BufferedImage_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getCenterGeoPos", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/GeoPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getCenterGeoPos", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getCenterGeoPos(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/framework/datamodel/GeoPos;");
    _resultPyObj = BPy_FromJObject(&GeoPos_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:normalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_ProductUtils_Class, _method, polygonJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#normalizeGeoPolygon([Lorg/esa/beam/framework/datamodel/GeoPos;)I");
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "normalizeGeoPolygon_old", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:normalizeGeoPolygon_old", &polygonPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_ProductUtils_Class, _method, polygonJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#normalizeGeoPolygon_old([Lorg/esa/beam/framework/datamodel/GeoPos;)I");
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "denormalizeGeoPolygon", "([Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:denormalizeGeoPolygon", &polygonPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, polygonJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#denormalizeGeoPolygon([Lorg/esa/beam/framework/datamodel/GeoPos;)V");
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:denormalizeGeoPos", &geoPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, geoPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#denormalizeGeoPos(Lorg/esa/beam/framework/datamodel/GeoPos;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* geoPosPyObj = NULL;
    jobject geoPosJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "denormalizeGeoPos_old", "(Lorg/esa/beam/framework/datamodel/GeoPos;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:denormalizeGeoPos_old", &geoPosPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoPosJObj = BPy_ToJObjectT(geoPosPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, geoPosJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#denormalizeGeoPos_old(Lorg/esa/beam/framework/datamodel/GeoPos;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getRotationDirection", "([Lorg/esa/beam/framework/datamodel/GeoPos;)I", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getRotationDirection", &polygonPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticIntMethod(jenv, BPy_ProductUtils_Class, _method, polygonJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getRotationDirection([Lorg/esa/beam/framework/datamodel/GeoPos;)I");
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyLong_FromLong(_result);
}

PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* polygonPyObj = NULL;
    jarray polygonJObj = NULL;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getAngleSum", "([Lorg/esa/beam/framework/datamodel/GeoPos;)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getAngleSum", &polygonPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        polygonJObj = BPy_ToJObjectArrayT(polygonPyObj, BPy_GeoPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, BPy_ProductUtils_Class, _method, polygonJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getAngleSum([Lorg/esa/beam/framework/datamodel/GeoPos;)D");
    (*jenv)->DeleteLocalRef(jenv, polygonJObj);
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* geoPathPyObj = NULL;
    jobject geoPathJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "convertToPixelPath", "(Ljava/awt/geom/GeneralPath;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:convertToPixelPath", &geoPathPyObj, &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoPathJObj = BPy_ToJObjectT(geoPathPyObj, BPy_GeneralPath_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, geoPathJObj, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#convertToPixelPath(Ljava/awt/geom/GeneralPath;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* shapePyObj = NULL;
    jobject shapeJObj = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "convertToGeoPath", "(Ljava/awt/Shape;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:convertToGeoPath", &shapePyObj, &geoCodingPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        shapeJObj = BPy_ToJObjectT(shapePyObj, BPy_Shape_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, shapeJObj, geoCodingJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#convertToGeoPath(Ljava/awt/Shape;Lorg/esa/beam/framework/datamodel/GeoCoding;)Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyMetadata", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceJObj = BPy_ToJObjectT(sourcePyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetJObj = BPy_ToJObjectT(targetPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceJObj, targetJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyMetadata(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourcePyObj = NULL;
    jobject sourceJObj = NULL;
    PyObject* targetPyObj = NULL;
    jobject targetJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyMetadata", "(Lorg/esa/beam/framework/datamodel/MetadataElement;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyMetadata", &sourcePyObj, &targetPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceJObj = BPy_ToJObjectT(sourcePyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetJObj = BPy_ToJObjectT(targetPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceJObj, targetJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyMetadata(Lorg/esa/beam/framework/datamodel/MetadataElement;Lorg/esa/beam/framework/datamodel/MetadataElement;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyPreferredTileSize", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:copyPreferredTileSize", &sourceProductPyObj, &targetProductPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyPreferredTileSize(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:createGeoTIFFMetadata", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoTIFFMetadata(Lorg/esa/beam/framework/datamodel/Product;)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;");
    _resultPyObj = BPy_FromJObject(&GeoTIFFMetadata_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* geoCodingPyObj = NULL;
    jobject geoCodingJObj = NULL;
    jint width = (jint) 0;
    jint height = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "createGeoTIFFMetadata", "(Lorg/esa/beam/framework/datamodel/GeoCoding;II)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oii:createGeoTIFFMetadata", &geoCodingPyObj, &width, &height)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        geoCodingJObj = BPy_ToJObjectT(geoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, geoCodingJObj, width, height);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#createGeoTIFFMetadata(Lorg/esa/beam/framework/datamodel/GeoCoding;II)Lorg/esa/beam/util/geotiff/GeoTIFFMetadata;");
    _resultPyObj = BPy_FromJObject(&GeoTIFFMetadata_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* negativeAreaPyObj = NULL;
    jobject negativeAreaJObj = NULL;
    jdouble deltaX = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "areaToPath", "(Ljava/awt/geom/Area;D)Ljava/awt/geom/GeneralPath;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:areaToPath", &negativeAreaPyObj, &deltaX)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        negativeAreaJObj = BPy_ToJObjectT(negativeAreaPyObj, BPy_Area_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, negativeAreaJObj, deltaX);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#areaToPath(Ljava/awt/geom/Area;D)Ljava/awt/geom/GeneralPath;");
    _resultPyObj = BPy_FromJObject(&GeneralPath_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* elemPyObj = NULL;
    jobject elemJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "addElementToHistory", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/MetadataElement;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OO:addElementToHistory", &productPyObj, &elemPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        elemJObj = BPy_ToJObjectT(elemPyObj, BPy_MetadataElement_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, elemJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#addElementToHistory(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/MetadataElement;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "removeInvalidExpressions", "(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeInvalidExpressions", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#removeInvalidExpressions(Lorg/esa/beam/framework/datamodel/Product;)[Ljava/lang/String;");
    _resultPyObj = BPy_FromJStringArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "findSuitableQuicklookBandName", "(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:findSuitableQuicklookBandName", &productPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#findSuitableQuicklookBandName(Lorg/esa/beam/framework/datamodel/Product;)Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceGeoCodingPyObj = NULL;
    jobject sourceGeoCodingJObj = NULL;
    jint sourceWidth = (jint) 0;
    jint sourceHeight = (jint) 0;
    PyObject* destGeoCodingPyObj = NULL;
    jobject destGeoCodingJObj = NULL;
    PyObject* destAreaPyObj = NULL;
    jobject destAreaJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "computeSourcePixelCoordinates", "(Lorg/esa/beam/framework/datamodel/GeoCoding;IILorg/esa/beam/framework/datamodel/GeoCoding;Ljava/awt/Rectangle;)[Lorg/esa/beam/framework/datamodel/PixelPos;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OiiOO:computeSourcePixelCoordinates", &sourceGeoCodingPyObj, &sourceWidth, &sourceHeight, &destGeoCodingPyObj, &destAreaPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceGeoCodingJObj = BPy_ToJObjectT(sourceGeoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        destGeoCodingJObj = BPy_ToJObjectT(destGeoCodingPyObj, BPy_GeoCoding_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        destAreaJObj = BPy_ToJObjectT(destAreaPyObj, BPy_Rectangle_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, sourceGeoCodingJObj, sourceWidth, sourceHeight, destGeoCodingJObj, destAreaJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#computeSourcePixelCoordinates(Lorg/esa/beam/framework/datamodel/GeoCoding;IILorg/esa/beam/framework/datamodel/GeoCoding;Ljava/awt/Rectangle;)[Lorg/esa/beam/framework/datamodel/PixelPos;");
    _resultPyObj = BPy_FromJObjectArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* pixelPositionsPyObj = NULL;
    jarray pixelPositionsJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "computeMinMaxY", "([Lorg/esa/beam/framework/datamodel/PixelPos;)[F", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:computeMinMaxY", &pixelPositionsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        pixelPositionsJObj = BPy_ToJObjectArrayT(pixelPositionsPyObj, BPy_PixelPos_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, pixelPositionsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#computeMinMaxY([Lorg/esa/beam/framework/datamodel/PixelPos;)[F");
    _resultPyObj = BPy_FromJFloatArray((jarray) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, pixelPositionsJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* addedRasterDataNodesPyObj = NULL;
    jobject addedRasterDataNodesJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;DLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OOdO:copyBandsForGeomTransform", &sourceProductPyObj, &targetProductPyObj, &defaultNoDataValue, &addedRasterDataNodesPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        addedRasterDataNodesJObj = BPy_ToJObjectT(addedRasterDataNodesPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj, defaultNoDataValue, addedRasterDataNodesJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBandsForGeomTransform(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;DLjava/util/Map;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* sourceProductPyObj = NULL;
    jobject sourceProductJObj = NULL;
    PyObject* targetProductPyObj = NULL;
    jobject targetProductJObj = NULL;
    jboolean includeTiePointGrids = (jboolean) 0;
    jdouble defaultNoDataValue = (jdouble) 0;
    PyObject* targetToSourceMapPyObj = NULL;
    jobject targetToSourceMapJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "copyBandsForGeomTransform", "(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;ZDLjava/util/Map;)V", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "OObdO:copyBandsForGeomTransform", &sourceProductPyObj, &targetProductPyObj, &includeTiePointGrids, &defaultNoDataValue, &targetToSourceMapPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        sourceProductJObj = BPy_ToJObjectT(sourceProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetProductJObj = BPy_ToJObjectT(targetProductPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    {
        jboolean ok = 1;
        targetToSourceMapJObj = BPy_ToJObjectT(targetToSourceMapPyObj, BPy_Map_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallStaticVoidMethod(jenv, BPy_ProductUtils_Class, _method, sourceProductJObj, targetProductJObj, includeTiePointGrids, defaultNoDataValue, targetToSourceMapJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#copyBandsForGeomTransform(Lorg/esa/beam/framework/datamodel/Product;Lorg/esa/beam/framework/datamodel/Product;ZDLjava/util/Map;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* productPyObj = NULL;
    jobject productJObj = NULL;
    jdouble y = (jdouble) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getScanLineTime", "(Lorg/esa/beam/framework/datamodel/Product;D)Lorg/esa/beam/framework/datamodel/ProductData$UTC;", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Od:getScanLineTime", &productPyObj, &y)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productJObj = BPy_ToJObjectT(productPyObj, BPy_Product_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallStaticObjectMethod(jenv, BPy_ProductUtils_Class, _method, productJObj, y);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getScanLineTime(Lorg/esa/beam/framework/datamodel/Product;D)Lorg/esa/beam/framework/datamodel/ProductData$UTC;");
    _resultPyObj = BPy_FromJObject(&ProductData_UTC_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jdouble _result = (jdouble) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleDouble", "(Lorg/esa/beam/framework/datamodel/Band;III)D", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:getGeophysicalSampleDouble", &bandPyObj, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandJObj = BPy_ToJObjectT(bandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticDoubleMethod(jenv, BPy_ProductUtils_Class, _method, bandJObj, pixelX, pixelY, level);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getGeophysicalSampleDouble(Lorg/esa/beam/framework/datamodel/Band;III)D");
    return PyFloat_FromDouble(_result);
}

PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    PyObject* bandPyObj = NULL;
    jobject bandJObj = NULL;
    jint pixelX = (jint) 0;
    jint pixelY = (jint) 0;
    jint level = (jint) 0;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_ProductUtils_Class, "org.esa.beam.util.ProductUtils", "getGeophysicalSampleLong", "(Lorg/esa/beam/framework/datamodel/Band;III)J", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "Oiii:getGeophysicalSampleLong", &bandPyObj, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        bandJObj = BPy_ToJObjectT(bandPyObj, BPy_Band_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallStaticLongMethod(jenv, BPy_ProductUtils_Class, _method, bandJObj, pixelX, pixelY, level);
    CHECK_JVM_EXCEPTION("org.esa.beam.util.ProductUtils#getGeophysicalSampleLong(Lorg/esa/beam/framework/datamodel/Band;III)J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "<init>", "(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData;Z)V", 0)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "sOb:<init>", &name, &dataPyObj, &readOnly)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->NewObject(jenv, BPy_MetadataAttribute_Class, _method, nameJObj, dataJObj, readOnly);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#<init>(Ljava/lang/String;Lorg/esa/beam/framework/datamodel/ProductData;Z)V");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getParentElement", "()Lorg/esa/beam/framework/datamodel/MetadataElement;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getParentElement()Lorg/esa/beam/framework/datamodel/MetadataElement;");
    _resultPyObj = BPy_FromJObject(&MetadataElement_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* objectPyObj = NULL;
    jobject objectJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "equals", "(Ljava/lang/Object;)Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:equals", &objectPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        objectJObj = BPy_ToJObjectT(objectPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method, objectJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#equals(Ljava/lang/Object;)Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* visitorPyObj = NULL;
    jobject visitorJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "acceptVisitor", "(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:acceptVisitor", &visitorPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        visitorJObj = BPy_ToJObjectT(visitorPyObj, BPy_ProductVisitor_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, visitorJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#acceptVisitor(Lorg/esa/beam/framework/datamodel/ProductVisitor;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "createDeepClone", "()Lorg/esa/beam/framework/datamodel/MetadataAttribute;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#createDeepClone()Lorg/esa/beam/framework/datamodel/MetadataAttribute;");
    _resultPyObj = BPy_FromJObject(&MetadataAttribute_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataType", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getDataType()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "isFloatingPointType", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#isFloatingPointType()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jlong _result = (jlong) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getNumDataElems", "()J", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallLongMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getNumDataElems()J");
    return PyLong_FromLongLong(_result);
}

PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* dataPyObj = NULL;
    jobject dataJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setData", "(Lorg/esa/beam/framework/datamodel/ProductData;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setData", &dataPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        dataJObj = BPy_ToJObjectT(dataPyObj, BPy_ProductData_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, dataJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setData(Lorg/esa/beam/framework/datamodel/ProductData;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getData", "()Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getData()Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* elemsPyObj = NULL;
    jobject elemsJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDataElems", "(Ljava/lang/Object;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:setDataElems", &elemsPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        elemsJObj = BPy_ToJObjectT(elemsPyObj, BPy_Object_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, elemsJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setDataElems(Ljava/lang/Object;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElems", "()Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getDataElems()Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint _result = (jint) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDataElemSize", "()I", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallIntMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getDataElemSize()I");
    return PyLong_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean readOnly = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setReadOnly", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setReadOnly", &readOnly)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, readOnly);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setReadOnly(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "isReadOnly", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#isReadOnly()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* unit = NULL;
    jstring unitJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setUnit", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setUnit", &unit)) {
        return NULL;
    }
    unitJObj =(*jenv)->NewStringUTF(jenv, unit);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, unitJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setUnit(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, unitJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getUnit", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getUnit()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "isSynthetic", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#isSynthetic()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setSynthetic(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean synthetic = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setSynthetic", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setSynthetic", &synthetic)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, synthetic);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setSynthetic(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "fireProductNodeDataChanged", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#fireProductNodeDataChanged()V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "dispose", "()V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#dispose()V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jint numElems = (jint) 0;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "createCompatibleProductData", "(I)Lorg/esa/beam/framework/datamodel/ProductData;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "i:createCompatibleProductData", &numElems)) {
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, numElems);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#createCompatibleProductData(I)Lorg/esa/beam/framework/datamodel/ProductData;");
    _resultPyObj = BPy_FromJObject(&ProductData_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getOwner", "()Lorg/esa/beam/framework/datamodel/ProductNode;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getOwner()Lorg/esa/beam/framework/datamodel/ProductNode;");
    _resultPyObj = BPy_FromJObject(&ProductNode_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setName", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setName(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDescription", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getDescription()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* description = NULL;
    jstring descriptionJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setDescription", "(Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:setDescription", &description)) {
        return NULL;
    }
    descriptionJObj =(*jenv)->NewStringUTF(jenv, description);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, descriptionJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setDescription(Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, descriptionJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "isModified", "()Z", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _result = (*jenv)->CallBooleanMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#isModified()Z");
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    jboolean modified = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "setModified", "(Z)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "b:setModified", &modified)) {
        return NULL;
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, modified);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#setModified(Z)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "toString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#toString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    const char* name = NULL;
    jstring nameJObj = NULL;
    jboolean _result = (jboolean) 0;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "isValidNodeName", "(Ljava/lang/String;)Z", 1)) {
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "s:isValidNodeName", &name)) {
        return NULL;
    }
    nameJObj =(*jenv)->NewStringUTF(jenv, name);
    _result = (*jenv)->CallStaticBooleanMethod(jenv, BPy_MetadataAttribute_Class, _method, nameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#isValidNodeName(Ljava/lang/String;)Z");
    (*jenv)->DeleteLocalRef(jenv, nameJObj);
    return PyBool_FromLong(_result);
}

PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProduct", "()Lorg/esa/beam/framework/datamodel/Product;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getProduct()Lorg/esa/beam/framework/datamodel/Product;");
    _resultPyObj = BPy_FromJObject(&Product_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductReader", "()Lorg/esa/beam/framework/dataio/ProductReader;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getProductReader()Lorg/esa/beam/framework/dataio/ProductReader;");
    _resultPyObj = BPy_FromJObject(&ProductReader_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductWriter", "()Lorg/esa/beam/framework/dataio/ProductWriter;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getProductWriter()Lorg/esa/beam/framework/dataio/ProductWriter;");
    _resultPyObj = BPy_FromJObject(&ProductWriter_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getDisplayName", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getDisplayName()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getProductRefString", "()Ljava/lang/String;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getProductRefString()Ljava/lang/String;");
    _resultPyObj = BPy_FromJString((jstring) _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}

PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    const char* oldExternalName = NULL;
    jstring oldExternalNameJObj = NULL;
    const char* newExternalName = NULL;
    jstring newExternalNameJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "updateExpression", "(Ljava/lang/String;Ljava/lang/String;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "ss:updateExpression", &oldExternalName, &newExternalName)) {
        return NULL;
    }
    oldExternalNameJObj =(*jenv)->NewStringUTF(jenv, oldExternalName);
    newExternalNameJObj =(*jenv)->NewStringUTF(jenv, newExternalName);
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, oldExternalNameJObj, newExternalNameJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#updateExpression(Ljava/lang/String;Ljava/lang/String;)V");
    (*jenv)->DeleteLocalRef(jenv, oldExternalNameJObj);
    (*jenv)->DeleteLocalRef(jenv, newExternalNameJObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* productWriterPyObj = NULL;
    jobject productWriterJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "removeFromFile", "(Lorg/esa/beam/framework/dataio/ProductWriter;)V", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:removeFromFile", &productWriterPyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        productWriterJObj = BPy_ToJObjectT(productWriterPyObj, BPy_ProductWriter_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    (*jenv)->CallVoidMethod(jenv, _thisJObj, _method, productWriterJObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#removeFromFile(Lorg/esa/beam/framework/dataio/ProductWriter;)V");
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getExtension(PyObject* self, PyObject* args)
{
    static jmethodID _method = NULL;
    
    jobject _thisJObj = NULL;
    PyObject* arg0PyObj = NULL;
    jobject arg0JObj = NULL;
    PyObject* _resultPyObj = NULL;
    jobject _resultJObj = NULL;
    if (!BPy_InitApi()) {
        return NULL;
    }
    if (!BPy_InitJMethod(&_method, BPy_MetadataAttribute_Class, "org.esa.beam.framework.datamodel.MetadataAttribute", "getExtension", "(Ljava/lang/Class;)Ljava/lang/Object;", 0)) {
        return NULL;
    }
    _thisJObj = JObject_AsJObjectRefT(self, BPy_MetadataAttribute_Class);
    if (_thisJObj == NULL) {
        PyErr_SetString(PyExc_ValueError, "argument 'self' must be of type 'MetadataAttribute' (Java object reference)");
        return NULL;
    }
    if (!PyArg_ParseTuple(args, "O:getExtension", &arg0PyObj)) {
        return NULL;
    }
    {
        jboolean ok = 1;
        arg0JObj = BPy_ToJObjectT(arg0PyObj, BPy_Class_Class, &ok);
        if (!ok) {
            return NULL;
        }
    }
    _resultJObj = (*jenv)->CallObjectMethod(jenv, _thisJObj, _method, arg0JObj);
    CHECK_JVM_EXCEPTION("org.esa.beam.framework.datamodel.MetadataAttribute#getExtension(Ljava/lang/Class;)Ljava/lang/Object;");
    _resultPyObj = BPy_FromJObject(&Object_Type, _resultJObj);
    (*jenv)->DeleteLocalRef(jenv, _resultJObj);
    return _resultPyObj;
}



/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * This code has been generated using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */

#include "beampy.h"
#include "beam_capi.h"
#include "python.h"

static PyObject* BeamPy_Error;

boolean* beam_new_boolean_array_from_pyseq(PyObject* seq, int* length);
char* beam_new_char_array_from_pyseq(PyObject* seq, int* length);
byte* beam_new_byte_array_from_pyseq(PyObject* seq, int* length);
short* beam_new_short_array_from_pyseq(PyObject* seq, int* length);
int* beam_new_int_array_from_pyseq(PyObject* seq, int* length);
dlong* beam_new_dlong_array_from_pyseq(PyObject* seq, int* length);
float* beam_new_float_array_from_pyseq(PyObject* seq, int* length);
double* beam_new_double_array_from_pyseq(PyObject* seq, int* length);
char** beam_new_string_array_from_pyseq(PyObject* seq, int* length);
void** beam_new_jobject_array_from_pyseq(const char* type, PyObject* seq, int* length);

PyObject* beam_new_pyseq_from_boolean_array(const boolean* elems, int length);
PyObject* beam_new_pyseq_from_char_array(const char* elems, int length);
PyObject* beam_new_pyseq_from_byte_array(const byte* elems, int length);
PyObject* beam_new_pyseq_from_short_array(const short* elems, int length);
PyObject* beam_new_pyseq_from_int_array(const int* elems, int length);
PyObject* beam_new_pyseq_from_dlong_array(const dlong* elems, int length);
PyObject* beam_new_pyseq_from_float_array(const float* elems, int length);
PyObject* beam_new_pyseq_from_double_array(const double* elems, int length);
PyObject* beam_new_pyseq_from_string_array(const char** elems, int length);
PyObject* beam_new_pyseq_from_jobject_array(const char* type, const void* elems, int length);

/* Extra global functions for beampy. These will also go into the module definition. */
PyObject* BeamPyString_newString(PyObject* self, PyObject* args);




PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args);
PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args);
PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGroups(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getNumResolutionsMax(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setNumResolutionsMax(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createProjectedProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args);
PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args);
PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args);
PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args);
PyObject* BeamPyImageGeometry_createValidRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args);
PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_toString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readRasterDataFully(PyObject* self, PyObject* args);
PyObject* BeamPyBand_readRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args);
PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scale(PyObject* self, PyObject* args);
PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args);
PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args);
PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args);
PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args);
PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args);
PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_newProductNodeGroup1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_newProductNodeGroup2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_get1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toArray1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toArray2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOf2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_indexOf1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_get2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_contains2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_contains1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_add2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_add1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRawStorageSize2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_getRawStorageSize1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_fireProductNodeChanged1(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_fireProductNodeChanged2(PyObject* self, PyObject* args);
PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getClosestGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyFlagBands(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args);
PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args);
PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args);


static PyMethodDef BeamPy_Methods[] = {
    {"GeoCoding_canGetPixelPos", BeamPyGeoCoding_canGetPixelPos, METH_VARARGS, " Checks whether or not this geo-coding can determine the pixel position from a geodetic position.\n\n @return <code>true</code>, if so\n\n@param this The GeoCoding object."},
    {"GeoCoding_canGetGeoPos", BeamPyGeoCoding_canGetGeoPos, METH_VARARGS, " Checks whether or not this geo-coding can determine the geodetic position from a pixel position.\n\n @return <code>true</code>, if so\n\n@param this The GeoCoding object."},
    {"GeoCoding_getPixelPos", BeamPyGeoCoding_getPixelPos, METH_VARARGS, " Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.\n\n \n@param this The GeoCoding object.\n@param geoPos   the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\n @param pixelPos an instance of <code>Point</code> to be used as retun value. If this parameter is\n                 <code>null</code>, the method creates a new instance which it then returns.\n\n @return the pixel co-ordinates as x/y\n"},
    {"GeoCoding_getGeoPos", BeamPyGeoCoding_getGeoPos, METH_VARARGS, " Returns the latitude and longitude value for a given pixel co-ordinate.\n\n \n@param this The GeoCoding object.\n@param pixelPos the pixel's co-ordinates given as x,y\n @param geoPos   an instance of <code>GeoPos</code> to be used as retun value. If this parameter is\n                 <code>null</code>, the method creates a new instance which it then returns.\n\n @return the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}\n"},
    {"GeoCoding_dispose", BeamPyGeoCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getImageCRS", BeamPyGeoCoding_getImageCRS, METH_VARARGS, " @return The image coordinate reference system (CRS). It is usually derived from the base CRS by including\n         a linear or non-linear transformation from base (geodetic) coordinates to image coordinates.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getMapCRS", BeamPyGeoCoding_getMapCRS, METH_VARARGS, " @return The map coordinate reference system (CRS). It may be either a geographical CRS (nominal case is\n         \"WGS-84\") or a derived projected CRS, e.g. \"UTM 32 - North\".\n\n@param this The GeoCoding object."},
    {"GeoCoding_getGeoCRS", BeamPyGeoCoding_getGeoCRS, METH_VARARGS, " @return The geographical coordinate reference system (CRS). It may be either \"WGS-84\" (nominal case) or\n         any other geographical CRS.\n\n@param this The GeoCoding object."},
    {"GeoCoding_getImageToMapTransform", BeamPyGeoCoding_getImageToMapTransform, METH_VARARGS, " @return The math transformation used to convert image coordinates to map coordinates.\n\n@param this The GeoCoding object."},
    {"ProductWriter_getWriterPlugIn", BeamPyProductWriter_getWriterPlugIn, METH_VARARGS, " Returns the plug-in which created this product writer.\n\n @return the product writer plug-in, should never be <code>null</code>\n\n@param this The ProductWriter object."},
    {"ProductWriter_getOutput", BeamPyProductWriter_getOutput, METH_VARARGS, " Retrives the current output destination object. Thie return value might be <code>null</code> if the\n <code>setOutput</code> has not been called so far.\n\n @return the output\n\n@param this The ProductWriter object."},
    {"ProductWriter_writeProductNodes", BeamPyProductWriter_writeProductNodes, METH_VARARGS, " Writes the in-memory representation of a data product.\n <p/>\n <p> Whether the band data - the actual pixel values - is written out immediately or later when pixels are\n flushed, is up to the implementation.\n\n \n@param this The ProductWriter object.\n@param product the in-memory representation of the data product\n @param output  an object representing a valid output for this writer, might be a <code>ImageInputStream</code> or\n                other <code>Object</code> to use for future decoding.\n\n @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is not one of the\n                                  supported output sources.\n @throws IOException              if an I/O error occurs\n"},
    {"ProductWriter_writeBandRasterData", BeamPyProductWriter_writeBandRasterData, METH_VARARGS, " Writes raster data from the given in-memory source buffer into the data sink specified by the given source band\n and region.\n <p/>\n <h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample\n values given in the source buffer. The method does not modify the pixel data of the given source band at all.\n <p/>\n <h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>\n and <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data\n and <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be\n <code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in\n line-by-line order, so the raster X co-ordinate varies faster than the Y.\n <p/>\n <h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,\n <code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the\n source band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates\n since product writers do not support spectral or spatial subsets.\n\n \n@param this The ProductWriter object.\n@param sourceBand    the source band which identifies the data sink to which to write the sample values\n @param sourceOffsetX the X-offset in the band's raster co-ordinates\n @param sourceOffsetY the Y-offset in the band's raster co-ordinates\n @param sourceWidth   the width of region to be written given in the band's raster co-ordinates\n @param sourceHeight  the height of region to be written given in the band's raster co-ordinates\n @param sourceBuffer  the source buffer which provides the sample values to be written\n @param pm            a monitor to inform the user about progress\n\n @throws IOException              if an I/O error occurs\n @throws IllegalArgumentException if the number of elements source buffer not equals <code>sourceWidth *\n                                  sourceHeight</code> or the source region is out of the band's raster\n @see org.esa.beam.framework.datamodel.Band#getRasterWidth()\n @see org.esa.beam.framework.datamodel.Band#getRasterHeight()\n"},
    {"ProductWriter_flush", BeamPyProductWriter_flush, METH_VARARGS, " Writes all data in memory to the data sink(s) associated with this writer.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_close", BeamPyProductWriter_close, METH_VARARGS, " Closes all output streams currently open. A concrete implementation should call <code>flush</code> before\n performing the actual close-operation.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_shouldWrite", BeamPyProductWriter_shouldWrite, METH_VARARGS, " Returns wether the given product node is to be written.\n\n \n@param this The ProductWriter object.\n@param node the product node\n\n @return <code>true</code> if so\n"},
    {"ProductWriter_isIncrementalMode", BeamPyProductWriter_isIncrementalMode, METH_VARARGS, " Returns whether this product writer writes only modified product nodes.\n\n @return <code>true</code> if so\n\n@param this The ProductWriter object."},
    {"ProductWriter_setIncrementalMode", BeamPyProductWriter_setIncrementalMode, METH_VARARGS, " Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress\n listening.\n\n \n@param this The ProductWriter object.\n@param enabled enables or disables progress listening.\n"},
    {"ProductWriter_deleteOutput", BeamPyProductWriter_deleteOutput, METH_VARARGS, " Complete deletes the physical representation of the given product from the file system.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductWriter object."},
    {"ProductWriter_removeBand", BeamPyProductWriter_removeBand, METH_VARARGS, " Physically deletes a <code>Band</code> in a product writer's output.\n\n \n@param this The ProductWriter object.\n@param band The band to delete.\n"},
    {"IndexCoding_newIndexCoding", BeamPyIndexCoding_newIndexCoding, METH_VARARGS, " Constructs a new index coding object with the given name.\n\n @param name the name\n"},
    {"IndexCoding_getIndex", BeamPyIndexCoding_getIndex, METH_VARARGS, " Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to\n getPropertyValue(String).\n\n \n@param this The IndexCoding object.\n@param name the flag name\n @return a metadata attribute wich is the representation of the flag with the given name\n"},
    {"IndexCoding_getIndexNames", BeamPyIndexCoding_getIndexNames, METH_VARARGS, " Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.\n\n @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned\n\n@param this The IndexCoding object."},
    {"IndexCoding_addIndex", BeamPyIndexCoding_addIndex, METH_VARARGS, " Adds a new index definition to this flags coding.\n\n \n@param this The IndexCoding object.\n@param name        the index name\n @param value       the index value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded index. \n"},
    {"IndexCoding_getIndexValue", BeamPyIndexCoding_getIndexValue, METH_VARARGS, " Returns the flag mask value for the specified flag name.\n\n \n@param this The IndexCoding object.\n@param name the flag name\n @return flagMask the flag's bit mask as a 32 bit integer\n @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist\n"},
    {"IndexCoding_acceptVisitor", BeamPyIndexCoding_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The IndexCoding object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"IndexCoding_addElement", BeamPyIndexCoding_addElement, METH_VARARGS, " Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\n because flag codings do not support inner elements.\n\n \n@param this The IndexCoding object.\n@param element the element to be added, always ignored\n"},
    {"IndexCoding_addAttribute", BeamPyIndexCoding_addAttribute, METH_VARARGS, " Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n\n \n@param this The IndexCoding object.\n@param attribute the attribute to be added\n @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value\n"},
    {"IndexCoding_addSample", BeamPyIndexCoding_addSample, METH_VARARGS, " Adds a new coding value to this sample coding.\n\n \n@param this The IndexCoding object.\n@param name        the coding name\n @param value       the value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded sample.\n"},
    {"IndexCoding_getSampleCount", BeamPyIndexCoding_getSampleCount, METH_VARARGS, " Gets the number of coded sample values.\n\n @return the number of coded sample values\n\n@param this The IndexCoding object."},
    {"IndexCoding_getSampleName", BeamPyIndexCoding_getSampleName, METH_VARARGS, " Gets the sample name at the specified attribute index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index.\n @return the sample name.\n"},
    {"IndexCoding_getSampleValue", BeamPyIndexCoding_getSampleValue, METH_VARARGS, " Gets the sample value at the specified attribute index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index.\n @return the sample value.\n"},
    {"IndexCoding_getElementGroup", BeamPyIndexCoding_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n @return The child element group, may be null.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getParentElement", BeamPyIndexCoding_getParentElement, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_addElementAt", BeamPyIndexCoding_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The IndexCoding object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"IndexCoding_removeElement", BeamPyIndexCoding_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The IndexCoding object.\n@param element the element to be removed, ignored if <code>null</code>\n @return true, if so\n"},
    {"IndexCoding_getNumElements", BeamPyIndexCoding_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElementAt", BeamPyIndexCoding_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The IndexCoding object.\n@param index the element index\n @return the element at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"IndexCoding_getElementNames", BeamPyIndexCoding_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElements", BeamPyIndexCoding_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getElement", BeamPyIndexCoding_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The IndexCoding object.\n@param name the element name\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"IndexCoding_containsElement", BeamPyIndexCoding_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The IndexCoding object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"IndexCoding_getElementIndex", BeamPyIndexCoding_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n \n@param this The IndexCoding object.\n@param element  The element .\n @return The element's index, or -1.\n @since BEAM 4.7\n"},
    {"IndexCoding_removeAttribute", BeamPyIndexCoding_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The IndexCoding object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n @return <code>true</code> if it was removed\n"},
    {"IndexCoding_getNumAttributes", BeamPyIndexCoding_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttributeAt", BeamPyIndexCoding_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The IndexCoding object.\n@param index the attribute index\n @return the attribute, or <code>null</code> if this node does not contain attributes\n @throws IndexOutOfBoundsException\n"},
    {"IndexCoding_getAttributeNames", BeamPyIndexCoding_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttributes", BeamPyIndexCoding_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getAttribute", BeamPyIndexCoding_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The IndexCoding object.\n@param name the attribute name\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"IndexCoding_containsAttribute", BeamPyIndexCoding_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The IndexCoding object.\n@param name the attribute name\n @return <code>true</code> if so\n"},
    {"IndexCoding_getAttributeIndex", BeamPyIndexCoding_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n \n@param this The IndexCoding object.\n@param attribute  The attribute.\n @return The attribute's index, or -1.\n @since BEAM 4.7\n"},
    {"IndexCoding_getAttributeDouble", BeamPyIndexCoding_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as double.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"IndexCoding_getAttributeUTC", BeamPyIndexCoding_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as UTC.\n"},
    {"IndexCoding_getAttributeInt", BeamPyIndexCoding_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"IndexCoding_setAttributeInt", BeamPyIndexCoding_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setAttributeDouble", BeamPyIndexCoding_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setAttributeUTC", BeamPyIndexCoding_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_getAttributeString", BeamPyIndexCoding_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The IndexCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n"},
    {"IndexCoding_setAttributeString", BeamPyIndexCoding_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The IndexCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"IndexCoding_setModified", BeamPyIndexCoding_setModified, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_createDeepClone", BeamPyIndexCoding_createDeepClone, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_dispose", BeamPyIndexCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getOwner", BeamPyIndexCoding_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The IndexCoding object."},
    {"IndexCoding_getName", BeamPyIndexCoding_getName, METH_VARARGS, " @return This node's name.\n\n@param this The IndexCoding object."},
    {"IndexCoding_setName", BeamPyIndexCoding_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The IndexCoding object.\n@param name The name.\n"},
    {"IndexCoding_getDescription", BeamPyIndexCoding_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The IndexCoding object."},
    {"IndexCoding_setDescription", BeamPyIndexCoding_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The IndexCoding object.\n@param description a description, can be <code>null</code>\n"},
    {"IndexCoding_isModified", BeamPyIndexCoding_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The IndexCoding object."},
    {"IndexCoding_toString", BeamPyIndexCoding_toString, METH_VARARGS, "\n@param this The IndexCoding object."},
    {"IndexCoding_isValidNodeName", BeamPyIndexCoding_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"IndexCoding_getProduct", BeamPyIndexCoding_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductReader", BeamPyIndexCoding_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductWriter", BeamPyIndexCoding_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The IndexCoding object."},
    {"IndexCoding_getDisplayName", BeamPyIndexCoding_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The IndexCoding object."},
    {"IndexCoding_getProductRefString", BeamPyIndexCoding_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The IndexCoding object."},
    {"IndexCoding_updateExpression", BeamPyIndexCoding_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The IndexCoding object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"IndexCoding_removeFromFile", BeamPyIndexCoding_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The IndexCoding object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"PixelPos_newPixelPos1", BeamPyPixelPos_newPixelPos1, METH_VARARGS, " Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0).\n"},
    {"PixelPos_newPixelPos2", BeamPyPixelPos_newPixelPos2, METH_VARARGS, " Constructs and initializes a <code>PixelPos</code> with the specified coordinate.\n\n @param x the x component of the coordinate\n @param y the y component of the coordinate\n"},
    {"PixelPos_isValid", BeamPyPixelPos_isValid, METH_VARARGS, " Tests whether or not this pixel position is valid.\n\n @return true, if so\n\n@param this The PixelPos object."},
    {"PixelPos_setInvalid", BeamPyPixelPos_setInvalid, METH_VARARGS, " Sets this pixel position so that is becomes invalid.\n\n@param this The PixelPos object."},
    {"PixelPos_getX", BeamPyPixelPos_getX, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_getY", BeamPyPixelPos_getY, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation1", BeamPyPixelPos_setLocation1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation2", BeamPyPixelPos_setLocation2, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_toString", BeamPyPixelPos_toString, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_setLocation3", BeamPyPixelPos_setLocation3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distanceSq2", BeamPyPixelPos_distanceSq2, METH_VARARGS, ""},
    {"PixelPos_distance2", BeamPyPixelPos_distance2, METH_VARARGS, ""},
    {"PixelPos_distanceSq1", BeamPyPixelPos_distanceSq1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distanceSq3", BeamPyPixelPos_distanceSq3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distance1", BeamPyPixelPos_distance1, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_distance3", BeamPyPixelPos_distance3, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_clone", BeamPyPixelPos_clone, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_hashCode", BeamPyPixelPos_hashCode, METH_VARARGS, "\n@param this The PixelPos object."},
    {"PixelPos_equals", BeamPyPixelPos_equals, METH_VARARGS, "\n@param this The PixelPos object."},
    {"ProductIO_getProductReader", BeamPyProductIO_getProductReader, METH_VARARGS, " Gets a product reader for the given format name.\n\n @param formatName the product format name\n @return a suitable product reader or <code>null</code> if none was found\n"},
    {"ProductIO_getProductWriterExtensions", BeamPyProductIO_getProductWriterExtensions, METH_VARARGS, " Gets an array of writer product file extensions for the given format name.\n\n @param formatName the format name\n @return an array of extensions or null if the format does not exist\n"},
    {"ProductIO_getProductWriter", BeamPyProductIO_getProductWriter, METH_VARARGS, " Gets a product writer for the given format name.\n\n @param formatName the product format name\n @return a suitable product writer or <code>null</code> if none was found\n"},
    {"ProductIO_readProduct", BeamPyProductIO_readProduct, METH_VARARGS, " Reads the data product specified by the given file path.\n <p>The product returned will be associated with the reader appropriate for the given\n file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>\n <p>The method does not automatically read band data, thus\n {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null\n for all bands in the product returned by this method.</p>\n\n @param filePath the data product file path\n @return a data model as an in-memory representation of the given product file or <code>null</code> if no\n         appropriate reader was found for the given product file\n @throws IOException if an I/O error occurs\n @see #readProduct(File)\n"},
    {"ProductIO_getProductReaderForInput", BeamPyProductIO_getProductReaderForInput, METH_VARARGS, " Tries to find a product reader instance suitable for the given input.\n The method returns {@code null}, if no\n registered product reader can handle the given {@code input} value.\n <p/>\n The {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or\n {@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.\n\n @param input the input object.\n @return a product reader for the given {@code input} or {@code null} if no registered reader can handle\n         the it.\n @see ProductReaderPlugIn#getDecodeQualification(Object)\n @see ProductReader#readProductNodes(Object, ProductSubsetDef)\n"},
    {"ProductIO_writeProduct", BeamPyProductIO_writeProduct, METH_VARARGS, " Writes a product with the specified format to the given file path.\n <p>The method also writes all band data to the file. Therefore the band data must either\n <ld>\n <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>\n <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>\n </ld>.\n\n @param product    the product, must not be <code>null</code>\n @param filePath   the file path\n @param formatName the name of a supported product format, e.g. \"HDF5\". If <code>null</code>, the default format\n                   \"BEAM-DIMAP\" will be used\n @throws IOException if an IOException occurs\n"},
    {"Placemark_newPlacemark", BeamPyPlacemark_newPlacemark, METH_VARARGS, " Constructor.\n\n @param descriptor The placemark descriptor that created this placemark.\n @param feature    The wrapped feature.\n"},
    {"Placemark_createPointPlacemark", BeamPyPlacemark_createPointPlacemark, METH_VARARGS, " Creates a point placemark.\n\n @param descriptor The placemark descriptor that created this placemark.\n @param name       The placemark's name.\n @param label      The placemark's label. May be {@code null}.\n @param text       The placemark's (XHTML) text. May be {@code null}.\n @param pixelPos   The placemark's pixel position. May be {@code null}, if {@code geoPos} is given.\n @param geoPos     The placemark's pixel position. May be {@code null}, if {@code pixelPos} is given.\n @param geoCoding  The placemark's geo-coding. Used to compute {@code pixelPos} from {@code geoPos}, if {@code pixelPos} is {@code null}.\n @return A new point placemark.\n"},
    {"Placemark_getDescriptor", BeamPyPlacemark_getDescriptor, METH_VARARGS, " @return The placemark descriptor that created this placemark.\n @since BEAM 4.10\n\n@param this The Placemark object."},
    {"Placemark_getFeature", BeamPyPlacemark_getFeature, METH_VARARGS, " @return The wrapped {@link SimpleFeature} underlying this placemark.\n @since BEAM 4.7\n\n@param this The Placemark object."},
    {"Placemark_getAttributeValue", BeamPyPlacemark_getAttributeValue, METH_VARARGS, " Gets the attribute value of the underlying feature.\n\n \n@param this The Placemark object.\n@param attributeName The feature's attribute name.\n @return The feature's attribute value, may be {@code null}.\n"},
    {"Placemark_setAttributeValue", BeamPyPlacemark_setAttributeValue, METH_VARARGS, " Sets the attribute value of the underlying feature.\n\n \n@param this The Placemark object.\n@param attributeName  The feature's attribute name.\n @param attributeValue The feature's attribute value, may be {@code null}.\n"},
    {"Placemark_setLabel", BeamPyPlacemark_setLabel, METH_VARARGS, " Sets this placemark's label.\n\n \n@param this The Placemark object.\n@param label the label, if {@code null} an empty label is set.\n"},
    {"Placemark_getLabel", BeamPyPlacemark_getLabel, METH_VARARGS, " @return This placemark's label, cannot be {@code null}.\n\n@param this The Placemark object."},
    {"Placemark_setText", BeamPyPlacemark_setText, METH_VARARGS, " Sets this placemark's (XHTML) text.\n\n \n@param this The Placemark object.\n@param text The text, if {@code null} an empty text is set.\n"},
    {"Placemark_getText", BeamPyPlacemark_getText, METH_VARARGS, " @return This placemark's (XHTML) text, cannot be {@code null}.\n\n@param this The Placemark object."},
    {"Placemark_setStyleCss", BeamPyPlacemark_setStyleCss, METH_VARARGS, " Sets this placemark's CSS style.\n\n \n@param this The Placemark object.\n@param styleCss The text, if {@code null} an empty text is set.\n @since BEAM 4.10\n"},
    {"Placemark_getStyleCss", BeamPyPlacemark_getStyleCss, METH_VARARGS, " @return This placemark's CSS style, cannot be {@code null}.\n @since BEAM 4.10\n\n@param this The Placemark object."},
    {"Placemark_acceptVisitor", BeamPyPlacemark_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n\n \n@param this The Placemark object.\n@param visitor the visitor\n"},
    {"Placemark_getPixelPos", BeamPyPlacemark_getPixelPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_setPixelPos", BeamPyPlacemark_setPixelPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_getGeoPos", BeamPyPlacemark_getGeoPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_setGeoPos", BeamPyPlacemark_setGeoPos, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_updatePositions", BeamPyPlacemark_updatePositions, METH_VARARGS, " Updates pixel and geo position according to the current geometry (model coordinates).\n\n@param this The Placemark object."},
    {"Placemark_createPinFeatureType", BeamPyPlacemark_createPinFeatureType, METH_VARARGS, ""},
    {"Placemark_createGcpFeatureType", BeamPyPlacemark_createGcpFeatureType, METH_VARARGS, ""},
    {"Placemark_createGeometryFeatureType", BeamPyPlacemark_createGeometryFeatureType, METH_VARARGS, ""},
    {"Placemark_createPointFeatureType", BeamPyPlacemark_createPointFeatureType, METH_VARARGS, ""},
    {"Placemark_getOwner", BeamPyPlacemark_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Placemark object."},
    {"Placemark_getName", BeamPyPlacemark_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Placemark object."},
    {"Placemark_setName", BeamPyPlacemark_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Placemark object.\n@param name The name.\n"},
    {"Placemark_getDescription", BeamPyPlacemark_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Placemark object."},
    {"Placemark_setDescription", BeamPyPlacemark_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Placemark object.\n@param description a description, can be <code>null</code>\n"},
    {"Placemark_isModified", BeamPyPlacemark_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Placemark object."},
    {"Placemark_setModified", BeamPyPlacemark_setModified, METH_VARARGS, " Sets this node's modified flag.\n <p/>\n If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\n true.\n\n \n@param this The Placemark object.\n@param modified whether or not this node is beeing marked as modified.\n @see org.esa.beam.framework.datamodel.Product#fireNodeChanged\n"},
    {"Placemark_toString", BeamPyPlacemark_toString, METH_VARARGS, "\n@param this The Placemark object."},
    {"Placemark_dispose", BeamPyPlacemark_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The Placemark object."},
    {"Placemark_isValidNodeName", BeamPyPlacemark_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Placemark_getProduct", BeamPyPlacemark_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Placemark object."},
    {"Placemark_getProductReader", BeamPyPlacemark_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The Placemark object."},
    {"Placemark_getProductWriter", BeamPyPlacemark_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The Placemark object."},
    {"Placemark_getDisplayName", BeamPyPlacemark_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Placemark object."},
    {"Placemark_getProductRefString", BeamPyPlacemark_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Placemark object."},
    {"Placemark_updateExpression", BeamPyPlacemark_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The Placemark object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"Placemark_removeFromFile", BeamPyPlacemark_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The Placemark object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"MetadataElement_newMetadataElement", BeamPyMetadataElement_newMetadataElement, METH_VARARGS, " Constructs a new metadata element.\n\n @param name the element name\n"},
    {"MetadataElement_getElementGroup", BeamPyMetadataElement_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n @return The child element group, may be null.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getParentElement", BeamPyMetadataElement_getParentElement, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_addElement", BeamPyMetadataElement_addElement, METH_VARARGS, " Adds the given element to this element.\n\n \n@param this The MetadataElement object.\n@param element the element to added, ignored if <code>null</code>\n"},
    {"MetadataElement_addElementAt", BeamPyMetadataElement_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The MetadataElement object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"MetadataElement_removeElement", BeamPyMetadataElement_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The MetadataElement object.\n@param element the element to be removed, ignored if <code>null</code>\n @return true, if so\n"},
    {"MetadataElement_getNumElements", BeamPyMetadataElement_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElementAt", BeamPyMetadataElement_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The MetadataElement object.\n@param index the element index\n @return the element at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"MetadataElement_getElementNames", BeamPyMetadataElement_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElements", BeamPyMetadataElement_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getElement", BeamPyMetadataElement_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The MetadataElement object.\n@param name the element name\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"MetadataElement_containsElement", BeamPyMetadataElement_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The MetadataElement object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"MetadataElement_getElementIndex", BeamPyMetadataElement_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n \n@param this The MetadataElement object.\n@param element  The element .\n @return The element's index, or -1.\n @since BEAM 4.7\n"},
    {"MetadataElement_addAttribute", BeamPyMetadataElement_addAttribute, METH_VARARGS, " Adds an attribute to this node.\n\n \n@param this The MetadataElement object.\n@param attribute the attribute to be added, <code>null</code> is ignored\n"},
    {"MetadataElement_removeAttribute", BeamPyMetadataElement_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The MetadataElement object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n @return <code>true</code> if it was removed\n"},
    {"MetadataElement_getNumAttributes", BeamPyMetadataElement_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttributeAt", BeamPyMetadataElement_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The MetadataElement object.\n@param index the attribute index\n @return the attribute, or <code>null</code> if this node does not contain attributes\n @throws IndexOutOfBoundsException\n"},
    {"MetadataElement_getAttributeNames", BeamPyMetadataElement_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttributes", BeamPyMetadataElement_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getAttribute", BeamPyMetadataElement_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The MetadataElement object.\n@param name the attribute name\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"MetadataElement_containsAttribute", BeamPyMetadataElement_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The MetadataElement object.\n@param name the attribute name\n @return <code>true</code> if so\n"},
    {"MetadataElement_getAttributeIndex", BeamPyMetadataElement_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n \n@param this The MetadataElement object.\n@param attribute  The attribute.\n @return The attribute's index, or -1.\n @since BEAM 4.7\n"},
    {"MetadataElement_getAttributeDouble", BeamPyMetadataElement_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as double.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"MetadataElement_getAttributeUTC", BeamPyMetadataElement_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as UTC.\n"},
    {"MetadataElement_getAttributeInt", BeamPyMetadataElement_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"MetadataElement_setAttributeInt", BeamPyMetadataElement_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setAttributeDouble", BeamPyMetadataElement_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setAttributeUTC", BeamPyMetadataElement_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_getAttributeString", BeamPyMetadataElement_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The MetadataElement object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n"},
    {"MetadataElement_setAttributeString", BeamPyMetadataElement_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The MetadataElement object.\n@param name  the attribute name\n @param value the new value\n"},
    {"MetadataElement_setModified", BeamPyMetadataElement_setModified, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_acceptVisitor", BeamPyMetadataElement_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then\n visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.\n\n \n@param this The MetadataElement object.\n@param visitor the visitor\n"},
    {"MetadataElement_createDeepClone", BeamPyMetadataElement_createDeepClone, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_dispose", BeamPyMetadataElement_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getOwner", BeamPyMetadataElement_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The MetadataElement object."},
    {"MetadataElement_getName", BeamPyMetadataElement_getName, METH_VARARGS, " @return This node's name.\n\n@param this The MetadataElement object."},
    {"MetadataElement_setName", BeamPyMetadataElement_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The MetadataElement object.\n@param name The name.\n"},
    {"MetadataElement_getDescription", BeamPyMetadataElement_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The MetadataElement object."},
    {"MetadataElement_setDescription", BeamPyMetadataElement_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The MetadataElement object.\n@param description a description, can be <code>null</code>\n"},
    {"MetadataElement_isModified", BeamPyMetadataElement_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The MetadataElement object."},
    {"MetadataElement_toString", BeamPyMetadataElement_toString, METH_VARARGS, "\n@param this The MetadataElement object."},
    {"MetadataElement_isValidNodeName", BeamPyMetadataElement_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"MetadataElement_getProduct", BeamPyMetadataElement_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductReader", BeamPyMetadataElement_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductWriter", BeamPyMetadataElement_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The MetadataElement object."},
    {"MetadataElement_getDisplayName", BeamPyMetadataElement_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The MetadataElement object."},
    {"MetadataElement_getProductRefString", BeamPyMetadataElement_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The MetadataElement object."},
    {"MetadataElement_updateExpression", BeamPyMetadataElement_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The MetadataElement object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"MetadataElement_removeFromFile", BeamPyMetadataElement_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The MetadataElement object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"Product_newProduct", BeamPyProduct_newProduct, METH_VARARGS, " Creates a new product without any reader (in-memory product)\n\n @param name              the product name\n @param type              the product type\n @param sceneRasterWidth  the scene width in pixels for this data product\n @param sceneRasterHeight the scene height in pixels for this data product\n"},
    {"Product_getFileLocation", BeamPyProduct_getFileLocation, METH_VARARGS, " Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no\n disk location (pure virtual memory product)\n\n @return the file location, may be <code>null</code>\n\n@param this The Product object."},
    {"Product_setFileLocation", BeamPyProduct_setFileLocation, METH_VARARGS, " Sets the file location for this product.\n\n \n@param this The Product object.\n@param fileLocation the file location, may be <code>null</code>\n"},
    {"Product_getProductType", BeamPyProduct_getProductType, METH_VARARGS, " Gets the product type string.\n\n @return the product type string\n\n@param this The Product object."},
    {"Product_setProductType", BeamPyProduct_setProductType, METH_VARARGS, " Sets the product type of this product.\n\n \n@param this The Product object.\n@param productType the product type.\n"},
    {"Product_setProductReader", BeamPyProduct_setProductReader, METH_VARARGS, " Sets the product reader which will be used to create this product in-memory represention from an external source\n and which will be used to (re-)load band rasters.\n\n \n@param this The Product object.\n@param reader the product reader.\n @throws IllegalArgumentException if the given reader is null.\n"},
    {"Product_getProductReader", BeamPyProduct_getProductReader, METH_VARARGS, " Returns the reader which was used to create this product in-memory represention from an external source and which\n will be used to (re-)load band rasters.\n\n @return the product reader, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_setProductWriter", BeamPyProduct_setProductWriter, METH_VARARGS, " Sets the writer which will be used to write modifications of this product's in-memory represention to an external\n destination.\n\n \n@param this The Product object.\n@param writer the product writer, can be <code>null</code>\n"},
    {"Product_getProductWriter", BeamPyProduct_getProductWriter, METH_VARARGS, " Returns the writer which will be used to write modifications of this product's in-memory represention to an\n external destination.\n\n @return the product writer, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_writeHeader", BeamPyProduct_writeHeader, METH_VARARGS, " <p>Writes the header of a data product.<p/>\n\n \n@param this The Product object.\n@param output an object representing a valid output for this writer, might be a <code>ImageOutputStream</code>\n               or a <code>File</code> or other <code>Object</code> to use for future decoding.\n @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is none of the\n                                  supported output types.\n @throws IOException              if an I/O error occurs\n"},
    {"Product_closeProductReader", BeamPyProduct_closeProductReader, METH_VARARGS, " Closes and clears this product's reader (if any).\n\n @throws IOException if an I/O error occurs\n @see #closeIO\n\n@param this The Product object."},
    {"Product_closeProductWriter", BeamPyProduct_closeProductWriter, METH_VARARGS, " Closes and clears this product's writer (if any).\n\n @throws IOException if an I/O error occurs\n @see #closeIO\n\n@param this The Product object."},
    {"Product_closeIO", BeamPyProduct_closeIO, METH_VARARGS, " Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and\n <code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but\n should be called if the product instance is no longer in use.\n\n @throws IOException if an I/O error occurs\n @see #closeProductReader\n @see #closeProductWriter\n @see #dispose\n\n@param this The Product object."},
    {"Product_dispose", BeamPyProduct_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n </p>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n </p>\n <p>This implementation also calls the <code>closeIO</code> in order to release all open I/O resources.\n\n@param this The Product object."},
    {"Product_getPointingFactory", BeamPyProduct_getPointingFactory, METH_VARARGS, " Gets the pointing factory associated with this data product.\n\n @return the pointing factory or null, if none\n\n@param this The Product object."},
    {"Product_setPointingFactory", BeamPyProduct_setPointingFactory, METH_VARARGS, " Sets the pointing factory for this data product.\n\n \n@param this The Product object.\n@param pointingFactory the pointing factory\n"},
    {"Product_setGeoCoding", BeamPyProduct_setGeoCoding, METH_VARARGS, " Geo-codes this data product.\n\n \n@param this The Product object.\n@param geoCoding the geo-coding, if <code>null</code> geo-coding is removed\n @throws IllegalArgumentException <br>- if the given <code>GeoCoding</code> is a <code>TiePointGeoCoding</code>\n                                  and <code>latGrid</code> or <code>lonGrid</code> are not instances of tie point\n                                  grids in this product. <br>- if the given <code>GeoCoding</code> is a\n                                  <code>MapGeoCoding</code> and its <code>MapInfo</code> is <code>null</code>\n                                  <br>- if the given <code>GeoCoding</code> is a <code>MapGeoCoding</code> and the\n                                  <code>sceneWith</code> or <code>sceneHeight</code> of its <code>MapInfo</code>\n                                  is not equal to this products <code>sceneRasterWidth</code> or\n                                  <code>sceneRasterHeight</code>\n"},
    {"Product_getGeoCoding", BeamPyProduct_getGeoCoding, METH_VARARGS, " Returns the geo-coding used for this data product.\n\n @return the geo-coding, can be <code>null</code> if this product is not geo-coded.\n\n@param this The Product object."},
    {"Product_isUsingSingleGeoCoding", BeamPyProduct_isUsingSingleGeoCoding, METH_VARARGS, " Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing\n the band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.\n If this product does not have a geo-coding, the method returns false.\n\n @return true, if so\n\n@param this The Product object."},
    {"Product_transferGeoCodingTo", BeamPyProduct_transferGeoCodingTo, METH_VARARGS, " Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to\n the given {@link ProductSubsetDef subsetDef}.\n\n \n@param this The Product object.\n@param destProduct the destination product\n @param subsetDef   the definition of the subset, may be <code>null</code>\n @return true, if the geo-coding could be transferred.\n"},
    {"Product_getSceneRasterWidth", BeamPyProduct_getSceneRasterWidth, METH_VARARGS, " Returns the scene width in pixels for this data product.\n\n @return the scene width in pixels for this data product.\n\n@param this The Product object."},
    {"Product_getSceneRasterHeight", BeamPyProduct_getSceneRasterHeight, METH_VARARGS, " Returns the scene height in pixels for this data product.\n\n @return the scene height in pixels for this data product.\n\n@param this The Product object."},
    {"Product_getStartTime", BeamPyProduct_getStartTime, METH_VARARGS, " Gets the (sensing) start time associated with the first raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the first raster data line.\n For Level-3 products, this could be the start time of first input product\n contributing data.</p>\n\n @return the sensing start time, can be null e.g. for non-swath products\n\n@param this The Product object."},
    {"Product_setStartTime", BeamPyProduct_setStartTime, METH_VARARGS, " Sets the (sensing) start time of this product.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the first raster data line.\n For Level-3 products, this could be the start time of first input product\n contributing data.</p>\n\n \n@param this The Product object.\n@param startTime the sensing start time, can be null\n"},
    {"Product_getEndTime", BeamPyProduct_getEndTime, METH_VARARGS, " Gets the (sensing) stop time associated with the last raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the last raster data line.\n For Level-3 products, this could be the end time of last input product\n contributing data.</p>\n\n @return the stop time , can be null e.g. for non-swath products\n\n@param this The Product object."},
    {"Product_setEndTime", BeamPyProduct_setEndTime, METH_VARARGS, " Sets the (sensing) stop time associated with the first raster data line.\n <p/>\n <p>For Level-1/2 products this is\n the data-take time associated with the last raster data line.\n For Level-3 products, this could be the end time of last input product\n contributing data.</p>\n\n \n@param this The Product object.\n@param endTime the sensing stop time, can be null\n"},
    {"Product_getMetadataRoot", BeamPyProduct_getMetadataRoot, METH_VARARGS, " Gets the root element of the associated metadata.\n\n @return the metadata root element\n\n@param this The Product object."},
    {"Product_getGroups", BeamPyProduct_getGroups, METH_VARARGS, " @return The group which contains all other product node groups.\n @since BEAM 5.0\n\n@param this The Product object."},
    {"Product_getGroup", BeamPyProduct_getGroup, METH_VARARGS, " \n@param this The Product object.\n@param name The group name.\n @return The group with the given name, or {@code null} if no such group exists.\n @since BEAM 5.0\n"},
    {"Product_getTiePointGridGroup", BeamPyProduct_getTiePointGridGroup, METH_VARARGS, " Gets the tie-point grid group of this product.\n\n @return The group of all tie-point grids.\n @since BEAM 4.7\n\n@param this The Product object."},
    {"Product_addTiePointGrid", BeamPyProduct_addTiePointGrid, METH_VARARGS, " Adds the given tie-point grid to this product.\n\n \n@param this The Product object.\n@param tiePointGrid the tie-point grid to added, ignored if <code>null</code>\n"},
    {"Product_removeTiePointGrid", BeamPyProduct_removeTiePointGrid, METH_VARARGS, " Removes the tie-point grid from this product.\n\n \n@param this The Product object.\n@param tiePointGrid the tie-point grid to be removed, ignored if <code>null</code>\n @return <code>true</code> if node could be removed\n"},
    {"Product_getNumTiePointGrids", BeamPyProduct_getNumTiePointGrids, METH_VARARGS, " Returns the number of tie-point grids contained in this product\n\n @return the number of tie-point grids\n\n@param this The Product object."},
    {"Product_getTiePointGridAt", BeamPyProduct_getTiePointGridAt, METH_VARARGS, " Returns the tie-point grid at the given index.\n\n \n@param this The Product object.\n@param index the tie-point grid index\n @return the tie-point grid at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"Product_getTiePointGridNames", BeamPyProduct_getTiePointGridNames, METH_VARARGS, " Returns a string array containing the names of the tie-point grids contained in this product\n\n @return a string array containing the names of the tie-point grids contained in this product. If this product has\n         no tie-point grids a zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getTiePointGrids", BeamPyProduct_getTiePointGrids, METH_VARARGS, " Returns an array of tie-point grids contained in this product\n\n @return an array of tie-point grids contained in this product. If this product has no  tie-point grids a\n         zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getTiePointGrid", BeamPyProduct_getTiePointGrid, METH_VARARGS, " Returns the tie-point grid with the given name.\n\n \n@param this The Product object.\n@param name the tie-point grid name\n @return the tie-point grid with the given name or <code>null</code> if a tie-point grid with the given name is\n         not contained in this product.\n"},
    {"Product_containsTiePointGrid", BeamPyProduct_containsTiePointGrid, METH_VARARGS, " Tests if a tie-point grid with the given name is contained in this product.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a tie-point grid with the given name is contained in this product,\n         <code>false</code> otherwise\n"},
    {"Product_getBandGroup", BeamPyProduct_getBandGroup, METH_VARARGS, " Gets the band group of this product.\n\n @return The group of all bands.\n @since BEAM 4.7\n\n@param this The Product object."},
    {"Product_addBand", BeamPyProduct_addBand, METH_VARARGS, " Adds the given band to this product.\n\n \n@param this The Product object.\n@param band the band to added, must not be <code>null</code>\n"},
    {"Product_addNewBand", BeamPyProduct_addNewBand, METH_VARARGS, " Creates a new band with the given name and data type and adds it to this product and returns it.\n\n \n@param this The Product object.\n@param bandName the new band's name\n @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\n                 constants\n @return the new band which has just been added\n"},
    {"Product_addComputedBand", BeamPyProduct_addComputedBand, METH_VARARGS, " Creates a new band with the given name and adds it to this product and returns it.\n The new band's data type is {@code float} and it's samples are computed from the given band maths expression.\n\n \n@param this The Product object.\n@param bandName   the new band's name\n @param expression the band maths expression\n @return the new band which has just been added\n @since BEAM 4.9\n"},
    {"Product_removeBand", BeamPyProduct_removeBand, METH_VARARGS, " Removes the given band from this product.\n\n \n@param this The Product object.\n@param band the band to be removed, ignored if <code>null</code>\n @return {@code true} if removed succesfully, otherwise {@code false}\n"},
    {"Product_getNumBands", BeamPyProduct_getNumBands, METH_VARARGS, " @return the number of bands contained in this product.\n\n@param this The Product object."},
    {"Product_getBandAt", BeamPyProduct_getBandAt, METH_VARARGS, " Returns the band at the given index.\n\n \n@param this The Product object.\n@param index the band index\n @return the band at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"Product_getBandNames", BeamPyProduct_getBandNames, METH_VARARGS, " Returns a string array containing the names of the bands contained in this product\n\n @return a string array containing the names of the bands contained in this product. If this product has no bands\n         a zero-length-array is returned.\n\n@param this The Product object."},
    {"Product_getBands", BeamPyProduct_getBands, METH_VARARGS, " Returns an array of bands contained in this product\n\n @return an array of bands contained in this product. If this product has no bands a zero-length-array is\n         returned.\n\n@param this The Product object."},
    {"Product_getBand", BeamPyProduct_getBand, METH_VARARGS, " Returns the band with the given name.\n\n \n@param this The Product object.\n@param name the band name\n @return the band with the given name or <code>null</code> if a band with the given name is not contained in this\n         product.\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_getBandIndex", BeamPyProduct_getBandIndex, METH_VARARGS, " Returns the index for the band with the given name.\n\n \n@param this The Product object.\n@param name the band name\n @return the band index or <code>-1</code> if a band with the given name is not contained in this product.\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_containsBand", BeamPyProduct_containsBand, METH_VARARGS, " Tests if a band with the given name is contained in this product.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a band with the given name is contained in this product, <code>false</code>\n         otherwise\n @throws IllegalArgumentException if the given name is <code>null</code> or empty.\n"},
    {"Product_containsRasterDataNode", BeamPyProduct_containsRasterDataNode, METH_VARARGS, " Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or\n tie-point grids.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a raster data node with the given name is contained in this product,\n         <code>false</code> otherwise\n"},
    {"Product_getRasterDataNode", BeamPyProduct_getRasterDataNode, METH_VARARGS, " Gets the raster data node with the given name. The method first searches for bands with the given name, then for\n tie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.\n\n \n@param this The Product object.\n@param name the name, must not be <code>null</code>\n @return the raster data node with the given name or <code>null</code> if a raster data node with the given name\n         is not contained in this product.\n"},
    {"Product_getMaskGroup", BeamPyProduct_getMaskGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getVectorDataGroup", BeamPyProduct_getVectorDataGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getFlagCodingGroup", BeamPyProduct_getFlagCodingGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getIndexCodingGroup", BeamPyProduct_getIndexCodingGroup, METH_VARARGS, "\n@param this The Product object."},
    {"Product_containsPixel", BeamPyProduct_containsPixel, METH_VARARGS, " Tests if the given pixel position is within the product pixel bounds.\n\n \n@param this The Product object.\n@param x the x coordinate of the pixel position\n @param y the y coordinate of the pixel position\n @return true, if so\n @see #containsPixel(PixelPos)\n"},
    {"Product_getGcpGroup", BeamPyProduct_getGcpGroup, METH_VARARGS, " Gets the group of ground-control points (GCPs).\n Note that this method will create the group, if none exists already.\n\n @return the GCP group.\n\n@param this The Product object."},
    {"Product_getPinGroup", BeamPyProduct_getPinGroup, METH_VARARGS, " Gets the group of pins.\n Note that this method will create the group, if none exists already.\n\n @return the pin group.\n\n@param this The Product object."},
    {"Product_getNumResolutionsMax", BeamPyProduct_getNumResolutionsMax, METH_VARARGS, " @return The maximum number of resolution levels common to all band images.\n         If less than or equal to zero, the  number of resolution levels is considered to be unknown.\n @since BEAM 5.0\n\n@param this The Product object."},
    {"Product_setNumResolutionsMax", BeamPyProduct_setNumResolutionsMax, METH_VARARGS, " \n@param this The Product object.\n@param numResolutionsMax The maximum number of resolution levels common to all band images.\n                          If less than or equal to zero, the  number of resolution levels is considered to be unknown.\n @since BEAM 5.0\n"},
    {"Product_isCompatibleProduct", BeamPyProduct_isCompatibleProduct, METH_VARARGS, " Checks whether or not the given product is compatible with this product.\n\n \n@param this The Product object.\n@param product the product to compare with\n @param eps     the maximum lat/lon error in degree\n @return <code>false</code> if the scene dimensions or geocoding are different, <code>true</code> otherwise.\n"},
    {"Product_parseExpression", BeamPyProduct_parseExpression, METH_VARARGS, " Parses a mathematical expression given as a text string.\n\n \n@param this The Product object.\n@param expression a expression given as a text string, e.g. \"radiance_4 / (1.0 + radiance_11)\".\n @return a term parsed from the given expression string\n @throws ParseException if the expression could not successfully be parsed\n"},
    {"Product_acceptVisitor", BeamPyProduct_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag\n codings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.\n\n \n@param this The Product object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"Product_addProductNodeListener", BeamPyProduct_addProductNodeListener, METH_VARARGS, " Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each\n time a node in this product changes.\n\n \n@param this The Product object.\n@param listener the listener to be added\n @return boolean if listener was added or not\n"},
    {"Product_removeProductNodeListener", BeamPyProduct_removeProductNodeListener, METH_VARARGS, " Removes a <code>ProductNodeListener</code> from this product.\n\n \n@param this The Product object.\n@param listener the listener to be removed.\n"},
    {"Product_getProductNodeListeners", BeamPyProduct_getProductNodeListeners, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getRefNo", BeamPyProduct_getRefNo, METH_VARARGS, " @return The reference number of this product.\n\n@param this The Product object."},
    {"Product_setRefNo", BeamPyProduct_setRefNo, METH_VARARGS, " Sets the reference number.\n\n \n@param this The Product object.\n@param refNo the reference number to set must be in the range 1 .. Integer.MAX_VALUE\n @throws IllegalArgumentException if the refNo is out of range\n @throws IllegalStateException\n"},
    {"Product_resetRefNo", BeamPyProduct_resetRefNo, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getProductManager", BeamPyProduct_getProductManager, METH_VARARGS, " Returns the product manager for this product.\n\n @return this product's manager, can be <code>null</code>\n\n@param this The Product object."},
    {"Product_createBandArithmeticParser", BeamPyProduct_createBandArithmeticParser, METH_VARARGS, " Creates a parser for band arithmetic expressions.\n The parser created will use a namespace comprising all tie-point grids, bands and flags of this product.\n\n @return a parser for band arithmetic expressions for this product, never null\n\n@param this The Product object."},
    {"Product_createBandArithmeticDefaultNamespace", BeamPyProduct_createBandArithmeticDefaultNamespace, METH_VARARGS, " Creates a namespace to be used by parsers for band arithmetic expressions.\n The namespace created comprises all tie-point grids, bands and flags of this product.\n\n @return a namespace, never null\n\n@param this The Product object."},
    {"Product_createSubset", BeamPyProduct_createSubset, METH_VARARGS, " Creates a subset of this product. The returned product represents a true spatial and spectral subset of this\n product, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the\n description from this product was used.\n\n \n@param this The Product object.\n@param subsetDef the product subset definition\n @param name      the name for the new product\n @param desc      the description for the new product\n @return the product subset, or <code>null</code> if the product/subset combination is not valid\n @throws IOException if an I/O error occurs\n"},
    {"Product_createProjectedProduct", BeamPyProduct_createProjectedProduct, METH_VARARGS, " Creates a map-projected version of this product.\n\n \n@param this The Product object.\n@param mapInfo the map information\n @param name    the name for the new product\n @param desc    the description for the new product\n @return the product subset, or <code>null</code> if the product/subset combination is not valid\n @throws IOException if an I/O error occurs\n"},
    {"Product_createFlippedProduct", BeamPyProduct_createFlippedProduct, METH_VARARGS, " Creates flipped raster-data version of this product.\n\n \n@param this The Product object.\n@param flipType the flip type, see <code>{@link org.esa.beam.framework.dataio.ProductFlipper}</code>\n @param name     the name for the new product\n @param desc     the description for the new product\n @return the product subset, or <code>null</code> if the product/subset combination is not valid\n @throws IOException if an I/O error occurs\n"},
    {"Product_setModified", BeamPyProduct_setModified, METH_VARARGS, "\n@param this The Product object."},
    {"Product_getQuicklookBandName", BeamPyProduct_getQuicklookBandName, METH_VARARGS, " Gets the name of the band suitable for quicklook generation.\n\n @return the name of the quicklook band, or null if none has been defined\n\n@param this The Product object."},
    {"Product_setQuicklookBandName", BeamPyProduct_setQuicklookBandName, METH_VARARGS, " Sets the name of the band suitable for quicklook generation.\n\n \n@param this The Product object.\n@param quicklookBandName the name of the quicklook band, or null\n"},
    {"Product_createPixelInfoString", BeamPyProduct_createPixelInfoString, METH_VARARGS, " Creates a string containing all available information at the given pixel position. The string returned is a line\n separated text with each line containing a key/value pair.\n\n \n@param this The Product object.\n@param pixelX the pixel X co-ordinate\n @param pixelY the pixel Y co-ordinate\n @return the info string at the given position\n"},
    {"Product_getRemovedChildNodes", BeamPyProduct_getRemovedChildNodes, METH_VARARGS, " @return All removed child nodes. Array may be empty.\n\n@param this The Product object."},
    {"Product_canBeOrthorectified", BeamPyProduct_canBeOrthorectified, METH_VARARGS, " Checks whether or not this product can be ortorectified.\n\n @return true if {@link Band#canBeOrthorectified()} returns true for all bands, false otherwise\n\n@param this The Product object."},
    {"Product_getPreferredTileSize", BeamPyProduct_getPreferredTileSize, METH_VARARGS, " Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\n created for a {@link RasterDataNode} of this product.\n\n @return the preferred tile size, may be <code>null</null> if not specified\n @see RasterDataNode#getSourceImage()\n @see RasterDataNode# setSourceImage (java.awt.image.RenderedImage)\n\n@param this The Product object."},
    {"Product_setPreferredTileSize", BeamPyProduct_setPreferredTileSize, METH_VARARGS, " Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}\n created for a {@link RasterDataNode} of this product.\n\n \n@param this The Product object.\n@param tileWidth  the preferred tile width\n @param tileHeight the preferred tile height\n @see #setPreferredTileSize(java.awt.Dimension)\n"},
    {"Product_getAllFlagNames", BeamPyProduct_getAllFlagNames, METH_VARARGS, " Returns the names of all flags of all flag datasets contained this product.\n <p/>\n <p>A flag name contains the dataset (a band of this product) and the actual flag name as defined in the\n flag-coding associated with the dataset. The general format for the flag name strings returned is therefore\n <code>\"<i>dataset</i>.<i>flag_name</i>\"</code>.\n </p>\n <p>The method is used to find out which flags a product has in order to use them in bit-mask expressions.\n\n @return the array of all flag names. If this product does not support flags, an empty array is returned, but\n         never <code>null</code>.\n @see #parseExpression(String)\n\n@param this The Product object."},
    {"Product_getAutoGrouping", BeamPyProduct_getAutoGrouping, METH_VARARGS, " Gets the auto-grouping applicable to product nodes contained in this product.\n\n @return The auto-grouping or {@code null}.\n @since BEAM 4.8\n\n@param this The Product object."},
    {"Product_setAutoGrouping", BeamPyProduct_setAutoGrouping, METH_VARARGS, " Sets the auto-grouping applicable to product nodes contained in this product.\n A given {@code pattern} parameter is a textual representation of the auto-grouping.\n The syntax for the pattern is:\n <pre>\n pattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | \"\" (empty string)\n groupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}\n groupName  :=  any non-empty string without characters ':' and '/'\n </pre>\n An example for {@code pattern} applicable to Envisat AATSR data is\n <pre>\n nadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward\n </pre>\n\n \n@param this The Product object.\n@param pattern The auto-grouping pattern.\n @since BEAM 4.8\n"},
    {"Product_addComputedMask", BeamPyProduct_addComputedMask, METH_VARARGS, " Creates a new mask using a band arithmetic expression\n and adds it to this product and returns it.\n\n \n@param this The Product object.\n@param maskName     the new mask's name\n @param expression   the band arithmetic expression\n @param description  the mask's description\n @param color        the display color\n @param transparency the display transparency\n @return the new mask which has just been added\n @since BEAM 4.10\n"},
    {"Product_getOwner", BeamPyProduct_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Product object."},
    {"Product_getName", BeamPyProduct_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Product object."},
    {"Product_setName", BeamPyProduct_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Product object.\n@param name The name.\n"},
    {"Product_getDescription", BeamPyProduct_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Product object."},
    {"Product_setDescription", BeamPyProduct_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Product object.\n@param description a description, can be <code>null</code>\n"},
    {"Product_isModified", BeamPyProduct_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Product object."},
    {"Product_toString", BeamPyProduct_toString, METH_VARARGS, "\n@param this The Product object."},
    {"Product_isValidNodeName", BeamPyProduct_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Product_getProduct", BeamPyProduct_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Product object."},
    {"Product_getDisplayName", BeamPyProduct_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Product object."},
    {"Product_getProductRefString", BeamPyProduct_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Product object."},
    {"Product_updateExpression", BeamPyProduct_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The Product object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"Product_removeFromFile", BeamPyProduct_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The Product object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"ColorPaletteDef_newColorPaletteDefFromRange", BeamPyColorPaletteDef_newColorPaletteDefFromRange, METH_VARARGS, ""},
    {"ColorPaletteDef_newColorPaletteDefFromPoints", BeamPyColorPaletteDef_newColorPaletteDefFromPoints, METH_VARARGS, ""},
    {"ColorPaletteDef_isDiscrete", BeamPyColorPaletteDef_isDiscrete, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setDiscrete", BeamPyColorPaletteDef_setDiscrete, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getNumColors", BeamPyColorPaletteDef_getNumColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setNumColors", BeamPyColorPaletteDef_setNumColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getNumPoints", BeamPyColorPaletteDef_getNumPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setNumPoints", BeamPyColorPaletteDef_setNumPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_isAutoDistribute", BeamPyColorPaletteDef_isAutoDistribute, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setAutoDistribute", BeamPyColorPaletteDef_setAutoDistribute, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getPointAt", BeamPyColorPaletteDef_getPointAt, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getFirstPoint", BeamPyColorPaletteDef_getFirstPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getLastPoint", BeamPyColorPaletteDef_getLastPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getMinDisplaySample", BeamPyColorPaletteDef_getMinDisplaySample, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getMaxDisplaySample", BeamPyColorPaletteDef_getMaxDisplaySample, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_insertPointAfter", BeamPyColorPaletteDef_insertPointAfter, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createPointAfter", BeamPyColorPaletteDef_createPointAfter, METH_VARARGS, " creates a new point between the point at the given index\n\n \n@param this The ColorPaletteDef object.\n@param index   the index\n @param scaling the scaling\n\n @return true, if a point has been inserted\n"},
    {"ColorPaletteDef_getCenterColor", BeamPyColorPaletteDef_getCenterColor, METH_VARARGS, " Creates the center color between the given two colors.\n\n @param c1 1st color\n @param c2 2nd color\n\n @return the center color\n"},
    {"ColorPaletteDef_removePointAt", BeamPyColorPaletteDef_removePointAt, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_addPoint", BeamPyColorPaletteDef_addPoint, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getPoints", BeamPyColorPaletteDef_getPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_setPoints", BeamPyColorPaletteDef_setPoints, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getIterator", BeamPyColorPaletteDef_getIterator, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_clone", BeamPyColorPaletteDef_clone, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createDeepCopy", BeamPyColorPaletteDef_createDeepCopy, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_loadColorPaletteDef", BeamPyColorPaletteDef_loadColorPaletteDef, METH_VARARGS, " Loads a color palette definition from the given file\n\n @param file the file\n\n @return the color palette definition, never null\n\n @throws IOException if an I/O error occurs\n"},
    {"ColorPaletteDef_storeColorPaletteDef", BeamPyColorPaletteDef_storeColorPaletteDef, METH_VARARGS, " Stores this color palette definition in the given file\n\n @param colorPaletteDef thje color palette definition\n @param file            the file\n\n @throws IOException if an I/O error occurs\n"},
    {"ColorPaletteDef_dispose", BeamPyColorPaletteDef_dispose, METH_VARARGS, " Releases all of the resources used by this color palette definition and all of its owned children. Its primary\n use is to allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_getColors", BeamPyColorPaletteDef_getColors, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_createColorPalette", BeamPyColorPaletteDef_createColorPalette, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ColorPaletteDef_computeColor", BeamPyColorPaletteDef_computeColor, METH_VARARGS, "\n@param this The ColorPaletteDef object."},
    {"ImageInfo_newImageInfoPalette", BeamPyImageInfo_newImageInfoPalette, METH_VARARGS, " Constructs a new image information instance.\n\n @param colorPaletteDef the color palette definition\n"},
    {"ImageInfo_newImageInfoRGB", BeamPyImageInfo_newImageInfoRGB, METH_VARARGS, " Constructs a new RGB image information instance.\n\n @param rgbChannelDef the RGB channel definition\n"},
    {"ImageInfo_getColorPaletteDef", BeamPyImageInfo_getColorPaletteDef, METH_VARARGS, " Gets the color palette definition as used for images created from single bands.\n\n @return The color palette definition. Can be {@code null}.\n         In this case {@link #getRgbChannelDef()} is non-null.\n\n@param this The ImageInfo object."},
    {"ImageInfo_getRgbChannelDef", BeamPyImageInfo_getRgbChannelDef, METH_VARARGS, " Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.\n\n @return The RGB(A) channel definition.\n         Can be {@code null}. In this case {@link #getColorPaletteDef()} is non-null.\n\n@param this The ImageInfo object."},
    {"ImageInfo_getNoDataColor", BeamPyImageInfo_getNoDataColor, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setNoDataColor", BeamPyImageInfo_setNoDataColor, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setHistogramMatching", BeamPyImageInfo_setHistogramMatching, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_isLogScaled", BeamPyImageInfo_isLogScaled, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_setLogScaled", BeamPyImageInfo_setLogScaled, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_getColors", BeamPyImageInfo_getColors, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_getColorComponentCount", BeamPyImageInfo_getColorComponentCount, METH_VARARGS, " Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.\n\n @return {@code 3} for RGB images, {@code 4} for RGB images with an alpha channel (transparency)\n\n@param this The ImageInfo object."},
    {"ImageInfo_createIndexColorModel", BeamPyImageInfo_createIndexColorModel, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_createComponentColorModel", BeamPyImageInfo_createComponentColorModel, METH_VARARGS, "\n@param this The ImageInfo object."},
    {"ImageInfo_clone", BeamPyImageInfo_clone, METH_VARARGS, " Creates and returns a copy of this object.\n\n @return a copy of this object\n\n@param this The ImageInfo object."},
    {"ImageInfo_createDeepCopy", BeamPyImageInfo_createDeepCopy, METH_VARARGS, " Creates and returns a \"deep\" copy of this object. The method simply returns the value of\n {@link #clone()}.\n\n @return a copy of this object\n\n@param this The ImageInfo object."},
    {"ImageInfo_dispose", BeamPyImageInfo_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The ImageInfo object."},
    {"ImageInfo_setColors", BeamPyImageInfo_setColors, METH_VARARGS, " Sets the colours of the colour palette of this image info.\n\n \n@param this The ImageInfo object.\n@param colors the new colours\n"},
    {"ImageInfo_setColorPaletteDef", BeamPyImageInfo_setColorPaletteDef, METH_VARARGS, " Transfers the colour palette into this image info.\n\n \n@param this The ImageInfo object.\n@param colorPaletteDef another colour palette\n @param minSample       the minium allowed sample value in the new colour palette\n @param maxSample       the maximum allowed sample value in the new colour palette\n @param autoDistribute  if true, points are distributed between minSample/maxSample.\n"},
    {"ImageInfo_getHistogramMatching", BeamPyImageInfo_getHistogramMatching, METH_VARARGS, " Converts a string to a histogram matching.\n\n @param mode the histogram matching string\n @return the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not \"Equalize\" or \"Normalize\".\n"},
    {"ProductManager_newProductManager", BeamPyProductManager_newProductManager, METH_VARARGS, " Constructs an product manager with an empty list of products.\n"},
    {"ProductManager_getProductCount", BeamPyProductManager_getProductCount, METH_VARARGS, " @return The number of products in this product manager.\n\n@param this The ProductManager object."},
    {"ProductManager_getProduct", BeamPyProductManager_getProduct, METH_VARARGS, " Gets the product at the given index.\n\n \n@param this The ProductManager object.\n@param index the index\n\n @return The product at the given index.\n"},
    {"ProductManager_getProductDisplayNames", BeamPyProductManager_getProductDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n\n @see ProductNode#getDisplayName()\n\n@param this The ProductManager object."},
    {"ProductManager_getProductNames", BeamPyProductManager_getProductNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The ProductManager object."},
    {"ProductManager_getProducts", BeamPyProductManager_getProducts, METH_VARARGS, " Returns an array of all products currently managed.\n\n @return an array containing the products, never <code>null</code>, but the array can have zero length\n\n@param this The ProductManager object."},
    {"ProductManager_getProductByDisplayName", BeamPyProductManager_getProductByDisplayName, METH_VARARGS, " \n@param this The ProductManager object.\n@param displayName The product's display name.\n\n @return The product with the given display name.\n"},
    {"ProductManager_getProductByRefNo", BeamPyProductManager_getProductByRefNo, METH_VARARGS, " \n@param this The ProductManager object.\n@param refNo The reference number.\n\n @return The product with the given reference number.\n"},
    {"ProductManager_getProductByName", BeamPyProductManager_getProductByName, METH_VARARGS, " \n@param this The ProductManager object.\n@param name The product name.\n\n @return The product with the given name.\n"},
    {"ProductManager_getProductIndex", BeamPyProductManager_getProductIndex, METH_VARARGS, "\n@param this The ProductManager object."},
    {"ProductManager_containsProduct", BeamPyProductManager_containsProduct, METH_VARARGS, " Tests whether a product with the given name is contained in this list.\n\n \n@param this The ProductManager object.\n@param name the product name\n\n @return true, if so\n"},
    {"ProductManager_contains", BeamPyProductManager_contains, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The ProductManager object.\n@param product The product.\n\n @return {@code true} if so.\n"},
    {"ProductManager_addProduct", BeamPyProductManager_addProduct, METH_VARARGS, " Adds the given product to this product manager if it does not already exists and sets it's reference number one\n biger than the greatest reference number in this product manager.\n\n \n@param this The ProductManager object.\n@param product the product to be added, ignored if <code>null</code>\n"},
    {"ProductManager_removeProduct", BeamPyProductManager_removeProduct, METH_VARARGS, " Removes the given product from this product manager if it exists.\n\n \n@param this The ProductManager object.\n@param product the product to be removed, ignored if <code>null</code>\n\n @return true, if the product was removed\n"},
    {"ProductManager_removeAllProducts", BeamPyProductManager_removeAllProducts, METH_VARARGS, " Removes all product from this list.\n\n@param this The ProductManager object."},
    {"ProductManager_addListener", BeamPyProductManager_addListener, METH_VARARGS, " Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is\n informed each time a product was added or removed.\n\n \n@param this The ProductManager object.\n@param listener the listener to be added.\n\n @return true if the listener was added, otherwise false.\n"},
    {"ProductManager_removeListener", BeamPyProductManager_removeListener, METH_VARARGS, " Removes a <code>ProductManagerListener</code> from this product manager.\n\n \n@param this The ProductManager object.\n@param listener The listener.\n\n @return true, if the listener was removed, otherwise false.\n"},
    {"ImageGeometry_newImageGeometry", BeamPyImageGeometry_newImageGeometry, METH_VARARGS, ""},
    {"ImageGeometry_getImage2MapTransform", BeamPyImageGeometry_getImage2MapTransform, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_getImageRect", BeamPyImageGeometry_getImageRect, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_getMapCrs", BeamPyImageGeometry_getMapCrs, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_changeYAxisDirection", BeamPyImageGeometry_changeYAxisDirection, METH_VARARGS, "\n@param this The ImageGeometry object."},
    {"ImageGeometry_calculateEastingNorthing", BeamPyImageGeometry_calculateEastingNorthing, METH_VARARGS, ""},
    {"ImageGeometry_calculateProductSize", BeamPyImageGeometry_calculateProductSize, METH_VARARGS, ""},
    {"ImageGeometry_createTargetGeometry", BeamPyImageGeometry_createTargetGeometry, METH_VARARGS, ""},
    {"ImageGeometry_createCollocationTargetGeometry", BeamPyImageGeometry_createCollocationTargetGeometry, METH_VARARGS, ""},
    {"ImageGeometry_createValidRect", BeamPyImageGeometry_createValidRect, METH_VARARGS, ""},
    {"Band_newBand", BeamPyBand_newBand, METH_VARARGS, " Constructs a new <code>Band</code>.\n\n @param name     the name of the new object\n @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>\n                 constants, with the exception of <code>ProductData.TYPE_UINT32</code>\n @param width    the width of the raster in pixels\n @param height   the height of the raster in pixels\n"},
    {"Band_getFlagCoding", BeamPyBand_getFlagCoding, METH_VARARGS, " Gets the flag coding for this band.\n\n @return a non-null value if this band is a flag dataset, <code>null</code> otherwise\n\n@param this The Band object."},
    {"Band_isFlagBand", BeamPyBand_isFlagBand, METH_VARARGS, " Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_getIndexCoding", BeamPyBand_getIndexCoding, METH_VARARGS, " Gets the index coding for this band.\n\n @return a non-null value if this band is a flag dataset, <code>null</code> otherwise\n\n@param this The Band object."},
    {"Band_isIndexBand", BeamPyBand_isIndexBand, METH_VARARGS, " Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_getSampleCoding", BeamPyBand_getSampleCoding, METH_VARARGS, " Gets the sample coding.\n\n @return the sample coding, or {@value null} if not set.\n\n@param this The Band object."},
    {"Band_setSampleCoding", BeamPyBand_setSampleCoding, METH_VARARGS, " Sets the sample coding for this band.\n\n \n@param this The Band object.\n@param sampleCoding the sample coding\n @throws IllegalArgumentException if this band does not contain integer pixels\n"},
    {"Band_getSpectralBandIndex", BeamPyBand_getSpectralBandIndex, METH_VARARGS, " Gets the (zero-based) spectral band index.\n\n @return the (zero-based) spectral band index or <code>-1</code> if it is unknown\n\n@param this The Band object."},
    {"Band_setSpectralBandIndex", BeamPyBand_setSpectralBandIndex, METH_VARARGS, " Sets the (zero-based) spectral band index.\n\n \n@param this The Band object.\n@param spectralBandIndex the (zero-based) spectral band index or <code>-1</code> if it is unknown\n"},
    {"Band_getSpectralWavelength", BeamPyBand_getSpectralWavelength, METH_VARARGS, " Gets the spectral wavelength in <code>nm</code> (nanomater) units.\n\n @return the wave length in nanometers of this band, or zero if this is not a spectral band or the wave length is\n         not known.\n\n@param this The Band object."},
    {"Band_setSpectralWavelength", BeamPyBand_setSpectralWavelength, METH_VARARGS, " Sets the spectral wavelength in <code>nm</code> (nanomater) units.\n\n \n@param this The Band object.\n@param spectralWavelength the wavelength in nanometers of this band, or zero if this is not a spectral band or\n                           the wavelength is not known.\n"},
    {"Band_getSpectralBandwidth", BeamPyBand_getSpectralBandwidth, METH_VARARGS, " Gets the spectral bandwidth in <code>nm</code> (nanomater) units.\n\n @return the bandwidth in nanometers of this band, or zero if this is not a spectral band or the bandwidth is not\n         known.\n\n@param this The Band object."},
    {"Band_setSpectralBandwidth", BeamPyBand_setSpectralBandwidth, METH_VARARGS, " Sets the spectral bandwidth in <code>nm</code> (nanomater) units.\n\n \n@param this The Band object.\n@param spectralBandwidth the spectral bandwidth in nanometers of this band, or zero if this is not a spectral band\n                          or the spectral bandwidth is not known.\n"},
    {"Band_getSolarFlux", BeamPyBand_getSolarFlux, METH_VARARGS, " Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\n units for the wavelength of this band.\n\n @return the solar flux for the wavelength of this band, or zero if this is not a spectral band or the solar flux\n         is not known.\n\n@param this The Band object."},
    {"Band_setSolarFlux", BeamPyBand_setSolarFlux, METH_VARARGS, " Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)\n units for the wavelength of this band.\n\n \n@param this The Band object.\n@param solarFlux the solar flux for the wavelength of this band, or zero if this is not a spectral band or the\n                  solar flux is not known.\n"},
    {"Band_acceptVisitor", BeamPyBand_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The Band object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"Band_toString", BeamPyBand_toString, METH_VARARGS, " Creates a string defining this band object.\n\n@param this The Band object."},
    {"Band_removeFromFile", BeamPyBand_removeFromFile, METH_VARARGS, "\n@param this The Band object."},
    {"Band_dispose", BeamPyBand_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The Band object."},
    {"Band_getSceneRasterData", BeamPyBand_getSceneRasterData, METH_VARARGS, " Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so\n far the method returns <code>null</code>.\n <p/>\n <p>In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the\n scene's pixels.\n\n @return raster data covering the pixels for a complete scene\n @see #getRasterData\n @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterWidth\n @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterHeight\n\n@param this The Band object."},
    {"Band_getPixelInt", BeamPyBand_getPixelInt, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as an integer value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n"},
    {"Band_getPixelFloat", BeamPyBand_getPixelFloat, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as a float value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n"},
    {"Band_getPixelDouble", BeamPyBand_getPixelDouble, METH_VARARGS, " Gets the sample for the pixel located at (x,y) as a double value.\n\n \n@param this The Band object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n @throws NullPointerException if this band has no raster data\n @throws java.lang.ArrayIndexOutOfBoundsException\n                              if the co-ordinates are not in bounds\n"},
    {"Band_setPixelInt", BeamPyBand_setPixelInt, METH_VARARGS, " Sets the pixel at the given pixel co-ordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_setPixelFloat", BeamPyBand_setPixelFloat, METH_VARARGS, " Sets the pixel at the given pixel coordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_setPixelDouble", BeamPyBand_setPixelDouble, METH_VARARGS, " Sets the pixel value at the given pixel coordinate to the given pixel value.\n\n \n@param this The Band object.\n@param x          The X co-ordinate of the pixel location\n @param y          The Y co-ordinate of the pixel location\n @param pixelValue the new pixel value\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_setPixelsInt", BeamPyBand_setPixelsInt, METH_VARARGS, " Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of\n data at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels integer array to be written\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_setPixelsFloat", BeamPyBand_setPixelsFloat, METH_VARARGS, " Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data\n at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels float array to be written\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_setPixelsDouble", BeamPyBand_setPixelsDouble, METH_VARARGS, " Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data\n at the specified location. Throws exception when the target buffer is not in memory.\n\n \n@param this The Band object.\n@param x      x offset into the band\n @param y      y offset into the band\n @param w      width of the pixel array to be written\n @param h      height of the pixel array to be written.\n @param pixels double array to be written\n @throws NullPointerException if this band has no raster data\n"},
    {"Band_ensureRasterData", BeamPyBand_ensureRasterData, METH_VARARGS, " Ensures that raster data exists\n\n@param this The Band object."},
    {"Band_unloadRasterData", BeamPyBand_unloadRasterData, METH_VARARGS, " Un-loads the raster data for this band.\n <p/>\n <p>After this method has been called successfully, the <code>hasRasterData()</code> method returns\n <code>false</code> and <code>getRasterData()</code> returns <code>null</code>.\n <p/>\n\n @see #loadRasterData()\n\n@param this The Band object."},
    {"Band_getViewModeId", BeamPyBand_getViewModeId, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getSceneRasterWidth", BeamPyBand_getSceneRasterWidth, METH_VARARGS, " Returns the width in pixels of the scene represented by this product raster. By default, the method simply\n returns <code>getRasterWidth()</code>.\n\n @return the scene width in pixels\n\n@param this The Band object."},
    {"Band_getSceneRasterHeight", BeamPyBand_getSceneRasterHeight, METH_VARARGS, " Returns the height in pixels of the scene represented by this product raster. By default, the method simply\n returns <code>getRasterHeight()</code>.\n\n @return the scene height in pixels\n\n@param this The Band object."},
    {"Band_getRasterWidth", BeamPyBand_getRasterWidth, METH_VARARGS, " Returns the width of the raster used by this product raster.\n\n @return the width of the raster\n\n@param this The Band object."},
    {"Band_getRasterHeight", BeamPyBand_getRasterHeight, METH_VARARGS, " Returns the height of the raster used by this product raster.\n\n @return the height of the raster\n\n@param this The Band object."},
    {"Band_setModified", BeamPyBand_setModified, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getGeoCoding", BeamPyBand_getGeoCoding, METH_VARARGS, " Returns the geo-coding of this {@link RasterDataNode}.\n\n @return the geo-coding\n\n@param this The Band object."},
    {"Band_setGeoCoding", BeamPyBand_setGeoCoding, METH_VARARGS, " Sets the geo-coding for this {@link RasterDataNode}.\n Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_GEOCODING}.</p>\n\n \n@param this The Band object.\n@param geoCoding the new geo-coding\n @see Product#setGeoCoding(GeoCoding)\n"},
    {"Band_getPointing", BeamPyBand_getPointing, METH_VARARGS, " Gets a {@link Pointing} if one is available for this raster.\n The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\n since the last creation of this raster's {@link Pointing} instance.\n\n @return the pointing object, or null if a pointing is not available\n\n@param this The Band object."},
    {"Band_canBeOrthorectified", BeamPyBand_canBeOrthorectified, METH_VARARGS, " Tests if this raster data node can be orthorectified.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_isFloatingPointType", BeamPyBand_isFloatingPointType, METH_VARARGS, " Returns <code>true</code> if the pixel data contained in this band is \"naturally\" a floating point number type.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_getGeophysicalDataType", BeamPyBand_getGeophysicalDataType, METH_VARARGS, " Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the\n <code>ProductData.TYPE_XXX</code> constants.\n\n @return the geophysical data type\n @see ProductData\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_getScalingFactor", BeamPyBand_getScalingFactor, METH_VARARGS, " Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>1.0</code> (no factor).\n\n @return the scaling factor\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setScalingFactor", BeamPyBand_setScalingFactor, METH_VARARGS, " Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The Band object.\n@param scalingFactor the scaling factor\n @see #isScalingApplied()\n"},
    {"Band_getScalingOffset", BeamPyBand_getScalingOffset, METH_VARARGS, " Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>0.0</code> (no offset).\n\n @return the scaling offset\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setScalingOffset", BeamPyBand_setScalingOffset, METH_VARARGS, " Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The Band object.\n@param scalingOffset the scaling offset\n @see #isScalingApplied()\n"},
    {"Band_isLog10Scaled", BeamPyBand_isLog10Scaled, METH_VARARGS, " Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n <code>false</code>.\n\n @return whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n\n@param this The Band object."},
    {"Band_setLog10Scaled", BeamPyBand_setLog10Scaled, METH_VARARGS, " Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data.\n\n \n@param this The Band object.\n@param log10Scaled whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n"},
    {"Band_isScalingApplied", BeamPyBand_isScalingApplied, METH_VARARGS, " Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\n pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n {@link #setPixelFloat(int, int, float)}.\n\n @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n @see #getScalingOffset\n @see #getScalingFactor\n @see #isLog10Scaled\n\n@param this The Band object."},
    {"Band_isValidMaskProperty", BeamPyBand_isValidMaskProperty, METH_VARARGS, " Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n\n @param propertyName the  name to test\n @return {@code true}, if so.\n @since BEAM 4.2\n"},
    {"Band_isNoDataValueSet", BeamPyBand_isNoDataValueSet, METH_VARARGS, " Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n\n @return true, if so\n @see #isNoDataValueUsed()\n @see #setNoDataValue(double)\n\n@param this The Band object."},
    {"Band_clearNoDataValue", BeamPyBand_clearNoDataValue, METH_VARARGS, " Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.\n\n@param this The Band object."},
    {"Band_isNoDataValueUsed", BeamPyBand_isNoDataValueUsed, METH_VARARGS, " Tests whether or not the no-data value is used.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n @see #setNoDataValueUsed(boolean)\n @see #isNoDataValueSet()\n\n@param this The Band object."},
    {"Band_setNoDataValueUsed", BeamPyBand_setNoDataValueUsed, METH_VARARGS, " Sets whether or not the no-data value is used.\n If the no-data value is enabled and the no-data value has not been set so far,\n a default no-data value it is set with a value of to zero.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n\n \n@param this The Band object.\n@param noDataValueUsed true, if so\n @see #isNoDataValueUsed()\n"},
    {"Band_getNoDataValue", BeamPyBand_getNoDataValue, METH_VARARGS, " Gets the no-data value as a primitive <code>double</code>.\n <p>Note that the value returned is NOT necessarily the same as the value returned by\n {@link #getGeophysicalNoDataValue()} because no scaling is applied.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.\n\n @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n @see #setNoDataValue(double)\n @see #isNoDataValueSet()\n\n@param this The Band object."},
    {"Band_setNoDataValue", BeamPyBand_setNoDataValue, METH_VARARGS, " Sets the no-data value as a primitive <code>double</code>.\n <p>Note that the given value is related to the \"raw\", un-scaled raster data.\n In order to set the geophysical, scaled no-data value use the method\n {@link #setGeophysicalNoDataValue(double)}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The Band object.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n @see #getNoDataValue()\n @see #isNoDataValueSet()\n"},
    {"Band_getGeophysicalNoDataValue", BeamPyBand_getGeophysicalNoDataValue, METH_VARARGS, " Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n\n@param this The Band object."},
    {"Band_setGeophysicalNoDataValue", BeamPyBand_setGeophysicalNoDataValue, METH_VARARGS, " Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The Band object.\n@param noDataValue the new geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n @see #isNoDataValueSet()\n"},
    {"Band_getValidPixelExpression", BeamPyBand_getValidPixelExpression, METH_VARARGS, " Gets the expression that is used to determine whether a pixel is valid or not.\n For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the valid mask expression.\n\n@param this The Band object."},
    {"Band_setValidPixelExpression", BeamPyBand_setValidPixelExpression, METH_VARARGS, " Sets the expression that is used to determine whether a pixel is valid or not.\n <p>The valid-pixel expression is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n\n \n@param this The Band object.\n@param validPixelExpression the valid mask expression, can be null\n"},
    {"Band_isValidMaskUsed", BeamPyBand_isValidMaskUsed, METH_VARARGS, " Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\n true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\n <p>The data-mask is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n\n@param this The Band object."},
    {"Band_resetValidMask", BeamPyBand_resetValidMask, METH_VARARGS, " Resets the valid mask of this raster.\n The mask will be lazily regenerated when requested the next time.\n\n@param this The Band object."},
    {"Band_getValidMaskExpression", BeamPyBand_getValidMaskExpression, METH_VARARGS, " Gets the expression used for the computation of the mask which identifies valid pixel values.\n It recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n {@link #getValidPixelExpression() validPixelExpression} properties, if any.\n The method returns {@code null},  if none of these properties are set.\n\n @return The expression used for the computation of the mask which identifies valid pixel values,\n         or {@code null}.\n @see #getValidPixelExpression()\n @see #getNoDataValue()\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_updateExpression", BeamPyBand_updateExpression, METH_VARARGS, " {@inheritDoc}\n\n@param this The Band object."},
    {"Band_hasRasterData", BeamPyBand_hasRasterData, METH_VARARGS, " Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\n false.\n\n @return true, if so.\n\n@param this The Band object."},
    {"Band_getRasterData", BeamPyBand_getRasterData, METH_VARARGS, " Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns\n <code>null</code>.\n\n @return the raster data for this band, or <code>null</code> if data has not been loaded\n\n@param this The Band object."},
    {"Band_setRasterData", BeamPyBand_setRasterData, METH_VARARGS, " Sets the raster data of this dataset.\n <p/>\n <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product\n raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\n dataset's data!\n\n \n@param this The Band object.\n@param rasterData the raster data for this dataset\n @see #getRasterData()\n"},
    {"Band_loadRasterData", BeamPyBand_loadRasterData, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n\n@param this The Band object."},
    {"Band_isPixelValid", BeamPyBand_isPixelValid, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n <p/>\n <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\n a synchronised block was used due to problem with the JAI ROI class that has been used in\n the former implementation.</i>\n\n \n@param this The Band object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"Band_getSampleInt", BeamPyBand_getSampleInt, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The Band object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"Band_getSampleFloat", BeamPyBand_getSampleFloat, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The Band object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"Band_getPixelsInt", BeamPyBand_getPixelsInt, METH_VARARGS, " @see #getPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_getPixelsFloat", BeamPyBand_getPixelsFloat, METH_VARARGS, " @see #getPixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_getPixelsDouble", BeamPyBand_getPixelsDouble, METH_VARARGS, " @see #getPixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readPixelsInt", BeamPyBand_readPixelsInt, METH_VARARGS, " @see #readPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readPixelsFloat", BeamPyBand_readPixelsFloat, METH_VARARGS, " @see #readPixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readPixelsDouble", BeamPyBand_readPixelsDouble, METH_VARARGS, " @see #readPixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_writePixelsInt", BeamPyBand_writePixelsInt, METH_VARARGS, " @see #writePixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_writePixelsFloat", BeamPyBand_writePixelsFloat, METH_VARARGS, " @see #writePixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_writePixelsDouble", BeamPyBand_writePixelsDouble, METH_VARARGS, " @see #writePixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readValidMask", BeamPyBand_readValidMask, METH_VARARGS, "\n@param this The Band object."},
    {"Band_readRasterDataFully", BeamPyBand_readRasterDataFully, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #readRasterDataFully(ProgressMonitor)\n\n@param this The Band object."},
    {"Band_readRasterData", BeamPyBand_readRasterData, METH_VARARGS, " Reads raster data from the node's associated data source into the given data\n buffer.\n\n \n@param this The Band object.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n @param offsetY    the Y-offset in the raster co-ordinates where reading starts\n @param width      the width of the raster data buffer\n @param height     the height of the raster data buffer\n @param rasterData a raster data buffer receiving the pixels to be read\n @throws java.io.IOException      if an I/O error occurs\n @throws IllegalArgumentException if the raster is null\n @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\n                                  which this product raster belongs to, has no associated product reader\n @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)\n"},
    {"Band_writeRasterDataFully", BeamPyBand_writeRasterDataFully, METH_VARARGS, "\n@param this The Band object."},
    {"Band_writeRasterData", BeamPyBand_writeRasterData, METH_VARARGS, "\n@param this The Band object."},
    {"Band_createCompatibleRasterData", BeamPyBand_createCompatibleRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleSceneRasterData\n\n@param this The Band object."},
    {"Band_createCompatibleSceneRasterData", BeamPyBand_createCompatibleSceneRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n\n@param this The Band object."},
    {"Band_createCompatibleRasterDataForRect", BeamPyBand_createCompatibleRasterDataForRect, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>width*height</code> elements of a compatible data type.\n\n \n@param this The Band object.\n@param width  the width of the raster data to be created\n @param height the height of the raster data to be created\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n @see #createCompatibleSceneRasterData\n"},
    {"Band_isCompatibleRasterData", BeamPyBand_isCompatibleRasterData, METH_VARARGS, " Tests whether the given parameters specify a compatible raster or not.\n\n \n@param this The Band object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @return {@code true} if so\n"},
    {"Band_checkCompatibleRasterData", BeamPyBand_checkCompatibleRasterData, METH_VARARGS, " Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n\n \n@param this The Band object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n"},
    {"Band_hasIntPixels", BeamPyBand_hasIntPixels, METH_VARARGS, " Determines whether this raster data node contains integer samples.\n\n @return true if this raster data node contains integer samples.\n\n@param this The Band object."},
    {"Band_createTransectProfileData", BeamPyBand_createTransectProfileData, METH_VARARGS, " Creates a transect profile for the given shape (-outline).\n\n \n@param this The Band object.\n@param shape the shape\n @return the profile data\n @throws IOException if an I/O error occurs\n"},
    {"Band_getImageInfo", BeamPyBand_getImageInfo, METH_VARARGS, " Gets the image information for image display.\n\n @return the image info or null\n\n@param this The Band object."},
    {"Band_setImageInfo", BeamPyBand_setImageInfo, METH_VARARGS, " Sets the image information for image display.\n\n \n@param this The Band object.\n@param imageInfo the image info, can be null\n"},
    {"Band_fireImageInfoChanged", BeamPyBand_fireImageInfoChanged, METH_VARARGS, " Notifies listeners that the image (display) information has changed.\n\n @since BEAM 4.7\n\n@param this The Band object."},
    {"Band_createDefaultImageInfo", BeamPyBand_createDefaultImageInfo, METH_VARARGS, " Creates an instance of a default image information.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The Band object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param histogram      the histogram to create the image information.\n @return a valid image information instance, never <code>null</code>.\n"},
    {"Band_getOverlayMaskGroup", BeamPyBand_getOverlayMaskGroup, METH_VARARGS, " @return The overlay mask group.\n\n@param this The Band object."},
    {"Band_createColorIndexedImage", BeamPyBand_createColorIndexedImage, METH_VARARGS, " Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\n null)</code>.\n\n \n@param this The Band object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"Band_createRgbImage", BeamPyBand_createRgbImage, METH_VARARGS, " Creates an RGB image for this raster data node.\n\n \n@param this The Band object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"Band_createPixelValidator", BeamPyBand_createPixelValidator, METH_VARARGS, " Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n\n \n@param this The Band object.\n@param lineOffset the absolute line offset, zero based\n @param roi        an optional ROI\n @return a new validator instance, never null\n @throws IOException if an I/O error occurs\n"},
    {"Band_scale", BeamPyBand_scale, METH_VARARGS, " Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\n scaling.\n\n \n@param this The Band object.\n@param v the input value\n @return the scaled value\n"},
    {"Band_scaleInverse", BeamPyBand_scaleInverse, METH_VARARGS, " Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\n scaling.\n\n \n@param this The Band object.\n@param v the input value\n @return the scaled value\n"},
    {"Band_getPixelString", BeamPyBand_getPixelString, METH_VARARGS, " Returns the pixel located at (x,y) as a string value.\n\n \n@param this The Band object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return the pixel value at (x,y) as string or an error message text\n"},
    {"Band_isSourceImageSet", BeamPyBand_isSourceImageSet, METH_VARARGS, " Returns whether the source image is set on this {@code RasterDataNode}.\n\n @return whether the source image is set.\n @see #getSourceImage()\n @see #setSourceImage(java.awt.image.RenderedImage)\n @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n @see #createSourceImage()\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_getSourceImage", BeamPyBand_getSourceImage, METH_VARARGS, " Gets the source image associated with this {@code RasterDataNode}.\n\n @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\n         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n @see #createSourceImage()\n @see #isSourceImageSet()\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_isGeophysicalImageSet", BeamPyBand_isGeophysicalImageSet, METH_VARARGS, " Returns whether the geophysical image is set on this {@code RasterDataNode}.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return whether the geophysical image is set.\n @since BEAM 4.6\n\n@param this The Band object."},
    {"Band_getGeophysicalImage", BeamPyBand_getGeophysicalImage, METH_VARARGS, " @return The geophysical source image.\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_isValidMaskImageSet", BeamPyBand_isValidMaskImageSet, METH_VARARGS, " Returns wether the valid mask image is set on this {@code RasterDataNode}.\n\n @return Wether the source image is set.\n @since BEAM 4.5\n\n@param this The Band object."},
    {"Band_getValidMaskImage", BeamPyBand_getValidMaskImage, METH_VARARGS, " Gets the valid-mask image associated with this {@code RasterDataNode}.\n\n @return The rendered image.\n @since BEAM 4.2\n\n@param this The Band object."},
    {"Band_isStxSet", BeamPyBand_isStxSet, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getStx", BeamPyBand_getStx, METH_VARARGS, " Gets the statistics. If statistcs are not yet available,\n the method will compute (possibly inaccurate) statistics and return those.\n <p/>\n If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\n shall be used instead.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return The statistics.\n @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n @see #setStx(Stx)\n @since BEAM 4.2, revised in BEAM 4.5\n\n@param this The Band object."},
    {"Band_setStx", BeamPyBand_setStx, METH_VARARGS, " Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\n are really related to this {@code RasterDataNode}'s raster data.\n The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The Band object.\n@param stx The statistics.\n @since BEAM 4.2, revised in BEAM 4.5\n"},
    {"Band_getValidShape", BeamPyBand_getValidShape, METH_VARARGS, " Gets the shape of the area where this raster data contains valid samples.\n The method returns <code>null</code>, if the entire raster contains valid samples.\n\n @return The shape of the area where the raster data has samples, can be {@code null}.\n @since BEAM 4.7\n\n@param this The Band object."},
    {"Band_getDataType", BeamPyBand_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The Band object."},
    {"Band_getNumDataElems", BeamPyBand_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The Band object."},
    {"Band_setData", BeamPyBand_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The Band object."},
    {"Band_getData", BeamPyBand_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The Band object."},
    {"Band_getDataElems", BeamPyBand_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The Band object."},
    {"Band_getDataElemSize", BeamPyBand_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The Band object."},
    {"Band_setReadOnly", BeamPyBand_setReadOnly, METH_VARARGS, "\n@param this The Band object."},
    {"Band_isReadOnly", BeamPyBand_isReadOnly, METH_VARARGS, "\n@param this The Band object."},
    {"Band_setUnit", BeamPyBand_setUnit, METH_VARARGS, "\n@param this The Band object."},
    {"Band_getUnit", BeamPyBand_getUnit, METH_VARARGS, "\n@param this The Band object."},
    {"Band_fireProductNodeDataChanged", BeamPyBand_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The Band object."},
    {"Band_createCompatibleProductData", BeamPyBand_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The Band object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"Band_getOwner", BeamPyBand_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The Band object."},
    {"Band_getName", BeamPyBand_getName, METH_VARARGS, " @return This node's name.\n\n@param this The Band object."},
    {"Band_setName", BeamPyBand_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The Band object.\n@param name The name.\n"},
    {"Band_getDescription", BeamPyBand_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The Band object."},
    {"Band_setDescription", BeamPyBand_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The Band object.\n@param description a description, can be <code>null</code>\n"},
    {"Band_isModified", BeamPyBand_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The Band object."},
    {"Band_isValidNodeName", BeamPyBand_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"Band_getProduct", BeamPyBand_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The Band object."},
    {"Band_getProductReader", BeamPyBand_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The Band object."},
    {"Band_getProductWriter", BeamPyBand_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The Band object."},
    {"Band_getDisplayName", BeamPyBand_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The Band object."},
    {"Band_getProductRefString", BeamPyBand_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The Band object."},
    {"PlacemarkGroup_getVectorDataNode", BeamPyPlacemarkGroup_getVectorDataNode, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getPlacemark", BeamPyPlacemarkGroup_getPlacemark, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_add4", BeamPyPlacemarkGroup_add4, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_add2", BeamPyPlacemarkGroup_add2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_remove2", BeamPyPlacemarkGroup_remove2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_dispose", BeamPyPlacemarkGroup_dispose, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_isTakingOverNodeOwnership", BeamPyPlacemarkGroup_isTakingOverNodeOwnership, METH_VARARGS, " @return {@code true}, if child nodes will have this group as owner after adding.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getNodeCount", BeamPyPlacemarkGroup_getNodeCount, METH_VARARGS, " @return The number of product nodes in this product group.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_get1", BeamPyPlacemarkGroup_get1, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param index The node index.\n @return The product node at the given index.\n"},
    {"PlacemarkGroup_getNodeDisplayNames", BeamPyPlacemarkGroup_getNodeDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n @see ProductNode#getDisplayName()\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getNodeNames", BeamPyPlacemarkGroup_getNodeNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toArray1", BeamPyPlacemarkGroup_toArray1, METH_VARARGS, " Returns an array of all products currently managed.\n\n @return an array containing the products, never <code>null</code>, but the array can have zero length\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toArray2", BeamPyPlacemarkGroup_toArray2, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a\n              new array of the same runtime type is allocated for this purpose.\n @return an array containing the product nodes, never <code>null</code>, but the array can have zero length\n"},
    {"PlacemarkGroup_indexOf2", BeamPyPlacemarkGroup_indexOf2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_indexOf1", BeamPyPlacemarkGroup_indexOf1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getByDisplayName", BeamPyPlacemarkGroup_getByDisplayName, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param displayName the display name\n @return the product node with the given display name.\n"},
    {"PlacemarkGroup_get2", BeamPyPlacemarkGroup_get2, METH_VARARGS, " \n@param this The PlacemarkGroup object.\n@param name the name\n @return the product node with the given name.\n"},
    {"PlacemarkGroup_contains2", BeamPyPlacemarkGroup_contains2, METH_VARARGS, " Tests whether a node with the given name is contained in this group.\n\n \n@param this The PlacemarkGroup object.\n@param name the name\n @return true, if so\n"},
    {"PlacemarkGroup_contains1", BeamPyPlacemarkGroup_contains1, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The PlacemarkGroup object.\n@param node the node\n @return true, if so\n"},
    {"PlacemarkGroup_add3", BeamPyPlacemarkGroup_add3, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The PlacemarkGroup object.\n@param node the node to be added, ignored if <code>null</code>\n @return true, if the node has been added\n"},
    {"PlacemarkGroup_add1", BeamPyPlacemarkGroup_add1, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The PlacemarkGroup object.\n@param index the index.\n @param node  the node to be added, ignored if <code>null</code>\n"},
    {"PlacemarkGroup_remove1", BeamPyPlacemarkGroup_remove1, METH_VARARGS, " Removes the given node from this group.\n\n \n@param this The PlacemarkGroup object.\n@param node the node to be removed\n @return true, if the node was removed\n"},
    {"PlacemarkGroup_removeAll", BeamPyPlacemarkGroup_removeAll, METH_VARARGS, " Removes all nodes from this group.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_clearRemovedList", BeamPyPlacemarkGroup_clearRemovedList, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRemovedNodes", BeamPyPlacemarkGroup_getRemovedNodes, METH_VARARGS, " Gets all removed node nodes.\n\n @return a collection of all removed node nodes.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRawStorageSize2", BeamPyPlacemarkGroup_getRawStorageSize2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setModified", BeamPyPlacemarkGroup_setModified, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_acceptVisitor", BeamPyPlacemarkGroup_acceptVisitor, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_updateExpression", BeamPyPlacemarkGroup_updateExpression, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getOwner", BeamPyPlacemarkGroup_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getName", BeamPyPlacemarkGroup_getName, METH_VARARGS, " @return This node's name.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setName", BeamPyPlacemarkGroup_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The PlacemarkGroup object.\n@param name The name.\n"},
    {"PlacemarkGroup_getDescription", BeamPyPlacemarkGroup_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_setDescription", BeamPyPlacemarkGroup_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The PlacemarkGroup object.\n@param description a description, can be <code>null</code>\n"},
    {"PlacemarkGroup_isModified", BeamPyPlacemarkGroup_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_toString", BeamPyPlacemarkGroup_toString, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_isValidNodeName", BeamPyPlacemarkGroup_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"PlacemarkGroup_getProduct", BeamPyPlacemarkGroup_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductReader", BeamPyPlacemarkGroup_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductWriter", BeamPyPlacemarkGroup_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getDisplayName", BeamPyPlacemarkGroup_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getProductRefString", BeamPyPlacemarkGroup_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_getRawStorageSize1", BeamPyPlacemarkGroup_getRawStorageSize1, METH_VARARGS, " Gets an estimated, raw storage size in bytes of this product node.\n\n @return the size in bytes.\n\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_fireProductNodeChanged1", BeamPyPlacemarkGroup_fireProductNodeChanged1, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_fireProductNodeChanged2", BeamPyPlacemarkGroup_fireProductNodeChanged2, METH_VARARGS, "\n@param this The PlacemarkGroup object."},
    {"PlacemarkGroup_removeFromFile", BeamPyPlacemarkGroup_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The PlacemarkGroup object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"TiePointGrid_newTiePointGrid1", BeamPyTiePointGrid_newTiePointGrid1, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name         the name of the new object\n @param gridWidth    the width of the tie-point grid in pixels\n @param gridHeight   the height of the tie-point grid in pixels\n @param offsetX      the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY      the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                     this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                     this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints    the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n"},
    {"TiePointGrid_newTiePointGrid2", BeamPyTiePointGrid_newTiePointGrid2, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name          the name of the new object\n @param gridWidth     the width of the tie-point grid in pixels\n @param gridHeight    the height of the tie-point grid in pixels\n @param offsetX       the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY       the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                      this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                      this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints     the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n @param discontinuity the discontinuity mode, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180}\n                      {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_newTiePointGrid3", BeamPyTiePointGrid_newTiePointGrid3, METH_VARARGS, " Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.\n\n @param name           the name of the new object\n @param gridWidth      the width of the tie-point grid in pixels\n @param gridHeight     the height of the tie-point grid in pixels\n @param offsetX        the X co-ordinate of the first (upper-left) tie-point in pixels\n @param offsetY        the Y co-ordinate of the first (upper-left) tie-point in pixels\n @param subSamplingX   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                       this tie-pint grid belongs to. Must not be less than one.\n @param subSamplingY   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which\n                       this tie-pint grid belongs to. Must not be less than one.\n @param tiePoints      the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>\n @param containsAngles if true, the {@link #getDiscontinuity() angular discontinuity} is derived from the provided tie-point data values\n"},
    {"TiePointGrid_getDiscontinuity2", BeamPyTiePointGrid_getDiscontinuity2, METH_VARARGS, " Determines the angular discontinuity of the given tie point values.\n\n @return the angular discontinuity, will always be either {@link #DISCONT_AT_180} or\n         {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_getDiscontinuity1", BeamPyTiePointGrid_getDiscontinuity1, METH_VARARGS, " Gets the angular discontinuity.\n\n @return the angular discontinuity, will always be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n         {@link #DISCONT_AT_360}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setDiscontinuity", BeamPyTiePointGrid_setDiscontinuity, METH_VARARGS, " Sets the angular discontinuity.\n\n \n@param this The TiePointGrid object.\n@param discontinuity angular discontinuity, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or\n                      {@link #DISCONT_AT_360}\n"},
    {"TiePointGrid_isFloatingPointType", BeamPyTiePointGrid_isFloatingPointType, METH_VARARGS, " Returns <code>true</code>\n\n @return true\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeophysicalDataType", BeamPyTiePointGrid_getGeophysicalDataType, METH_VARARGS, " Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the\n <code>ProductData.TYPE_XXX</code> constants.\n\n @return the geophysical data type\n\n @see ProductData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterData", BeamPyTiePointGrid_getSceneRasterData, METH_VARARGS, " Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. <p/>\n <p/>\n In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store\n the scene's pixels.\n\n @return raster data covering the pixels for a complete scene\n\n @see #getRasterData\n @see #getRasterWidth\n @see #getRasterHeight\n @see #getSceneRasterWidth\n @see #getSceneRasterHeight\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterWidth", BeamPyTiePointGrid_getSceneRasterWidth, METH_VARARGS, " Returns the width in pixels of the scene represented by this tie-point grid. The value returned is\n <code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>\n\n @return the scene width in pixels\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSceneRasterHeight", BeamPyTiePointGrid_getSceneRasterHeight, METH_VARARGS, " Returns the height in pixels of the scene represented by this tie-point grid. The value returned is\n <code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>\n\n @return the scene height in pixels\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getOffsetX", BeamPyTiePointGrid_getOffsetX, METH_VARARGS, " Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getOffsetY", BeamPyTiePointGrid_getOffsetY, METH_VARARGS, " Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSubSamplingX", BeamPyTiePointGrid_getSubSamplingX, METH_VARARGS, " Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this\n tie-pint grid belongs to.\n\n @return the sub-sampling in X-direction, never less than one.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSubSamplingY", BeamPyTiePointGrid_getSubSamplingY, METH_VARARGS, " Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this\n tie-pint grid belongs to.\n\n @return the sub-sampling in Y-direction, never less than one.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getTiePoints", BeamPyTiePointGrid_getTiePoints, METH_VARARGS, " Gets the data array holding this band's pixel samples.\n\n @return the data array for this band, or <code>null</code> if no data has been loaded\n\n @see ProductData#getElems\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixelInt", BeamPyTiePointGrid_getPixelInt, METH_VARARGS, " Gets the interpolated sample for the pixel located at (x,y) as an integer value. <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location\n @param y The Y co-ordinate of the pixel location\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_dispose", BeamPyTiePointGrid_dispose, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixelFloat2", BeamPyTiePointGrid_getPixelFloat2, METH_VARARGS, " Computes the interpolated sample for the pixel located at (x,y). <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_getPixelFloat1", BeamPyTiePointGrid_getPixelFloat1, METH_VARARGS, " Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. <p/>\n <p/>\n If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_getPixelDouble", BeamPyTiePointGrid_getPixelDouble, METH_VARARGS, " Gets the interpolated sample for the pixel located at (x,y) as a double value. <p/>\n <p/>\n If the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.\n\n \n@param this The TiePointGrid object.\n@param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which\n          this tie-pint grid belongs to.\n\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n"},
    {"TiePointGrid_setPixelInt", BeamPyTiePointGrid_setPixelInt, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixelFloat", BeamPyTiePointGrid_setPixelFloat, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixelDouble", BeamPyTiePointGrid_setPixelDouble, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels6", BeamPyTiePointGrid_getPixels6, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the integer array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_getPixels4", BeamPyTiePointGrid_getPixels4, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product width and height as float array. If the given\n array is <code>null</code> a new one is created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the float array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_getPixels2", BeamPyTiePointGrid_getPixels2, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the double array to be filled with data\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_setPixels3", BeamPyTiePointGrid_setPixels3, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixels2", BeamPyTiePointGrid_setPixels2, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setPixels1", BeamPyTiePointGrid_setPixels1, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels6", BeamPyTiePointGrid_readPixels6, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the integer array to be filled with data\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_readPixels4", BeamPyTiePointGrid_readPixels4, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as float array. If the given\n array is <code>null</code> a new one was created and returned. *\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the float array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_readPixels2", BeamPyTiePointGrid_readPixels2, METH_VARARGS, " Retrieves an array of tie point data interpolated to the product with and height as double array. If the given\n array is <code>null</code> a new one was created and returned.\n\n \n@param this The TiePointGrid object.\n@param x      the x coordinate of the array to be read\n @param y      the y coordinate of the array to be read\n @param w      the width of the array to be read\n @param h      the height of the array to be read\n @param pixels the double array to be filled with data\n @param pm     a monitor to inform the user about progress\n\n @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.\n"},
    {"TiePointGrid_writePixels6", BeamPyTiePointGrid_writePixels6, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels4", BeamPyTiePointGrid_writePixels4, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels2", BeamPyTiePointGrid_writePixels2, METH_VARARGS, " This method is not implemented because pixels are read-only in tie-point grids.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterData2", BeamPyTiePointGrid_readRasterData2, METH_VARARGS, " Reads raster data from this dataset into the user-supplied raster data buffer. <p/>\n <p/>\n This method always directly (re-)reads this band's data from its associated data source into the given data\n buffer.\n\n \n@param this The TiePointGrid object.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n @param offsetY    the Y-offset in the raster co-ordinates where reading starts\n @param width      the width of the raster data buffer\n @param height     the height of the raster data buffer\n @param rasterData a raster data buffer receiving the pixels to be read\n @param pm         a monitor to inform the user about progress\n\n @throws java.io.IOException      if an I/O error occurs\n @throws IllegalArgumentException if the raster is null\n @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\n                                  which this product raster belongs to, has no associated product reader\n @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor) \n"},
    {"TiePointGrid_readRasterDataFully2", BeamPyTiePointGrid_readRasterDataFully2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterData2", BeamPyTiePointGrid_writeRasterData2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterDataFully2", BeamPyTiePointGrid_writeRasterDataFully2, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_acceptVisitor", BeamPyTiePointGrid_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor. <p/>\n <p/>\n The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The TiePointGrid object.\n@param visitor the visitor\n"},
    {"TiePointGrid_cloneTiePointGrid", BeamPyTiePointGrid_cloneTiePointGrid, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_createZenithFromElevationAngleTiePointGrid", BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid, METH_VARARGS, ""},
    {"TiePointGrid_createSubset", BeamPyTiePointGrid_createSubset, METH_VARARGS, ""},
    {"TiePointGrid_getRasterWidth", BeamPyTiePointGrid_getRasterWidth, METH_VARARGS, " Returns the width of the raster used by this product raster.\n\n @return the width of the raster\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRasterHeight", BeamPyTiePointGrid_getRasterHeight, METH_VARARGS, " Returns the height of the raster used by this product raster.\n\n @return the height of the raster\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setModified", BeamPyTiePointGrid_setModified, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeoCoding", BeamPyTiePointGrid_getGeoCoding, METH_VARARGS, " Returns the geo-coding of this {@link RasterDataNode}.\n\n @return the geo-coding\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setGeoCoding", BeamPyTiePointGrid_setGeoCoding, METH_VARARGS, " Sets the geo-coding for this {@link RasterDataNode}.\n Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_GEOCODING}.</p>\n\n \n@param this The TiePointGrid object.\n@param geoCoding the new geo-coding\n @see Product#setGeoCoding(GeoCoding)\n"},
    {"TiePointGrid_getPointing", BeamPyTiePointGrid_getPointing, METH_VARARGS, " Gets a {@link Pointing} if one is available for this raster.\n The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed\n since the last creation of this raster's {@link Pointing} instance.\n\n @return the pointing object, or null if a pointing is not available\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_canBeOrthorectified", BeamPyTiePointGrid_canBeOrthorectified, METH_VARARGS, " Tests if this raster data node can be orthorectified.\n\n @return true, if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getScalingFactor", BeamPyTiePointGrid_getScalingFactor, METH_VARARGS, " Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>1.0</code> (no factor).\n\n @return the scaling factor\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setScalingFactor", BeamPyTiePointGrid_setScalingFactor, METH_VARARGS, " Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The TiePointGrid object.\n@param scalingFactor the scaling factor\n @see #isScalingApplied()\n"},
    {"TiePointGrid_getScalingOffset", BeamPyTiePointGrid_getScalingOffset, METH_VARARGS, " Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is\n <code>0.0</code> (no offset).\n\n @return the scaling offset\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setScalingOffset", BeamPyTiePointGrid_setScalingOffset, METH_VARARGS, " Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.\n\n \n@param this The TiePointGrid object.\n@param scalingOffset the scaling offset\n @see #isScalingApplied()\n"},
    {"TiePointGrid_isLog10Scaled", BeamPyTiePointGrid_isLog10Scaled, METH_VARARGS, " Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data. The default value is\n <code>false</code>.\n\n @return whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setLog10Scaled", BeamPyTiePointGrid_setLog10Scaled, METH_VARARGS, " Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and\n thus the common logarithm (base 10) of the values is stored in the raw data.\n\n \n@param this The TiePointGrid object.\n@param log10Scaled whether or not the data is logging-10 scaled\n @see #isScalingApplied()\n"},
    {"TiePointGrid_isScalingApplied", BeamPyTiePointGrid_isScalingApplied, METH_VARARGS, " Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful\n pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},\n {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and\n {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and\n <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and\n {@link #setPixelFloat(int, int, float)}.\n\n @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.\n @see #getScalingOffset\n @see #getScalingFactor\n @see #isLog10Scaled\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidMaskProperty", BeamPyTiePointGrid_isValidMaskProperty, METH_VARARGS, " Tests if the given name is the name of a property which is relevant for the computation of the valid mask.\n\n @param propertyName the  name to test\n @return {@code true}, if so.\n @since BEAM 4.2\n"},
    {"TiePointGrid_isNoDataValueSet", BeamPyTiePointGrid_isNoDataValueSet, METH_VARARGS, " Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either\n {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.\n\n @return true, if so\n @see #isNoDataValueUsed()\n @see #setNoDataValue(double)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_clearNoDataValue", BeamPyTiePointGrid_clearNoDataValue, METH_VARARGS, " Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isNoDataValueUsed", BeamPyTiePointGrid_isNoDataValueUsed, METH_VARARGS, " Tests whether or not the no-data value is used.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n @see #setNoDataValueUsed(boolean)\n @see #isNoDataValueSet()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setNoDataValueUsed", BeamPyTiePointGrid_setNoDataValueUsed, METH_VARARGS, " Sets whether or not the no-data value is used.\n If the no-data value is enabled and the no-data value has not been set so far,\n a default no-data value it is set with a value of to zero.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.\n\n \n@param this The TiePointGrid object.\n@param noDataValueUsed true, if so\n @see #isNoDataValueUsed()\n"},
    {"TiePointGrid_getNoDataValue", BeamPyTiePointGrid_getNoDataValue, METH_VARARGS, " Gets the no-data value as a primitive <code>double</code>.\n <p>Note that the value returned is NOT necessarily the same as the value returned by\n {@link #getGeophysicalNoDataValue()} because no scaling is applied.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.\n\n @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.\n @see #setNoDataValue(double)\n @see #isNoDataValueSet()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setNoDataValue", BeamPyTiePointGrid_setNoDataValue, METH_VARARGS, " Sets the no-data value as a primitive <code>double</code>.\n <p>Note that the given value is related to the \"raw\", un-scaled raster data.\n In order to set the geophysical, scaled no-data value use the method\n {@link #setGeophysicalNoDataValue(double)}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The TiePointGrid object.\n@param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.\n @see #getNoDataValue()\n @see #isNoDataValueSet()\n"},
    {"TiePointGrid_getGeophysicalNoDataValue", BeamPyTiePointGrid_getGeophysicalNoDataValue, METH_VARARGS, " Gets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setGeophysicalNoDataValue", BeamPyTiePointGrid_setGeophysicalNoDataValue, METH_VARARGS, " Sets the geophysical no-data value which is simply the scaled \"raw\" no-data value\n returned by {@link #getNoDataValue()}.\n <p>The no-data value is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_NO_DATA_VALUE}.\n\n \n@param this The TiePointGrid object.\n@param noDataValue the new geophysical no-data value\n @see #setGeophysicalNoDataValue(double)\n @see #isNoDataValueSet()\n"},
    {"TiePointGrid_getValidPixelExpression", BeamPyTiePointGrid_getValidPixelExpression, METH_VARARGS, " Gets the expression that is used to determine whether a pixel is valid or not.\n For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return the valid mask expression.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setValidPixelExpression", BeamPyTiePointGrid_setValidPixelExpression, METH_VARARGS, " Sets the expression that is used to determine whether a pixel is valid or not.\n <p>The valid-pixel expression is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property\n name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.\n\n \n@param this The TiePointGrid object.\n@param validPixelExpression the valid mask expression, can be null\n"},
    {"TiePointGrid_isValidMaskUsed", BeamPyTiePointGrid_isValidMaskUsed, METH_VARARGS, " Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns\n true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.\n <p>The data-mask is used to determine valid pixels. For more information\n on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}\n method.\n\n @return true, if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_resetValidMask", BeamPyTiePointGrid_resetValidMask, METH_VARARGS, " Resets the valid mask of this raster.\n The mask will be lazily regenerated when requested the next time.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getValidMaskExpression", BeamPyTiePointGrid_getValidMaskExpression, METH_VARARGS, " Gets the expression used for the computation of the mask which identifies valid pixel values.\n It recognizes the value of the {@link #getNoDataValue() noDataValue} and the\n {@link #getValidPixelExpression() validPixelExpression} properties, if any.\n The method returns {@code null},  if none of these properties are set.\n\n @return The expression used for the computation of the mask which identifies valid pixel values,\n         or {@code null}.\n @see #getValidPixelExpression()\n @see #getNoDataValue()\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_updateExpression", BeamPyTiePointGrid_updateExpression, METH_VARARGS, " {@inheritDoc}\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_hasRasterData", BeamPyTiePointGrid_hasRasterData, METH_VARARGS, " Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise\n false.\n\n @return true, if so.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRasterData", BeamPyTiePointGrid_getRasterData, METH_VARARGS, " Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns\n <code>null</code>.\n\n @return the raster data for this band, or <code>null</code> if data has not been loaded\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setRasterData", BeamPyTiePointGrid_setRasterData, METH_VARARGS, " Sets the raster data of this dataset.\n <p/>\n <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product\n raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this\n dataset's data!\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data for this dataset\n @see #getRasterData()\n"},
    {"TiePointGrid_loadRasterData1", BeamPyTiePointGrid_loadRasterData1, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_loadRasterData2", BeamPyTiePointGrid_loadRasterData2, METH_VARARGS, " Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,\n <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should\n always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>\n elements (samples).\n <p/>\n <p>The default implementation of this method does nothing.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @throws IOException if an I/O error occurs\n @see #unloadRasterData()\n"},
    {"TiePointGrid_unloadRasterData", BeamPyTiePointGrid_unloadRasterData, METH_VARARGS, " Un-loads the raster data for this <code>RasterDataNode</code>.\n <p/>\n <p>It is up to the implementation whether after this method has been called successfully, the\n <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.\n <p/>\n <p>The default implementation of this method does nothing.\n\n @see #loadRasterData()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isPixelValid2", BeamPyTiePointGrid_isPixelValid2, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n <p/>\n <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since\n a synchronised block was used due to problem with the JAI ROI class that has been used in\n the former implementation.</i>\n\n \n@param this The TiePointGrid object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"TiePointGrid_getSampleInt", BeamPyTiePointGrid_getSampleInt, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The TiePointGrid object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"TiePointGrid_getSampleFloat", BeamPyTiePointGrid_getSampleFloat, METH_VARARGS, " Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.\n <p/>\n <i>Note: This method does not belong to the public API.\n It has been added by Norman (2011-08-09) in order to perform performance tests.</i>\n\n \n@param this The TiePointGrid object.\n@param x pixel X coordinate\n @param y pixel Y coordinate\n @return The geo-physical sample value.\n"},
    {"TiePointGrid_isPixelValid1", BeamPyTiePointGrid_isPixelValid1, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or\n or if the bit corresponding to (x,y) is set within the returned mask image.\n\n \n@param this The TiePointGrid object.\n@param pixelIndex the linear pixel index in the range 0 to width * height - 1\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int, javax.media.jai.ROI)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n @since 4.1\n"},
    {"TiePointGrid_isPixelValid3", BeamPyTiePointGrid_isPixelValid3, METH_VARARGS, " Checks whether or not the pixel located at (x,y) is valid.\n The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,\n and secondly, if the pixel is within the ROI (if any).\n\n \n@param this The TiePointGrid object.\n@param x   the X co-ordinate of the pixel location\n @param y   the Y co-ordinate of the pixel location\n @param roi the ROI, if null the method returns {@link #isPixelValid(int, int)}\n @return <code>true</code> if the pixel is valid\n @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds\n @see #isPixelValid(int, int)\n @see #setNoDataValueUsed(boolean)\n @see #setNoDataValue(double)\n @see #setValidPixelExpression(String)\n"},
    {"TiePointGrid_getPixels5", BeamPyTiePointGrid_getPixels5, METH_VARARGS, " @see #getPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels3", BeamPyTiePointGrid_getPixels3, METH_VARARGS, " @see #getPixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getPixels1", BeamPyTiePointGrid_getPixels1, METH_VARARGS, " @see #getPixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels5", BeamPyTiePointGrid_readPixels5, METH_VARARGS, " @see #readPixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels3", BeamPyTiePointGrid_readPixels3, METH_VARARGS, " @see #readPixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readPixels1", BeamPyTiePointGrid_readPixels1, METH_VARARGS, " @see #readPixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels5", BeamPyTiePointGrid_writePixels5, METH_VARARGS, " @see #writePixels(int, int, int, int, int[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels3", BeamPyTiePointGrid_writePixels3, METH_VARARGS, " @see #writePixels(int, int, int, int, float[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_writePixels1", BeamPyTiePointGrid_writePixels1, METH_VARARGS, " @see #writePixels(int, int, int, int, double[], ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readValidMask", BeamPyTiePointGrid_readValidMask, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterDataFully1", BeamPyTiePointGrid_readRasterDataFully1, METH_VARARGS, " @throws java.io.IOException if an I/O error occurs\n @see #readRasterDataFully(ProgressMonitor)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_readRasterData1", BeamPyTiePointGrid_readRasterData1, METH_VARARGS, " Reads raster data from the node's associated data source into the given data\n buffer.\n\n \n@param this The TiePointGrid object.\n@param offsetX    the X-offset in the raster co-ordinates where reading starts\n @param offsetY    the Y-offset in the raster co-ordinates where reading starts\n @param width      the width of the raster data buffer\n @param height     the height of the raster data buffer\n @param rasterData a raster data buffer receiving the pixels to be read\n @throws java.io.IOException      if an I/O error occurs\n @throws IllegalArgumentException if the raster is null\n @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to\n                                  which this product raster belongs to, has no associated product reader\n @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)\n"},
    {"TiePointGrid_writeRasterDataFully1", BeamPyTiePointGrid_writeRasterDataFully1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_writeRasterData1", BeamPyTiePointGrid_writeRasterData1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleRasterData1", BeamPyTiePointGrid_createCompatibleRasterData1, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleSceneRasterData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleSceneRasterData", BeamPyTiePointGrid_createCompatibleSceneRasterData, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.\n\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createCompatibleRasterData2", BeamPyTiePointGrid_createCompatibleRasterData2, METH_VARARGS, " Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>width*height</code> elements of a compatible data type.\n\n \n@param this The TiePointGrid object.\n@param width  the width of the raster data to be created\n @param height the height of the raster data to be created\n @return raster data compatible with this product raster\n @see #createCompatibleRasterData\n @see #createCompatibleSceneRasterData\n"},
    {"TiePointGrid_isCompatibleRasterData", BeamPyTiePointGrid_isCompatibleRasterData, METH_VARARGS, " Tests whether the given parameters specify a compatible raster or not.\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n @return {@code true} if so\n"},
    {"TiePointGrid_checkCompatibleRasterData", BeamPyTiePointGrid_checkCompatibleRasterData, METH_VARARGS, " Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.\n\n \n@param this The TiePointGrid object.\n@param rasterData the raster data\n @param w          the raster width\n @param h          the raster height\n"},
    {"TiePointGrid_hasIntPixels", BeamPyTiePointGrid_hasIntPixels, METH_VARARGS, " Determines whether this raster data node contains integer samples.\n\n @return true if this raster data node contains integer samples.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createTransectProfileData", BeamPyTiePointGrid_createTransectProfileData, METH_VARARGS, " Creates a transect profile for the given shape (-outline).\n\n \n@param this The TiePointGrid object.\n@param shape the shape\n @return the profile data\n @throws IOException if an I/O error occurs\n"},
    {"TiePointGrid_getImageInfo1", BeamPyTiePointGrid_getImageInfo1, METH_VARARGS, " Gets the image information for image display.\n\n @return the image info or null\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setImageInfo", BeamPyTiePointGrid_setImageInfo, METH_VARARGS, " Sets the image information for image display.\n\n \n@param this The TiePointGrid object.\n@param imageInfo the image info, can be null\n"},
    {"TiePointGrid_fireImageInfoChanged", BeamPyTiePointGrid_fireImageInfoChanged, METH_VARARGS, " Notifies listeners that the image (display) information has changed.\n\n @since BEAM 4.7\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getImageInfo2", BeamPyTiePointGrid_getImageInfo2, METH_VARARGS, " Returns the image information for this raster data node.\n <p/>\n <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.\n\n \n@param this The TiePointGrid object.\n@param pm A progress monitor.\n @return A valid image information instance.\n @see #getImageInfo(double[], ProgressMonitor)\n @since BEAM 4.2\n"},
    {"TiePointGrid_getImageInfo3", BeamPyTiePointGrid_getImageInfo3, METH_VARARGS, " Gets the image creation information.\n <p/>\n <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is\n called with the given parameters passed to this method.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas Only used, if new image info is created (see <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code>\n                       method).\n @param pm             A progress monitor.\n @return The image creation information.\n @since BEAM 4.2\n"},
    {"TiePointGrid_createDefaultImageInfo1", BeamPyTiePointGrid_createDefaultImageInfo1, METH_VARARGS, " Creates a default image information instance.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param pm             a monitor to inform the user about progress\n @return a valid image information instance, never <code>null</code>.\n"},
    {"TiePointGrid_createDefaultImageInfo2", BeamPyTiePointGrid_createDefaultImageInfo2, METH_VARARGS, " Creates an instance of a default image information.\n <p/>\n <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.\n\n \n@param this The TiePointGrid object.\n@param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data\n                       histogram to be excluded when determining the value range for a linear constrast\n                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of\n                       the entire area is skipped.\n @param histogram      the histogram to create the image information.\n @return a valid image information instance, never <code>null</code>.\n"},
    {"TiePointGrid_getOverlayMaskGroup", BeamPyTiePointGrid_getOverlayMaskGroup, METH_VARARGS, " @return The overlay mask group.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_createColorIndexedImage", BeamPyTiePointGrid_createColorIndexedImage, METH_VARARGS, " Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,\n null)</code>.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"TiePointGrid_createRgbImage", BeamPyTiePointGrid_createRgbImage, METH_VARARGS, " Creates an RGB image for this raster data node.\n\n \n@param this The TiePointGrid object.\n@param pm a monitor to inform the user about progress\n @return a greyscale/palette-based image for this raster data node\n @throws IOException if the raster data is not loaded so far and reload causes an I/O error\n @see #setImageInfo(ImageInfo)\n"},
    {"TiePointGrid_quantizeRasterData1", BeamPyTiePointGrid_quantizeRasterData1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_quantizeRasterData2", BeamPyTiePointGrid_quantizeRasterData2, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_createPixelValidator", BeamPyTiePointGrid_createPixelValidator, METH_VARARGS, " Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.\n\n \n@param this The TiePointGrid object.\n@param lineOffset the absolute line offset, zero based\n @param roi        an optional ROI\n @return a new validator instance, never null\n @throws IOException if an I/O error occurs\n"},
    {"TiePointGrid_scale", BeamPyTiePointGrid_scale, METH_VARARGS, " Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual\n scaling.\n\n \n@param this The TiePointGrid object.\n@param v the input value\n @return the scaled value\n"},
    {"TiePointGrid_scaleInverse", BeamPyTiePointGrid_scaleInverse, METH_VARARGS, " Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the\n <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual\n scaling.\n\n \n@param this The TiePointGrid object.\n@param v the input value\n @return the scaled value\n"},
    {"TiePointGrid_getPixelString", BeamPyTiePointGrid_getPixelString, METH_VARARGS, " Returns the pixel located at (x,y) as a string value.\n\n \n@param this The TiePointGrid object.\n@param x the X co-ordinate of the pixel location\n @param y the Y co-ordinate of the pixel location\n @return the pixel value at (x,y) as string or an error message text\n"},
    {"TiePointGrid_isSourceImageSet", BeamPyTiePointGrid_isSourceImageSet, METH_VARARGS, " Returns whether the source image is set on this {@code RasterDataNode}.\n\n @return whether the source image is set.\n @see #getSourceImage()\n @see #setSourceImage(java.awt.image.RenderedImage)\n @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)\n @see #createSourceImage()\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getSourceImage", BeamPyTiePointGrid_getSourceImage, METH_VARARGS, " Gets the source image associated with this {@code RasterDataNode}.\n\n @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},\n         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.\n @see #createSourceImage()\n @see #isSourceImageSet()\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setSourceImage2", BeamPyTiePointGrid_setSourceImage2, METH_VARARGS, " Sets the source image associated with this {@code RasterDataNode}.\n\n \n@param this The TiePointGrid object.\n@param sourceImage The source image.\n                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\n @since BEAM 4.2\n"},
    {"TiePointGrid_setSourceImage1", BeamPyTiePointGrid_setSourceImage1, METH_VARARGS, " Sets the source image associated with this {@code RasterDataNode}.\n\n \n@param this The TiePointGrid object.\n@param sourceImage The source image.\n                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.\n @since BEAM 4.6\n"},
    {"TiePointGrid_isGeophysicalImageSet", BeamPyTiePointGrid_isGeophysicalImageSet, METH_VARARGS, " Returns whether the geophysical image is set on this {@code RasterDataNode}.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return whether the geophysical image is set.\n @since BEAM 4.6\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getGeophysicalImage", BeamPyTiePointGrid_getGeophysicalImage, METH_VARARGS, " @return The geophysical source image.\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidMaskImageSet", BeamPyTiePointGrid_isValidMaskImageSet, METH_VARARGS, " Returns wether the valid mask image is set on this {@code RasterDataNode}.\n\n @return Wether the source image is set.\n @since BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getValidMaskImage", BeamPyTiePointGrid_getValidMaskImage, METH_VARARGS, " Gets the valid-mask image associated with this {@code RasterDataNode}.\n\n @return The rendered image.\n @since BEAM 4.2\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_isStxSet", BeamPyTiePointGrid_isStxSet, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getStx1", BeamPyTiePointGrid_getStx1, METH_VARARGS, " Gets the statistics. If statistcs are not yet available,\n the method will compute (possibly inaccurate) statistics and return those.\n <p/>\n If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}\n shall be used instead.\n <p/>\n This method belongs to preliminary API and may be removed or changed in the future.\n\n @return The statistics.\n @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)\n @see #setStx(Stx)\n @since BEAM 4.2, revised in BEAM 4.5\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getStx2", BeamPyTiePointGrid_getStx2, METH_VARARGS, " Gets the statistics.\n If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The TiePointGrid object.\n@param accurate If true, accurate statistics are computed.\n @param pm       A progress monitor which is used to compute the new statistics, if required.\n @return The statistics.\n @since since BEAM 4.5\n"},
    {"TiePointGrid_setStx", BeamPyTiePointGrid_setStx, METH_VARARGS, " Sets the statistics. It is the responsibility of the caller to ensure that the given statistics\n are really related to this {@code RasterDataNode}'s raster data.\n The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.\n This method belongs to preliminary API and may be removed or changed in the future.\n\n \n@param this The TiePointGrid object.\n@param stx The statistics.\n @since BEAM 4.2, revised in BEAM 4.5\n"},
    {"TiePointGrid_getValidShape", BeamPyTiePointGrid_getValidShape, METH_VARARGS, " Gets the shape of the area where this raster data contains valid samples.\n The method returns <code>null</code>, if the entire raster contains valid samples.\n\n @return The shape of the area where the raster data has samples, can be {@code null}.\n @since BEAM 4.7\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataType", BeamPyTiePointGrid_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getNumDataElems", BeamPyTiePointGrid_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setData", BeamPyTiePointGrid_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getData", BeamPyTiePointGrid_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataElems", BeamPyTiePointGrid_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDataElemSize", BeamPyTiePointGrid_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setReadOnly", BeamPyTiePointGrid_setReadOnly, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_isReadOnly", BeamPyTiePointGrid_isReadOnly, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_setUnit", BeamPyTiePointGrid_setUnit, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_getUnit", BeamPyTiePointGrid_getUnit, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeDataChanged", BeamPyTiePointGrid_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRawStorageSize2", BeamPyTiePointGrid_getRawStorageSize2, METH_VARARGS, " Gets the estimated size in bytes of this product node.\n\n \n@param this The TiePointGrid object.\n@param subsetDef if not <code>null</code> the subset may limit the size returned\n @return the size in bytes.\n"},
    {"TiePointGrid_createCompatibleProductData", BeamPyTiePointGrid_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The TiePointGrid object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"TiePointGrid_getOwner", BeamPyTiePointGrid_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getName", BeamPyTiePointGrid_getName, METH_VARARGS, " @return This node's name.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setName", BeamPyTiePointGrid_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The TiePointGrid object.\n@param name The name.\n"},
    {"TiePointGrid_getDescription", BeamPyTiePointGrid_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_setDescription", BeamPyTiePointGrid_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The TiePointGrid object.\n@param description a description, can be <code>null</code>\n"},
    {"TiePointGrid_isModified", BeamPyTiePointGrid_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_toString", BeamPyTiePointGrid_toString, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_isValidNodeName", BeamPyTiePointGrid_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"TiePointGrid_getProduct", BeamPyTiePointGrid_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductReader", BeamPyTiePointGrid_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductWriter", BeamPyTiePointGrid_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getDisplayName", BeamPyTiePointGrid_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getProductRefString", BeamPyTiePointGrid_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_getRawStorageSize1", BeamPyTiePointGrid_getRawStorageSize1, METH_VARARGS, " Gets an estimated, raw storage size in bytes of this product node.\n\n @return the size in bytes.\n\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeChanged1", BeamPyTiePointGrid_fireProductNodeChanged1, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_fireProductNodeChanged2", BeamPyTiePointGrid_fireProductNodeChanged2, METH_VARARGS, "\n@param this The TiePointGrid object."},
    {"TiePointGrid_removeFromFile", BeamPyTiePointGrid_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The TiePointGrid object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"AngularDirection_newAngularDirection", BeamPyAngularDirection_newAngularDirection, METH_VARARGS, ""},
    {"AngularDirection_equals", BeamPyAngularDirection_equals, METH_VARARGS, "\n@param this The AngularDirection object."},
    {"AngularDirection_toString", BeamPyAngularDirection_toString, METH_VARARGS, "\n@param this The AngularDirection object."},
    {"FlagCoding_newFlagCoding", BeamPyFlagCoding_newFlagCoding, METH_VARARGS, " Constructs a new flag coding object with the given name.\n\n @param name the name\n"},
    {"FlagCoding_getFlag", BeamPyFlagCoding_getFlag, METH_VARARGS, " Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to\n getPropertyValue(String).\n\n \n@param this The FlagCoding object.\n@param name the flag name\n @return a metadata attribute wich is the representation of the flag with the given name\n"},
    {"FlagCoding_getFlagNames", BeamPyFlagCoding_getFlagNames, METH_VARARGS, " Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.\n\n @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this\n         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned\n\n@param this The FlagCoding object."},
    {"FlagCoding_addFlag", BeamPyFlagCoding_addFlag, METH_VARARGS, " Adds a new flag definition to this flags coding.\n\n \n@param this The FlagCoding object.\n@param name        the flag name\n @param flagMask    the flag's bit mask\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the flag.\n"},
    {"FlagCoding_getFlagMask", BeamPyFlagCoding_getFlagMask, METH_VARARGS, " Returns the flag mask value for the specified flag name.\n\n \n@param this The FlagCoding object.\n@param name the flag name\n @return flagMask the flag's bit mask as a 32 bit integer\n @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist\n"},
    {"FlagCoding_acceptVisitor", BeamPyFlagCoding_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The FlagCoding object.\n@param visitor the visitor, must not be <code>null</code>\n"},
    {"FlagCoding_addElement", BeamPyFlagCoding_addElement, METH_VARARGS, " Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding\n because flag codings do not support inner elements.\n\n \n@param this The FlagCoding object.\n@param element the element to be added, always ignored\n"},
    {"FlagCoding_addAttribute", BeamPyFlagCoding_addAttribute, METH_VARARGS, " Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.\n\n \n@param this The FlagCoding object.\n@param attribute the attribute to be added\n @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value\n"},
    {"FlagCoding_addSample", BeamPyFlagCoding_addSample, METH_VARARGS, " Adds a new coding value to this sample coding.\n\n \n@param this The FlagCoding object.\n@param name        the coding name\n @param value       the value\n @param description the description text\n @throws IllegalArgumentException if <code>name</code> is null\n @return A new attribute representing the coded sample.\n"},
    {"FlagCoding_getSampleCount", BeamPyFlagCoding_getSampleCount, METH_VARARGS, " Gets the number of coded sample values.\n\n @return the number of coded sample values\n\n@param this The FlagCoding object."},
    {"FlagCoding_getSampleName", BeamPyFlagCoding_getSampleName, METH_VARARGS, " Gets the sample name at the specified attribute index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index.\n @return the sample name.\n"},
    {"FlagCoding_getSampleValue", BeamPyFlagCoding_getSampleValue, METH_VARARGS, " Gets the sample value at the specified attribute index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index.\n @return the sample value.\n"},
    {"FlagCoding_getElementGroup", BeamPyFlagCoding_getElementGroup, METH_VARARGS, " Gets the group of child elements. The method returns null, if this element has no children.\n @return The child element group, may be null.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getParentElement", BeamPyFlagCoding_getParentElement, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_addElementAt", BeamPyFlagCoding_addElementAt, METH_VARARGS, " Adds the given element to this element at index.\n\n \n@param this The FlagCoding object.\n@param element the element to added, ignored if <code>null</code>\n @param index   where to put it\n"},
    {"FlagCoding_removeElement", BeamPyFlagCoding_removeElement, METH_VARARGS, " Removes the given element from this element.\n\n \n@param this The FlagCoding object.\n@param element the element to be removed, ignored if <code>null</code>\n @return true, if so\n"},
    {"FlagCoding_getNumElements", BeamPyFlagCoding_getNumElements, METH_VARARGS, " @return the number of elements contained in this element.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElementAt", BeamPyFlagCoding_getElementAt, METH_VARARGS, " Returns the element at the given index.\n\n \n@param this The FlagCoding object.\n@param index the element index\n @return the element at the given index\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"FlagCoding_getElementNames", BeamPyFlagCoding_getElementNames, METH_VARARGS, " Returns a string array containing the names of the groups contained in this element\n\n @return a string array containing the names of the groups contained in this element. If this element has no\n         groups a zero-length-array is returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElements", BeamPyFlagCoding_getElements, METH_VARARGS, " Returns an array of elements contained in this element.\n\n @return an array of elements contained in this product. If this element has no elements a zero-length-array is\n         returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getElement", BeamPyFlagCoding_getElement, METH_VARARGS, " Returns the element with the given name.\n\n \n@param this The FlagCoding object.\n@param name the element name\n @return the element with the given name or <code>null</code> if a element with the given name is not contained in\n         this element.\n"},
    {"FlagCoding_containsElement", BeamPyFlagCoding_containsElement, METH_VARARGS, " Tests if a element with the given name is contained in this element.\n\n \n@param this The FlagCoding object.\n@param name the name, must not be <code>null</code>\n @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>\n         otherwise\n"},
    {"FlagCoding_getElementIndex", BeamPyFlagCoding_getElementIndex, METH_VARARGS, " Gets the index of the given element.\n \n@param this The FlagCoding object.\n@param element  The element .\n @return The element's index, or -1.\n @since BEAM 4.7\n"},
    {"FlagCoding_removeAttribute", BeamPyFlagCoding_removeAttribute, METH_VARARGS, " Removes the given attribute from this annotation. If an attribute with the same name already exists, the method\n does nothing.\n\n \n@param this The FlagCoding object.\n@param attribute the attribute to be removed, <code>null</code> is ignored\n @return <code>true</code> if it was removed\n"},
    {"FlagCoding_getNumAttributes", BeamPyFlagCoding_getNumAttributes, METH_VARARGS, " Returns the number of attributes attaached to this node.\n\n @return the number of attributes\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttributeAt", BeamPyFlagCoding_getAttributeAt, METH_VARARGS, " Returns the attribute at the given index.\n\n \n@param this The FlagCoding object.\n@param index the attribute index\n @return the attribute, or <code>null</code> if this node does not contain attributes\n @throws IndexOutOfBoundsException\n"},
    {"FlagCoding_getAttributeNames", BeamPyFlagCoding_getAttributeNames, METH_VARARGS, " Returns the names of all attributes of this node.\n\n @return the attribute name array, never <code>null</code>\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttributes", BeamPyFlagCoding_getAttributes, METH_VARARGS, " Returns an array of attributes contained in this element.\n\n @return an array of attributes contained in this product. If this element has no attributes a zero-length-array\n         is returned.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getAttribute", BeamPyFlagCoding_getAttribute, METH_VARARGS, " Returns the attribute with the given name.\n\n \n@param this The FlagCoding object.\n@param name the attribute name\n @return the attribute with the given name or <code>null</code> if it could not be found\n"},
    {"FlagCoding_containsAttribute", BeamPyFlagCoding_containsAttribute, METH_VARARGS, " Checks whether this node has an element with the given name.\n\n \n@param this The FlagCoding object.\n@param name the attribute name\n @return <code>true</code> if so\n"},
    {"FlagCoding_getAttributeIndex", BeamPyFlagCoding_getAttributeIndex, METH_VARARGS, " Gets the index of the given attribute.\n \n@param this The FlagCoding object.\n@param attribute  The attribute.\n @return The attribute's index, or -1.\n @since BEAM 4.7\n"},
    {"FlagCoding_getAttributeDouble", BeamPyFlagCoding_getAttributeDouble, METH_VARARGS, " Returns the double value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as double.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"FlagCoding_getAttributeUTC", BeamPyFlagCoding_getAttributeUTC, METH_VARARGS, " Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as UTC.\n"},
    {"FlagCoding_getAttributeInt", BeamPyFlagCoding_getAttributeInt, METH_VARARGS, " Returns the integer value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number\n"},
    {"FlagCoding_setAttributeInt", BeamPyFlagCoding_setAttributeInt, METH_VARARGS, " Sets the attribute with the given name to the given integer value. <p>A new attribute with\n <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setAttributeDouble", BeamPyFlagCoding_setAttributeDouble, METH_VARARGS, " Sets the attribute with the given name to the given double value. <p>A new attribute with\n <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setAttributeUTC", BeamPyFlagCoding_setAttributeUTC, METH_VARARGS, " Sets the attribute with the given name to the given utc value. <p>A new attribute with\n <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_getAttributeString", BeamPyFlagCoding_getAttributeString, METH_VARARGS, " Returns the string value of the attribute with the given name. <p>The given default value is returned if an\n attribute with the given name could not be found in this node.\n\n \n@param this The FlagCoding object.\n@param name         the attribute name\n @param defaultValue the default value\n @return the attribute value as integer.\n"},
    {"FlagCoding_setAttributeString", BeamPyFlagCoding_setAttributeString, METH_VARARGS, " Sets the attribute with the given name to the given string value. <p>A new attribute with\n <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found\n in this node.\n\n \n@param this The FlagCoding object.\n@param name  the attribute name\n @param value the new value\n"},
    {"FlagCoding_setModified", BeamPyFlagCoding_setModified, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_createDeepClone", BeamPyFlagCoding_createDeepClone, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_dispose", BeamPyFlagCoding_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getOwner", BeamPyFlagCoding_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The FlagCoding object."},
    {"FlagCoding_getName", BeamPyFlagCoding_getName, METH_VARARGS, " @return This node's name.\n\n@param this The FlagCoding object."},
    {"FlagCoding_setName", BeamPyFlagCoding_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The FlagCoding object.\n@param name The name.\n"},
    {"FlagCoding_getDescription", BeamPyFlagCoding_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The FlagCoding object."},
    {"FlagCoding_setDescription", BeamPyFlagCoding_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The FlagCoding object.\n@param description a description, can be <code>null</code>\n"},
    {"FlagCoding_isModified", BeamPyFlagCoding_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The FlagCoding object."},
    {"FlagCoding_toString", BeamPyFlagCoding_toString, METH_VARARGS, "\n@param this The FlagCoding object."},
    {"FlagCoding_isValidNodeName", BeamPyFlagCoding_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"FlagCoding_getProduct", BeamPyFlagCoding_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductReader", BeamPyFlagCoding_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductWriter", BeamPyFlagCoding_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The FlagCoding object."},
    {"FlagCoding_getDisplayName", BeamPyFlagCoding_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The FlagCoding object."},
    {"FlagCoding_getProductRefString", BeamPyFlagCoding_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The FlagCoding object."},
    {"FlagCoding_updateExpression", BeamPyFlagCoding_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The FlagCoding object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"FlagCoding_removeFromFile", BeamPyFlagCoding_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The FlagCoding object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"ProductReader_getReaderPlugIn", BeamPyProductReader_getReaderPlugIn, METH_VARARGS, " Returns the plug-in which created this product reader.\n\n @return the product reader plug-in, should never be <code>null</code>\n\n@param this The ProductReader object."},
    {"ProductReader_getInput", BeamPyProductReader_getInput, METH_VARARGS, " Retrives the current input destination object. Thie return value might be <code>null</code> if the\n <code>setInput</code> has not been called so far.\n\n@param this The ProductReader object."},
    {"ProductReader_getSubsetDef", BeamPyProductReader_getSubsetDef, METH_VARARGS, " Returns the subset information with which this a data product is read from its physical source.\n\n @return the subset information, can be <code>null</code>\n\n@param this The ProductReader object."},
    {"ProductReader_readProductNodes", BeamPyProductReader_readProductNodes, METH_VARARGS, " Reads a data product and returns a in-memory representation of it.\n <p/>\n <p> The given subset info can be used to specify spatial and spectral portions of the original proudct. If the\n subset is omitted, the complete product is read in.\n <p/>\n <p> Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,\n is up to the implementation.\n\n \n@param this The ProductReader object.\n@param input     an object representing a valid output for this product reader, might be a\n                  <code>ImageInputStream</code> or other <code>Object</code> to use for future decoding.\n @param subsetDef a spectral or spatial subset (or both) of the product. If <code>null</code>, the entire product\n                  is read in\n @throws IllegalArgumentException   if <code>input</code> is <code>null</code> or it's type is not one of the\n                                    supported input sources.\n @throws IOException                if an I/O error occurs\n @throws IllegalFileFormatException if the file format is illegal\n"},
    {"ProductReader_readBandRasterData", BeamPyProductReader_readBandRasterData, METH_VARARGS, " Reads raster data from the data source specified by the given destination band into the given in-memory buffer\n and region.\n <p/>\n <h3>Destination band</h3> The destination band is used to identify the data source from which this method\n transfers the sample values into the given destination buffer. The method does not modify the given destination\n band at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method\n should also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.\n <p/>\n <h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,\n <code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's\n raster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and\n sub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset\n and sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The\n destination region should always specify a sub-region of the band's scene raster.\n <p/>\n <h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given\n <code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are\n <b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *\n destHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies\n faster than the Y co-ordinate.\n\n \n@param this The ProductReader object.\n@param destBand    the destination band which identifies the data source from which to read the sample values\n @param destOffsetX the X-offset in the band's raster co-ordinates\n @param destOffsetY the Y-offset in the band's raster co-ordinates\n @param destWidth   the width of region to be read given in the band's raster co-ordinates\n @param destHeight  the height of region to be read given in the band's raster co-ordinates\n @param destBuffer  the destination buffer which receives the sample values to be read\n @throws IOException              if an I/O error occurs\n @throws IllegalArgumentException if the number of elements destination buffer not equals <code>destWidth *\n                                  destHeight</code> or the destination region is out of the band's scene raster\n @see org.esa.beam.framework.datamodel.Band#getSceneRasterWidth()\n @see org.esa.beam.framework.datamodel.Band#getSceneRasterHeight()\n"},
    {"ProductReader_close", BeamPyProductReader_close, METH_VARARGS, " Closes the access to all currently opened resources such as file input streams and all resources of this children\n directly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>close()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.close();</code> after disposing this instance.\n\n @throws IOException if an I/O error occurs\n\n@param this The ProductReader object."},
    {"RGBChannelDef_newRGBChannelDef", BeamPyRGBChannelDef_newRGBChannelDef, METH_VARARGS, ""},
    {"RGBChannelDef_getSourceName", BeamPyRGBChannelDef_getSourceName, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setSourceName", BeamPyRGBChannelDef_setSourceName, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getSourceNames", BeamPyRGBChannelDef_getSourceNames, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setSourceNames", BeamPyRGBChannelDef_setSourceNames, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_isAlphaUsed", BeamPyRGBChannelDef_isAlphaUsed, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_isGammaUsed", BeamPyRGBChannelDef_isGammaUsed, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getGamma", BeamPyRGBChannelDef_getGamma, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setGamma", BeamPyRGBChannelDef_setGamma, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getMinDisplaySample", BeamPyRGBChannelDef_getMinDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setMinDisplaySample", BeamPyRGBChannelDef_setMinDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_getMaxDisplaySample", BeamPyRGBChannelDef_getMaxDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_setMaxDisplaySample", BeamPyRGBChannelDef_setMaxDisplaySample, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"RGBChannelDef_clone", BeamPyRGBChannelDef_clone, METH_VARARGS, "\n@param this The RGBChannelDef object."},
    {"ProductData_createInstance1", BeamPyProductData_createInstance1, METH_VARARGS, " Factory method which creates a value instance of the given type and with exactly one element.\n\n @param type the value's type\n\n @return a new value instance, <code>null</code> if the given type is not known\n"},
    {"ProductData_createInstance2", BeamPyProductData_createInstance2, METH_VARARGS, " Factory method which creates a value instance of the given type and with the specified number of elements.\n\n @param type     the value's type\n @param numElems the number of elements, must be greater than zero if type is not {@link ProductData#TYPE_UTC}\n\n @return a new value instance, <code>null</code> if the given type is not known\n\n @throws IllegalArgumentException if one of the arguments is invalid\n"},
    {"ProductData_createInstance3", BeamPyProductData_createInstance3, METH_VARARGS, " Factory method which creates a value instance of the given type and with the specified number of elements.\n\n @param type the value's type\n @param data if <code>type</code> is <code>TYPE_ASCII</code> the <code>String</code>, otherwise the primitive array type corresponding to <code>type</code>\n\n @return a new value instance, <code>null</code> if the given type is not known\n\n @throws IllegalArgumentException if one of the arguments is invalid\n"},
    {"ProductData_createInstance5", BeamPyProductData_createInstance5, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance1", BeamPyProductData_createUnsignedInstance1, METH_VARARGS, ""},
    {"ProductData_createInstance10", BeamPyProductData_createInstance10, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance3", BeamPyProductData_createUnsignedInstance3, METH_VARARGS, ""},
    {"ProductData_createInstance8", BeamPyProductData_createInstance8, METH_VARARGS, ""},
    {"ProductData_createUnsignedInstance2", BeamPyProductData_createUnsignedInstance2, METH_VARARGS, ""},
    {"ProductData_createInstance9", BeamPyProductData_createInstance9, METH_VARARGS, ""},
    {"ProductData_createInstance4", BeamPyProductData_createInstance4, METH_VARARGS, ""},
    {"ProductData_createInstance7", BeamPyProductData_createInstance7, METH_VARARGS, ""},
    {"ProductData_createInstance6", BeamPyProductData_createInstance6, METH_VARARGS, ""},
    {"ProductData_getType1", BeamPyProductData_getType1, METH_VARARGS, " Returns this value's type ID.\n\n@param this The ProductData object."},
    {"ProductData_getElemSize2", BeamPyProductData_getElemSize2, METH_VARARGS, " Gets the element size of an element of the given type in bytes.\n\n @param type the element type\n\n @return the size of a single element in bytes.\n\n @throws IllegalArgumentException if the type is not supported.\n"},
    {"ProductData_getElemSize1", BeamPyProductData_getElemSize1, METH_VARARGS, " Gets the element size of an element of this product data in bytes.\n\n @return the size of a single element in bytes\n\n@param this The ProductData object."},
    {"ProductData_getTypeString2", BeamPyProductData_getTypeString2, METH_VARARGS, " Returns a textual representation of the given data type.\n\n @return a data type string, <code>null</code> if the type is unknown\n"},
    {"ProductData_getType2", BeamPyProductData_getType2, METH_VARARGS, " Returns a integer representation of the given data type string.\n\n @return a data type integer, <code>null</code> if the type is unknown\n"},
    {"ProductData_getTypeString1", BeamPyProductData_getTypeString1, METH_VARARGS, " Returns this value's data type String.\n\n@param this The ProductData object."},
    {"ProductData_isInt", BeamPyProductData_isInt, METH_VARARGS, " Tests whether this value has an integer.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isIntType", BeamPyProductData_isIntType, METH_VARARGS, " Tests whether the given value type is a signed or unsigned integer type.\n\n @return true, if so\n"},
    {"ProductData_isSigned", BeamPyProductData_isSigned, METH_VARARGS, " Tests whether the actual instance is an signed data type.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isUnsigned", BeamPyProductData_isUnsigned, METH_VARARGS, " Tests whether the actual instance is an unsigned data type.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_isUIntType", BeamPyProductData_isUIntType, METH_VARARGS, " Tests whether the given value type is an unsigned integer type.\n\n @return true, if so\n"},
    {"ProductData_isFloatingPointType", BeamPyProductData_isFloatingPointType, METH_VARARGS, " Tests whether the given value type is a floating point type.\n\n @return true, if so\n"},
    {"ProductData_isScalar", BeamPyProductData_isScalar, METH_VARARGS, " Tests if this value is a scalar.\n\n @return true, if so\n\n@param this The ProductData object."},
    {"ProductData_getNumElems", BeamPyProductData_getNumElems, METH_VARARGS, " Returns the number of data elements this value has.\n\n@param this The ProductData object."},
    {"ProductData_getElemInt", BeamPyProductData_getElemInt, METH_VARARGS, " Returns the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply\n returns <code>getElemIntAt(0)</code>.\n\n @see #getElemIntAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemUInt", BeamPyProductData_getElemUInt, METH_VARARGS, " Returns the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this\n value is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.\n\n @see #getElemUIntAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemFloat", BeamPyProductData_getElemFloat, METH_VARARGS, " Returns the value as an <code>float</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemFloatAt(0)</code>.\n\n @see #getElemFloatAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemDouble", BeamPyProductData_getElemDouble, METH_VARARGS, " Returns the value as an <code>double</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemDoubleAt(0)</code>.\n\n @see #getElemDoubleAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemString", BeamPyProductData_getElemString, METH_VARARGS, " Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained\n in this value.\n\n @return a text representing this fields value, never <code>null</code>\n\n@param this The ProductData object."},
    {"ProductData_getElemBoolean", BeamPyProductData_getElemBoolean, METH_VARARGS, " Returns the value as an <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore\n simply returns <code>getElemBooleanAt(0)</code>.\n\n @see #getElemBooleanAt(int index)\n\n@param this The ProductData object."},
    {"ProductData_getElemIntAt", BeamPyProductData_getElemIntAt, METH_VARARGS, " Gets the value element with the given index as an <code>int</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemUIntAt", BeamPyProductData_getElemUIntAt, METH_VARARGS, " Gets the value element with the given index as a <code>long</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemFloatAt", BeamPyProductData_getElemFloatAt, METH_VARARGS, " Gets the value element with the given index as a <code>float</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemDoubleAt", BeamPyProductData_getElemDoubleAt, METH_VARARGS, " Gets the value element with the given index as a <code>double</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemStringAt", BeamPyProductData_getElemStringAt, METH_VARARGS, " Gets the value element with the given index as a <code>String</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElemBooleanAt", BeamPyProductData_getElemBooleanAt, METH_VARARGS, " Gets the value element with the given index as a <code>boolean</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemInt", BeamPyProductData_setElemInt, METH_VARARGS, " Sets the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemInt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemIntAt(int index, int value)\n"},
    {"ProductData_setElemUInt", BeamPyProductData_setElemUInt, METH_VARARGS, " Sets the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this\n value is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemUIntAt(int index, long value)\n"},
    {"ProductData_setElemFloat", BeamPyProductData_setElemFloat, METH_VARARGS, " Sets the value as a <code>float</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemFloatAt(0, value)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemFloatAt(int index, float value)\n"},
    {"ProductData_setElemDouble", BeamPyProductData_setElemDouble, METH_VARARGS, " Sets the value as a <code>double</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemDoubleAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemDoubleAt(int index, double value)\n"},
    {"ProductData_setElemString", BeamPyProductData_setElemString, METH_VARARGS, " Sets the value as a <code>String</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemStringAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemStringAt\n"},
    {"ProductData_setElemBoolean", BeamPyProductData_setElemBoolean, METH_VARARGS, " Sets the value as a <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore simply\n calls <code>setElemDoubleAt(0)</code>.\n\n \n@param this The ProductData object.\n@param value the value to be set\n\n @see #setElemBooleanAt(int index, boolean value)\n"},
    {"ProductData_setElemIntAt", BeamPyProductData_setElemIntAt, METH_VARARGS, " Sets the value at the specified index as an <code>int</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemUIntAt", BeamPyProductData_setElemUIntAt, METH_VARARGS, " Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemFloatAt", BeamPyProductData_setElemFloatAt, METH_VARARGS, " Sets the value at the specified index as a <code>float</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemDoubleAt", BeamPyProductData_setElemDoubleAt, METH_VARARGS, " Sets the value at the specified index as a <code>double</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemStringAt", BeamPyProductData_setElemStringAt, METH_VARARGS, " Sets the value at the specified index as a <code>String</code>.\n <p/>\n <p><i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_setElemBooleanAt", BeamPyProductData_setElemBooleanAt, METH_VARARGS, " Sets the value at the specified index as a <code>boolean</code>.\n\n \n@param this The ProductData object.\n@param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>\n @param value the value to be set\n\n @throws IndexOutOfBoundsException if the index is out of bounds\n"},
    {"ProductData_getElems", BeamPyProductData_getElems, METH_VARARGS, " Returns the internal value. The actual type of the returned object should only be one of <ol>\n <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\n signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\n fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\n for signed 64-bit floating point fields</li> </ol>\n\n @return an array of one of the described types\n\n@param this The ProductData object."},
    {"ProductData_setElems", BeamPyProductData_setElems, METH_VARARGS, " Sets the internal value. The actual type of the given data object should only be one of <ol>\n <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for\n signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer\n fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -\n for signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>\n\n \n@param this The ProductData object.\n@param data an array of one of the described types\n"},
    {"ProductData_readFrom4", BeamPyProductData_readFrom4, METH_VARARGS, " Reads all elements of this <code>ProductData</code> instance from to the given input stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position\n within the input stream.\n\n \n@param this The ProductData object.\n@param input a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom3", BeamPyProductData_readFrom3, METH_VARARGS, " Reads a single element of this <code>ProductData</code> instance from to the given output stream.\n <p/>\n <p> The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given\n output stream.<br> Reading starts at the current seek position within the output stream.\n\n \n@param this The ProductData object.\n@param pos   the destination position (zero-based)\n @param input a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom1", BeamPyProductData_readFrom1, METH_VARARGS, " Reads elements of this <code>ProductData</code> instance from the given output stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\n this <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek\n position of the input stream.\n\n \n@param this The ProductData object.\n@param startPos the destination start position (zero-based)\n @param numElems the number of elements to read\n @param input    a seekable data input stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_readFrom2", BeamPyProductData_readFrom2, METH_VARARGS, " Reads elements into this <code>ProductData</code> instance from the given input stream.\n <p/>\n <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of\n this <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>\n within the output stream. The method multiplies this position with the value returned by\n <code>getElemSize()</code> in order to find the correct stream offset in bytes.\n\n \n@param this The ProductData object.\n@param startPos the destination start position (zero-based)\n @param numElems the number of elements to read\n @param input    a seekable data input stream\n @param inputPos the (zero-based) position in the data output stream where reading starts\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo4", BeamPyProductData_writeTo4, METH_VARARGS, " Writes all elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this\n <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position\n within the output stream.\n\n \n@param this The ProductData object.\n@param output a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo3", BeamPyProductData_writeTo3, METH_VARARGS, " Writes a single element of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given\n output stream.<br> Writing starts at the current seek position within the output stream.\n\n \n@param this The ProductData object.\n@param pos    the source position (zero-based)\n @param output a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo1", BeamPyProductData_writeTo1, METH_VARARGS, " Writes elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\n of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek\n position within the output stream.\n\n \n@param this The ProductData object.\n@param startPos the source start position (zero-based)\n @param numElems the number of elements to be written\n @param output   a seekable data output stream\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_writeTo2", BeamPyProductData_writeTo2, METH_VARARGS, " Writes elements of this <code>ProductData</code> instance to to the given output stream.\n <p/>\n <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>\n of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at\n <code>outputPos</code> within the output stream. The method multiplies this position with the value returned by\n <code>getElemSize()</code> in order to find the correct stream offset in bytes.\n\n \n@param this The ProductData object.\n@param startPos  the source start position (zero-based)\n @param numElems  the number of elements to be written\n @param output    a seekable data output stream\n @param outputPos the position in the data output stream where writing starts\n\n @throws IOException if an I/O error occurs\n"},
    {"ProductData_toString", BeamPyProductData_toString, METH_VARARGS, " Returns a string representation of this value which can be used for debugging purposes.\n\n@param this The ProductData object."},
    {"ProductData_hashCode", BeamPyProductData_hashCode, METH_VARARGS, " Returns {@link Object#hashCode()}.\n\n@param this The ProductData object."},
    {"ProductData_equals", BeamPyProductData_equals, METH_VARARGS, " Returns {@link Object#equals(Object)}.\n Use {@link #equalElems} in order to perform an element-wise comparision.\n\n@param this The ProductData object."},
    {"ProductData_equalElems", BeamPyProductData_equalElems, METH_VARARGS, " Tests whether this ProductData is equal to another one.\n Performs an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.\n Otherwise the method behaves like {@link Object#equals(Object)}.\n\n \n@param this The ProductData object.\n@param other the other one\n"},
    {"ProductData_dispose", BeamPyProductData_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n\n@param this The ProductData object."},
    {"GeoPos_newGeoPos", BeamPyGeoPos_newGeoPos, METH_VARARGS, " Constructs a new geo-position with the given latitude and longitude values.\n\n @param lat the geographical latitude in decimal degree, valid range is -90 to +90\n @param lon the geographical longitude in decimal degree, valid range is -180 to +180\n"},
    {"GeoPos_getLat", BeamPyGeoPos_getLat, METH_VARARGS, " Gets the latitude value.\n\n @return the geographical latitude in decimal degree\n\n@param this The GeoPos object."},
    {"GeoPos_getLon", BeamPyGeoPos_getLon, METH_VARARGS, " Gets the longitude value.\n\n @return the geographical longitude in decimal degree\n\n@param this The GeoPos object."},
    {"GeoPos_setLocation", BeamPyGeoPos_setLocation, METH_VARARGS, " Sets the geographical location of this point.\n\n \n@param this The GeoPos object.\n@param lat the geographical latitude in decimal degree, valid range is -90 to +90\n @param lon the geographical longitude in decimal degree, valid range is -180 to +180\n"},
    {"GeoPos_isValid", BeamPyGeoPos_isValid, METH_VARARGS, " Tests whether or not this geo-position is valid.\n\n @return true, if so\n\n@param this The GeoPos object."},
    {"GeoPos_areValid", BeamPyGeoPos_areValid, METH_VARARGS, " Tests whether or not all given geo-positions are valid.\n\n @return true, if so\n"},
    {"GeoPos_setInvalid", BeamPyGeoPos_setInvalid, METH_VARARGS, " Sets the lat/lon fields so that {@link #isValid()} will return false.\n\n@param this The GeoPos object."},
    {"GeoPos_equals", BeamPyGeoPos_equals, METH_VARARGS, " Indicates whether some other object is \"equal to\" this one.\n\n \n@param this The GeoPos object.\n@param obj the reference object with which to compare.\n\n @return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.\n"},
    {"GeoPos_hashCode", BeamPyGeoPos_hashCode, METH_VARARGS, " Returns a hash code value for the object.\n\n @return a hash code value for this object.\n\n@param this The GeoPos object."},
    {"GeoPos_toString", BeamPyGeoPos_toString, METH_VARARGS, " Returns a string representation of the object. In general, the <code>toString</code> method returns a string that\n \"textually represents\" this object.\n\n @return a string representation of the object.\n\n@param this The GeoPos object."},
    {"GeoPos_normalize", BeamPyGeoPos_normalize, METH_VARARGS, " Normalizes this position so that its longitude is in the range -180 to +180 degree.\n\n@param this The GeoPos object."},
    {"GeoPos_normalizeLon", BeamPyGeoPos_normalizeLon, METH_VARARGS, " Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.\n Note that -180 will remain as is, although -180 is equivalent to +180 degrees.\n\n @param lon the longitude in degree\n\n @return the normalized longitude in the range\n"},
    {"GeoPos_getLatString", BeamPyGeoPos_getLatString, METH_VARARGS, " Returns a string representation of the latitude value.\n\n @return a string of the form DDD[MM'[SS\"]] [N|S].\n\n@param this The GeoPos object."},
    {"GeoPos_getLonString", BeamPyGeoPos_getLonString, METH_VARARGS, " Returns a string representation of the latitude value.\n\n @return a string of the form DDD[MM'[SS\"]] [W|E].\n\n@param this The GeoPos object."},
    {"ProductNodeGroup_newProductNodeGroup1", BeamPyProductNodeGroup_newProductNodeGroup1, METH_VARARGS, " Constructs a node group with no owner and which will not take ownership of added children.\n\n @param name The group name.\n @since BEAM 4.8\n"},
    {"ProductNodeGroup_newProductNodeGroup2", BeamPyProductNodeGroup_newProductNodeGroup2, METH_VARARGS, " Constructs a node group for the given owner.\n\n @param owner                   The owner of the group.\n @param name                    The group name.\n @param takingOverNodeOwnership If {@code true}, child nodes will have this group as owner after adding.\n"},
    {"ProductNodeGroup_isTakingOverNodeOwnership", BeamPyProductNodeGroup_isTakingOverNodeOwnership, METH_VARARGS, " @return {@code true}, if child nodes will have this group as owner after adding.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getNodeCount", BeamPyProductNodeGroup_getNodeCount, METH_VARARGS, " @return The number of product nodes in this product group.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_get1", BeamPyProductNodeGroup_get1, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param index The node index.\n @return The product node at the given index.\n"},
    {"ProductNodeGroup_getNodeDisplayNames", BeamPyProductNodeGroup_getNodeDisplayNames, METH_VARARGS, " Returns the display names of all products currently managed.\n\n @return an array containing the display names, never <code>null</code>, but the array can have zero length\n @see ProductNode#getDisplayName()\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getNodeNames", BeamPyProductNodeGroup_getNodeNames, METH_VARARGS, " Returns the names of all products currently managed.\n\n @return an array containing the names, never <code>null</code>, but the array can have zero length\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_toArray1", BeamPyProductNodeGroup_toArray1, METH_VARARGS, " Returns an array of all products currently managed.\n\n @return an array containing the products, never <code>null</code>, but the array can have zero length\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_toArray2", BeamPyProductNodeGroup_toArray2, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a\n              new array of the same runtime type is allocated for this purpose.\n @return an array containing the product nodes, never <code>null</code>, but the array can have zero length\n"},
    {"ProductNodeGroup_indexOf2", BeamPyProductNodeGroup_indexOf2, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_indexOf1", BeamPyProductNodeGroup_indexOf1, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getByDisplayName", BeamPyProductNodeGroup_getByDisplayName, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param displayName the display name\n @return the product node with the given display name.\n"},
    {"ProductNodeGroup_get2", BeamPyProductNodeGroup_get2, METH_VARARGS, " \n@param this The ProductNodeGroup object.\n@param name the name\n @return the product node with the given name.\n"},
    {"ProductNodeGroup_contains2", BeamPyProductNodeGroup_contains2, METH_VARARGS, " Tests whether a node with the given name is contained in this group.\n\n \n@param this The ProductNodeGroup object.\n@param name the name\n @return true, if so\n"},
    {"ProductNodeGroup_contains1", BeamPyProductNodeGroup_contains1, METH_VARARGS, " Tests whether the given product is contained in this list.\n\n \n@param this The ProductNodeGroup object.\n@param node the node\n @return true, if so\n"},
    {"ProductNodeGroup_add2", BeamPyProductNodeGroup_add2, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The ProductNodeGroup object.\n@param node the node to be added, ignored if <code>null</code>\n @return true, if the node has been added\n"},
    {"ProductNodeGroup_add1", BeamPyProductNodeGroup_add1, METH_VARARGS, " Adds the given node to this group.\n\n \n@param this The ProductNodeGroup object.\n@param index the index.\n @param node  the node to be added, ignored if <code>null</code>\n"},
    {"ProductNodeGroup_remove", BeamPyProductNodeGroup_remove, METH_VARARGS, " Removes the given node from this group.\n\n \n@param this The ProductNodeGroup object.\n@param node the node to be removed\n @return true, if the node was removed\n"},
    {"ProductNodeGroup_removeAll", BeamPyProductNodeGroup_removeAll, METH_VARARGS, " Removes all nodes from this group.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_clearRemovedList", BeamPyProductNodeGroup_clearRemovedList, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getRemovedNodes", BeamPyProductNodeGroup_getRemovedNodes, METH_VARARGS, " Gets all removed node nodes.\n\n @return a collection of all removed node nodes.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getRawStorageSize2", BeamPyProductNodeGroup_getRawStorageSize2, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setModified", BeamPyProductNodeGroup_setModified, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_acceptVisitor", BeamPyProductNodeGroup_acceptVisitor, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_dispose", BeamPyProductNodeGroup_dispose, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_updateExpression", BeamPyProductNodeGroup_updateExpression, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getOwner", BeamPyProductNodeGroup_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getName", BeamPyProductNodeGroup_getName, METH_VARARGS, " @return This node's name.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setName", BeamPyProductNodeGroup_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The ProductNodeGroup object.\n@param name The name.\n"},
    {"ProductNodeGroup_getDescription", BeamPyProductNodeGroup_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_setDescription", BeamPyProductNodeGroup_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The ProductNodeGroup object.\n@param description a description, can be <code>null</code>\n"},
    {"ProductNodeGroup_isModified", BeamPyProductNodeGroup_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_toString", BeamPyProductNodeGroup_toString, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_isValidNodeName", BeamPyProductNodeGroup_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"ProductNodeGroup_getProduct", BeamPyProductNodeGroup_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductReader", BeamPyProductNodeGroup_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductWriter", BeamPyProductNodeGroup_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getDisplayName", BeamPyProductNodeGroup_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getProductRefString", BeamPyProductNodeGroup_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_getRawStorageSize1", BeamPyProductNodeGroup_getRawStorageSize1, METH_VARARGS, " Gets an estimated, raw storage size in bytes of this product node.\n\n @return the size in bytes.\n\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_fireProductNodeChanged1", BeamPyProductNodeGroup_fireProductNodeChanged1, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_fireProductNodeChanged2", BeamPyProductNodeGroup_fireProductNodeChanged2, METH_VARARGS, "\n@param this The ProductNodeGroup object."},
    {"ProductNodeGroup_removeFromFile", BeamPyProductNodeGroup_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The ProductNodeGroup object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"ProductUtils_newProductUtils", BeamPyProductUtils_newProductUtils, METH_VARARGS, ""},
    {"ProductUtils_createImageInfo", BeamPyProductUtils_createImageInfo, METH_VARARGS, " Creates image creation information.\n\n @param rasters                 The raster data nodes.\n @param assignMissingImageInfos if {@code true}, it is ensured that to all {@code RasterDataNode}s a valid {@code ImageInfo} will be assigned.\n @param pm                      The progress monitor.\n @return image information\n @throws IOException if an I/O error occurs\n @since BEAM 4.2\n"},
    {"ProductUtils_createRgbImage", BeamPyProductUtils_createRgbImage, METH_VARARGS, " Creates a RGB image from the given array of <code>{@link RasterDataNode}</code>s.\n The given array <code>rasters</code> containing one or three raster data nodes. If three rasters are given\n RGB image is created, if only one raster is provided a gray scale image created.\n\n @param rasters   an array of one or three raster nodes.\n @param imageInfo the image info provides the information how to create the image\n @param pm        a monitor to inform the user about progress\n @return the created image\n @throws IOException if the given raster data is not loaded and reload causes an I/O error\n @see RasterDataNode#setImageInfo(org.esa.beam.framework.datamodel.ImageInfo)\n"},
    {"ProductUtils_createColorIndexedImage", BeamPyProductUtils_createColorIndexedImage, METH_VARARGS, " Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.\n <p/>\n <p>The method uses the given raster data node's image information (an instance of <code>{@link\n ImageInfo}</code>) to create the image.\n\n @param rasterDataNode the raster data node, must not be <code>null</code>\n @param pm             a monitor to inform the user about progress\n @return the color indexed image\n @throws IOException if the given raster data is not loaded and reload causes an I/O error\n @see org.esa.beam.framework.datamodel.RasterDataNode#getImageInfo()\n"},
    {"ProductUtils_createSuitableMapInfo1", BeamPyProductUtils_createSuitableMapInfo1, METH_VARARGS, " Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\n subset of the product's scene region for the given map projection. The position of the reference pixel will be\n the upper left pixel's center (0.5, 0.5).\n\n @param product       the product, must not be <code>null</code>\n @param rect          the rectangle in pixel coordinates of the product, if <code>null</code> the entire region is\n                      considered\n @param mapProjection the map projection, must not be <code>null</code>\n @return the map information instance\n"},
    {"ProductUtils_createSuitableMapInfo2", BeamPyProductUtils_createSuitableMapInfo2, METH_VARARGS, " Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a\n subset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.\n\n @param product       the product, must not be <code>null</code>\n @param mapProjection the map projection, must not be <code>null</code>\n @param orientation   the orientation angle\n @param noDataValue   the no-data value to be used\n @return the map information instance\n"},
    {"ProductUtils_getOutputRasterSize", BeamPyProductUtils_getOutputRasterSize, METH_VARARGS, ""},
    {"ProductUtils_createMapEnvelope2", BeamPyProductUtils_createMapEnvelope2, METH_VARARGS, " Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)\n and the given map transfromation. The method delegates to {@link #createMapEnvelope(org.esa.beam.framework.datamodel.Product,\n java.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,\n step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene raster width and\n height.\n\n @param product      The product.\n @param rect         The rectangle in pixel coordinates.\n @param mapTransform The map transformation.\n @return The boundary in map coordinates for the given product.\n"},
    {"ProductUtils_createMapEnvelope1", BeamPyProductUtils_createMapEnvelope1, METH_VARARGS, " Creates the boundary in map coordinates for the given product, source rectangle (in product\n pixel coordinates) and the given map transfromation. The method delegates to\n {@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,\n step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene\n raster width and height.\n\n @param product      The product.\n @param rect         The rectangle in pixel coordinates.\n @param step         The step size in pixels.\n @param mapTransform The map transformation.\n @return The boundary in map coordinates for the given product.\n"},
    {"ProductUtils_getMinMax", BeamPyProductUtils_getMinMax, METH_VARARGS, ""},
    {"ProductUtils_createMapBoundary", BeamPyProductUtils_createMapBoundary, METH_VARARGS, ""},
    {"ProductUtils_createGeoBoundary1", BeamPyProductUtils_createGeoBoundary1, METH_VARARGS, " Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.\n\n @param product the input product, must not be null\n @param step    the step given in pixels\n @return an array of geographical coordinates\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n"},
    {"ProductUtils_createGeoBoundary2", BeamPyProductUtils_createGeoBoundary2, METH_VARARGS, " Creates the geographical boundary of the given region within the given product and returns it as a list of\n geographical coordinates.\n <p> This method delegates to {@link #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param product the input product, must not be null\n @param region  the region rectangle in product pixel coordinates, can be null for entire product\n @param step    the step given in pixels\n @return an array of geographical coordinates\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundary3", BeamPyProductUtils_createGeoBoundary3, METH_VARARGS, " Creates the geographical boundary of the given region within the given product and returns it as a list of\n geographical coordinates.\n\n @param product        the input product, must not be null\n @param region         the region rectangle in product pixel coordinates, can be null for entire product\n @param step           the step given in pixels\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n @return an array of geographical coordinates\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)\n"},
    {"ProductUtils_getClosestGeoPos", BeamPyProductUtils_getClosestGeoPos, METH_VARARGS, " Searches for a valid GeoPos by considering the vicinity of a {@link PixelPos}. It does not check\n the original pixel position, but uses it for determining which pixel positions to examine.\n\n @param gc      the GeoCoding, must not be null\n @param origPos the original pixel position, must not be null\n @param region  the rectangle which determines the valid pixel positions, must not be null\n @param step    determines the step size between pixels which is used in the search process. Small step\n                sizes will increase the accuracy, but need more computational time\n @return a {@link GeoPos}. This will be valid if the search was successful. If not, a {@link GeoPos} with\n         NaN-values for latitude and longitude will be returned.\n"},
    {"ProductUtils_createGeoBoundary4", BeamPyProductUtils_createGeoBoundary4, METH_VARARGS, " Creates the geographical boundary of the given region within the given raster and returns it as a list of\n geographical coordinates.\n\n @param raster the input raster, must not be null\n @param region the region rectangle in raster pixel coordinates, can be null for entire raster\n @param step   the step given in pixels\n @return an array of geographical coordinates\n @throws IllegalArgumentException if raster is null or if the raster has no {@link GeoCoding} is null\n @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths1", BeamPyProductUtils_createGeoBoundaryPaths1, METH_VARARGS, " Converts the geographic boundary entire product into one, two or three shape objects. If the product does not\n intersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created\n and returned in the order from west to east.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product the input product\n @return an array of shape objects\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths2", BeamPyProductUtils_createGeoBoundaryPaths2, METH_VARARGS, " Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\n the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\n shapes are created and returned in the order from west to east.\n <p/>\n This method delegates to {@link #createGeoBoundaryPaths(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}\n and the additional parameter <code>usePixelCenter</code> is <code>true</code>.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product the input product\n @param region  the region rectangle in product pixel coordinates, can be null for entire product\n @param step    the step given in pixels\n @return an array of shape objects\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int)\n"},
    {"ProductUtils_createGeoBoundaryPaths3", BeamPyProductUtils_createGeoBoundaryPaths3, METH_VARARGS, " Converts the geographic boundary of the region within the given product into one, two or three shape objects. If\n the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three\n shapes are created and returned in the order from west to east.\n <p/>\n The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.\n\n @param product        the input product\n @param region         the region rectangle in product pixel coordinates, can be null for entire product\n @param step           the step given in pixels\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the pathes\n @return an array of shape objects\n @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null\n @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)\n"},
    {"ProductUtils_createPixelBoundary1", BeamPyProductUtils_createPixelBoundary1, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p> This method delegates to {@link #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param product the product\n @param rect    the source rectangle\n @param step    the mean distance from one pixel position to the other in the returned array\n @return the rectangular boundary\n"},
    {"ProductUtils_createPixelBoundary2", BeamPyProductUtils_createPixelBoundary2, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n\n @param product        the product\n @param rect           the source rectangle\n @param step           the mean distance from one pixel position to the other in the returned array\n @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary\n @return the rectangular boundary\n"},
    {"ProductUtils_createPixelBoundary3", BeamPyProductUtils_createPixelBoundary3, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n <p>This method is used for an intermediate step when determining a raster boundary expressed in geographical\n co-ordinates.\n\n @param raster the raster\n @param rect   the source rectangle\n @param step   the mean distance from one pixel position to the other in the returned array\n @return the rectangular boundary\n"},
    {"ProductUtils_createRectBoundary1", BeamPyProductUtils_createRectBoundary1, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p>This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p> This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}\n and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.\n\n @param rect the source rectangle\n @param step the mean distance from one pixel position to the other in the returned array\n @return the rectangular boundary\n"},
    {"ProductUtils_createRectBoundary2", BeamPyProductUtils_createRectBoundary2, METH_VARARGS, " Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source\n <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10\n + 2 * (5 - 2) = 26 pixel positions.\n <p/>\n This method is used for an intermediate step when determining a product boundary expressed in geographical\n co-ordinates.\n <p/>\n\n @param rect           the source rectangle\n @param step           the mean distance from one pixel position to the other in the returned array\n @param usePixelCenter <code>true</code> if the pixel center should be used\n @return the rectangular boundary\n"},
    {"ProductUtils_copyFlagCodings", BeamPyProductUtils_copyFlagCodings, METH_VARARGS, " Copies the flag codings from the source product to the target.\n\n @param source the source product\n @param target the target product\n"},
    {"ProductUtils_copyFlagCoding", BeamPyProductUtils_copyFlagCoding, METH_VARARGS, " Copies the given source flag coding to the target product.\n If it exists already, the method simply returns the existing instance.\n\n @param sourceFlagCoding the source flag coding\n @param target           the target product\n @return The flag coding.\n"},
    {"ProductUtils_copyIndexCoding", BeamPyProductUtils_copyIndexCoding, METH_VARARGS, " Copies the given source index coding to the target product\n If it exists already, the method simply returns the existing instance.\n\n @param sourceIndexCoding the source index coding\n @param target            the target product\n @return The index coding.\n"},
    {"ProductUtils_copyMasks", BeamPyProductUtils_copyMasks, METH_VARARGS, " Copies the {@link Mask}s from the source product to the target product.\n <p/>\n IMPORTANT NOTE: This method should only be used, if it is known that all masks\n in the source product will also be valid in the target product. This method does\n <em>not</em> copy overlay masks from the source bands to the target bands. Also\n note that a source mask is not copied to the target product, when there already\n is a mask in the target product with the same name as the source mask.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyOverlayMasks", BeamPyProductUtils_copyOverlayMasks, METH_VARARGS, " Copies the overlay {@link Mask}s from the source product's raster data nodes to\n the target product's raster data nodes.\n <p/>\n IMPORTANT NOTE: This method should only be used, if it is known that all masks\n in the source product will also be valid in the target product. This method does\n <em>not</em> copy overlay masks, which are not contained in the target product's\n mask group.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyFlagBands", BeamPyProductUtils_copyFlagBands, METH_VARARGS, " Copies all bands which contain a flagcoding from the source product to the target product.\n\n @param sourceProduct   the source product\n @param targetProduct   the target product\n @param copySourceImage whether the source image of the source band should be copied.\n @since BEAM 4.10\n"},
    {"ProductUtils_copyTiePointGrid", BeamPyProductUtils_copyTiePointGrid, METH_VARARGS, " Copies the named tie-point grid from the source product to the target product.\n\n @param gridName      the name of the tie-point grid to be copied.\n @param sourceProduct the source product\n @param targetProduct the target product\n @return the copied tie-point grid, or <code>null</code> if the sourceProduct does not contain a tie-point grid with the given name.\n"},
    {"ProductUtils_copyBand2", BeamPyProductUtils_copyBand2, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName  the name of the band to be copied.\n @param sourceProduct   the source product.\n @param targetProduct   the target product.\n @param copySourceImage whether the source image of the source band should be copied.\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n @since BEAM 4.10\n"},
    {"ProductUtils_copyBand1", BeamPyProductUtils_copyBand1, METH_VARARGS, " Copies the named band from the source product to the target product.\n\n @param sourceBandName  the name of the band to be copied.\n @param sourceProduct   the source product.\n @param targetBandName  the name of the band copied.\n @param targetProduct   the target product.\n @param copySourceImage whether the source image of the source band should be copied.\n @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.\n @since BEAM 4.10\n"},
    {"ProductUtils_copyRasterDataNodeProperties", BeamPyProductUtils_copyRasterDataNodeProperties, METH_VARARGS, " Copies all properties from source band to the target band.\n\n @param sourceRaster the source band\n @param targetRaster the target band\n @see #copySpectralBandProperties(org.esa.beam.framework.datamodel.Band, org.esa.beam.framework.datamodel.Band)\n"},
    {"ProductUtils_copySpectralBandProperties", BeamPyProductUtils_copySpectralBandProperties, METH_VARARGS, " Copies the spectral properties from source band to target band. These properties are:\n <ul>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandIndex() spectral band index},</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralWavelength() the central wavelength},</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandwidth() the spectral bandwidth} and</li>\n <li>{@link org.esa.beam.framework.datamodel.Band#getSolarFlux() the solar spectral flux}.</li>\n </ul>\n\n @param sourceBand the source band\n @param targetBand the target band\n @see #copyRasterDataNodeProperties(org.esa.beam.framework.datamodel.RasterDataNode, org.esa.beam.framework.datamodel.RasterDataNode)\n"},
    {"ProductUtils_copyGeoCoding", BeamPyProductUtils_copyGeoCoding, METH_VARARGS, " Copies the geocoding from the source product to target product.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n @throws IllegalArgumentException if one of the params is <code>null</code>.\n"},
    {"ProductUtils_copyTiePointGrids", BeamPyProductUtils_copyTiePointGrids, METH_VARARGS, " Copies all tie point grids from one product to another.\n\n @param sourceProduct the source product\n @param targetProduct the target product\n"},
    {"ProductUtils_copyVectorData", BeamPyProductUtils_copyVectorData, METH_VARARGS, ""},
    {"ProductUtils_canGetPixelPos1", BeamPyProductUtils_canGetPixelPos1, METH_VARARGS, " Returns whether or not a product can return a pixel position from a given geographical position.\n\n @param product the product to be checked\n @return <code>true</code> if the given product can return a pixel position\n"},
    {"ProductUtils_canGetPixelPos2", BeamPyProductUtils_canGetPixelPos2, METH_VARARGS, " Returns whether or not a raster can return a pixel position from a given geographical position.\n\n @param raster the raster to be checked\n @return <code>true</code> if the given raster can return a pixel position\n"},
    {"ProductUtils_createDensityPlotImage", BeamPyProductUtils_createDensityPlotImage, METH_VARARGS, " Creates a density plot image from two raster data nodes.\n\n @param raster1    the first raster data node\n @param sampleMin1 the minimum sample value to be considered in the first raster\n @param sampleMax1 the maximum sample value to be considered in the first raster\n @param raster2    the second raster data node\n @param sampleMin2 the minimum sample value to be considered in the second raster\n @param sampleMax2 the maximum sample value to be considered in the second raster\n @param roiMask    an optional mask to be used as a ROI for the computation\n @param width      the width of the output image\n @param height     the height of the output image\n @param background the background color of the output image\n @param image      an image to be used as output image, if <code>null</code> a new image is created\n @param pm         the progress monitor\n @return the density plot image\n @throws java.io.IOException when an error occurred.\n"},
    {"ProductUtils_overlayMasks", BeamPyProductUtils_overlayMasks, METH_VARARGS, " Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.\n\n @param raster     the raster data node which contains all the activated bitmask definitions\n @param overlayBIm the source image which is used as base image for all the overlays.\n @param pm         a monitor to inform the user about progress\n @return the modified given overlayBImm which contains all the activated masks.\n @see RasterDataNode#getOverlayMaskGroup()\n"},
    {"ProductUtils_getCenterGeoPos", BeamPyProductUtils_getCenterGeoPos, METH_VARARGS, ""},
    {"ProductUtils_normalizeGeoPolygon", BeamPyProductUtils_normalizeGeoPolygon, METH_VARARGS, " Normalizes the given geographical polygon so that maximum longitude differences between two points are 180\n degrees. The method operates only on the longitude values of the given polygon.\n\n @param polygon a geographical, closed polygon\n @return 0 if normalizing has not been applied , -1 if negative normalizing has been applied, 1 if positive\n         normalizing has been applied, 2 if positive and negative normalising has been applied\n @see #denormalizeGeoPolygon(GeoPos[])\n"},
    {"ProductUtils_normalizeGeoPolygon_old", BeamPyProductUtils_normalizeGeoPolygon_old, METH_VARARGS, ""},
    {"ProductUtils_denormalizeGeoPolygon", BeamPyProductUtils_denormalizeGeoPolygon, METH_VARARGS, " Denormalizes the longitude values which have been normalized using the\n {@link #normalizeGeoPolygon(org.esa.beam.framework.datamodel.GeoPos[])} method. The\n method operates only on the longitude values of the given polygon.\n\n @param polygon a geographical, closed polygon\n"},
    {"ProductUtils_denormalizeGeoPos", BeamPyProductUtils_denormalizeGeoPos, METH_VARARGS, ""},
    {"ProductUtils_denormalizeGeoPos_old", BeamPyProductUtils_denormalizeGeoPos_old, METH_VARARGS, ""},
    {"ProductUtils_getRotationDirection", BeamPyProductUtils_getRotationDirection, METH_VARARGS, ""},
    {"ProductUtils_getAngleSum", BeamPyProductUtils_getAngleSum, METH_VARARGS, ""},
    {"ProductUtils_convertToPixelPath", BeamPyProductUtils_convertToPixelPath, METH_VARARGS, " Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in\n pixel coordinates using the supplied geo coding.\n\n @param geoPath   a <code>GeneralPath</code> given in geographic lon/lat coordinates, as returned by the {@link\n                  #convertToGeoPath(Shape, GeoCoding)} method\n @param geoCoding the geocoding used to convert the geographic coordinates into pixel coordinates.\n @return a <code>GeneralPath</code> given in pixel coordinates.\n @throws IllegalArgumentException if one of the given parameter is null.\n @throws IllegalStateException    if the given geoPath is not a geo referenced <code>GeneralPath</code> wich\n                                  contains only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n @see #convertToGeoPath(Shape, GeoCoding)\n"},
    {"ProductUtils_convertToGeoPath", BeamPyProductUtils_convertToGeoPath, METH_VARARGS, " Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic\n coordinates using the supplied geo coding.\n\n @param shape     a <code>Shape</code> given in pixel X/Y coordinates\n @param geoCoding the geo coding used to convert the pixel coordinates into geografic coordinates.\n @return a <code>GeneralPath</code> given in geografic coordinates\n @throws IllegalArgumentException if one of the given parameter is <code>null</code> or the given geo coding can\n                                  not get geografic coordinates.\n @throws IllegalStateException    if this method was used with a java runtime version in which it is not guaranted\n                                  that a <code>PathIterator</code> returned by {@link Shape#getPathIterator(java.awt.geom.AffineTransform,\n                                  double)} returnes only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.\n @see GeoCoding#canGetGeoPos()\n"},
    {"ProductUtils_copyMetadata2", BeamPyProductUtils_copyMetadata2, METH_VARARGS, " Copies all metadata elements and attributes of the source product to the target product.\n The copied elements and attributes are deeply cloned.\n\n @param source the source product.\n @param target the target product.\n @throws NullPointerException if the source or the target product is {@code null}.\n"},
    {"ProductUtils_copyMetadata1", BeamPyProductUtils_copyMetadata1, METH_VARARGS, " Copies all metadata elements and attributes of the source element to the target element.\n The copied elements and attributes are deeply cloned.\n\n @param source the source element.\n @param target the target element.\n @throws NullPointerException if the source or the target element is {@code null}.\n"},
    {"ProductUtils_copyPreferredTileSize", BeamPyProductUtils_copyPreferredTileSize, METH_VARARGS, " Copies the source product's preferred tile size (if any) to the target product.\n\n @param sourceProduct The source product.\n @param targetProduct The target product.\n"},
    {"ProductUtils_createGeoTIFFMetadata2", BeamPyProductUtils_createGeoTIFFMetadata2, METH_VARARGS, ""},
    {"ProductUtils_createGeoTIFFMetadata1", BeamPyProductUtils_createGeoTIFFMetadata1, METH_VARARGS, ""},
    {"ProductUtils_areaToPath", BeamPyProductUtils_areaToPath, METH_VARARGS, ""},
    {"ProductUtils_addElementToHistory", BeamPyProductUtils_addElementToHistory, METH_VARARGS, " Adds a given elem to the history of the given product. If the products metadata root\n does not contain a history entry a new one will be created.\n\n @param product the product to add the history element.\n @param elem    the element to add to the products history. If <code>null</code> nothing will be added.\n"},
    {"ProductUtils_removeInvalidExpressions", BeamPyProductUtils_removeInvalidExpressions, METH_VARARGS, " Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given\n product, the related element is removed.\n\n @param product the (output) product to be cleaned up\n @return an array of messages which changes are done to the given product.\n"},
    {"ProductUtils_findSuitableQuicklookBandName", BeamPyProductUtils_findSuitableQuicklookBandName, METH_VARARGS, " Finds the name of a band in the given product which is suitable to product a good quicklook.\n The method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.\n\n @param product the product to be searched\n @return the name of a suitable band or null if the given product does not contain any bands\n"},
    {"ProductUtils_computeSourcePixelCoordinates", BeamPyProductUtils_computeSourcePixelCoordinates, METH_VARARGS, ""},
    {"ProductUtils_computeMinMaxY", BeamPyProductUtils_computeMinMaxY, METH_VARARGS, " Computes the minimum and maximum y value of the given {@link PixelPos} array.\n\n @param pixelPositions the {@link PixelPos} array\n @return an int array which containes the minimum and maximum y value of the given {@link PixelPos} array in the\n         order:<br> &nbsp;&nbsp;&nbsp;&nbsp;[0] - the minimum value<br>&nbsp;&nbsp;&nbsp;&nbsp;[1] - the maximum\n         value<br><br>or <code>null</code> if no minimum or maximum can be retrieved because there given array is\n         empty.\n @throws IllegalArgumentException if the given pixelPositions are <code>null</code>.\n"},
    {"ProductUtils_copyBandsForGeomTransform1", BeamPyProductUtils_copyBandsForGeomTransform1, METH_VARARGS, " Copies only the bands from source to target.\n\n @see #copyBandsForGeomTransform(org.esa.beam.framework.datamodel.Product, org.esa.beam.framework.datamodel.Product, boolean, double, java.util.Map)\n"},
    {"ProductUtils_copyBandsForGeomTransform2", BeamPyProductUtils_copyBandsForGeomTransform2, METH_VARARGS, " Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target\n product is a geometric transformation (e.g. map-projection) of the source product.\n <p>If\n {@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,\n this method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},\n regardless which raw data type the source band has.\n In this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}\n will always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}\n will always be 0.0 and\n {@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.\n This ensures that source pixel resampling methods operating on floating point\n data can be stored without loss in accuracy in the target band.\n <p/>\n <p>Furthermore, the\n {@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}\n and {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}\n properties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},\n will be either the one from the source band, if any, or otherwise the one passed into this method.\n\n @param sourceProduct        the source product as the source for the band specifications. Must be not\n                             <code>null</code>.\n @param targetProduct        the destination product to receive the bands created. Must be not <code>null</code>.\n @param includeTiePointGrids if {@code true}, tie-point grids of source product will be included as bands in target product\n @param defaultNoDataValue   the default, geophysical no-data value to be used if no no-data value is used by the source band.\n @param targetToSourceMap    a mapping from a target band to a source raster data node, can be {@code null}\n"},
    {"ProductUtils_getScanLineTime", BeamPyProductUtils_getScanLineTime, METH_VARARGS, ""},
    {"ProductUtils_getGeophysicalSampleDouble", BeamPyProductUtils_getGeophysicalSampleDouble, METH_VARARGS, ""},
    {"ProductUtils_getGeophysicalSampleLong", BeamPyProductUtils_getGeophysicalSampleLong, METH_VARARGS, ""},
    {"MetadataAttribute_newMetadataAttribute", BeamPyMetadataAttribute_newMetadataAttribute, METH_VARARGS, ""},
    {"MetadataAttribute_getParentElement", BeamPyMetadataAttribute_getParentElement, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_equals", BeamPyMetadataAttribute_equals, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_acceptVisitor", BeamPyMetadataAttribute_acceptVisitor, METH_VARARGS, " Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.\n The visitor pattern allows to define new operations on the product data model without the need to add more code\n to it. The new operation is implemented by the visitor.\n <p/>\n <p>The method simply calls <code>visitor.visit(this)</code>.\n\n \n@param this The MetadataAttribute object.\n@param visitor the visitor\n"},
    {"MetadataAttribute_createDeepClone", BeamPyMetadataAttribute_createDeepClone, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataType", BeamPyMetadataAttribute_getDataType, METH_VARARGS, " Gets the data type of this data node.\n\n @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isFloatingPointType", BeamPyMetadataAttribute_isFloatingPointType, METH_VARARGS, " Tests whether the data type of this node is a floating point type.\n\n @return true, if so\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getNumDataElems", BeamPyMetadataAttribute_getNumDataElems, METH_VARARGS, " Gets the number of data elements in this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setData", BeamPyMetadataAttribute_setData, METH_VARARGS, " Sets the data of this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getData", BeamPyMetadataAttribute_getData, METH_VARARGS, " Gets the data of this data node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataElems", BeamPyMetadataAttribute_getDataElems, METH_VARARGS, " Gets the data elements of this data node.\n\n @see ProductData#getElems()\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDataElemSize", BeamPyMetadataAttribute_getDataElemSize, METH_VARARGS, " Gets the data element size in bytes.\n\n @see ProductData#getElemSize(int)\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setReadOnly", BeamPyMetadataAttribute_setReadOnly, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isReadOnly", BeamPyMetadataAttribute_isReadOnly, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setUnit", BeamPyMetadataAttribute_setUnit, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getUnit", BeamPyMetadataAttribute_getUnit, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_fireProductNodeDataChanged", BeamPyMetadataAttribute_fireProductNodeDataChanged, METH_VARARGS, " Fires a node data changed event. This method is called after the data of this data node changed.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_dispose", BeamPyMetadataAttribute_dispose, METH_VARARGS, " Releases all of the resources used by this object instance and all of its owned children. Its primary use is to\n allow the garbage collector to perform a vanilla job.\n <p/>\n <p>This method should be called only if it is for sure that this object instance will never be used again. The\n results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.\n <p/>\n <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_createCompatibleProductData", BeamPyMetadataAttribute_createCompatibleProductData, METH_VARARGS, " Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly\n <code>numElems</code> elements of a compatible data type.\n\n \n@param this The MetadataAttribute object.\n@param numElems the number of elements, must not be less than one\n @return product data compatible with this data node\n"},
    {"MetadataAttribute_getOwner", BeamPyMetadataAttribute_getOwner, METH_VARARGS, " @return The owner node of this node.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getName", BeamPyMetadataAttribute_getName, METH_VARARGS, " @return This node's name.\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setName", BeamPyMetadataAttribute_setName, METH_VARARGS, " Sets this product's name.\n\n \n@param this The MetadataAttribute object.\n@param name The name.\n"},
    {"MetadataAttribute_getDescription", BeamPyMetadataAttribute_getDescription, METH_VARARGS, " Returns a short textual description for this products node.\n\n @return a description or <code>null</code>\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setDescription", BeamPyMetadataAttribute_setDescription, METH_VARARGS, " Sets a short textual description for this products node.\n\n \n@param this The MetadataAttribute object.\n@param description a description, can be <code>null</code>\n"},
    {"MetadataAttribute_isModified", BeamPyMetadataAttribute_isModified, METH_VARARGS, " Returns whether or not this node is modified.\n\n @return <code>true</code> if so\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_setModified", BeamPyMetadataAttribute_setModified, METH_VARARGS, " Sets this node's modified flag.\n <p/>\n If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to\n true.\n\n \n@param this The MetadataAttribute object.\n@param modified whether or not this node is beeing marked as modified.\n @see org.esa.beam.framework.datamodel.Product#fireNodeChanged\n"},
    {"MetadataAttribute_toString", BeamPyMetadataAttribute_toString, METH_VARARGS, "\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_isValidNodeName", BeamPyMetadataAttribute_isValidNodeName, METH_VARARGS, " Tests whether the given name is valid name for a node.\n A valid node name must not start with a dot. Also a valid node name must not contain\n any of the character  <code>\\/:*?\"&lt;&gt;|</code>\n\n @param name the name to test\n @return <code>true</code> if the name is a valid node identifier, <code>false</code> otherwise\n"},
    {"MetadataAttribute_getProduct", BeamPyMetadataAttribute_getProduct, METH_VARARGS, " Returns the product to which this node belongs to.\n\n @return the product, or <code>null</code> if this node was not owned by a product at the time this method was\n         called\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductReader", BeamPyMetadataAttribute_getProductReader, METH_VARARGS, " Returns the product reader for the product to which this node belongs to.\n\n @return the product reader, or <code>null</code> if no such exists\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductWriter", BeamPyMetadataAttribute_getProductWriter, METH_VARARGS, " Returns the product writer for the product to which this node belongs to.\n\n @return the product writer, or <code>null</code> if no such exists\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getDisplayName", BeamPyMetadataAttribute_getDisplayName, METH_VARARGS, " Returns this node's display name. The display name is the product reference string with the node name appended.\n <p>Example: The string <code>\"[2] <i>node-name</i>\"</code> means node <code><i>node-name</i></code> of the\n product with the reference number <code>2</code>.\n\n @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is\n         <code>null</code>\n @see #getProductRefString\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_getProductRefString", BeamPyMetadataAttribute_getProductRefString, METH_VARARGS, " Gets the product reference string. The product reference string is the product reference number enclosed in\n square brackets. <p>Example: The string <code>\"[2]\"</code> stands for a product with the reference number\n <code>2</code>.\n\n @return the product reference string. <br>or <code>null</code> if this node has no product <br>or\n         <code>null</code> if its product reference number was inactive\n\n@param this The MetadataAttribute object."},
    {"MetadataAttribute_updateExpression", BeamPyMetadataAttribute_updateExpression, METH_VARARGS, " Asks a product node to replace all occurences of and references to the node name\n given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur\n in band arithmetic expressions.\n\n \n@param this The MetadataAttribute object.\n@param oldExternalName The old node name.\n @param newExternalName The new node name.\n"},
    {"MetadataAttribute_removeFromFile", BeamPyMetadataAttribute_removeFromFile, METH_VARARGS, " Physically remove this node from the file associated with the given product writer. The default implementation\n does nothing.\n\n \n@param this The MetadataAttribute object.\n@param productWriter the product writer to be used to remove this node from the underlying file.\n"},
    {"String_newString", BeamPyString_newString, METH_VARARGS, "Converts a Python unicode string into a Java object"},
    {NULL, NULL, 0, NULL}  /* Sentinel */
};


typedef struct {
    PyObject_HEAD
    void* jobjectId;
} BeamPyJObject;

static int BeamPyJObject_init(BeamPyJObject* self, PyObject* args, PyObject* kwds)
{
    printf("BeamPyJObject_init\n");
    self->jobjectId = PyLong_AsVoidPtr(args);
    return self->jobjectId != NULL ? 0 : 1;
}

static void BeamPyJObject_dealloc(BeamPyJObject* self)
{
    printf("BeamPyJObject_dealloc\n");
    beam_release_jobject(&self->jobjectId);
}

// not used yet
static PyTypeObject BeamPy_JObjectTypeV = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "beampy.JObject",         /* tp_name */
    sizeof (BeamPyJObject),       /* tp_basicsize */
    0,                            /* tp_itemsize */
    (destructor)BeamPyJObject_dealloc, /* tp_dealloc */
    NULL,                         /* tp_print */
    NULL,                         /* tp_getattr */
    NULL,                         /* tp_setattr */
    NULL,                         /* tp_reserved */
    NULL,                         /* tp_repr */
    NULL,                         /* tp_as_number */
    NULL,                         /* tp_as_sequence */
    NULL,                         /* tp_as_mapping */
    NULL,                         /* tp_hash  */
    NULL,                         /* tp_call */
    NULL,                         /* tp_str */
    NULL,                         /* tp_getattro */
    NULL,                         /* tp_setattro */
    NULL,                         /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,           /* tp_flags */
    "BEAM Java Object",           /* tp_doc */
    NULL,                         /* tp_traverse */
    NULL,                         /* tp_clear */
    NULL,                         /* tp_richcompare */
    0,                            /* tp_weaklistoffset */
    NULL,                         /* tp_iter */
    NULL,                         /* tp_iternext */
    NULL,                         /* tp_methods */
    NULL,                         /* tp_members */
    NULL,                         /* tp_getset */
    NULL,                         /* tp_base */
    NULL,                         /* tp_dict */
    NULL,                         /* tp_descr_get */
    NULL,                         /* tp_descr_set */
    0,                            /* tp_dictoffset */
    (initproc)BeamPyJObject_init, /* tp_init */
    NULL,                         /* tp_alloc */
    NULL,                         /* tp_new */
};

// not used yet
static PyObject* BeamPy_JObjectType = (PyObject*) &BeamPy_JObjectTypeV;

/*
 * The BEAM/Python API module definition structure.
 */
static struct PyModuleDef BeamPy_Module =
{
   PyModuleDef_HEAD_INIT,
   "_beampy",           /* Name of the Python module */
   "Native BEAM/Python API",  /* Module documentation */
   -1,                 /* Size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */
   BeamPy_Methods      /* Structure containing all BEAM/Python API functions */
};

/*
 * Called by the Python interpreter once immediately after the shared lib has been loaded.
 */
PyMODINIT_FUNC PyInit__beampy()
{
    PyObject* m;

    fprintf(stdout, "beampy: Enter PyInit__beampy()\n");
    m = PyModule_Create(&BeamPy_Module);
    if (m == NULL) {
        return NULL;
    }

    BeamPy_Error = PyErr_NewException("beampy.error", NULL, NULL);
    Py_INCREF(BeamPy_Error);
    PyModule_AddObject(m, "error", BeamPy_Error);

    //Py_INCREF(BeamPy_JObjectType);
    //PyModule_AddObject(m, "JObject", BeamPy_JObjectType);

    // todo - use the new BeamPy_JObjectType object instead of the currently used (sK) tuples.
    // // JObject instances shall be created using the following pattern:
    // PyObject* arg = PyLong_FromVoidPtr(ptr); // ptr is the JNI Java object
    // PyObject* obj = PyObject_Call(BeamPy_JObjectType, arg, NULL);
    // Py_DECREF(arg);

    // todo - in  BeamPyJObject_init use:
    // self->jobject = PyLong_AsVoidPtr(args);

    if (!beam_create_jvm_with_defaults()) {
        PyErr_SetString(BeamPy_Error, "Failed to create Java VM");
        return NULL;
    }

    fprintf(stdout, "beampy: Exit PyInit__beampy()\n");

    return m;
}

PyObject* BeamPyString_newString(PyObject* self, PyObject* args)
{
    const char* chars;
    void* result;

    if (!PyArg_ParseTuple(args, "s:strToObj", &chars)) {
        return NULL;
    }

    result = String_newString(chars);

    if (result != NULL) {
        return Py_BuildValue("(sK)", "String", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}


PyObject* BeamPyGeoCoding_canGetPixelPos(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_canGetPixelPos", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_canGetPixelPos((GeoCoding) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyGeoCoding_canGetGeoPos(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_canGetGeoPos", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_canGetGeoPos((GeoCoding) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyGeoCoding_getPixelPos(PyObject* self, PyObject* args)
{
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    const char* pixelPosType;
    unsigned PY_LONG_LONG pixelPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):GeoCoding_getPixelPos", &thisObjType, &thisObj, &geoPosType, &geoPos, &pixelPosType, &pixelPos)) {
        return NULL;
    }
    result = GeoCoding_getPixelPos((GeoCoding) thisObj, (GeoPos) geoPos, (PixelPos) pixelPos);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PixelPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoCoding_getGeoPos(PyObject* self, PyObject* args)
{
    const char* pixelPosType;
    unsigned PY_LONG_LONG pixelPos;
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):GeoCoding_getGeoPos", &thisObjType, &thisObj, &pixelPosType, &pixelPos, &geoPosType, &geoPos)) {
        return NULL;
    }
    result = GeoCoding_getGeoPos((GeoCoding) thisObj, (PixelPos) pixelPos, (GeoPos) geoPos);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoCoding_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    GeoCoding_dispose((GeoCoding) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoCoding_getImageCRS(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_getImageCRS", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_getImageCRS((GeoCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "CoordinateReferenceSystem", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoCoding_getMapCRS(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_getMapCRS", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_getMapCRS((GeoCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "CoordinateReferenceSystem", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoCoding_getGeoCRS(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_getGeoCRS", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_getGeoCRS((GeoCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "CoordinateReferenceSystem", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoCoding_getImageToMapTransform(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):GeoCoding_getImageToMapTransform", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoCoding_getImageToMapTransform((GeoCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MathTransform", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductWriter_getWriterPlugIn(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_getWriterPlugIn", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductWriter_getWriterPlugIn((ProductWriter) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriterPlugIn", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductWriter_getOutput(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_getOutput", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductWriter_getOutput((ProductWriter) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductWriter_writeProductNodes(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* outputType;
    unsigned PY_LONG_LONG output;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ProductWriter_writeProductNodes", &thisObjType, &thisObj, &productType, &product, &outputType, &output)) {
        return NULL;
    }
    ProductWriter_writeProductNodes((ProductWriter) thisObj, (Product) product, (Object) output);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_writeBandRasterData(PyObject* self, PyObject* args)
{
    const char* sourceBandType;
    unsigned PY_LONG_LONG sourceBand;
    int sourceOffsetX;
    int sourceOffsetY;
    int sourceWidth;
    int sourceHeight;
    const char* sourceBufferType;
    unsigned PY_LONG_LONG sourceBuffer;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)iiii(sK)(sK):ProductWriter_writeBandRasterData", &thisObjType, &thisObj, &sourceBandType, &sourceBand, &sourceOffsetX, &sourceOffsetY, &sourceWidth, &sourceHeight, &sourceBufferType, &sourceBuffer, &pmType, &pm)) {
        return NULL;
    }
    ProductWriter_writeBandRasterData((ProductWriter) thisObj, (Band) sourceBand, sourceOffsetX, sourceOffsetY, sourceWidth, sourceHeight, (ProductData) sourceBuffer, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_flush(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_flush", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductWriter_flush((ProductWriter) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_close(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_close", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductWriter_close((ProductWriter) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_shouldWrite(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductWriter_shouldWrite", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = ProductWriter_shouldWrite((ProductWriter) thisObj, (ProductNode) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductWriter_isIncrementalMode(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_isIncrementalMode", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductWriter_isIncrementalMode((ProductWriter) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductWriter_setIncrementalMode(PyObject* self, PyObject* args)
{
    boolean enabled;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ProductWriter_setIncrementalMode", &thisObjType, &thisObj, &enabled)) {
        return NULL;
    }
    ProductWriter_setIncrementalMode((ProductWriter) thisObj, enabled);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_deleteOutput(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductWriter_deleteOutput", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductWriter_deleteOutput((ProductWriter) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductWriter_removeBand(PyObject* self, PyObject* args)
{
    const char* bandType;
    unsigned PY_LONG_LONG band;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductWriter_removeBand", &thisObjType, &thisObj, &bandType, &band)) {
        return NULL;
    }
    ProductWriter_removeBand((ProductWriter) thisObj, (Band) band);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_newIndexCoding(PyObject* self, PyObject* args)
{
    const char* name;
    void* result;
    if (!PyArg_ParseTuple(args, "s:IndexCoding_newIndexCoding", &name)) {
        return NULL;
    }
    result = IndexCoding_newIndexCoding(name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getIndex(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_getIndex", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_getIndex((IndexCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getIndexNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getIndexNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getIndexNames((IndexCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_addIndex(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sis:IndexCoding_addIndex", &thisObjType, &thisObj, &name, &value, &description)) {
        return NULL;
    }
    result = IndexCoding_addIndex((IndexCoding) thisObj, name, value, description);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getIndexValue(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_getIndexValue", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_getIndexValue((IndexCoding) thisObj, name);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    IndexCoding_acceptVisitor((IndexCoding) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_addElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    IndexCoding_addElement((IndexCoding) thisObj, (MetadataElement) element);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_addAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    IndexCoding_addAttribute((IndexCoding) thisObj, (MetadataAttribute) attribute);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_addSample(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sis:IndexCoding_addSample", &thisObjType, &thisObj, &name, &value, &description)) {
        return NULL;
    }
    result = IndexCoding_addSample((IndexCoding) thisObj, name, value, description);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getSampleCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getSampleCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getSampleCount((IndexCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_getSampleName(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)i:IndexCoding_getSampleName", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = IndexCoding_getSampleName((IndexCoding) thisObj, index);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getSampleValue(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)i:IndexCoding_getSampleValue", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = IndexCoding_getSampleValue((IndexCoding) thisObj, index);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_getElementGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getElementGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getElementGroup((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getParentElement(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getParentElement", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getParentElement((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_addElementAt(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:IndexCoding_addElementAt", &thisObjType, &thisObj, &elementType, &element, &index)) {
        return NULL;
    }
    IndexCoding_addElementAt((IndexCoding) thisObj, (MetadataElement) element, index);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_removeElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = IndexCoding_removeElement((IndexCoding) thisObj, (MetadataElement) element);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_getNumElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getNumElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getNumElements((IndexCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_getElementAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:IndexCoding_getElementAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = IndexCoding_getElementAt((IndexCoding) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getElementNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getElementNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getElementNames((IndexCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataElement* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getElements((IndexCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataElement", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_getElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_getElement((IndexCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_containsElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_containsElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_containsElement((IndexCoding) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_getElementIndex(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_getElementIndex", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = IndexCoding_getElementIndex((IndexCoding) thisObj, (MetadataElement) element);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_removeAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_removeAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = IndexCoding_removeAttribute((IndexCoding) thisObj, (MetadataAttribute) attribute);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getNumAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getNumAttributes((IndexCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:IndexCoding_getAttributeAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = IndexCoding_getAttributeAt((IndexCoding) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getAttributeNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getAttributeNames((IndexCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataAttribute* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getAttributes((IndexCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataAttribute", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_getAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_getAttribute((IndexCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_containsAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_containsAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = IndexCoding_containsAttribute((IndexCoding) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_getAttributeIndex", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = IndexCoding_getAttributeIndex((IndexCoding) thisObj, (MetadataAttribute) attribute);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)sd:IndexCoding_getAttributeDouble", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = IndexCoding_getAttributeDouble((IndexCoding) thisObj, name, defaultValue);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyIndexCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValueType;
    unsigned PY_LONG_LONG defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):IndexCoding_getAttributeUTC", &thisObjType, &thisObj, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    result = IndexCoding_getAttributeUTC((IndexCoding) thisObj, name, (ProductData_UTC) defaultValue);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)si:IndexCoding_getAttributeInt", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = IndexCoding_getAttributeInt((IndexCoding) thisObj, name, defaultValue);
    return PyLong_FromLong(result);
}

PyObject* BeamPyIndexCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)si:IndexCoding_setAttributeInt", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    IndexCoding_setAttributeInt((IndexCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)sd:IndexCoding_setAttributeDouble", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    IndexCoding_setAttributeDouble((IndexCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* valueType;
    unsigned PY_LONG_LONG value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):IndexCoding_setAttributeUTC", &thisObjType, &thisObj, &name, &valueType, &value)) {
        return NULL;
    }
    IndexCoding_setAttributeUTC((IndexCoding) thisObj, name, (ProductData_UTC) value);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ss:IndexCoding_getAttributeString", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = IndexCoding_getAttributeString((IndexCoding) thisObj, name, defaultValue);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_setAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:IndexCoding_setAttributeString", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    IndexCoding_setAttributeString((IndexCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:IndexCoding_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    IndexCoding_setModified((IndexCoding) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_createDeepClone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_createDeepClone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_createDeepClone((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    IndexCoding_dispose((IndexCoding) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getOwner((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getName((IndexCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    IndexCoding_setName((IndexCoding) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getDescription((IndexCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:IndexCoding_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    IndexCoding_setDescription((IndexCoding) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_isModified((IndexCoding) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_toString((IndexCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:IndexCoding_isValidNodeName", &name)) {
        return NULL;
    }
    result = IndexCoding_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyIndexCoding_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getProduct((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getProductReader((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getProductWriter((IndexCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getDisplayName((IndexCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):IndexCoding_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = IndexCoding_getProductRefString((IndexCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyIndexCoding_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:IndexCoding_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    IndexCoding_updateExpression((IndexCoding) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyIndexCoding_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):IndexCoding_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    IndexCoding_removeFromFile((IndexCoding) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_newPixelPos1(PyObject* self, PyObject* args)
{
    void* result;
    result = PixelPos_newPixelPos1();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PixelPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPixelPos_newPixelPos2(PyObject* self, PyObject* args)
{
    float x;
    float y;
    void* result;
    if (!PyArg_ParseTuple(args, "ff:PixelPos_newPixelPos2", &x, &y)) {
        return NULL;
    }
    result = PixelPos_newPixelPos2(x, y);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PixelPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPixelPos_isValid(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_isValid", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_isValid((PixelPos) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPixelPos_setInvalid(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_setInvalid", &thisObjType, &thisObj)) {
        return NULL;
    }
    PixelPos_setInvalid((PixelPos) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_getX(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_getX", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_getX((PixelPos) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_getY(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_getY", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_getY((PixelPos) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_setLocation1(PyObject* self, PyObject* args)
{
    double arg0;
    double arg1;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)dd:PixelPos_setLocation1", &thisObjType, &thisObj, &arg0, &arg1)) {
        return NULL;
    }
    PixelPos_setLocation1((PixelPos) thisObj, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_setLocation2(PyObject* self, PyObject* args)
{
    float arg0;
    float arg1;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ff:PixelPos_setLocation2", &thisObjType, &thisObj, &arg0, &arg1)) {
        return NULL;
    }
    PixelPos_setLocation2((PixelPos) thisObj, arg0, arg1);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_toString((PixelPos) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPixelPos_setLocation3(PyObject* self, PyObject* args)
{
    const char* arg0Type;
    unsigned PY_LONG_LONG arg0;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PixelPos_setLocation3", &thisObjType, &thisObj, &arg0Type, &arg0)) {
        return NULL;
    }
    PixelPos_setLocation3((PixelPos) thisObj, (Point2D) arg0);
    return Py_BuildValue("");
}

PyObject* BeamPyPixelPos_distanceSq2(PyObject* self, PyObject* args)
{
    double arg0;
    double arg1;
    double arg2;
    double arg3;
    double result;
    if (!PyArg_ParseTuple(args, "dddd:PixelPos_distanceSq2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    result = PixelPos_distanceSq2(arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_distance2(PyObject* self, PyObject* args)
{
    double arg0;
    double arg1;
    double arg2;
    double arg3;
    double result;
    if (!PyArg_ParseTuple(args, "dddd:PixelPos_distance2", &arg0, &arg1, &arg2, &arg3)) {
        return NULL;
    }
    result = PixelPos_distance2(arg0, arg1, arg2, arg3);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_distanceSq1(PyObject* self, PyObject* args)
{
    double arg0;
    double arg1;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)dd:PixelPos_distanceSq1", &thisObjType, &thisObj, &arg0, &arg1)) {
        return NULL;
    }
    result = PixelPos_distanceSq1((PixelPos) thisObj, arg0, arg1);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_distanceSq3(PyObject* self, PyObject* args)
{
    const char* arg0Type;
    unsigned PY_LONG_LONG arg0;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PixelPos_distanceSq3", &thisObjType, &thisObj, &arg0Type, &arg0)) {
        return NULL;
    }
    result = PixelPos_distanceSq3((PixelPos) thisObj, (Point2D) arg0);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_distance1(PyObject* self, PyObject* args)
{
    double arg0;
    double arg1;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)dd:PixelPos_distance1", &thisObjType, &thisObj, &arg0, &arg1)) {
        return NULL;
    }
    result = PixelPos_distance1((PixelPos) thisObj, arg0, arg1);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_distance3(PyObject* self, PyObject* args)
{
    const char* arg0Type;
    unsigned PY_LONG_LONG arg0;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PixelPos_distance3", &thisObjType, &thisObj, &arg0Type, &arg0)) {
        return NULL;
    }
    result = PixelPos_distance3((PixelPos) thisObj, (Point2D) arg0);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyPixelPos_clone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_clone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_clone((PixelPos) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPixelPos_hashCode(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):PixelPos_hashCode", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PixelPos_hashCode((PixelPos) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyPixelPos_equals(PyObject* self, PyObject* args)
{
    const char* arg0Type;
    unsigned PY_LONG_LONG arg0;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PixelPos_equals", &thisObjType, &thisObj, &arg0Type, &arg0)) {
        return NULL;
    }
    result = PixelPos_equals((PixelPos) thisObj, (Object) arg0);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductIO_getProductReader(PyObject* self, PyObject* args)
{
    const char* formatName;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ProductIO_getProductReader", &formatName)) {
        return NULL;
    }
    result = ProductIO_getProductReader(formatName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductIO_getProductWriterExtensions(PyObject* self, PyObject* args)
{
    const char* formatName;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "s:ProductIO_getProductWriterExtensions", &formatName)) {
        return NULL;
    }
    result = ProductIO_getProductWriterExtensions(formatName, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductIO_getProductWriter(PyObject* self, PyObject* args)
{
    const char* formatName;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ProductIO_getProductWriter", &formatName)) {
        return NULL;
    }
    result = ProductIO_getProductWriter(formatName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductIO_readProduct(PyObject* self, PyObject* args)
{
    const char* filePath;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ProductIO_readProduct", &filePath)) {
        return NULL;
    }
    result = ProductIO_readProduct(filePath);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductIO_getProductReaderForInput(PyObject* self, PyObject* args)
{
    const char* inputType;
    unsigned PY_LONG_LONG input;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductIO_getProductReaderForInput", &inputType, &input)) {
        return NULL;
    }
    result = ProductIO_getProductReaderForInput((Object) input);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductIO_writeProduct(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* filePath;
    const char* formatName;
    if (!PyArg_ParseTuple(args, "(sK)ss:ProductIO_writeProduct", &productType, &product, &filePath, &formatName)) {
        return NULL;
    }
    ProductIO_writeProduct((Product) product, filePath, formatName);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_newPlacemark(PyObject* self, PyObject* args)
{
    const char* descriptorType;
    unsigned PY_LONG_LONG descriptor;
    const char* featureType;
    unsigned PY_LONG_LONG feature;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Placemark_newPlacemark", &descriptorType, &descriptor, &featureType, &feature)) {
        return NULL;
    }
    result = Placemark_newPlacemark((PlacemarkDescriptor) descriptor, (SimpleFeature) feature);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Placemark", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_createPointPlacemark(PyObject* self, PyObject* args)
{
    const char* descriptorType;
    unsigned PY_LONG_LONG descriptor;
    const char* name;
    const char* label;
    const char* text;
    const char* pixelPosType;
    unsigned PY_LONG_LONG pixelPos;
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sss(sK)(sK)(sK):Placemark_createPointPlacemark", &descriptorType, &descriptor, &name, &label, &text, &pixelPosType, &pixelPos, &geoPosType, &geoPos, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    result = Placemark_createPointPlacemark((PlacemarkDescriptor) descriptor, name, label, text, (PixelPos) pixelPos, (GeoPos) geoPos, (GeoCoding) geoCoding);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Placemark", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getDescriptor(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getDescriptor", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getDescriptor((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PlacemarkDescriptor", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getFeature(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getFeature", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getFeature((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SimpleFeature", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getAttributeValue(PyObject* self, PyObject* args)
{
    const char* attributeName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_getAttributeValue", &thisObjType, &thisObj, &attributeName)) {
        return NULL;
    }
    result = Placemark_getAttributeValue((Placemark) thisObj, attributeName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setAttributeValue(PyObject* self, PyObject* args)
{
    const char* attributeName;
    const char* attributeValueType;
    unsigned PY_LONG_LONG attributeValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):Placemark_setAttributeValue", &thisObjType, &thisObj, &attributeName, &attributeValueType, &attributeValue)) {
        return NULL;
    }
    Placemark_setAttributeValue((Placemark) thisObj, attributeName, (Object) attributeValue);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_setLabel(PyObject* self, PyObject* args)
{
    const char* label;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_setLabel", &thisObjType, &thisObj, &label)) {
        return NULL;
    }
    Placemark_setLabel((Placemark) thisObj, label);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getLabel(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getLabel", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getLabel((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setText(PyObject* self, PyObject* args)
{
    const char* text;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_setText", &thisObjType, &thisObj, &text)) {
        return NULL;
    }
    Placemark_setText((Placemark) thisObj, text);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getText(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getText", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getText((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setStyleCss(PyObject* self, PyObject* args)
{
    const char* styleCss;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_setStyleCss", &thisObjType, &thisObj, &styleCss)) {
        return NULL;
    }
    Placemark_setStyleCss((Placemark) thisObj, styleCss);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getStyleCss(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getStyleCss", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getStyleCss((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Placemark_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    Placemark_acceptVisitor((Placemark) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getPixelPos(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getPixelPos", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getPixelPos((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PixelPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setPixelPos(PyObject* self, PyObject* args)
{
    const char* pixelPosType;
    unsigned PY_LONG_LONG pixelPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Placemark_setPixelPos", &thisObjType, &thisObj, &pixelPosType, &pixelPos)) {
        return NULL;
    }
    Placemark_setPixelPos((Placemark) thisObj, (PixelPos) pixelPos);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getGeoPos(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getGeoPos", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getGeoPos((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setGeoPos(PyObject* self, PyObject* args)
{
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Placemark_setGeoPos", &thisObjType, &thisObj, &geoPosType, &geoPos)) {
        return NULL;
    }
    Placemark_setGeoPos((Placemark) thisObj, (GeoPos) geoPos);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_updatePositions(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_updatePositions", &thisObjType, &thisObj)) {
        return NULL;
    }
    Placemark_updatePositions((Placemark) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_createPinFeatureType(PyObject* self, PyObject* args)
{
    void* result;
    result = Placemark_createPinFeatureType();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SimpleFeatureType", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_createGcpFeatureType(PyObject* self, PyObject* args)
{
    void* result;
    result = Placemark_createGcpFeatureType();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SimpleFeatureType", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_createGeometryFeatureType(PyObject* self, PyObject* args)
{
    void* result;
    result = Placemark_createGeometryFeatureType();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SimpleFeatureType", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_createPointFeatureType(PyObject* self, PyObject* args)
{
    const char* name;
    void* result;
    if (!PyArg_ParseTuple(args, "s:Placemark_createPointFeatureType", &name)) {
        return NULL;
    }
    result = Placemark_createPointFeatureType(name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SimpleFeatureType", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getOwner((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getName((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    Placemark_setName((Placemark) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getDescription((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Placemark_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    Placemark_setDescription((Placemark) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_isModified((Placemark) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemark_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Placemark_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    Placemark_setModified((Placemark) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_toString((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    Placemark_dispose((Placemark) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:Placemark_isValidNodeName", &name)) {
        return NULL;
    }
    result = Placemark_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemark_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getProduct((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getProductReader((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getProductWriter((Placemark) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getDisplayName((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Placemark_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Placemark_getProductRefString((Placemark) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemark_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:Placemark_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    Placemark_updateExpression((Placemark) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemark_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Placemark_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    Placemark_removeFromFile((Placemark) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_newMetadataElement(PyObject* self, PyObject* args)
{
    const char* name;
    void* result;
    if (!PyArg_ParseTuple(args, "s:MetadataElement_newMetadataElement", &name)) {
        return NULL;
    }
    result = MetadataElement_newMetadataElement(name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getElementGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getElementGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getElementGroup((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getParentElement(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getParentElement", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getParentElement((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_addElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_addElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    MetadataElement_addElement((MetadataElement) thisObj, (MetadataElement) element);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_addElementAt(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:MetadataElement_addElementAt", &thisObjType, &thisObj, &elementType, &element, &index)) {
        return NULL;
    }
    MetadataElement_addElementAt((MetadataElement) thisObj, (MetadataElement) element, index);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_removeElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = MetadataElement_removeElement((MetadataElement) thisObj, (MetadataElement) element);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_getNumElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getNumElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getNumElements((MetadataElement) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataElement_getElementAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:MetadataElement_getElementAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = MetadataElement_getElementAt((MetadataElement) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getElementNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getElementNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getElementNames((MetadataElement) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataElement* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getElements((MetadataElement) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataElement", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_getElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = MetadataElement_getElement((MetadataElement) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_containsElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_containsElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = MetadataElement_containsElement((MetadataElement) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_getElementIndex(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_getElementIndex", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = MetadataElement_getElementIndex((MetadataElement) thisObj, (MetadataElement) element);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataElement_addAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_addAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    MetadataElement_addAttribute((MetadataElement) thisObj, (MetadataAttribute) attribute);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_removeAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = MetadataElement_removeAttribute((MetadataElement) thisObj, (MetadataAttribute) attribute);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_getNumAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getNumAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getNumAttributes((MetadataElement) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataElement_getAttributeAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:MetadataElement_getAttributeAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = MetadataElement_getAttributeAt((MetadataElement) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getAttributeNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getAttributeNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getAttributeNames((MetadataElement) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataAttribute* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getAttributes((MetadataElement) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataAttribute", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_getAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = MetadataElement_getAttribute((MetadataElement) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_containsAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_containsAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = MetadataElement_containsAttribute((MetadataElement) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_getAttributeIndex(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_getAttributeIndex", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = MetadataElement_getAttributeIndex((MetadataElement) thisObj, (MetadataAttribute) attribute);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataElement_getAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)sd:MetadataElement_getAttributeDouble", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = MetadataElement_getAttributeDouble((MetadataElement) thisObj, name, defaultValue);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyMetadataElement_getAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValueType;
    unsigned PY_LONG_LONG defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):MetadataElement_getAttributeUTC", &thisObjType, &thisObj, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    result = MetadataElement_getAttributeUTC((MetadataElement) thisObj, name, (ProductData_UTC) defaultValue);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)si:MetadataElement_getAttributeInt", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = MetadataElement_getAttributeInt((MetadataElement) thisObj, name, defaultValue);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataElement_setAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)si:MetadataElement_setAttributeInt", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    MetadataElement_setAttributeInt((MetadataElement) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)sd:MetadataElement_setAttributeDouble", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    MetadataElement_setAttributeDouble((MetadataElement) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* valueType;
    unsigned PY_LONG_LONG value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):MetadataElement_setAttributeUTC", &thisObjType, &thisObj, &name, &valueType, &value)) {
        return NULL;
    }
    MetadataElement_setAttributeUTC((MetadataElement) thisObj, name, (ProductData_UTC) value);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ss:MetadataElement_getAttributeString", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = MetadataElement_getAttributeString((MetadataElement) thisObj, name, defaultValue);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_setAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:MetadataElement_setAttributeString", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    MetadataElement_setAttributeString((MetadataElement) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:MetadataElement_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    MetadataElement_setModified((MetadataElement) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    MetadataElement_acceptVisitor((MetadataElement) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_createDeepClone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_createDeepClone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_createDeepClone((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    MetadataElement_dispose((MetadataElement) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getOwner((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getName((MetadataElement) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    MetadataElement_setName((MetadataElement) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getDescription((MetadataElement) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataElement_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    MetadataElement_setDescription((MetadataElement) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_isModified((MetadataElement) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_toString((MetadataElement) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:MetadataElement_isValidNodeName", &name)) {
        return NULL;
    }
    result = MetadataElement_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataElement_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getProduct((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getProductReader((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getProductWriter((MetadataElement) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getDisplayName((MetadataElement) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataElement_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataElement_getProductRefString((MetadataElement) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataElement_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:MetadataElement_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    MetadataElement_updateExpression((MetadataElement) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataElement_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataElement_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    MetadataElement_removeFromFile((MetadataElement) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_newProduct(PyObject* self, PyObject* args)
{
    const char* name;
    const char* type;
    int sceneRasterWidth;
    int sceneRasterHeight;
    void* result;
    if (!PyArg_ParseTuple(args, "ssii:Product_newProduct", &name, &type, &sceneRasterWidth, &sceneRasterHeight)) {
        return NULL;
    }
    result = Product_newProduct(name, type, sceneRasterWidth, sceneRasterHeight);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getFileLocation(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getFileLocation", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getFileLocation((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "File", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setFileLocation(PyObject* self, PyObject* args)
{
    const char* fileLocationType;
    unsigned PY_LONG_LONG fileLocation;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setFileLocation", &thisObjType, &thisObj, &fileLocationType, &fileLocation)) {
        return NULL;
    }
    Product_setFileLocation((Product) thisObj, (File) fileLocation);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductType((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setProductType(PyObject* self, PyObject* args)
{
    const char* productType;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_setProductType", &thisObjType, &thisObj, &productType)) {
        return NULL;
    }
    Product_setProductType((Product) thisObj, productType);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setProductReader(PyObject* self, PyObject* args)
{
    const char* readerType;
    unsigned PY_LONG_LONG reader;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setProductReader", &thisObjType, &thisObj, &readerType, &reader)) {
        return NULL;
    }
    Product_setProductReader((Product) thisObj, (ProductReader) reader);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductReader((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setProductWriter(PyObject* self, PyObject* args)
{
    const char* writerType;
    unsigned PY_LONG_LONG writer;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setProductWriter", &thisObjType, &thisObj, &writerType, &writer)) {
        return NULL;
    }
    Product_setProductWriter((Product) thisObj, (ProductWriter) writer);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductWriter((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_writeHeader(PyObject* self, PyObject* args)
{
    const char* outputType;
    unsigned PY_LONG_LONG output;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_writeHeader", &thisObjType, &thisObj, &outputType, &output)) {
        return NULL;
    }
    Product_writeHeader((Product) thisObj, (Object) output);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Product_closeProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    Product_closeProductReader((Product) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Product_closeProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    Product_closeProductWriter((Product) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_closeIO(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Product_closeIO", &thisObjType, &thisObj)) {
        return NULL;
    }
    Product_closeIO((Product) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Product_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    Product_dispose((Product) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getPointingFactory(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getPointingFactory", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getPointingFactory((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PointingFactory", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setPointingFactory(PyObject* self, PyObject* args)
{
    const char* pointingFactoryType;
    unsigned PY_LONG_LONG pointingFactory;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setPointingFactory", &thisObjType, &thisObj, &pointingFactoryType, &pointingFactory)) {
        return NULL;
    }
    Product_setPointingFactory((Product) thisObj, (PointingFactory) pointingFactory);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_setGeoCoding(PyObject* self, PyObject* args)
{
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setGeoCoding", &thisObjType, &thisObj, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    Product_setGeoCoding((Product) thisObj, (GeoCoding) geoCoding);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getGeoCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getGeoCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getGeoCoding((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_isUsingSingleGeoCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Product_isUsingSingleGeoCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_isUsingSingleGeoCoding((Product) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_transferGeoCodingTo(PyObject* self, PyObject* args)
{
    const char* destProductType;
    unsigned PY_LONG_LONG destProduct;
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):Product_transferGeoCodingTo", &thisObjType, &thisObj, &destProductType, &destProduct, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = Product_transferGeoCodingTo((Product) thisObj, (Product) destProduct, (ProductSubsetDef) subsetDef);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getSceneRasterWidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getSceneRasterWidth((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getSceneRasterHeight", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getSceneRasterHeight((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_getStartTime(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getStartTime", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getStartTime((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setStartTime(PyObject* self, PyObject* args)
{
    const char* startTimeType;
    unsigned PY_LONG_LONG startTime;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setStartTime", &thisObjType, &thisObj, &startTimeType, &startTime)) {
        return NULL;
    }
    Product_setStartTime((Product) thisObj, (ProductData_UTC) startTime);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getEndTime(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getEndTime", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getEndTime((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setEndTime(PyObject* self, PyObject* args)
{
    const char* endTimeType;
    unsigned PY_LONG_LONG endTime;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_setEndTime", &thisObjType, &thisObj, &endTimeType, &endTime)) {
        return NULL;
    }
    Product_setEndTime((Product) thisObj, (ProductData_UTC) endTime);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getMetadataRoot(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getMetadataRoot", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getMetadataRoot((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getGroups(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getGroups", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getGroups((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getGroup(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_getGroup", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_getGroup((Product) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getTiePointGridGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getTiePointGridGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getTiePointGridGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_addTiePointGrid(PyObject* self, PyObject* args)
{
    const char* tiePointGridType;
    unsigned PY_LONG_LONG tiePointGrid;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_addTiePointGrid", &thisObjType, &thisObj, &tiePointGridType, &tiePointGrid)) {
        return NULL;
    }
    Product_addTiePointGrid((Product) thisObj, (TiePointGrid) tiePointGrid);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeTiePointGrid(PyObject* self, PyObject* args)
{
    const char* tiePointGridType;
    unsigned PY_LONG_LONG tiePointGrid;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_removeTiePointGrid", &thisObjType, &thisObj, &tiePointGridType, &tiePointGrid)) {
        return NULL;
    }
    result = Product_removeTiePointGrid((Product) thisObj, (TiePointGrid) tiePointGrid);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getNumTiePointGrids(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getNumTiePointGrids", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getNumTiePointGrids((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_getTiePointGridAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:Product_getTiePointGridAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = Product_getTiePointGridAt((Product) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getTiePointGridNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getTiePointGridNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getTiePointGridNames((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getTiePointGrids(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    TiePointGrid* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getTiePointGrids", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getTiePointGrids((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("TiePointGrid", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getTiePointGrid(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_getTiePointGrid", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_getTiePointGrid((Product) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_containsTiePointGrid(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_containsTiePointGrid", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_containsTiePointGrid((Product) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getBandGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getBandGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getBandGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_addBand(PyObject* self, PyObject* args)
{
    const char* bandType;
    unsigned PY_LONG_LONG band;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_addBand", &thisObjType, &thisObj, &bandType, &band)) {
        return NULL;
    }
    Product_addBand((Product) thisObj, (Band) band);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addNewBand(PyObject* self, PyObject* args)
{
    const char* bandName;
    int dataType;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)si:Product_addNewBand", &thisObjType, &thisObj, &bandName, &dataType)) {
        return NULL;
    }
    result = Product_addNewBand((Product) thisObj, bandName, dataType);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_addComputedBand(PyObject* self, PyObject* args)
{
    const char* bandName;
    const char* expression;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)ss:Product_addComputedBand", &thisObjType, &thisObj, &bandName, &expression)) {
        return NULL;
    }
    result = Product_addComputedBand((Product) thisObj, bandName, expression);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_removeBand(PyObject* self, PyObject* args)
{
    const char* bandType;
    unsigned PY_LONG_LONG band;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_removeBand", &thisObjType, &thisObj, &bandType, &band)) {
        return NULL;
    }
    result = Product_removeBand((Product) thisObj, (Band) band);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getNumBands(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getNumBands", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getNumBands((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_getBandAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:Product_getBandAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = Product_getBandAt((Product) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getBandNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getBandNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getBandNames((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getBands(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    Band* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getBands", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getBands((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Band", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getBand(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_getBand", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_getBand((Product) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getBandIndex(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_getBandIndex", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_getBandIndex((Product) thisObj, name);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_containsBand(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_containsBand", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_containsBand((Product) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_containsRasterDataNode(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_containsRasterDataNode", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_containsRasterDataNode((Product) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getRasterDataNode(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_getRasterDataNode", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = Product_getRasterDataNode((Product) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "RasterDataNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getMaskGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getMaskGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getMaskGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getVectorDataGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getVectorDataGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getVectorDataGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getFlagCodingGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getFlagCodingGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getFlagCodingGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getIndexCodingGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getIndexCodingGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getIndexCodingGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_containsPixel(PyObject* self, PyObject* args)
{
    float x;
    float y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)ff:Product_containsPixel", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Product_containsPixel((Product) thisObj, x, y);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getGcpGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getGcpGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getGcpGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PlacemarkGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getPinGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getPinGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getPinGroup((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "PlacemarkGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getNumResolutionsMax(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getNumResolutionsMax", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getNumResolutionsMax((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_setNumResolutionsMax(PyObject* self, PyObject* args)
{
    int numResolutionsMax;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:Product_setNumResolutionsMax", &thisObjType, &thisObj, &numResolutionsMax)) {
        return NULL;
    }
    Product_setNumResolutionsMax((Product) thisObj, numResolutionsMax);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isCompatibleProduct(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    float eps;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)f:Product_isCompatibleProduct", &thisObjType, &thisObj, &productType, &product, &eps)) {
        return NULL;
    }
    result = Product_isCompatibleProduct((Product) thisObj, (Product) product, eps);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_parseExpression(PyObject* self, PyObject* args)
{
    const char* expression;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_parseExpression", &thisObjType, &thisObj, &expression)) {
        return NULL;
    }
    result = Product_parseExpression((Product) thisObj, expression);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Term", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    Product_acceptVisitor((Product) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addProductNodeListener(PyObject* self, PyObject* args)
{
    const char* listenerType;
    unsigned PY_LONG_LONG listener;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_addProductNodeListener", &thisObjType, &thisObj, &listenerType, &listener)) {
        return NULL;
    }
    result = Product_addProductNodeListener((Product) thisObj, (ProductNodeListener) listener);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_removeProductNodeListener(PyObject* self, PyObject* args)
{
    const char* listenerType;
    unsigned PY_LONG_LONG listener;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_removeProductNodeListener", &thisObjType, &thisObj, &listenerType, &listener)) {
        return NULL;
    }
    Product_removeProductNodeListener((Product) thisObj, (ProductNodeListener) listener);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductNodeListeners(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    ProductNodeListener* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductNodeListeners", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductNodeListeners((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("ProductNodeListener", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getRefNo(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getRefNo", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getRefNo((Product) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProduct_setRefNo(PyObject* self, PyObject* args)
{
    int refNo;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:Product_setRefNo", &thisObjType, &thisObj, &refNo)) {
        return NULL;
    }
    Product_setRefNo((Product) thisObj, refNo);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_resetRefNo(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Product_resetRefNo", &thisObjType, &thisObj)) {
        return NULL;
    }
    Product_resetRefNo((Product) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getProductManager(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductManager", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductManager((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductManager", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_createBandArithmeticParser(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_createBandArithmeticParser", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_createBandArithmeticParser((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Parser", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_createBandArithmeticDefaultNamespace(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_createBandArithmeticDefaultNamespace", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_createBandArithmeticDefaultNamespace((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "WritableNamespace", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_createSubset(PyObject* self, PyObject* args)
{
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* name;
    const char* desc;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ss:Product_createSubset", &thisObjType, &thisObj, &subsetDefType, &subsetDef, &name, &desc)) {
        return NULL;
    }
    result = Product_createSubset((Product) thisObj, (ProductSubsetDef) subsetDef, name, desc);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_createProjectedProduct(PyObject* self, PyObject* args)
{
    const char* mapInfoType;
    unsigned PY_LONG_LONG mapInfo;
    const char* name;
    const char* desc;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ss:Product_createProjectedProduct", &thisObjType, &thisObj, &mapInfoType, &mapInfo, &name, &desc)) {
        return NULL;
    }
    result = Product_createProjectedProduct((Product) thisObj, (MapInfo) mapInfo, name, desc);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_createFlippedProduct(PyObject* self, PyObject* args)
{
    int flipType;
    const char* name;
    const char* desc;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)iss:Product_createFlippedProduct", &thisObjType, &thisObj, &flipType, &name, &desc)) {
        return NULL;
    }
    result = Product_createFlippedProduct((Product) thisObj, flipType, name, desc);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Product_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    Product_setModified((Product) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getQuicklookBandName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getQuicklookBandName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getQuicklookBandName((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setQuicklookBandName(PyObject* self, PyObject* args)
{
    const char* quicklookBandName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_setQuicklookBandName", &thisObjType, &thisObj, &quicklookBandName)) {
        return NULL;
    }
    Product_setQuicklookBandName((Product) thisObj, quicklookBandName);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_createPixelInfoString(PyObject* self, PyObject* args)
{
    int pixelX;
    int pixelY;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ii:Product_createPixelInfoString", &thisObjType, &thisObj, &pixelX, &pixelY)) {
        return NULL;
    }
    result = Product_createPixelInfoString((Product) thisObj, pixelX, pixelY);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getRemovedChildNodes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    ProductNode* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getRemovedChildNodes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getRemovedChildNodes((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("ProductNode", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_canBeOrthorectified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Product_canBeOrthorectified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_canBeOrthorectified((Product) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getPreferredTileSize(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getPreferredTileSize", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getPreferredTileSize((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Dimension", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setPreferredTileSize(PyObject* self, PyObject* args)
{
    int tileWidth;
    int tileHeight;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii:Product_setPreferredTileSize", &thisObjType, &thisObj, &tileWidth, &tileHeight)) {
        return NULL;
    }
    Product_setPreferredTileSize((Product) thisObj, tileWidth, tileHeight);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getAllFlagNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):Product_getAllFlagNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getAllFlagNames((Product) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getAutoGrouping(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getAutoGrouping", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getAutoGrouping((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product_AutoGrouping", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setAutoGrouping(PyObject* self, PyObject* args)
{
    const char* pattern;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_setAutoGrouping", &thisObjType, &thisObj, &pattern)) {
        return NULL;
    }
    Product_setAutoGrouping((Product) thisObj, pattern);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_addComputedMask(PyObject* self, PyObject* args)
{
    const char* maskName;
    const char* expression;
    const char* description;
    const char* colorType;
    unsigned PY_LONG_LONG color;
    double transparency;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sss(sK)d:Product_addComputedMask", &thisObjType, &thisObj, &maskName, &expression, &description, &colorType, &color, &transparency)) {
        return NULL;
    }
    result = Product_addComputedMask((Product) thisObj, maskName, expression, description, (Color) color, transparency);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Mask", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getOwner((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getName((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    Product_setName((Product) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getDescription((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Product_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    Product_setDescription((Product) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Product_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_isModified((Product) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_toString((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:Product_isValidNodeName", &name)) {
        return NULL;
    }
    result = Product_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProduct_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProduct((Product) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getDisplayName((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Product_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Product_getProductRefString((Product) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProduct_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:Product_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    Product_updateExpression((Product) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyProduct_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Product_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    Product_removeFromFile((Product) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromRange(PyObject* self, PyObject* args)
{
    double minSample;
    double maxSample;
    void* result;
    if (!PyArg_ParseTuple(args, "dd:ColorPaletteDef_newColorPaletteDefFromRange", &minSample, &maxSample)) {
        return NULL;
    }
    result = ColorPaletteDef_newColorPaletteDefFromRange(minSample, maxSample);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_newColorPaletteDefFromPoints(PyObject* self, PyObject* args)
{
    ColorPaletteDef_Point points;
    int pointsLength;
    PyObject* pointsSeq;
    int numColors;
    void* result;
    if (!PyArg_ParseTuple(args, "Oi:ColorPaletteDef_newColorPaletteDefFromPoints", &pointsSeq, &numColors)) {
        return NULL;
    }
    points = beam_new_jobject_array_from_pyseq("ColorPaletteDef_Point", pointsSeq, &pointsLength);
    result = ColorPaletteDef_newColorPaletteDefFromPoints(points, pointsLength, numColors);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_isDiscrete(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_isDiscrete", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_isDiscrete((ColorPaletteDef) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyColorPaletteDef_setDiscrete(PyObject* self, PyObject* args)
{
    boolean discrete;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ColorPaletteDef_setDiscrete", &thisObjType, &thisObj, &discrete)) {
        return NULL;
    }
    ColorPaletteDef_setDiscrete((ColorPaletteDef) thisObj, discrete);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumColors(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getNumColors", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getNumColors((ColorPaletteDef) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyColorPaletteDef_setNumColors(PyObject* self, PyObject* args)
{
    int numColors;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:ColorPaletteDef_setNumColors", &thisObjType, &thisObj, &numColors)) {
        return NULL;
    }
    ColorPaletteDef_setNumColors((ColorPaletteDef) thisObj, numColors);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getNumPoints(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getNumPoints", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getNumPoints((ColorPaletteDef) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyColorPaletteDef_setNumPoints(PyObject* self, PyObject* args)
{
    int numPoints;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:ColorPaletteDef_setNumPoints", &thisObjType, &thisObj, &numPoints)) {
        return NULL;
    }
    ColorPaletteDef_setNumPoints((ColorPaletteDef) thisObj, numPoints);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_isAutoDistribute(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_isAutoDistribute", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_isAutoDistribute((ColorPaletteDef) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyColorPaletteDef_setAutoDistribute(PyObject* self, PyObject* args)
{
    boolean autoDistribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ColorPaletteDef_setAutoDistribute", &thisObjType, &thisObj, &autoDistribute)) {
        return NULL;
    }
    ColorPaletteDef_setAutoDistribute((ColorPaletteDef) thisObj, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPointAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:ColorPaletteDef_getPointAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ColorPaletteDef_getPointAt((ColorPaletteDef) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef_Point", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_getFirstPoint(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getFirstPoint", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getFirstPoint((ColorPaletteDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef_Point", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_getLastPoint(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getLastPoint", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getLastPoint((ColorPaletteDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef_Point", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getMinDisplaySample", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getMinDisplaySample((ColorPaletteDef) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyColorPaletteDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getMaxDisplaySample", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getMaxDisplaySample((ColorPaletteDef) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyColorPaletteDef_insertPointAfter(PyObject* self, PyObject* args)
{
    int index;
    const char* pointType;
    unsigned PY_LONG_LONG point;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):ColorPaletteDef_insertPointAfter", &thisObjType, &thisObj, &index, &pointType, &point)) {
        return NULL;
    }
    ColorPaletteDef_insertPointAfter((ColorPaletteDef) thisObj, index, (ColorPaletteDef_Point) point);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_createPointAfter(PyObject* self, PyObject* args)
{
    int index;
    const char* scalingType;
    unsigned PY_LONG_LONG scaling;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):ColorPaletteDef_createPointAfter", &thisObjType, &thisObj, &index, &scalingType, &scaling)) {
        return NULL;
    }
    result = ColorPaletteDef_createPointAfter((ColorPaletteDef) thisObj, index, (Scaling) scaling);
    return PyBool_FromLong(result);
}

PyObject* BeamPyColorPaletteDef_getCenterColor(PyObject* self, PyObject* args)
{
    const char* c1Type;
    unsigned PY_LONG_LONG c1;
    const char* c2Type;
    unsigned PY_LONG_LONG c2;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ColorPaletteDef_getCenterColor", &c1Type, &c1, &c2Type, &c2)) {
        return NULL;
    }
    result = ColorPaletteDef_getCenterColor((Color) c1, (Color) c2);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Color", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_removePointAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:ColorPaletteDef_removePointAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    ColorPaletteDef_removePointAt((ColorPaletteDef) thisObj, index);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_addPoint(PyObject* self, PyObject* args)
{
    const char* pointType;
    unsigned PY_LONG_LONG point;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ColorPaletteDef_addPoint", &thisObjType, &thisObj, &pointType, &point)) {
        return NULL;
    }
    ColorPaletteDef_addPoint((ColorPaletteDef) thisObj, (ColorPaletteDef_Point) point);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getPoints(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    ColorPaletteDef_Point* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getPoints", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getPoints((ColorPaletteDef) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("ColorPaletteDef_Point", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_setPoints(PyObject* self, PyObject* args)
{
    ColorPaletteDef_Point points;
    int pointsLength;
    PyObject* pointsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)O:ColorPaletteDef_setPoints", &thisObjType, &thisObj, &pointsSeq)) {
        return NULL;
    }
    points = beam_new_jobject_array_from_pyseq("ColorPaletteDef_Point", pointsSeq, &pointsLength);
    ColorPaletteDef_setPoints((ColorPaletteDef) thisObj, points, pointsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getIterator(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getIterator", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getIterator((ColorPaletteDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Iterator", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_clone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_clone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_clone((ColorPaletteDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_createDeepCopy(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_createDeepCopy", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_createDeepCopy((ColorPaletteDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_loadColorPaletteDef(PyObject* self, PyObject* args)
{
    const char* fileType;
    unsigned PY_LONG_LONG file;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_loadColorPaletteDef", &fileType, &file)) {
        return NULL;
    }
    result = ColorPaletteDef_loadColorPaletteDef((File) file);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_storeColorPaletteDef(PyObject* self, PyObject* args)
{
    const char* colorPaletteDefType;
    unsigned PY_LONG_LONG colorPaletteDef;
    const char* fileType;
    unsigned PY_LONG_LONG file;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ColorPaletteDef_storeColorPaletteDef", &colorPaletteDefType, &colorPaletteDef, &fileType, &file)) {
        return NULL;
    }
    ColorPaletteDef_storeColorPaletteDef((ColorPaletteDef) colorPaletteDef, (File) file);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    ColorPaletteDef_dispose((ColorPaletteDef) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyColorPaletteDef_getColors(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    Color* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ColorPaletteDef_getColors", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ColorPaletteDef_getColors((ColorPaletteDef) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Color", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_createColorPalette(PyObject* self, PyObject* args)
{
    const char* scalingType;
    unsigned PY_LONG_LONG scaling;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    Color* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ColorPaletteDef_createColorPalette", &thisObjType, &thisObj, &scalingType, &scaling)) {
        return NULL;
    }
    result = ColorPaletteDef_createColorPalette((ColorPaletteDef) thisObj, (Scaling) scaling, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Color", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyColorPaletteDef_computeColor(PyObject* self, PyObject* args)
{
    const char* scalingType;
    unsigned PY_LONG_LONG scaling;
    double sample;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)d:ColorPaletteDef_computeColor", &thisObjType, &thisObj, &scalingType, &scaling, &sample)) {
        return NULL;
    }
    result = ColorPaletteDef_computeColor((ColorPaletteDef) thisObj, (Scaling) scaling, sample);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Color", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_newImageInfoPalette(PyObject* self, PyObject* args)
{
    const char* colorPaletteDefType;
    unsigned PY_LONG_LONG colorPaletteDef;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_newImageInfoPalette", &colorPaletteDefType, &colorPaletteDef)) {
        return NULL;
    }
    result = ImageInfo_newImageInfoPalette((ColorPaletteDef) colorPaletteDef);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_newImageInfoRGB(PyObject* self, PyObject* args)
{
    const char* rgbChannelDefType;
    unsigned PY_LONG_LONG rgbChannelDef;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_newImageInfoRGB", &rgbChannelDefType, &rgbChannelDef)) {
        return NULL;
    }
    result = ImageInfo_newImageInfoRGB((RGBChannelDef) rgbChannelDef);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_getColorPaletteDef(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_getColorPaletteDef", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_getColorPaletteDef((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ColorPaletteDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_getRgbChannelDef(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_getRgbChannelDef", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_getRgbChannelDef((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "RGBChannelDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_getNoDataColor(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_getNoDataColor", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_getNoDataColor((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Color", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_setNoDataColor(PyObject* self, PyObject* args)
{
    const char* noDataColorType;
    unsigned PY_LONG_LONG noDataColor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ImageInfo_setNoDataColor", &thisObjType, &thisObj, &noDataColorType, &noDataColor)) {
        return NULL;
    }
    ImageInfo_setNoDataColor((ImageInfo) thisObj, (Color) noDataColor);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setHistogramMatching(PyObject* self, PyObject* args)
{
    const char* histogramMatchingType;
    unsigned PY_LONG_LONG histogramMatching;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ImageInfo_setHistogramMatching", &thisObjType, &thisObj, &histogramMatchingType, &histogramMatching)) {
        return NULL;
    }
    ImageInfo_setHistogramMatching((ImageInfo) thisObj, (ImageInfo_HistogramMatching) histogramMatching);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_isLogScaled(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_isLogScaled", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_isLogScaled((ImageInfo) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyImageInfo_setLogScaled(PyObject* self, PyObject* args)
{
    boolean logScaled;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ImageInfo_setLogScaled", &thisObjType, &thisObj, &logScaled)) {
        return NULL;
    }
    ImageInfo_setLogScaled((ImageInfo) thisObj, logScaled);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getColors(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    Color* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_getColors", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_getColors((ImageInfo) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Color", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_getColorComponentCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_getColorComponentCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_getColorComponentCount((ImageInfo) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyImageInfo_createIndexColorModel(PyObject* self, PyObject* args)
{
    const char* scalingType;
    unsigned PY_LONG_LONG scaling;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ImageInfo_createIndexColorModel", &thisObjType, &thisObj, &scalingType, &scaling)) {
        return NULL;
    }
    result = ImageInfo_createIndexColorModel((ImageInfo) thisObj, (Scaling) scaling);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexColorModel", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_createComponentColorModel(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_createComponentColorModel", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_createComponentColorModel((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ComponentColorModel", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_clone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_clone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_clone((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_createDeepCopy(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_createDeepCopy", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageInfo_createDeepCopy((ImageInfo) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageInfo_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ImageInfo_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    ImageInfo_dispose((ImageInfo) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColors(PyObject* self, PyObject* args)
{
    Color colors;
    int colorsLength;
    PyObject* colorsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)O:ImageInfo_setColors", &thisObjType, &thisObj, &colorsSeq)) {
        return NULL;
    }
    colors = beam_new_jobject_array_from_pyseq("Color", colorsSeq, &colorsLength);
    ImageInfo_setColors((ImageInfo) thisObj, colors, colorsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_setColorPaletteDef(PyObject* self, PyObject* args)
{
    const char* colorPaletteDefType;
    unsigned PY_LONG_LONG colorPaletteDef;
    double minSample;
    double maxSample;
    boolean autoDistribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ddp:ImageInfo_setColorPaletteDef", &thisObjType, &thisObj, &colorPaletteDefType, &colorPaletteDef, &minSample, &maxSample, &autoDistribute)) {
        return NULL;
    }
    ImageInfo_setColorPaletteDef((ImageInfo) thisObj, (ColorPaletteDef) colorPaletteDef, minSample, maxSample, autoDistribute);
    return Py_BuildValue("");
}

PyObject* BeamPyImageInfo_getHistogramMatching(PyObject* self, PyObject* args)
{
    const char* mode;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ImageInfo_getHistogramMatching", &mode)) {
        return NULL;
    }
    result = ImageInfo_getHistogramMatching(mode);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo_HistogramMatching", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_newProductManager(PyObject* self, PyObject* args)
{
    void* result;
    result = ProductManager_newProductManager();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductManager", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductManager_getProductCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductManager_getProductCount((ProductManager) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductManager_getProduct(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductManager_getProduct", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductManager_getProduct((ProductManager) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductDisplayNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductManager_getProductDisplayNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductManager_getProductDisplayNames((ProductManager) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductManager_getProductNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductManager_getProductNames((ProductManager) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProducts(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    Product* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductManager_getProducts", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductManager_getProducts((ProductManager) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Product", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductByDisplayName(PyObject* self, PyObject* args)
{
    const char* displayName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductManager_getProductByDisplayName", &thisObjType, &thisObj, &displayName)) {
        return NULL;
    }
    result = ProductManager_getProductByDisplayName((ProductManager) thisObj, displayName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductByRefNo(PyObject* self, PyObject* args)
{
    int refNo;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductManager_getProductByRefNo", &thisObjType, &thisObj, &refNo)) {
        return NULL;
    }
    result = ProductManager_getProductByRefNo((ProductManager) thisObj, refNo);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductByName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductManager_getProductByName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = ProductManager_getProductByName((ProductManager) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductManager_getProductIndex(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_getProductIndex", &thisObjType, &thisObj, &productType, &product)) {
        return NULL;
    }
    result = ProductManager_getProductIndex((ProductManager) thisObj, (Product) product);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductManager_containsProduct(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductManager_containsProduct", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = ProductManager_containsProduct((ProductManager) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductManager_contains(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_contains", &thisObjType, &thisObj, &productType, &product)) {
        return NULL;
    }
    result = ProductManager_contains((ProductManager) thisObj, (Product) product);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductManager_addProduct(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_addProduct", &thisObjType, &thisObj, &productType, &product)) {
        return NULL;
    }
    ProductManager_addProduct((ProductManager) thisObj, (Product) product);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_removeProduct(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_removeProduct", &thisObjType, &thisObj, &productType, &product)) {
        return NULL;
    }
    result = ProductManager_removeProduct((ProductManager) thisObj, (Product) product);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductManager_removeAllProducts(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductManager_removeAllProducts", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductManager_removeAllProducts((ProductManager) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductManager_addListener(PyObject* self, PyObject* args)
{
    const char* listenerType;
    unsigned PY_LONG_LONG listener;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_addListener", &thisObjType, &thisObj, &listenerType, &listener)) {
        return NULL;
    }
    result = ProductManager_addListener((ProductManager) thisObj, (ProductManager_Listener) listener);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductManager_removeListener(PyObject* self, PyObject* args)
{
    const char* listenerType;
    unsigned PY_LONG_LONG listener;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductManager_removeListener", &thisObjType, &thisObj, &listenerType, &listener)) {
        return NULL;
    }
    result = ProductManager_removeListener((ProductManager) thisObj, (ProductManager_Listener) listener);
    return PyBool_FromLong(result);
}

PyObject* BeamPyImageGeometry_newImageGeometry(PyObject* self, PyObject* args)
{
    const char* boundsType;
    unsigned PY_LONG_LONG bounds;
    const char* mapCrsType;
    unsigned PY_LONG_LONG mapCrs;
    const char* image2mapType;
    unsigned PY_LONG_LONG image2map;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ImageGeometry_newImageGeometry", &boundsType, &bounds, &mapCrsType, &mapCrs, &image2mapType, &image2map)) {
        return NULL;
    }
    result = ImageGeometry_newImageGeometry((Rectangle) bounds, (CoordinateReferenceSystem) mapCrs, (AffineTransform) image2map);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageGeometry", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_getImage2MapTransform(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageGeometry_getImage2MapTransform", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageGeometry_getImage2MapTransform((ImageGeometry) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "AffineTransform", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_getImageRect(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageGeometry_getImageRect", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageGeometry_getImageRect((ImageGeometry) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Rectangle", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_getMapCrs(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageGeometry_getMapCrs", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ImageGeometry_getMapCrs((ImageGeometry) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "CoordinateReferenceSystem", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_changeYAxisDirection(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ImageGeometry_changeYAxisDirection", &thisObjType, &thisObj)) {
        return NULL;
    }
    ImageGeometry_changeYAxisDirection((ImageGeometry) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyImageGeometry_calculateEastingNorthing(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetCrsType;
    unsigned PY_LONG_LONG targetCrs;
    double referencePixelX;
    double referencePixelY;
    double pixelSizeX;
    double pixelSizeY;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)dddd:ImageGeometry_calculateEastingNorthing", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &referencePixelX, &referencePixelY, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    result = ImageGeometry_calculateEastingNorthing((Product) sourceProduct, (CoordinateReferenceSystem) targetCrs, referencePixelX, referencePixelY, pixelSizeX, pixelSizeY);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Point2D", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_calculateProductSize(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetCrsType;
    unsigned PY_LONG_LONG targetCrs;
    double pixelSizeX;
    double pixelSizeY;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)dd:ImageGeometry_calculateProductSize", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    result = ImageGeometry_calculateProductSize((Product) sourceProduct, (CoordinateReferenceSystem) targetCrs, pixelSizeX, pixelSizeY);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Rectangle", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_createTargetGeometry(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetCrsType;
    unsigned PY_LONG_LONG targetCrs;
    const char* pixelSizeXType;
    unsigned PY_LONG_LONG pixelSizeX;
    const char* pixelSizeYType;
    unsigned PY_LONG_LONG pixelSizeY;
    const char* widthType;
    unsigned PY_LONG_LONG width;
    const char* heightType;
    unsigned PY_LONG_LONG height;
    const char* orientationType;
    unsigned PY_LONG_LONG orientation;
    const char* eastingType;
    unsigned PY_LONG_LONG easting;
    const char* northingType;
    unsigned PY_LONG_LONG northing;
    const char* referencePixelXType;
    unsigned PY_LONG_LONG referencePixelX;
    const char* referencePixelYType;
    unsigned PY_LONG_LONG referencePixelY;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK)(sK):ImageGeometry_createTargetGeometry", &sourceProductType, &sourceProduct, &targetCrsType, &targetCrs, &pixelSizeXType, &pixelSizeX, &pixelSizeYType, &pixelSizeY, &widthType, &width, &heightType, &height, &orientationType, &orientation, &eastingType, &easting, &northingType, &northing, &referencePixelXType, &referencePixelX, &referencePixelYType, &referencePixelY)) {
        return NULL;
    }
    result = ImageGeometry_createTargetGeometry((Product) sourceProduct, (CoordinateReferenceSystem) targetCrs, (Double) pixelSizeX, (Double) pixelSizeY, (Integer) width, (Integer) height, (Double) orientation, (Double) easting, (Double) northing, (Double) referencePixelX, (Double) referencePixelY);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageGeometry", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_createCollocationTargetGeometry(PyObject* self, PyObject* args)
{
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    const char* collocationProductType;
    unsigned PY_LONG_LONG collocationProduct;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ImageGeometry_createCollocationTargetGeometry", &targetProductType, &targetProduct, &collocationProductType, &collocationProduct)) {
        return NULL;
    }
    result = ImageGeometry_createCollocationTargetGeometry((Product) targetProduct, (Product) collocationProduct);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageGeometry", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyImageGeometry_createValidRect(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ImageGeometry_createValidRect", &productType, &product)) {
        return NULL;
    }
    result = ImageGeometry_createValidRect((Product) product);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Rectangle2D", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_newBand(PyObject* self, PyObject* args)
{
    const char* name;
    int dataType;
    int width;
    int height;
    void* result;
    if (!PyArg_ParseTuple(args, "siii:Band_newBand", &name, &dataType, &width, &height)) {
        return NULL;
    }
    result = Band_newBand(name, dataType, width, height);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getFlagCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getFlagCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getFlagCoding((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "FlagCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isFlagBand(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isFlagBand", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isFlagBand((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getIndexCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getIndexCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getIndexCoding((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isIndexBand(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isIndexBand", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isIndexBand((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getSampleCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSampleCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSampleCoding((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "SampleCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setSampleCoding(PyObject* self, PyObject* args)
{
    const char* sampleCodingType;
    unsigned PY_LONG_LONG sampleCoding;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setSampleCoding", &thisObjType, &thisObj, &sampleCodingType, &sampleCoding)) {
        return NULL;
    }
    Band_setSampleCoding((Band) thisObj, (SampleCoding) sampleCoding);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandIndex(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSpectralBandIndex", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSpectralBandIndex((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_setSpectralBandIndex(PyObject* self, PyObject* args)
{
    int spectralBandIndex;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:Band_setSpectralBandIndex", &thisObjType, &thisObj, &spectralBandIndex)) {
        return NULL;
    }
    Band_setSpectralBandIndex((Band) thisObj, spectralBandIndex);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralWavelength(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSpectralWavelength", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSpectralWavelength((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setSpectralWavelength(PyObject* self, PyObject* args)
{
    float spectralWavelength;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)f:Band_setSpectralWavelength", &thisObjType, &thisObj, &spectralWavelength)) {
        return NULL;
    }
    Band_setSpectralWavelength((Band) thisObj, spectralWavelength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSpectralBandwidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSpectralBandwidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSpectralBandwidth((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setSpectralBandwidth(PyObject* self, PyObject* args)
{
    float spectralBandwidth;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)f:Band_setSpectralBandwidth", &thisObjType, &thisObj, &spectralBandwidth)) {
        return NULL;
    }
    Band_setSpectralBandwidth((Band) thisObj, spectralBandwidth);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSolarFlux(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSolarFlux", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSolarFlux((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setSolarFlux(PyObject* self, PyObject* args)
{
    float solarFlux;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)f:Band_setSolarFlux", &thisObjType, &thisObj, &solarFlux)) {
        return NULL;
    }
    Band_setSolarFlux((Band) thisObj, solarFlux);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    Band_acceptVisitor((Band) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_toString((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    Band_removeFromFile((Band) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_dispose((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getSceneRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSceneRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSceneRasterData((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getPixelInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getPixelInt", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getPixelInt((Band) thisObj, x, y);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getPixelFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getPixelFloat", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getPixelFloat((Band) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_getPixelDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getPixelDouble", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getPixelDouble((Band) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setPixelInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iii:Band_setPixelInt", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    Band_setPixelInt((Band) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    float pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iif:Band_setPixelFloat", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    Band_setPixelFloat((Band) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    double pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iid:Band_setPixelDouble", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    Band_setPixelDouble((Band) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_setPixelsInt", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_setPixelsInt((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_setPixelsFloat", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_setPixelsFloat((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_setPixelsDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_setPixelsDouble", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_setPixelsDouble((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_ensureRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_ensureRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_ensureRasterData((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_unloadRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_unloadRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_unloadRasterData((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getViewModeId(PyObject* self, PyObject* args)
{
    const char* bandName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)s:Band_getViewModeId", &thisObjType, &thisObj, &bandName)) {
        return NULL;
    }
    result = Band_getViewModeId((Band) thisObj, bandName);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSceneRasterWidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSceneRasterWidth((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSceneRasterHeight", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSceneRasterHeight((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getRasterWidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getRasterWidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getRasterWidth((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getRasterHeight(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getRasterHeight", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getRasterHeight((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Band_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    Band_setModified((Band) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeoCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getGeoCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getGeoCoding((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setGeoCoding(PyObject* self, PyObject* args)
{
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setGeoCoding", &thisObjType, &thisObj, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    Band_setGeoCoding((Band) thisObj, (GeoCoding) geoCoding);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getPointing(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getPointing", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getPointing((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Pointing", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_canBeOrthorectified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_canBeOrthorectified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_canBeOrthorectified((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_isFloatingPointType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isFloatingPointType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isFloatingPointType((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getGeophysicalDataType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getGeophysicalDataType((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getScalingFactor(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getScalingFactor", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getScalingFactor((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setScalingFactor(PyObject* self, PyObject* args)
{
    double scalingFactor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_setScalingFactor", &thisObjType, &thisObj, &scalingFactor)) {
        return NULL;
    }
    Band_setScalingFactor((Band) thisObj, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getScalingOffset(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getScalingOffset", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getScalingOffset((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setScalingOffset(PyObject* self, PyObject* args)
{
    double scalingOffset;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_setScalingOffset", &thisObjType, &thisObj, &scalingOffset)) {
        return NULL;
    }
    Band_setScalingOffset((Band) thisObj, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isLog10Scaled(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isLog10Scaled", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isLog10Scaled((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_setLog10Scaled(PyObject* self, PyObject* args)
{
    boolean log10Scaled;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Band_setLog10Scaled", &thisObjType, &thisObj, &log10Scaled)) {
        return NULL;
    }
    Band_setLog10Scaled((Band) thisObj, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isScalingApplied(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isScalingApplied", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isScalingApplied((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_isValidMaskProperty(PyObject* self, PyObject* args)
{
    const char* propertyName;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:Band_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    result = Band_isValidMaskProperty(propertyName);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_isNoDataValueSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isNoDataValueSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isNoDataValueSet((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_clearNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_clearNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_clearNoDataValue((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isNoDataValueUsed", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isNoDataValueUsed((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    boolean noDataValueUsed;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Band_setNoDataValueUsed", &thisObjType, &thisObj, &noDataValueUsed)) {
        return NULL;
    }
    Band_setNoDataValueUsed((Band) thisObj, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getNoDataValue((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setNoDataValue(PyObject* self, PyObject* args)
{
    double noDataValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_setNoDataValue", &thisObjType, &thisObj, &noDataValue)) {
        return NULL;
    }
    Band_setNoDataValue((Band) thisObj, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getGeophysicalNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getGeophysicalNoDataValue((Band) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    double noDataValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_setGeophysicalNoDataValue", &thisObjType, &thisObj, &noDataValue)) {
        return NULL;
    }
    Band_setGeophysicalNoDataValue((Band) thisObj, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidPixelExpression(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getValidPixelExpression", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getValidPixelExpression((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setValidPixelExpression(PyObject* self, PyObject* args)
{
    const char* validPixelExpression;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Band_setValidPixelExpression", &thisObjType, &thisObj, &validPixelExpression)) {
        return NULL;
    }
    Band_setValidPixelExpression((Band) thisObj, validPixelExpression);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isValidMaskUsed(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isValidMaskUsed", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isValidMaskUsed((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_resetValidMask(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_resetValidMask", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_resetValidMask((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidMaskExpression(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getValidMaskExpression", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getValidMaskExpression((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:Band_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    Band_updateExpression((Band) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_hasRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_hasRasterData((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getRasterData((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData)) {
        return NULL;
    }
    Band_setRasterData((Band) thisObj, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_loadRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_loadRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_loadRasterData((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isPixelValid(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_isPixelValid", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_isPixelValid((Band) thisObj, x, y);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getSampleInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getSampleInt", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getSampleInt((Band) thisObj, x, y);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getSampleFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getSampleFloat", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getSampleFloat((Band) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_getPixelsInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_getPixelsInt", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_getPixelsInt((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getPixelsFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_getPixelsFloat", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_getPixelsFloat((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getPixelsDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_getPixelsDouble", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_getPixelsDouble((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_readPixelsInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_readPixelsInt", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_readPixelsInt((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_readPixelsFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_readPixelsFloat", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_readPixelsFloat((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_readPixelsDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_readPixelsDouble", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = Band_readPixelsDouble((Band) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_writePixelsInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_writePixelsInt", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_writePixelsInt((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_writePixelsFloat", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_writePixelsFloat((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writePixelsDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_writePixelsDouble", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    Band_writePixelsDouble((Band) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_readValidMask(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    boolean* validMask;
    int validMaskLength;
    PyObject* validMaskSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:Band_readValidMask", &thisObjType, &thisObj, &x, &y, &w, &h, &validMaskSeq)) {
        return NULL;
    }
    validMask = beam_new_boolean_array_from_pyseq(validMaskSeq, &validMaskLength);
    result = Band_readValidMask((Band) thisObj, x, y, w, h, validMask, validMaskLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_boolean_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_readRasterDataFully(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_readRasterDataFully", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_readRasterDataFully((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_readRasterData(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):Band_readRasterData", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    Band_readRasterData((Band) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writeRasterDataFully(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_writeRasterDataFully", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_writeRasterDataFully((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_writeRasterData(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):Band_writeRasterData", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    Band_writeRasterData((Band) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_createCompatibleRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_createCompatibleRasterData((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_createCompatibleSceneRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_createCompatibleSceneRasterData((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_createCompatibleRasterDataForRect(PyObject* self, PyObject* args)
{
    int width;
    int height;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_createCompatibleRasterDataForRect", &thisObjType, &thisObj, &width, &height)) {
        return NULL;
    }
    result = Band_createCompatibleRasterDataForRect((Band) thisObj, width, height);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    int w;
    int h;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:Band_isCompatibleRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    result = Band_isCompatibleRasterData((Band) thisObj, (ProductData) rasterData, w, h);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    int w;
    int h;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:Band_checkCompatibleRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    Band_checkCompatibleRasterData((Band) thisObj, (ProductData) rasterData, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_hasIntPixels(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_hasIntPixels", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_hasIntPixels((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_createTransectProfileData(PyObject* self, PyObject* args)
{
    const char* shapeType;
    unsigned PY_LONG_LONG shape;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_createTransectProfileData", &thisObjType, &thisObj, &shapeType, &shape)) {
        return NULL;
    }
    result = Band_createTransectProfileData((Band) thisObj, (Shape) shape);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TransectProfileData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getImageInfo(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getImageInfo", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getImageInfo((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setImageInfo(PyObject* self, PyObject* args)
{
    const char* imageInfoType;
    unsigned PY_LONG_LONG imageInfo;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setImageInfo", &thisObjType, &thisObj, &imageInfoType, &imageInfo)) {
        return NULL;
    }
    Band_setImageInfo((Band) thisObj, (ImageInfo) imageInfo);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_fireImageInfoChanged", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_fireImageInfoChanged((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createDefaultImageInfo(PyObject* self, PyObject* args)
{
    double* histoSkipAreas;
    int histoSkipAreasLength;
    PyObject* histoSkipAreasSeq;
    const char* histogramType;
    unsigned PY_LONG_LONG histogram;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)O(sK):Band_createDefaultImageInfo", &thisObjType, &thisObj, &histoSkipAreasSeq, &histogramType, &histogram)) {
        return NULL;
    }
    histoSkipAreas = beam_new_double_array_from_pyseq(histoSkipAreasSeq, &histoSkipAreasLength);
    result = Band_createDefaultImageInfo((Band) thisObj, histoSkipAreas, histoSkipAreasLength, (Histogram) histogram);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getOverlayMaskGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getOverlayMaskGroup((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_createColorIndexedImage(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_createColorIndexedImage", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    result = Band_createColorIndexedImage((Band) thisObj, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_createRgbImage(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_createRgbImage", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    result = Band_createRgbImage((Band) thisObj, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_createPixelValidator(PyObject* self, PyObject* args)
{
    int lineOffset;
    const char* roiType;
    unsigned PY_LONG_LONG roi;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):Band_createPixelValidator", &thisObjType, &thisObj, &lineOffset, &roiType, &roi)) {
        return NULL;
    }
    result = Band_createPixelValidator((Band) thisObj, lineOffset, (ROI) roi);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexValidator", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_scale(PyObject* self, PyObject* args)
{
    double v;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_scale", &thisObjType, &thisObj, &v)) {
        return NULL;
    }
    result = Band_scale((Band) thisObj, v);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_scaleInverse(PyObject* self, PyObject* args)
{
    double v;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)d:Band_scaleInverse", &thisObjType, &thisObj, &v)) {
        return NULL;
    }
    result = Band_scaleInverse((Band) thisObj, v);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyBand_getPixelString(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ii:Band_getPixelString", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = Band_getPixelString((Band) thisObj, x, y);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isSourceImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isSourceImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isSourceImageSet((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getSourceImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getSourceImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getSourceImage((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isGeophysicalImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isGeophysicalImageSet((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getGeophysicalImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getGeophysicalImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getGeophysicalImage((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isValidMaskImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isValidMaskImageSet((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getValidMaskImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getValidMaskImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getValidMaskImage((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_isStxSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isStxSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isStxSet((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getStx(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getStx", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getStx((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Stx", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setStx(PyObject* self, PyObject* args)
{
    const char* stxType;
    unsigned PY_LONG_LONG stx;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setStx", &thisObjType, &thisObj, &stxType, &stx)) {
        return NULL;
    }
    Band_setStx((Band) thisObj, (Stx) stx);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getValidShape(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getValidShape", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getValidShape((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Shape", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getDataType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getDataType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getDataType((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_getNumDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getNumDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getNumDataElems((Band) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyBand_setData(PyObject* self, PyObject* args)
{
    const char* dataType;
    unsigned PY_LONG_LONG data;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):Band_setData", &thisObjType, &thisObj, &dataType, &data)) {
        return NULL;
    }
    Band_setData((Band) thisObj, (ProductData) data);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getData((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getDataElems((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getDataElemSize(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getDataElemSize", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getDataElemSize((Band) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyBand_setReadOnly(PyObject* self, PyObject* args)
{
    boolean readOnly;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:Band_setReadOnly", &thisObjType, &thisObj, &readOnly)) {
        return NULL;
    }
    Band_setReadOnly((Band) thisObj, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isReadOnly(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isReadOnly", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isReadOnly((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_setUnit(PyObject* self, PyObject* args)
{
    const char* unit;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Band_setUnit", &thisObjType, &thisObj, &unit)) {
        return NULL;
    }
    Band_setUnit((Band) thisObj, unit);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getUnit(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getUnit", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getUnit((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):Band_fireProductNodeDataChanged", &thisObjType, &thisObj)) {
        return NULL;
    }
    Band_fireProductNodeDataChanged((Band) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_createCompatibleProductData(PyObject* self, PyObject* args)
{
    int numElems;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:Band_createCompatibleProductData", &thisObjType, &thisObj, &numElems)) {
        return NULL;
    }
    result = Band_createCompatibleProductData((Band) thisObj, numElems);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getOwner((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getName((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Band_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    Band_setName((Band) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getDescription((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:Band_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    Band_setDescription((Band) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyBand_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):Band_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_isModified((Band) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:Band_isValidNodeName", &name)) {
        return NULL;
    }
    result = Band_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyBand_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getProduct((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getProductReader((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):Band_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getProductWriter((Band) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getDisplayName((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyBand_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):Band_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = Band_getProductRefString((Band) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getVectorDataNode(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getVectorDataNode", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getVectorDataNode((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "VectorDataNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getPlacemark(PyObject* self, PyObject* args)
{
    const char* featureType;
    unsigned PY_LONG_LONG feature;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_getPlacemark", &thisObjType, &thisObj, &featureType, &feature)) {
        return NULL;
    }
    result = PlacemarkGroup_getPlacemark((PlacemarkGroup) thisObj, (SimpleFeature) feature);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Placemark", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_add4(PyObject* self, PyObject* args)
{
    const char* placemarkType;
    unsigned PY_LONG_LONG placemark;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_add4", &thisObjType, &thisObj, &placemarkType, &placemark)) {
        return NULL;
    }
    result = PlacemarkGroup_add4((PlacemarkGroup) thisObj, (Placemark) placemark);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_add2(PyObject* self, PyObject* args)
{
    int index;
    const char* placemarkType;
    unsigned PY_LONG_LONG placemark;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):PlacemarkGroup_add2", &thisObjType, &thisObj, &index, &placemarkType, &placemark)) {
        return NULL;
    }
    PlacemarkGroup_add2((PlacemarkGroup) thisObj, index, (Placemark) placemark);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove2(PyObject* self, PyObject* args)
{
    const char* placemarkType;
    unsigned PY_LONG_LONG placemark;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_remove2", &thisObjType, &thisObj, &placemarkType, &placemark)) {
        return NULL;
    }
    result = PlacemarkGroup_remove2((PlacemarkGroup) thisObj, (Placemark) placemark);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    PlacemarkGroup_dispose((PlacemarkGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_isTakingOverNodeOwnership", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_isTakingOverNodeOwnership((PlacemarkGroup) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_getNodeCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getNodeCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getNodeCount((PlacemarkGroup) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_get1(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:PlacemarkGroup_get1", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = PlacemarkGroup_get1((PlacemarkGroup) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getNodeDisplayNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getNodeDisplayNames((PlacemarkGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getNodeNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getNodeNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getNodeNames((PlacemarkGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_toArray1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    ProductNode* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_toArray1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_toArray1((PlacemarkGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("ProductNode", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_toArray2(PyObject* self, PyObject* args)
{
    T array;
    int arrayLength;
    PyObject* arraySeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    T* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)O:PlacemarkGroup_toArray2", &thisObjType, &thisObj, &arraySeq)) {
        return NULL;
    }
    array = beam_new_jobject_array_from_pyseq("T", arraySeq, &arrayLength);
    result = PlacemarkGroup_toArray2((PlacemarkGroup) thisObj, array, arrayLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("T", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_indexOf2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_indexOf2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = PlacemarkGroup_indexOf2((PlacemarkGroup) thisObj, name);
    return PyLong_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_indexOf1(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_indexOf1", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = PlacemarkGroup_indexOf1((PlacemarkGroup) thisObj, (T) element);
    return PyLong_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    const char* displayName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_getByDisplayName", &thisObjType, &thisObj, &displayName)) {
        return NULL;
    }
    result = PlacemarkGroup_getByDisplayName((PlacemarkGroup) thisObj, displayName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_get2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_get2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = PlacemarkGroup_get2((PlacemarkGroup) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_contains2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_contains2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = PlacemarkGroup_contains2((PlacemarkGroup) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_contains1(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_contains1", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = PlacemarkGroup_contains1((PlacemarkGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_add3(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_add3", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = PlacemarkGroup_add3((PlacemarkGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_add1(PyObject* self, PyObject* args)
{
    int index;
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):PlacemarkGroup_add1", &thisObjType, &thisObj, &index, &nodeType, &node)) {
        return NULL;
    }
    PlacemarkGroup_add1((PlacemarkGroup) thisObj, index, (T) node);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_remove1(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_remove1", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = PlacemarkGroup_remove1((PlacemarkGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_removeAll(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_removeAll", &thisObjType, &thisObj)) {
        return NULL;
    }
    PlacemarkGroup_removeAll((PlacemarkGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_clearRemovedList", &thisObjType, &thisObj)) {
        return NULL;
    }
    PlacemarkGroup_clearRemovedList((PlacemarkGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getRemovedNodes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getRemovedNodes((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Collection", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize2(PyObject* self, PyObject* args)
{
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_getRawStorageSize2", &thisObjType, &thisObj, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = PlacemarkGroup_getRawStorageSize2((PlacemarkGroup) thisObj, (ProductSubsetDef) subsetDef);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyPlacemarkGroup_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:PlacemarkGroup_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    PlacemarkGroup_setModified((PlacemarkGroup) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    PlacemarkGroup_acceptVisitor((PlacemarkGroup) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:PlacemarkGroup_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    PlacemarkGroup_updateExpression((PlacemarkGroup) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getOwner((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getName((PlacemarkGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    PlacemarkGroup_setName((PlacemarkGroup) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getDescription((PlacemarkGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    PlacemarkGroup_setDescription((PlacemarkGroup) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_isModified((PlacemarkGroup) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_toString((PlacemarkGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:PlacemarkGroup_isValidNodeName", &name)) {
        return NULL;
    }
    result = PlacemarkGroup_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyPlacemarkGroup_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getProduct((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getProductReader((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getProductWriter((PlacemarkGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getDisplayName((PlacemarkGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getProductRefString((PlacemarkGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyPlacemarkGroup_getRawStorageSize1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):PlacemarkGroup_getRawStorageSize1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = PlacemarkGroup_getRawStorageSize1((PlacemarkGroup) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:PlacemarkGroup_fireProductNodeChanged1", &thisObjType, &thisObj, &propertyName)) {
        return NULL;
    }
    PlacemarkGroup_fireProductNodeChanged1((PlacemarkGroup) thisObj, propertyName);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* oldValueType;
    unsigned PY_LONG_LONG oldValue;
    const char* newValueType;
    unsigned PY_LONG_LONG newValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK)(sK):PlacemarkGroup_fireProductNodeChanged2", &thisObjType, &thisObj, &propertyName, &oldValueType, &oldValue, &newValueType, &newValue)) {
        return NULL;
    }
    PlacemarkGroup_fireProductNodeChanged2((PlacemarkGroup) thisObj, propertyName, (Object) oldValue, (Object) newValue);
    return Py_BuildValue("");
}

PyObject* BeamPyPlacemarkGroup_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):PlacemarkGroup_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    PlacemarkGroup_removeFromFile((PlacemarkGroup) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_newTiePointGrid1(PyObject* self, PyObject* args)
{
    const char* name;
    int gridWidth;
    int gridHeight;
    float offsetX;
    float offsetY;
    float subSamplingX;
    float subSamplingY;
    float* tiePoints;
    int tiePointsLength;
    PyObject* tiePointsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "siiffffO:TiePointGrid_newTiePointGrid1", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsSeq)) {
        return NULL;
    }
    tiePoints = beam_new_float_array_from_pyseq(tiePointsSeq, &tiePointsLength);
    result = TiePointGrid_newTiePointGrid1(name, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePoints, tiePointsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_newTiePointGrid2(PyObject* self, PyObject* args)
{
    const char* name;
    int gridWidth;
    int gridHeight;
    float offsetX;
    float offsetY;
    float subSamplingX;
    float subSamplingY;
    float* tiePoints;
    int tiePointsLength;
    PyObject* tiePointsSeq;
    int discontinuity;
    void* result;
    if (!PyArg_ParseTuple(args, "siiffffOi:TiePointGrid_newTiePointGrid2", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsSeq, &discontinuity)) {
        return NULL;
    }
    tiePoints = beam_new_float_array_from_pyseq(tiePointsSeq, &tiePointsLength);
    result = TiePointGrid_newTiePointGrid2(name, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePoints, tiePointsLength, discontinuity);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_newTiePointGrid3(PyObject* self, PyObject* args)
{
    const char* name;
    int gridWidth;
    int gridHeight;
    float offsetX;
    float offsetY;
    float subSamplingX;
    float subSamplingY;
    float* tiePoints;
    int tiePointsLength;
    PyObject* tiePointsSeq;
    boolean containsAngles;
    void* result;
    if (!PyArg_ParseTuple(args, "siiffffOp:TiePointGrid_newTiePointGrid3", &name, &gridWidth, &gridHeight, &offsetX, &offsetY, &subSamplingX, &subSamplingY, &tiePointsSeq, &containsAngles)) {
        return NULL;
    }
    tiePoints = beam_new_float_array_from_pyseq(tiePointsSeq, &tiePointsLength);
    result = TiePointGrid_newTiePointGrid3(name, gridWidth, gridHeight, offsetX, offsetY, subSamplingX, subSamplingY, tiePoints, tiePointsLength, containsAngles);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getDiscontinuity2(PyObject* self, PyObject* args)
{
    float* tiePoints;
    int tiePointsLength;
    PyObject* tiePointsSeq;
    int result;
    if (!PyArg_ParseTuple(args, "O:TiePointGrid_getDiscontinuity2", &tiePointsSeq)) {
        return NULL;
    }
    tiePoints = beam_new_float_array_from_pyseq(tiePointsSeq, &tiePointsLength);
    result = TiePointGrid_getDiscontinuity2(tiePoints, tiePointsLength);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getDiscontinuity1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDiscontinuity1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDiscontinuity1((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setDiscontinuity(PyObject* self, PyObject* args)
{
    int discontinuity;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:TiePointGrid_setDiscontinuity", &thisObjType, &thisObj, &discontinuity)) {
        return NULL;
    }
    TiePointGrid_setDiscontinuity((TiePointGrid) thisObj, discontinuity);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isFloatingPointType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isFloatingPointType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isFloatingPointType((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalDataType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getGeophysicalDataType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getGeophysicalDataType((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSceneRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSceneRasterData((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getSceneRasterWidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSceneRasterWidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSceneRasterWidth((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getSceneRasterHeight(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSceneRasterHeight", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSceneRasterHeight((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getOffsetX(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getOffsetX", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getOffsetX((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getOffsetY(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getOffsetY", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getOffsetY((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingX(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSubSamplingX", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSubSamplingX((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getSubSamplingY(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSubSamplingY", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSubSamplingY((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getTiePoints(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getTiePoints", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getTiePoints((TiePointGrid) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getPixelInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getPixelInt", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getPixelInt((TiePointGrid) thisObj, x, y);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_dispose((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixelFloat2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getPixelFloat2", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getPixelFloat2((TiePointGrid) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getPixelFloat1(PyObject* self, PyObject* args)
{
    float x;
    float y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)ff:TiePointGrid_getPixelFloat1", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getPixelFloat1((TiePointGrid) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getPixelDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getPixelDouble", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getPixelDouble((TiePointGrid) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_setPixelInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iii:TiePointGrid_setPixelInt", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    TiePointGrid_setPixelInt((TiePointGrid) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    float pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iif:TiePointGrid_setPixelFloat", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    TiePointGrid_setPixelFloat((TiePointGrid) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixelDouble(PyObject* self, PyObject* args)
{
    int x;
    int y;
    double pixelValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iid:TiePointGrid_setPixelDouble", &thisObjType, &thisObj, &x, &y, &pixelValue)) {
        return NULL;
    }
    TiePointGrid_setPixelDouble((TiePointGrid) thisObj, x, y, pixelValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPixels6(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_getPixels6", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels6((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getPixels4(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_getPixels4", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels4((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getPixels2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_getPixels2", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels2((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setPixels3(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_setPixels3", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_setPixels3((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_setPixels2", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_setPixels2((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setPixels1(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_setPixels1", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_setPixels1((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readPixels6(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_readPixels6", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels6((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readPixels4(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_readPixels4", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels4((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readPixels2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_readPixels2", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels2((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_writePixels6(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_writePixels6", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels6((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels4(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_writePixels4", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels4((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO(sK):TiePointGrid_writePixels2", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq, &pmType, &pm)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels2((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData2(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)(sK):TiePointGrid_readRasterData2", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData, &pmType, &pm)) {
        return NULL;
    }
    TiePointGrid_readRasterData2((TiePointGrid) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterDataFully2(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_readRasterDataFully2", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    TiePointGrid_readRasterDataFully2((TiePointGrid) thisObj, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData2(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK)(sK):TiePointGrid_writeRasterData2", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData, &pmType, &pm)) {
        return NULL;
    }
    TiePointGrid_writeRasterData2((TiePointGrid) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully2(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_writeRasterDataFully2", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    TiePointGrid_writeRasterDataFully2((TiePointGrid) thisObj, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    TiePointGrid_acceptVisitor((TiePointGrid) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_cloneTiePointGrid(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_cloneTiePointGrid", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_cloneTiePointGrid((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createZenithFromElevationAngleTiePointGrid(PyObject* self, PyObject* args)
{
    const char* elevationAngleGridType;
    unsigned PY_LONG_LONG elevationAngleGrid;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_createZenithFromElevationAngleTiePointGrid", &elevationAngleGridType, &elevationAngleGrid)) {
        return NULL;
    }
    result = TiePointGrid_createZenithFromElevationAngleTiePointGrid((TiePointGrid) elevationAngleGrid);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createSubset(PyObject* self, PyObject* args)
{
    const char* sourceTiePointGridType;
    unsigned PY_LONG_LONG sourceTiePointGrid;
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_createSubset", &sourceTiePointGridType, &sourceTiePointGrid, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = TiePointGrid_createSubset((TiePointGrid) sourceTiePointGrid, (ProductSubsetDef) subsetDef);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getRasterWidth(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getRasterWidth", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getRasterWidth((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getRasterHeight(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getRasterHeight", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getRasterHeight((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:TiePointGrid_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    TiePointGrid_setModified((TiePointGrid) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeoCoding(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getGeoCoding", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getGeoCoding((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setGeoCoding(PyObject* self, PyObject* args)
{
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setGeoCoding", &thisObjType, &thisObj, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    TiePointGrid_setGeoCoding((TiePointGrid) thisObj, (GeoCoding) geoCoding);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getPointing(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getPointing", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getPointing((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Pointing", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_canBeOrthorectified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_canBeOrthorectified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_canBeOrthorectified((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getScalingFactor(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getScalingFactor", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getScalingFactor((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_setScalingFactor(PyObject* self, PyObject* args)
{
    double scalingFactor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_setScalingFactor", &thisObjType, &thisObj, &scalingFactor)) {
        return NULL;
    }
    TiePointGrid_setScalingFactor((TiePointGrid) thisObj, scalingFactor);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getScalingOffset(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getScalingOffset", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getScalingOffset((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_setScalingOffset(PyObject* self, PyObject* args)
{
    double scalingOffset;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_setScalingOffset", &thisObjType, &thisObj, &scalingOffset)) {
        return NULL;
    }
    TiePointGrid_setScalingOffset((TiePointGrid) thisObj, scalingOffset);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isLog10Scaled(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isLog10Scaled", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isLog10Scaled((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setLog10Scaled(PyObject* self, PyObject* args)
{
    boolean log10Scaled;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:TiePointGrid_setLog10Scaled", &thisObjType, &thisObj, &log10Scaled)) {
        return NULL;
    }
    TiePointGrid_setLog10Scaled((TiePointGrid) thisObj, log10Scaled);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isScalingApplied(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isScalingApplied", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isScalingApplied((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_isValidMaskProperty(PyObject* self, PyObject* args)
{
    const char* propertyName;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:TiePointGrid_isValidMaskProperty", &propertyName)) {
        return NULL;
    }
    result = TiePointGrid_isValidMaskProperty(propertyName);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_isNoDataValueSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isNoDataValueSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isNoDataValueSet((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_clearNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_clearNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_clearNoDataValue((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isNoDataValueUsed(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isNoDataValueUsed", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isNoDataValueUsed((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setNoDataValueUsed(PyObject* self, PyObject* args)
{
    boolean noDataValueUsed;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:TiePointGrid_setNoDataValueUsed", &thisObjType, &thisObj, &noDataValueUsed)) {
        return NULL;
    }
    TiePointGrid_setNoDataValueUsed((TiePointGrid) thisObj, noDataValueUsed);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getNoDataValue((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_setNoDataValue(PyObject* self, PyObject* args)
{
    double noDataValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_setNoDataValue", &thisObjType, &thisObj, &noDataValue)) {
        return NULL;
    }
    TiePointGrid_setNoDataValue((TiePointGrid) thisObj, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getGeophysicalNoDataValue", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getGeophysicalNoDataValue((TiePointGrid) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_setGeophysicalNoDataValue(PyObject* self, PyObject* args)
{
    double noDataValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_setGeophysicalNoDataValue", &thisObjType, &thisObj, &noDataValue)) {
        return NULL;
    }
    TiePointGrid_setGeophysicalNoDataValue((TiePointGrid) thisObj, noDataValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidPixelExpression(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getValidPixelExpression", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getValidPixelExpression((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setValidPixelExpression(PyObject* self, PyObject* args)
{
    const char* validPixelExpression;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:TiePointGrid_setValidPixelExpression", &thisObjType, &thisObj, &validPixelExpression)) {
        return NULL;
    }
    TiePointGrid_setValidPixelExpression((TiePointGrid) thisObj, validPixelExpression);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isValidMaskUsed(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isValidMaskUsed", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isValidMaskUsed((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_resetValidMask(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_resetValidMask", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_resetValidMask((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidMaskExpression(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getValidMaskExpression", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getValidMaskExpression((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:TiePointGrid_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    TiePointGrid_updateExpression((TiePointGrid) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_hasRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_hasRasterData((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getRasterData((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData)) {
        return NULL;
    }
    TiePointGrid_setRasterData((TiePointGrid) thisObj, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_loadRasterData1", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_loadRasterData1((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_loadRasterData2(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_loadRasterData2", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    TiePointGrid_loadRasterData2((TiePointGrid) thisObj, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_unloadRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_unloadRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_unloadRasterData((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isPixelValid2(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_isPixelValid2", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_isPixelValid2((TiePointGrid) thisObj, x, y);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getSampleInt(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getSampleInt", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getSampleInt((TiePointGrid) thisObj, x, y);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getSampleFloat(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getSampleFloat", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getSampleFloat((TiePointGrid) thisObj, x, y);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_isPixelValid1(PyObject* self, PyObject* args)
{
    int pixelIndex;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)i:TiePointGrid_isPixelValid1", &thisObjType, &thisObj, &pixelIndex)) {
        return NULL;
    }
    result = TiePointGrid_isPixelValid1((TiePointGrid) thisObj, pixelIndex);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_isPixelValid3(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* roiType;
    unsigned PY_LONG_LONG roi;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):TiePointGrid_isPixelValid3", &thisObjType, &thisObj, &x, &y, &roiType, &roi)) {
        return NULL;
    }
    result = TiePointGrid_isPixelValid3((TiePointGrid) thisObj, x, y, (ROI) roi);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getPixels5(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_getPixels5", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels5((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getPixels3(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_getPixels3", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels3((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getPixels1(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_getPixels1", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_getPixels1((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readPixels5(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_readPixels5", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels5((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_int_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readPixels3(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_readPixels3", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels3((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readPixels1(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_readPixels1", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    result = TiePointGrid_readPixels1((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_double_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_writePixels5(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    int* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_writePixels5", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_int_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels5((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels3(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    float* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_writePixels3", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_float_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels3((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writePixels1(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    double* pixels;
    int pixelsLength;
    PyObject* pixelsSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_writePixels1", &thisObjType, &thisObj, &x, &y, &w, &h, &pixelsSeq)) {
        return NULL;
    }
    pixels = beam_new_double_array_from_pyseq(pixelsSeq, &pixelsLength);
    TiePointGrid_writePixels1((TiePointGrid) thisObj, x, y, w, h, pixels, pixelsLength);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readValidMask(PyObject* self, PyObject* args)
{
    int x;
    int y;
    int w;
    int h;
    boolean* validMask;
    int validMaskLength;
    PyObject* validMaskSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)iiiiO:TiePointGrid_readValidMask", &thisObjType, &thisObj, &x, &y, &w, &h, &validMaskSeq)) {
        return NULL;
    }
    validMask = beam_new_boolean_array_from_pyseq(validMaskSeq, &validMaskLength);
    result = TiePointGrid_readValidMask((TiePointGrid) thisObj, x, y, w, h, validMask, validMaskLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_boolean_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_readRasterDataFully1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_readRasterDataFully1", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_readRasterDataFully1((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_readRasterData1(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):TiePointGrid_readRasterData1", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    TiePointGrid_readRasterData1((TiePointGrid) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterDataFully1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_writeRasterDataFully1", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_writeRasterDataFully1((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_writeRasterData1(PyObject* self, PyObject* args)
{
    int offsetX;
    int offsetY;
    int width;
    int height;
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iiii(sK):TiePointGrid_writeRasterData1", &thisObjType, &thisObj, &offsetX, &offsetY, &width, &height, &rasterDataType, &rasterData)) {
        return NULL;
    }
    TiePointGrid_writeRasterData1((TiePointGrid) thisObj, offsetX, offsetY, width, height, (ProductData) rasterData);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_createCompatibleRasterData1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_createCompatibleRasterData1((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createCompatibleSceneRasterData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_createCompatibleSceneRasterData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_createCompatibleSceneRasterData((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createCompatibleRasterData2(PyObject* self, PyObject* args)
{
    int width;
    int height;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_createCompatibleRasterData2", &thisObjType, &thisObj, &width, &height)) {
        return NULL;
    }
    result = TiePointGrid_createCompatibleRasterData2((TiePointGrid) thisObj, width, height);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_isCompatibleRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    int w;
    int h;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:TiePointGrid_isCompatibleRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    result = TiePointGrid_isCompatibleRasterData((TiePointGrid) thisObj, (ProductData) rasterData, w, h);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_checkCompatibleRasterData(PyObject* self, PyObject* args)
{
    const char* rasterDataType;
    unsigned PY_LONG_LONG rasterData;
    int w;
    int h;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ii:TiePointGrid_checkCompatibleRasterData", &thisObjType, &thisObj, &rasterDataType, &rasterData, &w, &h)) {
        return NULL;
    }
    TiePointGrid_checkCompatibleRasterData((TiePointGrid) thisObj, (ProductData) rasterData, w, h);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_hasIntPixels(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_hasIntPixels", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_hasIntPixels((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_createTransectProfileData(PyObject* self, PyObject* args)
{
    const char* shapeType;
    unsigned PY_LONG_LONG shape;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_createTransectProfileData", &thisObjType, &thisObj, &shapeType, &shape)) {
        return NULL;
    }
    result = TiePointGrid_createTransectProfileData((TiePointGrid) thisObj, (Shape) shape);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TransectProfileData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getImageInfo1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getImageInfo1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getImageInfo1((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setImageInfo(PyObject* self, PyObject* args)
{
    const char* imageInfoType;
    unsigned PY_LONG_LONG imageInfo;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setImageInfo", &thisObjType, &thisObj, &imageInfoType, &imageInfo)) {
        return NULL;
    }
    TiePointGrid_setImageInfo((TiePointGrid) thisObj, (ImageInfo) imageInfo);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireImageInfoChanged(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_fireImageInfoChanged", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_fireImageInfoChanged((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getImageInfo2(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_getImageInfo2", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    result = TiePointGrid_getImageInfo2((TiePointGrid) thisObj, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getImageInfo3(PyObject* self, PyObject* args)
{
    double* histoSkipAreas;
    int histoSkipAreasLength;
    PyObject* histoSkipAreasSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)O(sK):TiePointGrid_getImageInfo3", &thisObjType, &thisObj, &histoSkipAreasSeq, &pmType, &pm)) {
        return NULL;
    }
    histoSkipAreas = beam_new_double_array_from_pyseq(histoSkipAreasSeq, &histoSkipAreasLength);
    result = TiePointGrid_getImageInfo3((TiePointGrid) thisObj, histoSkipAreas, histoSkipAreasLength, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo1(PyObject* self, PyObject* args)
{
    double* histoSkipAreas;
    int histoSkipAreasLength;
    PyObject* histoSkipAreasSeq;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)O(sK):TiePointGrid_createDefaultImageInfo1", &thisObjType, &thisObj, &histoSkipAreasSeq, &pmType, &pm)) {
        return NULL;
    }
    histoSkipAreas = beam_new_double_array_from_pyseq(histoSkipAreasSeq, &histoSkipAreasLength);
    result = TiePointGrid_createDefaultImageInfo1((TiePointGrid) thisObj, histoSkipAreas, histoSkipAreasLength, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createDefaultImageInfo2(PyObject* self, PyObject* args)
{
    double* histoSkipAreas;
    int histoSkipAreasLength;
    PyObject* histoSkipAreasSeq;
    const char* histogramType;
    unsigned PY_LONG_LONG histogram;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)O(sK):TiePointGrid_createDefaultImageInfo2", &thisObjType, &thisObj, &histoSkipAreasSeq, &histogramType, &histogram)) {
        return NULL;
    }
    histoSkipAreas = beam_new_double_array_from_pyseq(histoSkipAreasSeq, &histoSkipAreasLength);
    result = TiePointGrid_createDefaultImageInfo2((TiePointGrid) thisObj, histoSkipAreas, histoSkipAreasLength, (Histogram) histogram);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getOverlayMaskGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getOverlayMaskGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getOverlayMaskGroup((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createColorIndexedImage(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_createColorIndexedImage", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    result = TiePointGrid_createColorIndexedImage((TiePointGrid) thisObj, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_createRgbImage(PyObject* self, PyObject* args)
{
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_createRgbImage", &thisObjType, &thisObj, &pmType, &pm)) {
        return NULL;
    }
    result = TiePointGrid_createRgbImage((TiePointGrid) thisObj, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_quantizeRasterData1(PyObject* self, PyObject* args)
{
    double newMin;
    double newMax;
    double gamma;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    byte* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)ddd(sK):TiePointGrid_quantizeRasterData1", &thisObjType, &thisObj, &newMin, &newMax, &gamma, &pmType, &pm)) {
        return NULL;
    }
    result = TiePointGrid_quantizeRasterData1((TiePointGrid) thisObj, newMin, newMax, gamma, (ProgressMonitor) pm, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_byte_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_quantizeRasterData2(PyObject* self, PyObject* args)
{
    double newMin;
    double newMax;
    double gamma;
    byte* samples;
    int samplesLength;
    PyObject* samplesSeq;
    int offset;
    int stride;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)dddOii(sK):TiePointGrid_quantizeRasterData2", &thisObjType, &thisObj, &newMin, &newMax, &gamma, &samplesSeq, &offset, &stride, &pmType, &pm)) {
        return NULL;
    }
    samples = beam_new_byte_array_from_pyseq(samplesSeq, &samplesLength);
    TiePointGrid_quantizeRasterData2((TiePointGrid) thisObj, newMin, newMax, gamma, samples, samplesLength, offset, stride, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_createPixelValidator(PyObject* self, PyObject* args)
{
    int lineOffset;
    const char* roiType;
    unsigned PY_LONG_LONG roi;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):TiePointGrid_createPixelValidator", &thisObjType, &thisObj, &lineOffset, &roiType, &roi)) {
        return NULL;
    }
    result = TiePointGrid_createPixelValidator((TiePointGrid) thisObj, lineOffset, (ROI) roi);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexValidator", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_scale(PyObject* self, PyObject* args)
{
    double v;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_scale", &thisObjType, &thisObj, &v)) {
        return NULL;
    }
    result = TiePointGrid_scale((TiePointGrid) thisObj, v);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_scaleInverse(PyObject* self, PyObject* args)
{
    double v;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)d:TiePointGrid_scaleInverse", &thisObjType, &thisObj, &v)) {
        return NULL;
    }
    result = TiePointGrid_scaleInverse((TiePointGrid) thisObj, v);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyTiePointGrid_getPixelString(PyObject* self, PyObject* args)
{
    int x;
    int y;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ii:TiePointGrid_getPixelString", &thisObjType, &thisObj, &x, &y)) {
        return NULL;
    }
    result = TiePointGrid_getPixelString((TiePointGrid) thisObj, x, y);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_isSourceImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isSourceImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isSourceImageSet((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getSourceImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getSourceImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getSourceImage((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setSourceImage2(PyObject* self, PyObject* args)
{
    const char* sourceImageType;
    unsigned PY_LONG_LONG sourceImage;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setSourceImage2", &thisObjType, &thisObj, &sourceImageType, &sourceImage)) {
        return NULL;
    }
    TiePointGrid_setSourceImage2((TiePointGrid) thisObj, (RenderedImage) sourceImage);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_setSourceImage1(PyObject* self, PyObject* args)
{
    const char* sourceImageType;
    unsigned PY_LONG_LONG sourceImage;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setSourceImage1", &thisObjType, &thisObj, &sourceImageType, &sourceImage)) {
        return NULL;
    }
    TiePointGrid_setSourceImage1((TiePointGrid) thisObj, (MultiLevelImage) sourceImage);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isGeophysicalImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isGeophysicalImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isGeophysicalImageSet((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getGeophysicalImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getGeophysicalImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getGeophysicalImage((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_isValidMaskImageSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isValidMaskImageSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isValidMaskImageSet((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getValidMaskImage(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getValidMaskImage", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getValidMaskImage((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MultiLevelImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_isStxSet(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isStxSet", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isStxSet((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getStx1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getStx1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getStx1((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Stx", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getStx2(PyObject* self, PyObject* args)
{
    boolean accurate;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)p(sK):TiePointGrid_getStx2", &thisObjType, &thisObj, &accurate, &pmType, &pm)) {
        return NULL;
    }
    result = TiePointGrid_getStx2((TiePointGrid) thisObj, accurate, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Stx", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setStx(PyObject* self, PyObject* args)
{
    const char* stxType;
    unsigned PY_LONG_LONG stx;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setStx", &thisObjType, &thisObj, &stxType, &stx)) {
        return NULL;
    }
    TiePointGrid_setStx((TiePointGrid) thisObj, (Stx) stx);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getValidShape(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getValidShape", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getValidShape((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Shape", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getDataType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDataType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDataType((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getNumDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getNumDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getNumDataElems((TiePointGrid) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyTiePointGrid_setData(PyObject* self, PyObject* args)
{
    const char* dataType;
    unsigned PY_LONG_LONG data;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_setData", &thisObjType, &thisObj, &dataType, &data)) {
        return NULL;
    }
    TiePointGrid_setData((TiePointGrid) thisObj, (ProductData) data);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getData((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDataElems((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getDataElemSize(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDataElemSize", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDataElemSize((TiePointGrid) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setReadOnly(PyObject* self, PyObject* args)
{
    boolean readOnly;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:TiePointGrid_setReadOnly", &thisObjType, &thisObj, &readOnly)) {
        return NULL;
    }
    TiePointGrid_setReadOnly((TiePointGrid) thisObj, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isReadOnly(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isReadOnly", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isReadOnly((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_setUnit(PyObject* self, PyObject* args)
{
    const char* unit;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:TiePointGrid_setUnit", &thisObjType, &thisObj, &unit)) {
        return NULL;
    }
    TiePointGrid_setUnit((TiePointGrid) thisObj, unit);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getUnit(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getUnit", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getUnit((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_fireProductNodeDataChanged", &thisObjType, &thisObj)) {
        return NULL;
    }
    TiePointGrid_fireProductNodeDataChanged((TiePointGrid) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getRawStorageSize2(PyObject* self, PyObject* args)
{
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_getRawStorageSize2", &thisObjType, &thisObj, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = TiePointGrid_getRawStorageSize2((TiePointGrid) thisObj, (ProductSubsetDef) subsetDef);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyTiePointGrid_createCompatibleProductData(PyObject* self, PyObject* args)
{
    int numElems;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:TiePointGrid_createCompatibleProductData", &thisObjType, &thisObj, &numElems)) {
        return NULL;
    }
    result = TiePointGrid_createCompatibleProductData((TiePointGrid) thisObj, numElems);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getOwner((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getName((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:TiePointGrid_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    TiePointGrid_setName((TiePointGrid) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDescription((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:TiePointGrid_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    TiePointGrid_setDescription((TiePointGrid) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_isModified((TiePointGrid) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_toString((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:TiePointGrid_isValidNodeName", &name)) {
        return NULL;
    }
    result = TiePointGrid_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyTiePointGrid_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getProduct((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getProductReader((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getProductWriter((TiePointGrid) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getDisplayName((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getProductRefString((TiePointGrid) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyTiePointGrid_getRawStorageSize1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):TiePointGrid_getRawStorageSize1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = TiePointGrid_getRawStorageSize1((TiePointGrid) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:TiePointGrid_fireProductNodeChanged1", &thisObjType, &thisObj, &propertyName)) {
        return NULL;
    }
    TiePointGrid_fireProductNodeChanged1((TiePointGrid) thisObj, propertyName);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* oldValueType;
    unsigned PY_LONG_LONG oldValue;
    const char* newValueType;
    unsigned PY_LONG_LONG newValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK)(sK):TiePointGrid_fireProductNodeChanged2", &thisObjType, &thisObj, &propertyName, &oldValueType, &oldValue, &newValueType, &newValue)) {
        return NULL;
    }
    TiePointGrid_fireProductNodeChanged2((TiePointGrid) thisObj, propertyName, (Object) oldValue, (Object) newValue);
    return Py_BuildValue("");
}

PyObject* BeamPyTiePointGrid_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):TiePointGrid_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    TiePointGrid_removeFromFile((TiePointGrid) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyAngularDirection_newAngularDirection(PyObject* self, PyObject* args)
{
    double azimuth;
    double zenith;
    void* result;
    if (!PyArg_ParseTuple(args, "dd:AngularDirection_newAngularDirection", &azimuth, &zenith)) {
        return NULL;
    }
    result = AngularDirection_newAngularDirection(azimuth, zenith);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "AngularDirection", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyAngularDirection_equals(PyObject* self, PyObject* args)
{
    const char* objType;
    unsigned PY_LONG_LONG obj;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):AngularDirection_equals", &thisObjType, &thisObj, &objType, &obj)) {
        return NULL;
    }
    result = AngularDirection_equals((AngularDirection) thisObj, (Object) obj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyAngularDirection_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):AngularDirection_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = AngularDirection_toString((AngularDirection) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_newFlagCoding(PyObject* self, PyObject* args)
{
    const char* name;
    void* result;
    if (!PyArg_ParseTuple(args, "s:FlagCoding_newFlagCoding", &name)) {
        return NULL;
    }
    result = FlagCoding_newFlagCoding(name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "FlagCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getFlag(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_getFlag", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_getFlag((FlagCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getFlagNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getFlagNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getFlagNames((FlagCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_addFlag(PyObject* self, PyObject* args)
{
    const char* name;
    int flagMask;
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sis:FlagCoding_addFlag", &thisObjType, &thisObj, &name, &flagMask, &description)) {
        return NULL;
    }
    result = FlagCoding_addFlag((FlagCoding) thisObj, name, flagMask, description);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getFlagMask(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_getFlagMask", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_getFlagMask((FlagCoding) thisObj, name);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    FlagCoding_acceptVisitor((FlagCoding) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_addElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    FlagCoding_addElement((FlagCoding) thisObj, (MetadataElement) element);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_addAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    FlagCoding_addAttribute((FlagCoding) thisObj, (MetadataAttribute) attribute);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_addSample(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sis:FlagCoding_addSample", &thisObjType, &thisObj, &name, &value, &description)) {
        return NULL;
    }
    result = FlagCoding_addSample((FlagCoding) thisObj, name, value, description);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getSampleCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getSampleCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getSampleCount((FlagCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_getSampleName(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)i:FlagCoding_getSampleName", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = FlagCoding_getSampleName((FlagCoding) thisObj, index);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getSampleValue(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)i:FlagCoding_getSampleValue", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = FlagCoding_getSampleValue((FlagCoding) thisObj, index);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_getElementGroup(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getElementGroup", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getElementGroup((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getParentElement(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getParentElement", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getParentElement((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_addElementAt(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:FlagCoding_addElementAt", &thisObjType, &thisObj, &elementType, &element, &index)) {
        return NULL;
    }
    FlagCoding_addElementAt((FlagCoding) thisObj, (MetadataElement) element, index);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeElement(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_removeElement", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = FlagCoding_removeElement((FlagCoding) thisObj, (MetadataElement) element);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_getNumElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getNumElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getNumElements((FlagCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_getElementAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:FlagCoding_getElementAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = FlagCoding_getElementAt((FlagCoding) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getElementNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getElementNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getElementNames((FlagCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getElements(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataElement* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getElements", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getElements((FlagCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataElement", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_getElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_getElement((FlagCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_containsElement(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_containsElement", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_containsElement((FlagCoding) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_getElementIndex(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_getElementIndex", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = FlagCoding_getElementIndex((FlagCoding) thisObj, (MetadataElement) element);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_removeAttribute(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_removeAttribute", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = FlagCoding_removeAttribute((FlagCoding) thisObj, (MetadataAttribute) attribute);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_getNumAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getNumAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getNumAttributes((FlagCoding) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_getAttributeAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:FlagCoding_getAttributeAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = FlagCoding_getAttributeAt((FlagCoding) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getAttributeNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getAttributeNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getAttributeNames((FlagCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getAttributes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    MetadataAttribute* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getAttributes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getAttributes((FlagCoding) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("MetadataAttribute", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_getAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_getAttribute((FlagCoding) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_containsAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_containsAttribute", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = FlagCoding_containsAttribute((FlagCoding) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_getAttributeIndex(PyObject* self, PyObject* args)
{
    const char* attributeType;
    unsigned PY_LONG_LONG attribute;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_getAttributeIndex", &thisObjType, &thisObj, &attributeType, &attribute)) {
        return NULL;
    }
    result = FlagCoding_getAttributeIndex((FlagCoding) thisObj, (MetadataAttribute) attribute);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_getAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)sd:FlagCoding_getAttributeDouble", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = FlagCoding_getAttributeDouble((FlagCoding) thisObj, name, defaultValue);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyFlagCoding_getAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValueType;
    unsigned PY_LONG_LONG defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):FlagCoding_getAttributeUTC", &thisObjType, &thisObj, &name, &defaultValueType, &defaultValue)) {
        return NULL;
    }
    result = FlagCoding_getAttributeUTC((FlagCoding) thisObj, name, (ProductData_UTC) defaultValue);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)si:FlagCoding_getAttributeInt", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = FlagCoding_getAttributeInt((FlagCoding) thisObj, name, defaultValue);
    return PyLong_FromLong(result);
}

PyObject* BeamPyFlagCoding_setAttributeInt(PyObject* self, PyObject* args)
{
    const char* name;
    int value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)si:FlagCoding_setAttributeInt", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    FlagCoding_setAttributeInt((FlagCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeDouble(PyObject* self, PyObject* args)
{
    const char* name;
    double value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)sd:FlagCoding_setAttributeDouble", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    FlagCoding_setAttributeDouble((FlagCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setAttributeUTC(PyObject* self, PyObject* args)
{
    const char* name;
    const char* valueType;
    unsigned PY_LONG_LONG value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK):FlagCoding_setAttributeUTC", &thisObjType, &thisObj, &name, &valueType, &value)) {
        return NULL;
    }
    FlagCoding_setAttributeUTC((FlagCoding) thisObj, name, (ProductData_UTC) value);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* defaultValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)ss:FlagCoding_getAttributeString", &thisObjType, &thisObj, &name, &defaultValue)) {
        return NULL;
    }
    result = FlagCoding_getAttributeString((FlagCoding) thisObj, name, defaultValue);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_setAttributeString(PyObject* self, PyObject* args)
{
    const char* name;
    const char* value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:FlagCoding_setAttributeString", &thisObjType, &thisObj, &name, &value)) {
        return NULL;
    }
    FlagCoding_setAttributeString((FlagCoding) thisObj, name, value);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:FlagCoding_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    FlagCoding_setModified((FlagCoding) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_createDeepClone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_createDeepClone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_createDeepClone((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    FlagCoding_dispose((FlagCoding) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getOwner((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getName((FlagCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    FlagCoding_setName((FlagCoding) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getDescription((FlagCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:FlagCoding_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    FlagCoding_setDescription((FlagCoding) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_isModified((FlagCoding) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_toString((FlagCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:FlagCoding_isValidNodeName", &name)) {
        return NULL;
    }
    result = FlagCoding_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyFlagCoding_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getProduct((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getProductReader((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getProductWriter((FlagCoding) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getDisplayName((FlagCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):FlagCoding_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = FlagCoding_getProductRefString((FlagCoding) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyFlagCoding_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:FlagCoding_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    FlagCoding_updateExpression((FlagCoding) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyFlagCoding_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):FlagCoding_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    FlagCoding_removeFromFile((FlagCoding) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_getReaderPlugIn(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductReader_getReaderPlugIn", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductReader_getReaderPlugIn((ProductReader) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReaderPlugIn", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductReader_getInput(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductReader_getInput", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductReader_getInput((ProductReader) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductReader_getSubsetDef(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductReader_getSubsetDef", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductReader_getSubsetDef((ProductReader) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductSubsetDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductReader_readProductNodes(PyObject* self, PyObject* args)
{
    const char* inputType;
    unsigned PY_LONG_LONG input;
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ProductReader_readProductNodes", &thisObjType, &thisObj, &inputType, &input, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = ProductReader_readProductNodes((ProductReader) thisObj, (Object) input, (ProductSubsetDef) subsetDef);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductReader_readBandRasterData(PyObject* self, PyObject* args)
{
    const char* destBandType;
    unsigned PY_LONG_LONG destBand;
    int destOffsetX;
    int destOffsetY;
    int destWidth;
    int destHeight;
    const char* destBufferType;
    unsigned PY_LONG_LONG destBuffer;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK)iiii(sK)(sK):ProductReader_readBandRasterData", &thisObjType, &thisObj, &destBandType, &destBand, &destOffsetX, &destOffsetY, &destWidth, &destHeight, &destBufferType, &destBuffer, &pmType, &pm)) {
        return NULL;
    }
    ProductReader_readBandRasterData((ProductReader) thisObj, (Band) destBand, destOffsetX, destOffsetY, destWidth, destHeight, (ProductData) destBuffer, (ProgressMonitor) pm);
    return Py_BuildValue("");
}

PyObject* BeamPyProductReader_close(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductReader_close", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductReader_close((ProductReader) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_newRGBChannelDef(PyObject* self, PyObject* args)
{
    void* result;
    result = RGBChannelDef_newRGBChannelDef();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "RGBChannelDef", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyRGBChannelDef_getSourceName(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)i:RGBChannelDef_getSourceName", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = RGBChannelDef_getSourceName((RGBChannelDef) thisObj, index);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyRGBChannelDef_setSourceName(PyObject* self, PyObject* args)
{
    int index;
    const char* sourceName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)is:RGBChannelDef_setSourceName", &thisObjType, &thisObj, &index, &sourceName)) {
        return NULL;
    }
    RGBChannelDef_setSourceName((RGBChannelDef) thisObj, index, sourceName);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getSourceNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):RGBChannelDef_getSourceNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = RGBChannelDef_getSourceNames((RGBChannelDef) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyRGBChannelDef_setSourceNames(PyObject* self, PyObject* args)
{
    char** bandNames;
    int bandNamesLength;
    PyObject* bandNamesSeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)O:RGBChannelDef_setSourceNames", &thisObjType, &thisObj, &bandNamesSeq)) {
        return NULL;
    }
    bandNames = beam_new_string_array_from_pyseq(bandNamesSeq, &bandNamesLength);
    RGBChannelDef_setSourceNames((RGBChannelDef) thisObj, bandNames, bandNamesLength);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_isAlphaUsed(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):RGBChannelDef_isAlphaUsed", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = RGBChannelDef_isAlphaUsed((RGBChannelDef) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyRGBChannelDef_isGammaUsed(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)i:RGBChannelDef_isGammaUsed", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = RGBChannelDef_isGammaUsed((RGBChannelDef) thisObj, index);
    return PyBool_FromLong(result);
}

PyObject* BeamPyRGBChannelDef_getGamma(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)i:RGBChannelDef_getGamma", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = RGBChannelDef_getGamma((RGBChannelDef) thisObj, index);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyRGBChannelDef_setGamma(PyObject* self, PyObject* args)
{
    int index;
    double gamma;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)id:RGBChannelDef_setGamma", &thisObjType, &thisObj, &index, &gamma)) {
        return NULL;
    }
    RGBChannelDef_setGamma((RGBChannelDef) thisObj, index, gamma);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMinDisplaySample(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)i:RGBChannelDef_getMinDisplaySample", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = RGBChannelDef_getMinDisplaySample((RGBChannelDef) thisObj, index);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyRGBChannelDef_setMinDisplaySample(PyObject* self, PyObject* args)
{
    int index;
    double min;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)id:RGBChannelDef_setMinDisplaySample", &thisObjType, &thisObj, &index, &min)) {
        return NULL;
    }
    RGBChannelDef_setMinDisplaySample((RGBChannelDef) thisObj, index, min);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_getMaxDisplaySample(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)i:RGBChannelDef_getMaxDisplaySample", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = RGBChannelDef_getMaxDisplaySample((RGBChannelDef) thisObj, index);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyRGBChannelDef_setMaxDisplaySample(PyObject* self, PyObject* args)
{
    int index;
    double max;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)id:RGBChannelDef_setMaxDisplaySample", &thisObjType, &thisObj, &index, &max)) {
        return NULL;
    }
    RGBChannelDef_setMaxDisplaySample((RGBChannelDef) thisObj, index, max);
    return Py_BuildValue("");
}

PyObject* BeamPyRGBChannelDef_clone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):RGBChannelDef_clone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = RGBChannelDef_clone((RGBChannelDef) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance1(PyObject* self, PyObject* args)
{
    int type;
    void* result;
    if (!PyArg_ParseTuple(args, "i:ProductData_createInstance1", &type)) {
        return NULL;
    }
    result = ProductData_createInstance1(type);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance2(PyObject* self, PyObject* args)
{
    int type;
    int numElems;
    void* result;
    if (!PyArg_ParseTuple(args, "ii:ProductData_createInstance2", &type, &numElems)) {
        return NULL;
    }
    result = ProductData_createInstance2(type, numElems);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance3(PyObject* self, PyObject* args)
{
    int type;
    const char* dataType;
    unsigned PY_LONG_LONG data;
    void* result;
    if (!PyArg_ParseTuple(args, "i(sK):ProductData_createInstance3", &type, &dataType, &data)) {
        return NULL;
    }
    result = ProductData_createInstance3(type, (Object) data);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance5(PyObject* self, PyObject* args)
{
    byte* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance5", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_byte_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance5(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createUnsignedInstance1(PyObject* self, PyObject* args)
{
    byte* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createUnsignedInstance1", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_byte_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createUnsignedInstance1(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance10(PyObject* self, PyObject* args)
{
    short* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance10", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_short_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance10(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createUnsignedInstance3(PyObject* self, PyObject* args)
{
    short* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createUnsignedInstance3", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_short_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createUnsignedInstance3(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance8(PyObject* self, PyObject* args)
{
    int* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance8", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_int_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance8(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createUnsignedInstance2(PyObject* self, PyObject* args)
{
    int* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createUnsignedInstance2", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_int_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createUnsignedInstance2(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance9(PyObject* self, PyObject* args)
{
    dlong* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance9", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_dlong_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance9(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance4(PyObject* self, PyObject* args)
{
    const char* strData;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ProductData_createInstance4", &strData)) {
        return NULL;
    }
    result = ProductData_createInstance4(strData);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance7(PyObject* self, PyObject* args)
{
    float* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance7", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_float_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance7(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_createInstance6(PyObject* self, PyObject* args)
{
    double* elems;
    int elemsLength;
    PyObject* elemsSeq;
    void* result;
    if (!PyArg_ParseTuple(args, "O:ProductData_createInstance6", &elemsSeq)) {
        return NULL;
    }
    elems = beam_new_double_array_from_pyseq(elemsSeq, &elemsLength);
    result = ProductData_createInstance6(elems, elemsLength);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_getType1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getType1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getType1((ProductData) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getElemSize2(PyObject* self, PyObject* args)
{
    int type;
    int result;
    if (!PyArg_ParseTuple(args, "i:ProductData_getElemSize2", &type)) {
        return NULL;
    }
    result = ProductData_getElemSize2(type);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getElemSize1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemSize1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemSize1((ProductData) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getTypeString2(PyObject* self, PyObject* args)
{
    int type;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "i:ProductData_getTypeString2", &type)) {
        return NULL;
    }
    result = ProductData_getTypeString2(type);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_getType2(PyObject* self, PyObject* args)
{
    const char* type;
    int result;
    if (!PyArg_ParseTuple(args, "s:ProductData_getType2", &type)) {
        return NULL;
    }
    result = ProductData_getType2(type);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getTypeString1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getTypeString1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getTypeString1((ProductData) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_isInt(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_isInt", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_isInt((ProductData) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isIntType(PyObject* self, PyObject* args)
{
    int type;
    boolean result;
    if (!PyArg_ParseTuple(args, "i:ProductData_isIntType", &type)) {
        return NULL;
    }
    result = ProductData_isIntType(type);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isSigned(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_isSigned", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_isSigned((ProductData) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isUnsigned(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_isUnsigned", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_isUnsigned((ProductData) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isUIntType(PyObject* self, PyObject* args)
{
    int type;
    boolean result;
    if (!PyArg_ParseTuple(args, "i:ProductData_isUIntType", &type)) {
        return NULL;
    }
    result = ProductData_isUIntType(type);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isFloatingPointType(PyObject* self, PyObject* args)
{
    int type;
    boolean result;
    if (!PyArg_ParseTuple(args, "i:ProductData_isFloatingPointType", &type)) {
        return NULL;
    }
    result = ProductData_isFloatingPointType(type);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_isScalar(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_isScalar", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_isScalar((ProductData) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_getNumElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getNumElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getNumElems((ProductData) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getElemInt(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemInt", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemInt((ProductData) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getElemUInt(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemUInt", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemUInt((ProductData) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyProductData_getElemFloat(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemFloat", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemFloat((ProductData) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductData_getElemDouble(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemDouble", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemDouble((ProductData) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductData_getElemString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemString((ProductData) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_getElemBoolean(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElemBoolean", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElemBoolean((ProductData) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_getElemIntAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemIntAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemIntAt((ProductData) thisObj, index);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_getElemUIntAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemUIntAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemUIntAt((ProductData) thisObj, index);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyProductData_getElemFloatAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemFloatAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemFloatAt((ProductData) thisObj, index);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductData_getElemDoubleAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemDoubleAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemDoubleAt((ProductData) thisObj, index);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductData_getElemStringAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemStringAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemStringAt((ProductData) thisObj, index);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_getElemBooleanAt(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_getElemBooleanAt", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductData_getElemBooleanAt((ProductData) thisObj, index);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_setElemInt(PyObject* self, PyObject* args)
{
    int value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductData_setElemInt", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemInt((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUInt(PyObject* self, PyObject* args)
{
    dlong value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)L:ProductData_setElemUInt", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemUInt((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloat(PyObject* self, PyObject* args)
{
    float value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)f:ProductData_setElemFloat", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemFloat((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDouble(PyObject* self, PyObject* args)
{
    double value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)d:ProductData_setElemDouble", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemDouble((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemString(PyObject* self, PyObject* args)
{
    const char* value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductData_setElemString", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemString((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBoolean(PyObject* self, PyObject* args)
{
    boolean value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ProductData_setElemBoolean", &thisObjType, &thisObj, &value)) {
        return NULL;
    }
    ProductData_setElemBoolean((ProductData) thisObj, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemIntAt(PyObject* self, PyObject* args)
{
    int index;
    int value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii:ProductData_setElemIntAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemIntAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemUIntAt(PyObject* self, PyObject* args)
{
    int index;
    dlong value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)iL:ProductData_setElemUIntAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemUIntAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemFloatAt(PyObject* self, PyObject* args)
{
    int index;
    float value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)if:ProductData_setElemFloatAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemFloatAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemDoubleAt(PyObject* self, PyObject* args)
{
    int index;
    double value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)id:ProductData_setElemDoubleAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemDoubleAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemStringAt(PyObject* self, PyObject* args)
{
    int index;
    const char* value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)is:ProductData_setElemStringAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemStringAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_setElemBooleanAt(PyObject* self, PyObject* args)
{
    int index;
    boolean value;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ip:ProductData_setElemBooleanAt", &thisObjType, &thisObj, &index, &value)) {
        return NULL;
    }
    ProductData_setElemBooleanAt((ProductData) thisObj, index, value);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_getElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_getElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_getElems((ProductData) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_setElems(PyObject* self, PyObject* args)
{
    const char* dataType;
    unsigned PY_LONG_LONG data;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductData_setElems", &thisObjType, &thisObj, &dataType, &data)) {
        return NULL;
    }
    ProductData_setElems((ProductData) thisObj, (Object) data);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom4(PyObject* self, PyObject* args)
{
    const char* inputType;
    unsigned PY_LONG_LONG input;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductData_readFrom4", &thisObjType, &thisObj, &inputType, &input)) {
        return NULL;
    }
    ProductData_readFrom4((ProductData) thisObj, (ImageInputStream) input);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom3(PyObject* self, PyObject* args)
{
    int pos;
    const char* inputType;
    unsigned PY_LONG_LONG input;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):ProductData_readFrom3", &thisObjType, &thisObj, &pos, &inputType, &input)) {
        return NULL;
    }
    ProductData_readFrom3((ProductData) thisObj, pos, (ImageInputStream) input);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom1(PyObject* self, PyObject* args)
{
    int startPos;
    int numElems;
    const char* inputType;
    unsigned PY_LONG_LONG input;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):ProductData_readFrom1", &thisObjType, &thisObj, &startPos, &numElems, &inputType, &input)) {
        return NULL;
    }
    ProductData_readFrom1((ProductData) thisObj, startPos, numElems, (ImageInputStream) input);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_readFrom2(PyObject* self, PyObject* args)
{
    int startPos;
    int numElems;
    const char* inputType;
    unsigned PY_LONG_LONG input;
    dlong inputPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)L:ProductData_readFrom2", &thisObjType, &thisObj, &startPos, &numElems, &inputType, &input, &inputPos)) {
        return NULL;
    }
    ProductData_readFrom2((ProductData) thisObj, startPos, numElems, (ImageInputStream) input, inputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo4(PyObject* self, PyObject* args)
{
    const char* outputType;
    unsigned PY_LONG_LONG output;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductData_writeTo4", &thisObjType, &thisObj, &outputType, &output)) {
        return NULL;
    }
    ProductData_writeTo4((ProductData) thisObj, (ImageOutputStream) output);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo3(PyObject* self, PyObject* args)
{
    int pos;
    const char* outputType;
    unsigned PY_LONG_LONG output;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):ProductData_writeTo3", &thisObjType, &thisObj, &pos, &outputType, &output)) {
        return NULL;
    }
    ProductData_writeTo3((ProductData) thisObj, pos, (ImageOutputStream) output);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo1(PyObject* self, PyObject* args)
{
    int startPos;
    int numElems;
    const char* outputType;
    unsigned PY_LONG_LONG output;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK):ProductData_writeTo1", &thisObjType, &thisObj, &startPos, &numElems, &outputType, &output)) {
        return NULL;
    }
    ProductData_writeTo1((ProductData) thisObj, startPos, numElems, (ImageOutputStream) output);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_writeTo2(PyObject* self, PyObject* args)
{
    int startPos;
    int numElems;
    const char* outputType;
    unsigned PY_LONG_LONG output;
    dlong outputPos;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)L:ProductData_writeTo2", &thisObjType, &thisObj, &startPos, &numElems, &outputType, &output, &outputPos)) {
        return NULL;
    }
    ProductData_writeTo2((ProductData) thisObj, startPos, numElems, (ImageOutputStream) output, outputPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductData_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_toString((ProductData) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductData_hashCode(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_hashCode", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductData_hashCode((ProductData) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductData_equals(PyObject* self, PyObject* args)
{
    const char* otherType;
    unsigned PY_LONG_LONG other;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductData_equals", &thisObjType, &thisObj, &otherType, &other)) {
        return NULL;
    }
    result = ProductData_equals((ProductData) thisObj, (Object) other);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_equalElems(PyObject* self, PyObject* args)
{
    const char* otherType;
    unsigned PY_LONG_LONG other;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductData_equalElems", &thisObjType, &thisObj, &otherType, &other)) {
        return NULL;
    }
    result = ProductData_equalElems((ProductData) thisObj, (ProductData) other);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductData_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductData_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductData_dispose((ProductData) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_newGeoPos(PyObject* self, PyObject* args)
{
    float lat;
    float lon;
    void* result;
    if (!PyArg_ParseTuple(args, "ff:GeoPos_newGeoPos", &lat, &lon)) {
        return NULL;
    }
    result = GeoPos_newGeoPos(lat, lon);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoPos_getLat(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_getLat", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_getLat((GeoPos) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyGeoPos_getLon(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    float result;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_getLon", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_getLon((GeoPos) thisObj);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyGeoPos_setLocation(PyObject* self, PyObject* args)
{
    float lat;
    float lon;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ff:GeoPos_setLocation", &thisObjType, &thisObj, &lat, &lon)) {
        return NULL;
    }
    GeoPos_setLocation((GeoPos) thisObj, lat, lon);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_isValid(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_isValid", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_isValid((GeoPos) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyGeoPos_areValid(PyObject* self, PyObject* args)
{
    GeoPos a;
    int aLength;
    PyObject* aSeq;
    boolean result;
    if (!PyArg_ParseTuple(args, "O:GeoPos_areValid", &aSeq)) {
        return NULL;
    }
    a = beam_new_jobject_array_from_pyseq("GeoPos", aSeq, &aLength);
    result = GeoPos_areValid(a, aLength);
    return PyBool_FromLong(result);
}

PyObject* BeamPyGeoPos_setInvalid(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_setInvalid", &thisObjType, &thisObj)) {
        return NULL;
    }
    GeoPos_setInvalid((GeoPos) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_equals(PyObject* self, PyObject* args)
{
    const char* objType;
    unsigned PY_LONG_LONG obj;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):GeoPos_equals", &thisObjType, &thisObj, &objType, &obj)) {
        return NULL;
    }
    result = GeoPos_equals((GeoPos) thisObj, (Object) obj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyGeoPos_hashCode(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_hashCode", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_hashCode((GeoPos) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyGeoPos_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_toString((GeoPos) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoPos_normalize(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_normalize", &thisObjType, &thisObj)) {
        return NULL;
    }
    GeoPos_normalize((GeoPos) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyGeoPos_normalizeLon(PyObject* self, PyObject* args)
{
    float lon;
    float result;
    if (!PyArg_ParseTuple(args, "f:GeoPos_normalizeLon", &lon)) {
        return NULL;
    }
    result = GeoPos_normalizeLon(lon);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyGeoPos_getLatString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_getLatString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_getLatString((GeoPos) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyGeoPos_getLonString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):GeoPos_getLonString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = GeoPos_getLonString((GeoPos) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_newProductNodeGroup1(PyObject* self, PyObject* args)
{
    const char* name;
    void* result;
    if (!PyArg_ParseTuple(args, "s:ProductNodeGroup_newProductNodeGroup1", &name)) {
        return NULL;
    }
    result = ProductNodeGroup_newProductNodeGroup1(name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_newProductNodeGroup2(PyObject* self, PyObject* args)
{
    const char* ownerType;
    unsigned PY_LONG_LONG owner;
    const char* name;
    boolean takingOverNodeOwnership;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)sp:ProductNodeGroup_newProductNodeGroup2", &ownerType, &owner, &name, &takingOverNodeOwnership)) {
        return NULL;
    }
    result = ProductNodeGroup_newProductNodeGroup2((ProductNode) owner, name, takingOverNodeOwnership);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNodeGroup", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_isTakingOverNodeOwnership(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_isTakingOverNodeOwnership", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_isTakingOverNodeOwnership((ProductNodeGroup) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_getNodeCount(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getNodeCount", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getNodeCount((ProductNodeGroup) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_get1(PyObject* self, PyObject* args)
{
    int index;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductNodeGroup_get1", &thisObjType, &thisObj, &index)) {
        return NULL;
    }
    result = ProductNodeGroup_get1((ProductNodeGroup) thisObj, index);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getNodeDisplayNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getNodeDisplayNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getNodeDisplayNames((ProductNodeGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getNodeNames(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getNodeNames", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getNodeNames((ProductNodeGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_toArray1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    ProductNode* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_toArray1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_toArray1((ProductNodeGroup) thisObj, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("ProductNode", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_toArray2(PyObject* self, PyObject* args)
{
    T array;
    int arrayLength;
    PyObject* arraySeq;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    T* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)O:ProductNodeGroup_toArray2", &thisObjType, &thisObj, &arraySeq)) {
        return NULL;
    }
    array = beam_new_jobject_array_from_pyseq("T", arraySeq, &arrayLength);
    result = ProductNodeGroup_toArray2((ProductNodeGroup) thisObj, array, arrayLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("T", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_indexOf2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_indexOf2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = ProductNodeGroup_indexOf2((ProductNodeGroup) thisObj, name);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_indexOf1(PyObject* self, PyObject* args)
{
    const char* elementType;
    unsigned PY_LONG_LONG element;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_indexOf1", &thisObjType, &thisObj, &elementType, &element)) {
        return NULL;
    }
    result = ProductNodeGroup_indexOf1((ProductNodeGroup) thisObj, (T) element);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_getByDisplayName(PyObject* self, PyObject* args)
{
    const char* displayName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_getByDisplayName", &thisObjType, &thisObj, &displayName)) {
        return NULL;
    }
    result = ProductNodeGroup_getByDisplayName((ProductNodeGroup) thisObj, displayName);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_get2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_get2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = ProductNodeGroup_get2((ProductNodeGroup) thisObj, name);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "T", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_contains2(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_contains2", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    result = ProductNodeGroup_contains2((ProductNodeGroup) thisObj, name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_contains1(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_contains1", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = ProductNodeGroup_contains1((ProductNodeGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_add2(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_add2", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = ProductNodeGroup_add2((ProductNodeGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_add1(PyObject* self, PyObject* args)
{
    int index;
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)i(sK):ProductNodeGroup_add1", &thisObjType, &thisObj, &index, &nodeType, &node)) {
        return NULL;
    }
    ProductNodeGroup_add1((ProductNodeGroup) thisObj, index, (T) node);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_remove(PyObject* self, PyObject* args)
{
    const char* nodeType;
    unsigned PY_LONG_LONG node;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_remove", &thisObjType, &thisObj, &nodeType, &node)) {
        return NULL;
    }
    result = ProductNodeGroup_remove((ProductNodeGroup) thisObj, (T) node);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_removeAll(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_removeAll", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductNodeGroup_removeAll((ProductNodeGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_clearRemovedList(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_clearRemovedList", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductNodeGroup_clearRemovedList((ProductNodeGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getRemovedNodes(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getRemovedNodes", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getRemovedNodes((ProductNodeGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Collection", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getRawStorageSize2(PyObject* self, PyObject* args)
{
    const char* subsetDefType;
    unsigned PY_LONG_LONG subsetDef;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_getRawStorageSize2", &thisObjType, &thisObj, &subsetDefType, &subsetDef)) {
        return NULL;
    }
    result = ProductNodeGroup_getRawStorageSize2((ProductNodeGroup) thisObj, (ProductSubsetDef) subsetDef);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyProductNodeGroup_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:ProductNodeGroup_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    ProductNodeGroup_setModified((ProductNodeGroup) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    ProductNodeGroup_acceptVisitor((ProductNodeGroup) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    ProductNodeGroup_dispose((ProductNodeGroup) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:ProductNodeGroup_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    ProductNodeGroup_updateExpression((ProductNodeGroup) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getOwner((ProductNodeGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getName((ProductNodeGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    ProductNodeGroup_setName((ProductNodeGroup) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getDescription((ProductNodeGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    ProductNodeGroup_setDescription((ProductNodeGroup) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_isModified((ProductNodeGroup) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_toString((ProductNodeGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:ProductNodeGroup_isValidNodeName", &name)) {
        return NULL;
    }
    result = ProductNodeGroup_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductNodeGroup_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getProduct((ProductNodeGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getProductReader((ProductNodeGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getProductWriter((ProductNodeGroup) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getDisplayName((ProductNodeGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getProductRefString((ProductNodeGroup) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductNodeGroup_getRawStorageSize1(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):ProductNodeGroup_getRawStorageSize1", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = ProductNodeGroup_getRawStorageSize1((ProductNodeGroup) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyProductNodeGroup_fireProductNodeChanged1(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:ProductNodeGroup_fireProductNodeChanged1", &thisObjType, &thisObj, &propertyName)) {
        return NULL;
    }
    ProductNodeGroup_fireProductNodeChanged1((ProductNodeGroup) thisObj, propertyName);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_fireProductNodeChanged2(PyObject* self, PyObject* args)
{
    const char* propertyName;
    const char* oldValueType;
    unsigned PY_LONG_LONG oldValue;
    const char* newValueType;
    unsigned PY_LONG_LONG newValue;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s(sK)(sK):ProductNodeGroup_fireProductNodeChanged2", &thisObjType, &thisObj, &propertyName, &oldValueType, &oldValue, &newValueType, &newValue)) {
        return NULL;
    }
    ProductNodeGroup_fireProductNodeChanged2((ProductNodeGroup) thisObj, propertyName, (Object) oldValue, (Object) newValue);
    return Py_BuildValue("");
}

PyObject* BeamPyProductNodeGroup_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductNodeGroup_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    ProductNodeGroup_removeFromFile((ProductNodeGroup) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_newProductUtils(PyObject* self, PyObject* args)
{
    void* result;
    result = ProductUtils_newProductUtils();
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductUtils", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createImageInfo(PyObject* self, PyObject* args)
{
    RasterDataNode rasters;
    int rastersLength;
    PyObject* rastersSeq;
    boolean assignMissingImageInfos;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    void* result;
    if (!PyArg_ParseTuple(args, "Op(sK):ProductUtils_createImageInfo", &rastersSeq, &assignMissingImageInfos, &pmType, &pm)) {
        return NULL;
    }
    rasters = beam_new_jobject_array_from_pyseq("RasterDataNode", rastersSeq, &rastersLength);
    result = ProductUtils_createImageInfo(rasters, rastersLength, assignMissingImageInfos, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ImageInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createRgbImage(PyObject* self, PyObject* args)
{
    RasterDataNode rasters;
    int rastersLength;
    PyObject* rastersSeq;
    const char* imageInfoType;
    unsigned PY_LONG_LONG imageInfo;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    void* result;
    if (!PyArg_ParseTuple(args, "O(sK)(sK):ProductUtils_createRgbImage", &rastersSeq, &imageInfoType, &imageInfo, &pmType, &pm)) {
        return NULL;
    }
    rasters = beam_new_jobject_array_from_pyseq("RasterDataNode", rastersSeq, &rastersLength);
    result = ProductUtils_createRgbImage(rasters, rastersLength, (ImageInfo) imageInfo, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createColorIndexedImage(PyObject* self, PyObject* args)
{
    const char* rasterDataNodeType;
    unsigned PY_LONG_LONG rasterDataNode;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_createColorIndexedImage", &rasterDataNodeType, &rasterDataNode, &pmType, &pm)) {
        return NULL;
    }
    result = ProductUtils_createColorIndexedImage((RasterDataNode) rasterDataNode, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createSuitableMapInfo1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    const char* mapProjectionType;
    unsigned PY_LONG_LONG mapProjection;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ProductUtils_createSuitableMapInfo1", &productType, &product, &rectType, &rect, &mapProjectionType, &mapProjection)) {
        return NULL;
    }
    result = ProductUtils_createSuitableMapInfo1((Product) product, (Rectangle) rect, (MapProjection) mapProjection);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MapInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createSuitableMapInfo2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* mapProjectionType;
    unsigned PY_LONG_LONG mapProjection;
    double orientation;
    double noDataValue;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)dd:ProductUtils_createSuitableMapInfo2", &productType, &product, &mapProjectionType, &mapProjection, &orientation, &noDataValue)) {
        return NULL;
    }
    result = ProductUtils_createSuitableMapInfo2((Product) product, (MapProjection) mapProjection, orientation, noDataValue);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MapInfo", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_getOutputRasterSize(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    const char* mapTransformType;
    unsigned PY_LONG_LONG mapTransform;
    double pixelSizeX;
    double pixelSizeY;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)dd:ProductUtils_getOutputRasterSize", &productType, &product, &rectType, &rect, &mapTransformType, &mapTransform, &pixelSizeX, &pixelSizeY)) {
        return NULL;
    }
    result = ProductUtils_getOutputRasterSize((Product) product, (Rectangle) rect, (MapTransform) mapTransform, pixelSizeX, pixelSizeY);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Dimension", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createMapEnvelope2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    const char* mapTransformType;
    unsigned PY_LONG_LONG mapTransform;
    Point2D* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ProductUtils_createMapEnvelope2", &productType, &product, &rectType, &rect, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    result = ProductUtils_createMapEnvelope2((Product) product, (Rectangle) rect, (MapTransform) mapTransform, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Point2D", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createMapEnvelope1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    const char* mapTransformType;
    unsigned PY_LONG_LONG mapTransform;
    Point2D* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i(sK):ProductUtils_createMapEnvelope1", &productType, &product, &rectType, &rect, &step, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    result = ProductUtils_createMapEnvelope1((Product) product, (Rectangle) rect, step, (MapTransform) mapTransform, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Point2D", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_getMinMax(PyObject* self, PyObject* args)
{
    Point2D boundary;
    int boundaryLength;
    PyObject* boundarySeq;
    Point2D* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_getMinMax", &boundarySeq)) {
        return NULL;
    }
    boundary = beam_new_jobject_array_from_pyseq("Point2D", boundarySeq, &boundaryLength);
    result = ProductUtils_getMinMax(boundary, boundaryLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Point2D", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createMapBoundary(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    const char* mapTransformType;
    unsigned PY_LONG_LONG mapTransform;
    Point2D* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i(sK):ProductUtils_createMapBoundary", &productType, &product, &rectType, &rect, &step, &mapTransformType, &mapTransform)) {
        return NULL;
    }
    result = ProductUtils_createMapBoundary((Product) product, (Rectangle) rect, step, (MapTransform) mapTransform, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("Point2D", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundary1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    int step;
    GeoPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductUtils_createGeoBoundary1", &productType, &product, &step)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundary1((Product) product, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeoPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundary2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    GeoPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:ProductUtils_createGeoBoundary2", &productType, &product, &regionType, &region, &step)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundary2((Product) product, (Rectangle) region, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeoPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundary3(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    boolean usePixelCenter;
    GeoPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ip:ProductUtils_createGeoBoundary3", &productType, &product, &regionType, &region, &step, &usePixelCenter)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundary3((Product) product, (Rectangle) region, step, usePixelCenter, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeoPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_getClosestGeoPos(PyObject* self, PyObject* args)
{
    const char* gcType;
    unsigned PY_LONG_LONG gc;
    const char* origPosType;
    unsigned PY_LONG_LONG origPos;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK)i:ProductUtils_getClosestGeoPos", &gcType, &gc, &origPosType, &origPos, &regionType, &region, &step)) {
        return NULL;
    }
    result = ProductUtils_getClosestGeoPos((GeoCoding) gc, (PixelPos) origPos, (Rectangle) region, step);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundary4(PyObject* self, PyObject* args)
{
    const char* rasterType;
    unsigned PY_LONG_LONG raster;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    GeoPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:ProductUtils_createGeoBoundary4", &rasterType, &raster, &regionType, &region, &step)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundary4((RasterDataNode) raster, (Rectangle) region, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeoPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    GeneralPath* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_createGeoBoundaryPaths1", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundaryPaths1((Product) product, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeneralPath", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    GeneralPath* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:ProductUtils_createGeoBoundaryPaths2", &productType, &product, &regionType, &region, &step)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundaryPaths2((Product) product, (Rectangle) region, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeneralPath", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoBoundaryPaths3(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* regionType;
    unsigned PY_LONG_LONG region;
    int step;
    boolean usePixelCenter;
    GeneralPath* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ip:ProductUtils_createGeoBoundaryPaths3", &productType, &product, &regionType, &region, &step, &usePixelCenter)) {
        return NULL;
    }
    result = ProductUtils_createGeoBoundaryPaths3((Product) product, (Rectangle) region, step, usePixelCenter, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("GeneralPath", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createPixelBoundary1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:ProductUtils_createPixelBoundary1", &productType, &product, &rectType, &rect, &step)) {
        return NULL;
    }
    result = ProductUtils_createPixelBoundary1((Product) product, (Rectangle) rect, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createPixelBoundary2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    boolean usePixelCenter;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)ip:ProductUtils_createPixelBoundary2", &productType, &product, &rectType, &rect, &step, &usePixelCenter)) {
        return NULL;
    }
    result = ProductUtils_createPixelBoundary2((Product) product, (Rectangle) rect, step, usePixelCenter, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createPixelBoundary3(PyObject* self, PyObject* args)
{
    const char* rasterType;
    unsigned PY_LONG_LONG raster;
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)(sK)i:ProductUtils_createPixelBoundary3", &rasterType, &raster, &rectType, &rect, &step)) {
        return NULL;
    }
    result = ProductUtils_createPixelBoundary3((RasterDataNode) raster, (Rectangle) rect, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createRectBoundary1(PyObject* self, PyObject* args)
{
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)i:ProductUtils_createRectBoundary1", &rectType, &rect, &step)) {
        return NULL;
    }
    result = ProductUtils_createRectBoundary1((Rectangle) rect, step, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createRectBoundary2(PyObject* self, PyObject* args)
{
    const char* rectType;
    unsigned PY_LONG_LONG rect;
    int step;
    boolean usePixelCenter;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)ip:ProductUtils_createRectBoundary2", &rectType, &rect, &step, &usePixelCenter)) {
        return NULL;
    }
    result = ProductUtils_createRectBoundary2((Rectangle) rect, step, usePixelCenter, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyFlagCodings(PyObject* self, PyObject* args)
{
    const char* sourceType;
    unsigned PY_LONG_LONG source;
    const char* targetType;
    unsigned PY_LONG_LONG target;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyFlagCodings", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    ProductUtils_copyFlagCodings((Product) source, (Product) target);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagCoding(PyObject* self, PyObject* args)
{
    const char* sourceFlagCodingType;
    unsigned PY_LONG_LONG sourceFlagCoding;
    const char* targetType;
    unsigned PY_LONG_LONG target;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyFlagCoding", &sourceFlagCodingType, &sourceFlagCoding, &targetType, &target)) {
        return NULL;
    }
    result = ProductUtils_copyFlagCoding((FlagCoding) sourceFlagCoding, (Product) target);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "FlagCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyIndexCoding(PyObject* self, PyObject* args)
{
    const char* sourceIndexCodingType;
    unsigned PY_LONG_LONG sourceIndexCoding;
    const char* targetType;
    unsigned PY_LONG_LONG target;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyIndexCoding", &sourceIndexCodingType, &sourceIndexCoding, &targetType, &target)) {
        return NULL;
    }
    result = ProductUtils_copyIndexCoding((IndexCoding) sourceIndexCoding, (Product) target);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "IndexCoding", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyMasks(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyMasks", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyMasks((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyOverlayMasks(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyOverlayMasks", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyOverlayMasks((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyFlagBands(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    boolean copySourceImage;
    if (!PyArg_ParseTuple(args, "(sK)(sK)p:ProductUtils_copyFlagBands", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    ProductUtils_copyFlagBands((Product) sourceProduct, (Product) targetProduct, copySourceImage);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrid(PyObject* self, PyObject* args)
{
    const char* gridName;
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    void* result;
    if (!PyArg_ParseTuple(args, "s(sK)(sK):ProductUtils_copyTiePointGrid", &gridName, &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    result = ProductUtils_copyTiePointGrid(gridName, (Product) sourceProduct, (Product) targetProduct);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "TiePointGrid", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyBand2(PyObject* self, PyObject* args)
{
    const char* sourceBandName;
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    boolean copySourceImage;
    void* result;
    if (!PyArg_ParseTuple(args, "s(sK)(sK)p:ProductUtils_copyBand2", &sourceBandName, &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    result = ProductUtils_copyBand2(sourceBandName, (Product) sourceProduct, (Product) targetProduct, copySourceImage);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyBand1(PyObject* self, PyObject* args)
{
    const char* sourceBandName;
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetBandName;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    boolean copySourceImage;
    void* result;
    if (!PyArg_ParseTuple(args, "s(sK)s(sK)p:ProductUtils_copyBand1", &sourceBandName, &sourceProductType, &sourceProduct, &targetBandName, &targetProductType, &targetProduct, &copySourceImage)) {
        return NULL;
    }
    result = ProductUtils_copyBand1(sourceBandName, (Product) sourceProduct, targetBandName, (Product) targetProduct, copySourceImage);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Band", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyRasterDataNodeProperties(PyObject* self, PyObject* args)
{
    const char* sourceRasterType;
    unsigned PY_LONG_LONG sourceRaster;
    const char* targetRasterType;
    unsigned PY_LONG_LONG targetRaster;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyRasterDataNodeProperties", &sourceRasterType, &sourceRaster, &targetRasterType, &targetRaster)) {
        return NULL;
    }
    ProductUtils_copyRasterDataNodeProperties((RasterDataNode) sourceRaster, (RasterDataNode) targetRaster);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copySpectralBandProperties(PyObject* self, PyObject* args)
{
    const char* sourceBandType;
    unsigned PY_LONG_LONG sourceBand;
    const char* targetBandType;
    unsigned PY_LONG_LONG targetBand;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copySpectralBandProperties", &sourceBandType, &sourceBand, &targetBandType, &targetBand)) {
        return NULL;
    }
    ProductUtils_copySpectralBandProperties((Band) sourceBand, (Band) targetBand);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyGeoCoding(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyGeoCoding", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyGeoCoding((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyTiePointGrids(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyTiePointGrids", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyTiePointGrids((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyVectorData(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyVectorData", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyVectorData((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_canGetPixelPos1(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_canGetPixelPos1", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_canGetPixelPos1((Product) product);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductUtils_canGetPixelPos2(PyObject* self, PyObject* args)
{
    const char* rasterType;
    unsigned PY_LONG_LONG raster;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_canGetPixelPos2", &rasterType, &raster)) {
        return NULL;
    }
    result = ProductUtils_canGetPixelPos2((RasterDataNode) raster);
    return PyBool_FromLong(result);
}

PyObject* BeamPyProductUtils_createDensityPlotImage(PyObject* self, PyObject* args)
{
    const char* raster1Type;
    unsigned PY_LONG_LONG raster1;
    float sampleMin1;
    float sampleMax1;
    const char* raster2Type;
    unsigned PY_LONG_LONG raster2;
    float sampleMin2;
    float sampleMax2;
    const char* roiMaskType;
    unsigned PY_LONG_LONG roiMask;
    int width;
    int height;
    const char* backgroundType;
    unsigned PY_LONG_LONG background;
    const char* imageType;
    unsigned PY_LONG_LONG image;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)ff(sK)ff(sK)ii(sK)(sK)(sK):ProductUtils_createDensityPlotImage", &raster1Type, &raster1, &sampleMin1, &sampleMax1, &raster2Type, &raster2, &sampleMin2, &sampleMax2, &roiMaskType, &roiMask, &width, &height, &backgroundType, &background, &imageType, &image, &pmType, &pm)) {
        return NULL;
    }
    result = ProductUtils_createDensityPlotImage((RasterDataNode) raster1, sampleMin1, sampleMax1, (RasterDataNode) raster2, sampleMin2, sampleMax2, (Mask) roiMask, width, height, (Color) background, (BufferedImage) image, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_overlayMasks(PyObject* self, PyObject* args)
{
    const char* rasterType;
    unsigned PY_LONG_LONG raster;
    const char* overlayBImType;
    unsigned PY_LONG_LONG overlayBIm;
    const char* pmType;
    unsigned PY_LONG_LONG pm;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK)(sK):ProductUtils_overlayMasks", &rasterType, &raster, &overlayBImType, &overlayBIm, &pmType, &pm)) {
        return NULL;
    }
    result = ProductUtils_overlayMasks((RasterDataNode) raster, (BufferedImage) overlayBIm, (ProgressMonitor) pm);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "BufferedImage", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_getCenterGeoPos(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_getCenterGeoPos", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_getCenterGeoPos((Product) product);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoPos", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon(PyObject* self, PyObject* args)
{
    GeoPos polygon;
    int polygonLength;
    PyObject* polygonSeq;
    int result;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_normalizeGeoPolygon", &polygonSeq)) {
        return NULL;
    }
    polygon = beam_new_jobject_array_from_pyseq("GeoPos", polygonSeq, &polygonLength);
    result = ProductUtils_normalizeGeoPolygon(polygon, polygonLength);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductUtils_normalizeGeoPolygon_old(PyObject* self, PyObject* args)
{
    GeoPos polygon;
    int polygonLength;
    PyObject* polygonSeq;
    int result;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_normalizeGeoPolygon_old", &polygonSeq)) {
        return NULL;
    }
    polygon = beam_new_jobject_array_from_pyseq("GeoPos", polygonSeq, &polygonLength);
    result = ProductUtils_normalizeGeoPolygon_old(polygon, polygonLength);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductUtils_denormalizeGeoPolygon(PyObject* self, PyObject* args)
{
    GeoPos polygon;
    int polygonLength;
    PyObject* polygonSeq;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_denormalizeGeoPolygon", &polygonSeq)) {
        return NULL;
    }
    polygon = beam_new_jobject_array_from_pyseq("GeoPos", polygonSeq, &polygonLength);
    ProductUtils_denormalizeGeoPolygon(polygon, polygonLength);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos(PyObject* self, PyObject* args)
{
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_denormalizeGeoPos", &geoPosType, &geoPos)) {
        return NULL;
    }
    ProductUtils_denormalizeGeoPos((GeoPos) geoPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_denormalizeGeoPos_old(PyObject* self, PyObject* args)
{
    const char* geoPosType;
    unsigned PY_LONG_LONG geoPos;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_denormalizeGeoPos_old", &geoPosType, &geoPos)) {
        return NULL;
    }
    ProductUtils_denormalizeGeoPos_old((GeoPos) geoPos);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getRotationDirection(PyObject* self, PyObject* args)
{
    GeoPos polygon;
    int polygonLength;
    PyObject* polygonSeq;
    int result;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_getRotationDirection", &polygonSeq)) {
        return NULL;
    }
    polygon = beam_new_jobject_array_from_pyseq("GeoPos", polygonSeq, &polygonLength);
    result = ProductUtils_getRotationDirection(polygon, polygonLength);
    return PyLong_FromLong(result);
}

PyObject* BeamPyProductUtils_getAngleSum(PyObject* self, PyObject* args)
{
    GeoPos polygon;
    int polygonLength;
    PyObject* polygonSeq;
    double result;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_getAngleSum", &polygonSeq)) {
        return NULL;
    }
    polygon = beam_new_jobject_array_from_pyseq("GeoPos", polygonSeq, &polygonLength);
    result = ProductUtils_getAngleSum(polygon, polygonLength);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductUtils_convertToPixelPath(PyObject* self, PyObject* args)
{
    const char* geoPathType;
    unsigned PY_LONG_LONG geoPath;
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_convertToPixelPath", &geoPathType, &geoPath, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    result = ProductUtils_convertToPixelPath((GeneralPath) geoPath, (GeoCoding) geoCoding);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeneralPath", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_convertToGeoPath(PyObject* self, PyObject* args)
{
    const char* shapeType;
    unsigned PY_LONG_LONG shape;
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_convertToGeoPath", &shapeType, &shape, &geoCodingType, &geoCoding)) {
        return NULL;
    }
    result = ProductUtils_convertToGeoPath((Shape) shape, (GeoCoding) geoCoding);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeneralPath", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyMetadata2(PyObject* self, PyObject* args)
{
    const char* sourceType;
    unsigned PY_LONG_LONG source;
    const char* targetType;
    unsigned PY_LONG_LONG target;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyMetadata2", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    ProductUtils_copyMetadata2((Product) source, (Product) target);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyMetadata1(PyObject* self, PyObject* args)
{
    const char* sourceType;
    unsigned PY_LONG_LONG source;
    const char* targetType;
    unsigned PY_LONG_LONG target;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyMetadata1", &sourceType, &source, &targetType, &target)) {
        return NULL;
    }
    ProductUtils_copyMetadata1((MetadataElement) source, (MetadataElement) target);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyPreferredTileSize(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_copyPreferredTileSize", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct)) {
        return NULL;
    }
    ProductUtils_copyPreferredTileSize((Product) sourceProduct, (Product) targetProduct);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata2(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_createGeoTIFFMetadata2", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_createGeoTIFFMetadata2((Product) product);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoTIFFMetadata", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_createGeoTIFFMetadata1(PyObject* self, PyObject* args)
{
    const char* geoCodingType;
    unsigned PY_LONG_LONG geoCoding;
    int width;
    int height;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)ii:ProductUtils_createGeoTIFFMetadata1", &geoCodingType, &geoCoding, &width, &height)) {
        return NULL;
    }
    result = ProductUtils_createGeoTIFFMetadata1((GeoCoding) geoCoding, width, height);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeoTIFFMetadata", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_areaToPath(PyObject* self, PyObject* args)
{
    const char* negativeAreaType;
    unsigned PY_LONG_LONG negativeArea;
    double deltaX;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)d:ProductUtils_areaToPath", &negativeAreaType, &negativeArea, &deltaX)) {
        return NULL;
    }
    result = ProductUtils_areaToPath((Area) negativeArea, deltaX);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "GeneralPath", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_addElementToHistory(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    const char* elemType;
    unsigned PY_LONG_LONG elem;
    if (!PyArg_ParseTuple(args, "(sK)(sK):ProductUtils_addElementToHistory", &productType, &product, &elemType, &elem)) {
        return NULL;
    }
    ProductUtils_addElementToHistory((Product) product, (MetadataElement) elem);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_removeInvalidExpressions(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    char** result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_removeInvalidExpressions", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_removeInvalidExpressions((Product) product, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_string_array(result, resultLength);
        beam_release_string_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_findSuitableQuicklookBandName(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):ProductUtils_findSuitableQuicklookBandName", &productType, &product)) {
        return NULL;
    }
    result = ProductUtils_findSuitableQuicklookBandName((Product) product);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_computeSourcePixelCoordinates(PyObject* self, PyObject* args)
{
    const char* sourceGeoCodingType;
    unsigned PY_LONG_LONG sourceGeoCoding;
    int sourceWidth;
    int sourceHeight;
    const char* destGeoCodingType;
    unsigned PY_LONG_LONG destGeoCoding;
    const char* destAreaType;
    unsigned PY_LONG_LONG destArea;
    PixelPos* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "(sK)ii(sK)(sK):ProductUtils_computeSourcePixelCoordinates", &sourceGeoCodingType, &sourceGeoCoding, &sourceWidth, &sourceHeight, &destGeoCodingType, &destGeoCoding, &destAreaType, &destArea)) {
        return NULL;
    }
    result = ProductUtils_computeSourcePixelCoordinates((GeoCoding) sourceGeoCoding, sourceWidth, sourceHeight, (GeoCoding) destGeoCoding, (Rectangle) destArea, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_jobject_array("PixelPos", result, resultLength);
        beam_release_object_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_computeMinMaxY(PyObject* self, PyObject* args)
{
    PixelPos pixelPositions;
    int pixelPositionsLength;
    PyObject* pixelPositionsSeq;
    float* result;
    int resultLength;
    PyObject* resultSeq;
    if (!PyArg_ParseTuple(args, "O:ProductUtils_computeMinMaxY", &pixelPositionsSeq)) {
        return NULL;
    }
    pixelPositions = beam_new_jobject_array_from_pyseq("PixelPos", pixelPositionsSeq, &pixelPositionsLength);
    result = ProductUtils_computeMinMaxY(pixelPositions, pixelPositionsLength, &resultLength);
    if (result != NULL) {
        resultSeq = beam_new_pyseq_from_float_array(result, resultLength);
        beam_release_primitive_array(result, resultLength);
        return resultSeq;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform1(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    double defaultNoDataValue;
    const char* addedRasterDataNodesType;
    unsigned PY_LONG_LONG addedRasterDataNodes;
    if (!PyArg_ParseTuple(args, "(sK)(sK)d(sK):ProductUtils_copyBandsForGeomTransform1", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &defaultNoDataValue, &addedRasterDataNodesType, &addedRasterDataNodes)) {
        return NULL;
    }
    ProductUtils_copyBandsForGeomTransform1((Product) sourceProduct, (Product) targetProduct, defaultNoDataValue, (Map) addedRasterDataNodes);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_copyBandsForGeomTransform2(PyObject* self, PyObject* args)
{
    const char* sourceProductType;
    unsigned PY_LONG_LONG sourceProduct;
    const char* targetProductType;
    unsigned PY_LONG_LONG targetProduct;
    boolean includeTiePointGrids;
    double defaultNoDataValue;
    const char* targetToSourceMapType;
    unsigned PY_LONG_LONG targetToSourceMap;
    if (!PyArg_ParseTuple(args, "(sK)(sK)pd(sK):ProductUtils_copyBandsForGeomTransform2", &sourceProductType, &sourceProduct, &targetProductType, &targetProduct, &includeTiePointGrids, &defaultNoDataValue, &targetToSourceMapType, &targetToSourceMap)) {
        return NULL;
    }
    ProductUtils_copyBandsForGeomTransform2((Product) sourceProduct, (Product) targetProduct, includeTiePointGrids, defaultNoDataValue, (Map) targetToSourceMap);
    return Py_BuildValue("");
}

PyObject* BeamPyProductUtils_getScanLineTime(PyObject* self, PyObject* args)
{
    const char* productType;
    unsigned PY_LONG_LONG product;
    double y;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)d:ProductUtils_getScanLineTime", &productType, &product, &y)) {
        return NULL;
    }
    result = ProductUtils_getScanLineTime((Product) product, y);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData_UTC", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyProductUtils_getGeophysicalSampleDouble(PyObject* self, PyObject* args)
{
    const char* bandType;
    unsigned PY_LONG_LONG band;
    int pixelX;
    int pixelY;
    int level;
    double result;
    if (!PyArg_ParseTuple(args, "(sK)iii:ProductUtils_getGeophysicalSampleDouble", &bandType, &band, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    result = ProductUtils_getGeophysicalSampleDouble((Band) band, pixelX, pixelY, level);
    return PyFloat_FromDouble(result);
}

PyObject* BeamPyProductUtils_getGeophysicalSampleLong(PyObject* self, PyObject* args)
{
    const char* bandType;
    unsigned PY_LONG_LONG band;
    int pixelX;
    int pixelY;
    int level;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK)iii:ProductUtils_getGeophysicalSampleLong", &bandType, &band, &pixelX, &pixelY, &level)) {
        return NULL;
    }
    result = ProductUtils_getGeophysicalSampleLong((Band) band, pixelX, pixelY, level);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyMetadataAttribute_newMetadataAttribute(PyObject* self, PyObject* args)
{
    const char* name;
    const char* dataType;
    unsigned PY_LONG_LONG data;
    boolean readOnly;
    void* result;
    if (!PyArg_ParseTuple(args, "s(sK)p:MetadataAttribute_newMetadataAttribute", &name, &dataType, &data, &readOnly)) {
        return NULL;
    }
    result = MetadataAttribute_newMetadataAttribute(name, (ProductData) data, readOnly);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getParentElement(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getParentElement", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getParentElement((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataElement", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_equals(PyObject* self, PyObject* args)
{
    const char* objectType;
    unsigned PY_LONG_LONG object;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataAttribute_equals", &thisObjType, &thisObj, &objectType, &object)) {
        return NULL;
    }
    result = MetadataAttribute_equals((MetadataAttribute) thisObj, (Object) object);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_acceptVisitor(PyObject* self, PyObject* args)
{
    const char* visitorType;
    unsigned PY_LONG_LONG visitor;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataAttribute_acceptVisitor", &thisObjType, &thisObj, &visitorType, &visitor)) {
        return NULL;
    }
    MetadataAttribute_acceptVisitor((MetadataAttribute) thisObj, (ProductVisitor) visitor);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createDeepClone(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_createDeepClone", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_createDeepClone((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "MetadataAttribute", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getDataType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getDataType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getDataType((MetadataAttribute) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_isFloatingPointType(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_isFloatingPointType", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_isFloatingPointType((MetadataAttribute) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_getNumDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    dlong result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getNumDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getNumDataElems((MetadataAttribute) thisObj);
    return PyLong_FromLongLong(result);
}

PyObject* BeamPyMetadataAttribute_setData(PyObject* self, PyObject* args)
{
    const char* dataType;
    unsigned PY_LONG_LONG data;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataAttribute_setData", &thisObjType, &thisObj, &dataType, &data)) {
        return NULL;
    }
    MetadataAttribute_setData((MetadataAttribute) thisObj, (ProductData) data);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getData(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getData", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getData((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getDataElems(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getDataElems", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getDataElems((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Object", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getDataElemSize(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    int result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getDataElemSize", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getDataElemSize((MetadataAttribute) thisObj);
    return PyLong_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_setReadOnly(PyObject* self, PyObject* args)
{
    boolean readOnly;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:MetadataAttribute_setReadOnly", &thisObjType, &thisObj, &readOnly)) {
        return NULL;
    }
    MetadataAttribute_setReadOnly((MetadataAttribute) thisObj, readOnly);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isReadOnly(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_isReadOnly", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_isReadOnly((MetadataAttribute) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_setUnit(PyObject* self, PyObject* args)
{
    const char* unit;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataAttribute_setUnit", &thisObjType, &thisObj, &unit)) {
        return NULL;
    }
    MetadataAttribute_setUnit((MetadataAttribute) thisObj, unit);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getUnit(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getUnit", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getUnit((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_fireProductNodeDataChanged(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_fireProductNodeDataChanged", &thisObjType, &thisObj)) {
        return NULL;
    }
    MetadataAttribute_fireProductNodeDataChanged((MetadataAttribute) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_dispose(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_dispose", &thisObjType, &thisObj)) {
        return NULL;
    }
    MetadataAttribute_dispose((MetadataAttribute) thisObj);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_createCompatibleProductData(PyObject* self, PyObject* args)
{
    int numElems;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK)i:MetadataAttribute_createCompatibleProductData", &thisObjType, &thisObj, &numElems)) {
        return NULL;
    }
    result = MetadataAttribute_createCompatibleProductData((MetadataAttribute) thisObj, numElems);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductData", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getOwner(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getOwner", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getOwner((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductNode", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getName((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_setName(PyObject* self, PyObject* args)
{
    const char* name;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataAttribute_setName", &thisObjType, &thisObj, &name)) {
        return NULL;
    }
    MetadataAttribute_setName((MetadataAttribute) thisObj, name);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_getDescription(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getDescription", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getDescription((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_setDescription(PyObject* self, PyObject* args)
{
    const char* description;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)s:MetadataAttribute_setDescription", &thisObjType, &thisObj, &description)) {
        return NULL;
    }
    MetadataAttribute_setDescription((MetadataAttribute) thisObj, description);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_isModified(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    boolean result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_isModified", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_isModified((MetadataAttribute) thisObj);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_setModified(PyObject* self, PyObject* args)
{
    boolean modified;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)p:MetadataAttribute_setModified", &thisObjType, &thisObj, &modified)) {
        return NULL;
    }
    MetadataAttribute_setModified((MetadataAttribute) thisObj, modified);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_toString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_toString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_toString((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_isValidNodeName(PyObject* self, PyObject* args)
{
    const char* name;
    boolean result;
    if (!PyArg_ParseTuple(args, "s:MetadataAttribute_isValidNodeName", &name)) {
        return NULL;
    }
    result = MetadataAttribute_isValidNodeName(name);
    return PyBool_FromLong(result);
}

PyObject* BeamPyMetadataAttribute_getProduct(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getProduct", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getProduct((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "Product", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getProductReader(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getProductReader", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getProductReader((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductReader", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getProductWriter(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    void* result;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getProductWriter", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getProductWriter((MetadataAttribute) thisObj);
    if (result != NULL) {
        return Py_BuildValue("(sK)", "ProductWriter", (unsigned PY_LONG_LONG) result);
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getDisplayName(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getDisplayName", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getDisplayName((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_getProductRefString(PyObject* self, PyObject* args)
{
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    char* result;
    PyObject* resultStr;
    if (!PyArg_ParseTuple(args, "(sK):MetadataAttribute_getProductRefString", &thisObjType, &thisObj)) {
        return NULL;
    }
    result = MetadataAttribute_getProductRefString((MetadataAttribute) thisObj);
    if (result != NULL) {
        resultStr = PyUnicode_FromString(result);
        beam_release_string(result);
        return resultStr;
    } else {
        return Py_BuildValue("");
    }
}

PyObject* BeamPyMetadataAttribute_updateExpression(PyObject* self, PyObject* args)
{
    const char* oldExternalName;
    const char* newExternalName;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)ss:MetadataAttribute_updateExpression", &thisObjType, &thisObj, &oldExternalName, &newExternalName)) {
        return NULL;
    }
    MetadataAttribute_updateExpression((MetadataAttribute) thisObj, oldExternalName, newExternalName);
    return Py_BuildValue("");
}

PyObject* BeamPyMetadataAttribute_removeFromFile(PyObject* self, PyObject* args)
{
    const char* productWriterType;
    unsigned PY_LONG_LONG productWriter;
    const char* thisObjType;
    unsigned PY_LONG_LONG thisObj;
    if (!PyArg_ParseTuple(args, "(sK)(sK):MetadataAttribute_removeFromFile", &thisObjType, &thisObj, &productWriterType, &productWriter)) {
        return NULL;
    }
    MetadataAttribute_removeFromFile((MetadataAttribute) thisObj, (ProductWriter) productWriter);
    return Py_BuildValue("");
}



PyObject* beam_new_pyseq_from_boolean_array(const boolean* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyBool_FromLong(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

boolean* beam_new_boolean_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    boolean* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (boolean*) malloc(size * sizeof (boolean));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (boolean)(PyLong_AsLong(item) != 0);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_char_array(const char* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyUnicode_FromFormat("%c", elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

char* beam_new_char_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    char* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (char*) malloc(size * sizeof (char));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (char) PyLong_AsLong(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_byte_array(const byte* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

byte* beam_new_byte_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    byte* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (byte*) malloc(size * sizeof (byte));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (byte) PyLong_AsLong(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_short_array(const short* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

short* beam_new_short_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    short* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (short*) malloc(size * sizeof (short));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (short) PyLong_AsLong(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_int_array(const int* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLong(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

int* beam_new_int_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    int* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (int*) malloc(size * sizeof (int));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (int) PyLong_AsLong(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_dlong_array(const dlong* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyLong_FromLongLong(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

dlong* beam_new_dlong_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    dlong* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (dlong*) malloc(size * sizeof (dlong));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = PyLong_AsLongLong(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_float_array(const float* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyFloat_FromDouble(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

float* beam_new_float_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    float* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (float*) malloc(size * sizeof (float));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = (float) PyFloat_AsDouble(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_double_array(const double* elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyFloat_FromDouble(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

double* beam_new_double_array_from_pyseq(PyObject* seq, int* length)
{
    Py_ssize_t size;
    double* elems;
    Py_ssize_t i;
    PyObject* item;

    size = PySequence_Size(seq);
    elems = (double*) malloc(size * sizeof (double));
    if (elems == NULL) {
        /* todo: throw Python exception */
        return NULL;
    }
    for (i = 0; i < size; i++) {
        item = PySequence_GetItem(seq, i);
        if (item == NULL) {
            free(elems);
            return NULL;
        }
        elems[i] = PyFloat_AsDouble(item);
    }
    /* todo: check if conversion to int is ok */
    *length = (int) size;
    return elems;
}

PyObject* beam_new_pyseq_from_jobject_array(const char* type, const void** elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = Py_BuildValue("(sK)", type, (unsigned PY_LONG_LONG) elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

void** beam_new_jobject_array_from_pyseq(const char* type, PyObject* seq, int* length)
{
    /*
       todo: implement me!
       Use char* PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
       PyArg_ParseTuple(item, "(sK)", &itemType, &itemObj);
     */
    return NULL;
}


PyObject* beam_new_pyseq_from_string_array(const char** elems, int length)
{
    PyObject* list;
    PyObject* item;
    int i;
    list = PyList_New(length);
    if (list == NULL) {
        return NULL;
    }
    for (i = 0; i < length; i++) {
        item = PyUnicode_FromString(elems[i]);
        if (item == NULL) {
            Py_DECREF(list);
            return NULL;
        }
        if (PyList_SetItem(list, i, item) != 0) {
            Py_DECREF(item);
            Py_DECREF(list);
            return NULL;
        }
    }
    return list;
}

char** beam_new_string_array_from_pyseq(PyObject* seq, int* length)
{
    /* todo: implement me!
       Use char* PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     */
    return NULL;
}



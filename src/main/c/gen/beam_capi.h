/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * File created at Wed Oct 31 12:35:23 CET 2012 using org.esa.beam.extapi.gen.GeneratorDoclet
 */


/* Wrapped API classes */
typedef void* ProductIO;
typedef void* ProductReader;
typedef void* ProductWriter;
typedef void* AngularDirection;
typedef void* Band;
typedef void* ColorPaletteDef;
typedef void* ColorPaletteDef_Point;
typedef void* FlagCoding;
typedef void* GeoCoding;
typedef void* GeoPos;
typedef void* ImageGeometry;
typedef void* ImageInfo;
typedef void* IndexCoding;
typedef void* MetadataAttribute;
typedef void* MetadataElement;
typedef void* PixelPos;
typedef void* Placemark;
typedef void* PlacemarkGroup;
typedef void* Product;
typedef void* ProductData;
typedef void* ProductManager;
typedef void* ProductNodeGroup;
typedef void* RGBChannelDef;
typedef void* RasterDataNode;
typedef void* SampleCoding;
typedef void* TiePointGrid;
typedef void* VectorDataNode;
typedef void* GPF;
typedef void* Operator;
typedef void* OperatorException;
typedef void* OperatorSpi;
typedef void* OperatorSpiRegistry;
typedef void* Tile;
typedef void* Tile_Pos;
typedef void* ProductUtils;


typedef char byte;
typedef unsigned char boolean;
typedef long long dlong;


/* Non-API classes used in the API */
typedef void* AffineTransform;
typedef void* Mask;
typedef void* Throwable;
typedef void* Class;
typedef void* ServiceRegistry;
typedef void* FeatureCollection;
typedef void* ProductNode;
typedef void* Rectangle;
typedef void* Object;
typedef void* ReferencedEnvelope;
typedef void* ProductReaderPlugIn;
typedef void* IndexValidator;
typedef void* Area;
typedef void* ComponentColorModel;
typedef void* MathTransform;
typedef void* CoordinateReferenceSystem;
typedef void* ProductWriterPlugIn;
typedef void* IndexColorModel;
typedef void* ProductNodeListener;
typedef void* Product_AutoGrouping;
typedef void* Color;
typedef void* TransectProfileData;
typedef void* T;
typedef void* ProductVisitor;
typedef void* WritableNamespace;
typedef void* MultiLevelImage;
typedef void* ROI;
typedef void* BorderExtender;
typedef void* Logger;
typedef void* Mask_ImageType;
typedef void* ImageInputStream;
typedef void* RenderingHints;
typedef void* ProductManager_Listener;
typedef void* Shape;
typedef void* MapTransform;
typedef void* Parser;
typedef void* ImageInfo_HistogramMatching;
typedef void* Double;
typedef void* Term;
typedef void* ImageOutputStream;
typedef void* Stx;
typedef void* Dimension;
typedef void* ProductData_UTC;
typedef void* SimpleFeatureType;
typedef void* Integer;
typedef void* RenderedImage;
typedef void* Iterator;
typedef void* File;
typedef void* MapProjection;
typedef void* Map;
typedef void* Pointing;
typedef void* PointingFactory;
typedef void* PlacemarkDescriptor;
typedef void* Point2D;
typedef void* Scaling;
typedef void* Collection;
typedef void* GeoTIFFMetadata;
typedef void* MapInfo;
typedef void* BufferedImage;
typedef void* SimpleFeature;
typedef void* ProductSubsetDef;
typedef void* ProgressMonitor;
typedef void* GeneralPath;

int beam_init_vm();

/* Functions for class ProductIO */

/**
 * Gets a product reader for the given format name.
 */
ProductReader ProductIO_getProductReader(const char* formatName);
/**
 * Gets an array of writer product file extensions for the given format name.
 */
char** ProductIO_getProductWriterExtensions(const char* formatName, size_t* resultArrayLength);
/**
 * Gets a product writer for the given format name.
 */
ProductWriter ProductIO_getProductWriter(const char* formatName);
/**
 * Reads the data product specified by the given file.
 <p>The returned product will be associated with a reader capable of decoding the file (also
 see {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).
 If more than one appropriate reader exists in the registry, the returned product will be
 associated with the reader which is the most preferred according to the product format names
 supplied as last argument. If no reader capable of decoding the file is capable of handling
 any of these product formats, the returned product will be associated with the first reader
 found in the registry which is capable of decoding the file.</p>
 <p/>
 <p>The method does not automatically load band raster data, so
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct1(File file, const char** formatNamesElems, int formatNamesLength);
/**
 * Reads the data product specified by the given file path.
 <p>The product returned will be associated with the reader appropriate for the given
 file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>
 <p>The method does not automatically read band data, thus
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct2(const char* filePath);
/**
 * Reads the data product specified by the given file.
 <p>The product returned will be associated with the reader appropriate for the given
 file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>
 <p>The method does not automatically read band data, thus
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct3(File file);
/**
 * Tries to find a product reader instance suitable for the given input.
 The method returns {@code null}, if no
 registered product reader can handle the given {@code input} value.
 <p/>
 The {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or
 {@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.
 */
ProductReader ProductIO_getProductReaderForInput(Object input);
/**
 * Writes a product with the specified format to the given file path.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct1(Product product, const char* filePath, const char* formatName);
/**
 * Writes a product with the specified format to the given file path.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct2(Product product, const char* filePath, const char* formatName, ProgressMonitor pm);
/**
 * Writes a product with the specified format to the given file.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct3(Product product, File file, const char* formatName, boolean incremental);
/**
 * Writes a product with the specified format to the given file.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct4(Product product, File file, const char* formatName, boolean incremental, ProgressMonitor pm);

/* Functions for class ProductReader */

/**
 * Returns the plug-in which created this product reader.
 */
ProductReaderPlugIn ProductReader_getReaderPlugIn(ProductReader _self);
/**
 * Retrives the current input destination object. Thie return value might be <code>null</code> if the
 <code>setInput</code> has not been called so far.
 */
Object ProductReader_getInput(ProductReader _self);
/**
 * Returns the subset information with which this a data product is read from its physical source.
 */
ProductSubsetDef ProductReader_getSubsetDef(ProductReader _self);
/**
 * Reads a data product and returns a in-memory representation of it.
 <p/>
 <p> The given subset info can be used to specify spatial and spectral portions of the original proudct. If the
 subset is omitted, the complete product is read in.
 <p/>
 <p> Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,
 is up to the implementation.
 */
Product ProductReader_readProductNodes(ProductReader _self, Object input, ProductSubsetDef subsetDef);
/**
 * Reads raster data from the data source specified by the given destination band into the given in-memory buffer
 and region.
 <p/>
 <h3>Destination band</h3> The destination band is used to identify the data source from which this method
 transfers the sample values into the given destination buffer. The method does not modify the given destination
 band at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method
 should also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.
 <p/>
 <h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,
 <code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's
 raster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and
 sub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset
 and sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The
 destination region should always specify a sub-region of the band's scene raster.
 <p/>
 <h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given
 <code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are
 <b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *
 destHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies
 faster than the Y co-ordinate.
 */
void ProductReader_readBandRasterData(ProductReader _self, Band destBand, int destOffsetX, int destOffsetY, int destWidth, int destHeight, ProductData destBuffer, ProgressMonitor pm);
/**
 * Closes the access to all currently opened resources such as file input streams and all resources of this children
 directly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>close()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.close();</code> after disposing this instance.
 */
void ProductReader_close(ProductReader _self);

/* Functions for class ProductWriter */

/**
 * Returns the plug-in which created this product writer.
 */
ProductWriterPlugIn ProductWriter_getWriterPlugIn(ProductWriter _self);
/**
 * Retrives the current output destination object. Thie return value might be <code>null</code> if the
 <code>setOutput</code> has not been called so far.
 */
Object ProductWriter_getOutput(ProductWriter _self);
/**
 * Writes the in-memory representation of a data product.
 <p/>
 <p> Whether the band data - the actual pixel values - is written out immediately or later when pixels are
 flushed, is up to the implementation.
 */
void ProductWriter_writeProductNodes(ProductWriter _self, Product product, Object output);
/**
 * Writes raster data from the given in-memory source buffer into the data sink specified by the given source band
 and region.
 <p/>
 <h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample
 values given in the source buffer. The method does not modify the pixel data of the given source band at all.
 <p/>
 <h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>
 and <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data
 and <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be
 <code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in
 line-by-line order, so the raster X co-ordinate varies faster than the Y.
 <p/>
 <h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,
 <code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the
 source band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates
 since product writers do not support spectral or spatial subsets.
 */
void ProductWriter_writeBandRasterData(ProductWriter _self, Band sourceBand, int sourceOffsetX, int sourceOffsetY, int sourceWidth, int sourceHeight, ProductData sourceBuffer, ProgressMonitor pm);
/**
 * Writes all data in memory to the data sink(s) associated with this writer.
 */
void ProductWriter_flush(ProductWriter _self);
/**
 * Closes all output streams currently open. A concrete implementation should call <code>flush</code> before
 performing the actual close-operation.
 */
void ProductWriter_close(ProductWriter _self);
/**
 * Returns wether the given product node is to be written.
 */
boolean ProductWriter_shouldWrite(ProductWriter _self, ProductNode node);
/**
 * Returns whether this product writer writes only modified product nodes.
 */
boolean ProductWriter_isIncrementalMode(ProductWriter _self);
/**
 * Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress
 listening.
 */
void ProductWriter_setIncrementalMode(ProductWriter _self, boolean enabled);
/**
 * Complete deletes the physical representation of the given product from the file system.
 */
void ProductWriter_deleteOutput(ProductWriter _self);
/**
 * Physically deletes a <code>Band</code> in a product writer's output.
 */
void ProductWriter_removeBand(ProductWriter _self, Band band);

/* Functions for class AngularDirection */

/**
 * 
 */
AngularDirection AngularDirection_newAngularDirection1();
/**
 * 
 */
AngularDirection AngularDirection_newAngularDirection2(double azimuth, double zenith);
/**
 * 
 */
boolean AngularDirection_equals(AngularDirection _self, Object obj);
/**
 * 
 */
char* AngularDirection_toString(AngularDirection _self);

/* Functions for class Band */

/**
 * Constructs a new <code>Band</code>.
 */
Band Band_newBand(const char* name, int dataType, int width, int height);
/**
 * Gets the flag coding for this band.
 */
FlagCoding Band_getFlagCoding(Band _self);
/**
 * Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).
 */
boolean Band_isFlagBand(Band _self);
/**
 * Gets the index coding for this band.
 */
IndexCoding Band_getIndexCoding(Band _self);
/**
 * Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).
 */
boolean Band_isIndexBand(Band _self);
/**
 * Gets the sample coding.
 */
SampleCoding Band_getSampleCoding(Band _self);
/**
 * Sets the sample coding for this band.
 */
void Band_setSampleCoding(Band _self, SampleCoding sampleCoding);
/**
 * Gets the (zero-based) spectral band index.
 */
int Band_getSpectralBandIndex(Band _self);
/**
 * Sets the (zero-based) spectral band index.
 */
void Band_setSpectralBandIndex(Band _self, int spectralBandIndex);
/**
 * Gets the spectral wavelength in <code>nm</code> (nanomater) units.
 */
float Band_getSpectralWavelength(Band _self);
/**
 * Sets the spectral wavelength in <code>nm</code> (nanomater) units.
 */
void Band_setSpectralWavelength(Band _self, float spectralWavelength);
/**
 * Gets the spectral bandwidth in <code>nm</code> (nanomater) units.
 */
float Band_getSpectralBandwidth(Band _self);
/**
 * Sets the spectral bandwidth in <code>nm</code> (nanomater) units.
 */
void Band_setSpectralBandwidth(Band _self, float spectralBandwidth);
/**
 * Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.
 */
float Band_getSolarFlux(Band _self);
/**
 * Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.
 */
void Band_setSolarFlux(Band _self, float solarFlux);
/**
 * Reads raster data from its associated data source into the given data buffer.
 */
void Band_readRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_readRasterDataFully(Band _self, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_writeRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_writeRasterDataFully(Band _self, ProgressMonitor pm);
/**
 * Gets an estimated raw storage size in bytes of this product node.
 */
dlong Band_getRawStorageSize(Band _self, ProductSubsetDef subsetDef);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void Band_acceptVisitor(Band _self, ProductVisitor visitor);
/**
 * Creates a string defining this band object.
 */
char* Band_toString(Band _self);
/**
 * 
 */
void Band_removeFromFile(Band _self, ProductWriter productWriter);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void Band_dispose(Band _self);

/* Functions for class ColorPaletteDef */

/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef1(double minSample, double maxSample);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef2(double minSample, double centerSample, double maxSample);
/**
 * 
 */
boolean ColorPaletteDef_isDiscrete(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setDiscrete(ColorPaletteDef _self, boolean discrete);
/**
 * 
 */
int ColorPaletteDef_getNumColors(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumColors(ColorPaletteDef _self, int numColors);
/**
 * 
 */
int ColorPaletteDef_getNumPoints(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumPoints(ColorPaletteDef _self, int numPoints);
/**
 * 
 */
boolean ColorPaletteDef_isAutoDistribute(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setAutoDistribute(ColorPaletteDef _self, boolean autoDistribute);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getPointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getFirstPoint(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getLastPoint(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMinDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMaxDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_insertPointAfter(ColorPaletteDef _self, int index, ColorPaletteDef_Point point);
/**
 * creates a new point between the point at the given index
 */
boolean ColorPaletteDef_createPointAfter(ColorPaletteDef _self, int index, Scaling scaling);
/**
 * Creates the center color between the given two colors.
 */
Color ColorPaletteDef_getCenterColor(Color c1, Color c2);
/**
 * 
 */
void ColorPaletteDef_removePointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
void ColorPaletteDef_addPoint(ColorPaletteDef _self, ColorPaletteDef_Point point);
/**
 * 
 */
Iterator ColorPaletteDef_getIterator(ColorPaletteDef _self);
/**
 * 
 */
Object ColorPaletteDef_clone(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_createDeepCopy(ColorPaletteDef _self);
/**
 * Loads a color palette definition from the given file
 */
ColorPaletteDef ColorPaletteDef_loadColorPaletteDef(File file);
/**
 * Stores this color palette definition in the given file
 */
void ColorPaletteDef_storeColorPaletteDef(ColorPaletteDef colorPaletteDef, File file);
/**
 * Releases all of the resources used by this color palette definition and all of its owned children. Its primary
 use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void ColorPaletteDef_dispose(ColorPaletteDef _self);
/**
 * 
 */
Color ColorPaletteDef_computeColor(ColorPaletteDef _self, Scaling scaling, double sample);

/* Functions for class ColorPaletteDef_Point */

/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point1();
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point2(double sample, Color color);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point3(double sample, Color color, const char* label);
/**
 * 
 */
double ColorPaletteDef_Point_getSample(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setSample(ColorPaletteDef_Point _self, double sample);
/**
 * 
 */
Color ColorPaletteDef_Point_getColor(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setColor(ColorPaletteDef_Point _self, Color color);
/**
 * 
 */
char* ColorPaletteDef_Point_getLabel(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setLabel(ColorPaletteDef_Point _self, const char* label);
/**
 * 
 */
Object ColorPaletteDef_Point_clone(ColorPaletteDef_Point _self);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_createClone(ColorPaletteDef_Point _self);

/* Functions for class FlagCoding */

/**
 * Constructs a new flag coding object with the given name.
 */
FlagCoding FlagCoding_newFlagCoding(const char* name);
/**
 * Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to
 getPropertyValue(String).
 */
MetadataAttribute FlagCoding_getFlag(FlagCoding _self, const char* name);
/**
 * Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.
 */
char** FlagCoding_getFlagNames(FlagCoding _self, size_t* resultArrayLength);
/**
 * Adds a new flag definition to this flags coding.
 */
MetadataAttribute FlagCoding_addFlag(FlagCoding _self, const char* name, int flagMask, const char* description);
/**
 * Returns the flag mask value for the specified flag name.
 */
int FlagCoding_getFlagMask(FlagCoding _self, const char* name);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void FlagCoding_acceptVisitor(FlagCoding _self, ProductVisitor visitor);

/* Functions for class GeoCoding */

/**
 * Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.
 */
boolean GeoCoding_isCrossingMeridianAt180(GeoCoding _self);
/**
 * Checks whether or not this geo-coding can determine the pixel position from a geodetic position.
 */
boolean GeoCoding_canGetPixelPos(GeoCoding _self);
/**
 * Checks whether or not this geo-coding can determine the geodetic position from a pixel position.
 */
boolean GeoCoding_canGetGeoPos(GeoCoding _self);
/**
 * Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.
 */
PixelPos GeoCoding_getPixelPos(GeoCoding _self, GeoPos geoPos, PixelPos pixelPos);
/**
 * Returns the latitude and longitude value for a given pixel co-ordinate.
 */
GeoPos GeoCoding_getGeoPos(GeoCoding _self, PixelPos pixelPos, GeoPos geoPos);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 */
void GeoCoding_dispose(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getImageCRS(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getMapCRS(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getGeoCRS(GeoCoding _self);
/**
 * 
 */
MathTransform GeoCoding_getImageToMapTransform(GeoCoding _self);

/* Functions for class GeoPos */

/**
 * Constructs a new geo-position with latitude and longitude set to zero.
 */
GeoPos GeoPos_newGeoPos1();
/**
 * Constructs a new geo-position with latitude and longitude set to that of the given geo-position.
 */
GeoPos GeoPos_newGeoPos2(GeoPos geoPos);
/**
 * Constructs a new geo-position with the given latitude and longitude values.
 */
GeoPos GeoPos_newGeoPos3(float lat, float lon);
/**
 * Gets the latitude value.
 */
float GeoPos_getLat(GeoPos _self);
/**
 * Gets the longitude value.
 */
float GeoPos_getLon(GeoPos _self);
/**
 * Sets the geographical location of this point.
 */
void GeoPos_setLocation(GeoPos _self, float lat, float lon);
/**
 * Tests whether or not this geo-position is valid.
 */
boolean GeoPos_isValid(GeoPos _self);
/**
 * Sets the lat/lon fields so that {@link #isValid()} will return false.
 */
void GeoPos_setInvalid(GeoPos _self);
/**
 * Indicates whether some other object is "equal to" this one.
 */
boolean GeoPos_equals(GeoPos _self, Object obj);
/**
 * Returns a hash code value for the object.
 */
int GeoPos_hashCode(GeoPos _self);
/**
 * Returns a string representation of the object. In general, the <code>toString</code> method returns a string that
 "textually represents" this object.
 */
char* GeoPos_toString(GeoPos _self);
/**
 * Normalizes this position so that its longitude is in the range -180 to +180 degree.
 */
void GeoPos_normalize(GeoPos _self);
/**
 * Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.
 Note that -180 will remain as is, although -180 is equivalent to +180 degrees.
 */
float GeoPos_normalizeLon(float lon);
/**
 * Returns a string representation of the latitude value.
 */
char* GeoPos_getLatString1(GeoPos _self);
/**
 * Returns a string representation of the latitude value.
 */
char* GeoPos_getLonString1(GeoPos _self);
/**
 * Returns a string representation of the given longitude value.
 */
char* GeoPos_getLatString2(float lat);
/**
 * Returns a string representation of the given longitude value.
 */
char* GeoPos_getLonString2(float lon);

/* Functions for class ImageGeometry */

/**
 * 
 */
ImageGeometry ImageGeometry_newImageGeometry(Rectangle bounds, CoordinateReferenceSystem mapCrs, AffineTransform image2map);
/**
 * 
 */
AffineTransform ImageGeometry_getImage2MapTransform(ImageGeometry _self);
/**
 * 
 */
Rectangle ImageGeometry_getImageRect(ImageGeometry _self);
/**
 * 
 */
CoordinateReferenceSystem ImageGeometry_getMapCrs(ImageGeometry _self);
/**
 * 
 */
void ImageGeometry_changeYAxisDirection(ImageGeometry _self);
/**
 * 
 */
Point2D ImageGeometry_calculateEastingNorthing(Product sourceProduct, CoordinateReferenceSystem targetCrs, double referencePixelX, double referencePixelY, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
Rectangle ImageGeometry_calculateProductSize(Product sourceProduct, CoordinateReferenceSystem targetCrs, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
ImageGeometry ImageGeometry_createTargetGeometry(Product sourceProduct, CoordinateReferenceSystem targetCrs, Double pixelSizeX, Double pixelSizeY, Integer width, Integer height, Double orientation, Double easting, Double northing, Double referencePixelX, Double referencePixelY);
/**
 * 
 */
ImageGeometry ImageGeometry_createCollocationTargetGeometry(Product targetProduct, Product collocationProduct);

/* Functions for class ImageInfo */

/**
 * Constructs a new image information instance.
 */
ImageInfo ImageInfo_newImageInfo1(ColorPaletteDef colorPaletteDef);
/**
 * Constructs a new RGB image information instance.
 */
ImageInfo ImageInfo_newImageInfo2(RGBChannelDef rgbChannelDef);
/**
 * Gets the color palette definition as used for images created from single bands.
 */
ColorPaletteDef ImageInfo_getColorPaletteDef(ImageInfo _self);
/**
 * Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.
 */
RGBChannelDef ImageInfo_getRgbChannelDef(ImageInfo _self);
/**
 * 
 */
Color ImageInfo_getNoDataColor(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setNoDataColor(ImageInfo _self, Color noDataColor);
/**
 * 
 */
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching1(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setHistogramMatching(ImageInfo _self, ImageInfo_HistogramMatching histogramMatching);
/**
 * 
 */
boolean ImageInfo_isLogScaled(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setLogScaled(ImageInfo _self, boolean logScaled);
/**
 * Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.
 */
int ImageInfo_getColorComponentCount(ImageInfo _self);
/**
 * 
 */
IndexColorModel ImageInfo_createIndexColorModel(ImageInfo _self, Scaling scaling);
/**
 * 
 */
ComponentColorModel ImageInfo_createComponentColorModel(ImageInfo _self);
/**
 * Creates and returns a copy of this object.
 */
Object ImageInfo_clone(ImageInfo _self);
/**
 * Creates and returns a "deep" copy of this object. The method simply returns the value of
 {@link #clone()}.
 */
ImageInfo ImageInfo_createDeepCopy(ImageInfo _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void ImageInfo_dispose(ImageInfo _self);
/**
 * Transfers the colour palette into this image info.
 */
void ImageInfo_setColorPaletteDef(ImageInfo _self, ColorPaletteDef colorPaletteDef, double minSample, double maxSample, boolean autoDistribute);
/**
 * Converts a string to a histogram matching.
 */
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching2(const char* mode);

/* Functions for class IndexCoding */

/**
 * Constructs a new index coding object with the given name.
 */
IndexCoding IndexCoding_newIndexCoding(const char* name);
/**
 * Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to
 getPropertyValue(String).
 */
MetadataAttribute IndexCoding_getIndex(IndexCoding _self, const char* name);
/**
 * Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.
 */
char** IndexCoding_getIndexNames(IndexCoding _self, size_t* resultArrayLength);
/**
 * Adds a new index definition to this flags coding.
 */
MetadataAttribute IndexCoding_addIndex(IndexCoding _self, const char* name, int value, const char* description);
/**
 * Returns the flag mask value for the specified flag name.
 */
int IndexCoding_getIndexValue(IndexCoding _self, const char* name);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void IndexCoding_acceptVisitor(IndexCoding _self, ProductVisitor visitor);

/* Functions for class MetadataAttribute */

/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute1(const char* name, int type);
/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute2(const char* name, int type, int numElems);
/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute3(const char* name, ProductData data, boolean readOnly);
/**
 * 
 */
MetadataElement MetadataAttribute_getParentElement(MetadataAttribute _self);
/**
 * 
 */
boolean MetadataAttribute_equals(MetadataAttribute _self, Object object);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void MetadataAttribute_acceptVisitor(MetadataAttribute _self, ProductVisitor visitor);
/**
 * 
 */
MetadataAttribute MetadataAttribute_createDeepClone(MetadataAttribute _self);

/* Functions for class MetadataElement */

/**
 * Constructs a new metadata element.
 */
MetadataElement MetadataElement_newMetadataElement(const char* name);
/**
 * Gets the group of child elements. The method returns null, if this element has no children.
 */
ProductNodeGroup MetadataElement_getElementGroup(MetadataElement _self);
/**
 * 
 */
MetadataElement MetadataElement_getParentElement(MetadataElement _self);
/**
 * Adds the given element to this element.
 */
void MetadataElement_addElement(MetadataElement _self, MetadataElement element);
/**
 * Adds the given element to this element at index.
 */
void MetadataElement_addElementAt(MetadataElement _self, MetadataElement element, int index);
/**
 * Removes the given element from this element.
 */
boolean MetadataElement_removeElement(MetadataElement _self, MetadataElement element);
/**
 * 
 */
int MetadataElement_getNumElements(MetadataElement _self);
/**
 * Returns the element at the given index.
 */
MetadataElement MetadataElement_getElementAt(MetadataElement _self, int index);
/**
 * Returns a string array containing the names of the groups contained in this element
 */
char** MetadataElement_getElementNames(MetadataElement _self, size_t* resultArrayLength);
/**
 * Returns the element with the given name.
 */
MetadataElement MetadataElement_getElement(MetadataElement _self, const char* name);
/**
 * Tests if a element with the given name is contained in this element.
 */
boolean MetadataElement_containsElement(MetadataElement _self, const char* name);
/**
 * Gets the index of the given element.
 */
int MetadataElement_getElementIndex(MetadataElement _self, MetadataElement element);
/**
 * Adds an attribute to this node.
 */
void MetadataElement_addAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 * Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.
 */
boolean MetadataElement_removeAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 * Returns the number of attributes attaached to this node.
 */
int MetadataElement_getNumAttributes(MetadataElement _self);
/**
 * Returns the attribute at the given index.
 */
MetadataAttribute MetadataElement_getAttributeAt(MetadataElement _self, int index);
/**
 * Returns the names of all attributes of this node.
 */
char** MetadataElement_getAttributeNames(MetadataElement _self, size_t* resultArrayLength);
/**
 * Returns the attribute with the given name.
 */
MetadataAttribute MetadataElement_getAttribute(MetadataElement _self, const char* name);
/**
 * Checks whether this node has an element with the given name.
 */
boolean MetadataElement_containsAttribute(MetadataElement _self, const char* name);
/**
 * Gets the index of the given attribute.
 */
int MetadataElement_getAttributeIndex(MetadataElement _self, MetadataAttribute attribute);
/**
 * Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
double MetadataElement_getAttributeDouble1(MetadataElement _self, const char* name, double defaultValue);
/**
 * Returns the double value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
double MetadataElement_getAttributeDouble2(MetadataElement _self, const char* name);
/**
 * Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
ProductData_UTC MetadataElement_getAttributeUTC1(MetadataElement _self, const char* name, ProductData_UTC defaultValue);
/**
 * Returns the UTC value of the attribute with the given name.
 */
ProductData_UTC MetadataElement_getAttributeUTC2(MetadataElement _self, const char* name);
/**
 * Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
int MetadataElement_getAttributeInt1(MetadataElement _self, const char* name, int defaultValue);
/**
 * Returns the integer value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
int MetadataElement_getAttributeInt2(MetadataElement _self, const char* name);
/**
 * Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeInt(MetadataElement _self, const char* name, int value);
/**
 * Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeDouble(MetadataElement _self, const char* name, double value);
/**
 * Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC value);
/**
 * Returns the string value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
char* MetadataElement_getAttributeString1(MetadataElement _self, const char* name);
/**
 * Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
char* MetadataElement_getAttributeString2(MetadataElement _self, const char* name, const char* defaultValue);
/**
 * Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeString(MetadataElement _self, const char* name, const char* value);
/**
 * 
 */
void MetadataElement_setModified(MetadataElement _self, boolean modified);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then
 visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.
 */
void MetadataElement_acceptVisitor(MetadataElement _self, ProductVisitor visitor);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong MetadataElement_getRawStorageSize(MetadataElement _self, ProductSubsetDef subsetDef);
/**
 * 
 */
MetadataElement MetadataElement_createDeepClone(MetadataElement _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void MetadataElement_dispose(MetadataElement _self);

/* Functions for class PixelPos */

/**
 * Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0).
 */
PixelPos PixelPos_newPixelPos1();
/**
 * Constructs and initializes a <code>PixelPos</code> with the specified coordinate.
 */
PixelPos PixelPos_newPixelPos2(float x, float y);
/**
 * Tests whether or not this pixel position is valid.
 */
boolean PixelPos_isValid(PixelPos _self);
/**
 * Sets this pixel position so that is becomes invalid.
 */
void PixelPos_setInvalid(PixelPos _self);

/* Functions for class Placemark */

/**
 * Constructor.
 */
Placemark Placemark_newPlacemark(PlacemarkDescriptor descriptor, SimpleFeature feature);
/**
 * Creates a point placemark.
 */
Placemark Placemark_createPointPlacemark(PlacemarkDescriptor descriptor, const char* name, const char* label, const char* text, PixelPos pixelPos, GeoPos geoPos, GeoCoding geoCoding);
/**
 * 
 */
PlacemarkDescriptor Placemark_getDescriptor(Placemark _self);
/**
 * 
 */
SimpleFeature Placemark_getFeature(Placemark _self);
/**
 * Gets the attribute value of the underlying feature.
 */
Object Placemark_getAttributeValue(Placemark _self, const char* attributeName);
/**
 * Sets the attribute value of the underlying feature.
 */
void Placemark_setAttributeValue(Placemark _self, const char* attributeName, Object attributeValue);
/**
 * Sets this placemark's label.
 */
void Placemark_setLabel(Placemark _self, const char* label);
/**
 * 
 */
char* Placemark_getLabel(Placemark _self);
/**
 * Sets this placemark's (XHTML) text.
 */
void Placemark_setText(Placemark _self, const char* text);
/**
 * 
 */
char* Placemark_getText(Placemark _self);
/**
 * Sets this placemark's CSS style.
 */
void Placemark_setStyleCss(Placemark _self, const char* styleCss);
/**
 * 
 */
char* Placemark_getStyleCss(Placemark _self);
/**
 * Returns an estimated, raw storage size in bytes of this placemark.
 */
dlong Placemark_getRawStorageSize(Placemark _self, ProductSubsetDef subsetDef);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 */
void Placemark_acceptVisitor(Placemark _self, ProductVisitor visitor);
/**
 * 
 */
PixelPos Placemark_getPixelPos(Placemark _self);
/**
 * 
 */
void Placemark_setPixelPos(Placemark _self, PixelPos pixelPos);
/**
 * 
 */
GeoPos Placemark_getGeoPos(Placemark _self);
/**
 * 
 */
void Placemark_setGeoPos(Placemark _self, GeoPos geoPos);
/**
 * Updates pixel and geo position according to the current geometry (model coordinates).
 */
void Placemark_updatePositions(Placemark _self);
/**
 * 
 */
SimpleFeatureType Placemark_createPinFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGcpFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGeometryFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createPointFeatureType(const char* name);

/* Functions for class PlacemarkGroup */

/**
 * 
 */
VectorDataNode PlacemarkGroup_getVectorDataNode(PlacemarkGroup _self);
/**
 * 
 */
Placemark PlacemarkGroup_getPlacemark(PlacemarkGroup _self, SimpleFeature feature);
/**
 * 
 */
boolean PlacemarkGroup_add1(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_add2(PlacemarkGroup _self, int index, Placemark placemark);
/**
 * 
 */
boolean PlacemarkGroup_remove(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_dispose(PlacemarkGroup _self);

/* Functions for class Product */

/**
 * Creates a new product without any reader (in-memory product)
 */
Product Product_newProduct1(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight);
/**
 * Constructs a new product with the given name and the given reader.
 */
Product Product_newProduct2(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight, ProductReader reader);
/**
 * Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no
 disk location (pure virtual memory product)
 */
File Product_getFileLocation(Product _self);
/**
 * Sets the file location for this product.
 */
void Product_setFileLocation(Product _self, File fileLocation);
/**
 * Gets the product type string.
 */
char* Product_getProductType(Product _self);
/**
 * Sets the product type of this product.
 */
void Product_setProductType(Product _self, const char* productType);
/**
 * Sets the product reader which will be used to create this product in-memory represention from an external source
 and which will be used to (re-)load band rasters.
 */
void Product_setProductReader(Product _self, ProductReader reader);
/**
 * Returns the reader which was used to create this product in-memory represention from an external source and which
 will be used to (re-)load band rasters.
 */
ProductReader Product_getProductReader(Product _self);
/**
 * Sets the writer which will be used to write modifications of this product's in-memory represention to an external
 destination.
 */
void Product_setProductWriter(Product _self, ProductWriter writer);
/**
 * Returns the writer which will be used to write modifications of this product's in-memory represention to an
 external destination.
 */
ProductWriter Product_getProductWriter(Product _self);
/**
 * <p>Writes the header of a data product.<p/>
 */
void Product_writeHeader(Product _self, Object output);
/**
 * Closes and clears this product's reader (if any).
 */
void Product_closeProductReader(Product _self);
/**
 * Closes and clears this product's writer (if any).
 */
void Product_closeProductWriter(Product _self);
/**
 * Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and
 <code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but
 should be called if the product instance is no longer in use.
 */
void Product_closeIO(Product _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 </p>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 </p>
 <p>This implementation also calls the <code>closeIO</code> in order to release all open I/O resources.
 */
void Product_dispose(Product _self);
/**
 * Gets the pointing factory associated with this data product.
 */
PointingFactory Product_getPointingFactory(Product _self);
/**
 * Sets the pointing factory for this data product.
 */
void Product_setPointingFactory(Product _self, PointingFactory pointingFactory);
/**
 * Geo-codes this data product.
 */
void Product_setGeoCoding(Product _self, GeoCoding geoCoding);
/**
 * Returns the geo-coding used for this data product.
 */
GeoCoding Product_getGeoCoding(Product _self);
/**
 * Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing
 the band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.
 If this product does not have a geo-coding, the method returns false.
 */
boolean Product_isUsingSingleGeoCoding(Product _self);
/**
 * Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to
 the given {@link ProductSubsetDef subsetDef}.
 */
boolean Product_transferGeoCodingTo(Product _self, Product destProduct, ProductSubsetDef subsetDef);
/**
 * Returns the scene width in pixels for this data product.
 */
int Product_getSceneRasterWidth(Product _self);
/**
 * Returns the scene height in pixels for this data product.
 */
int Product_getSceneRasterHeight(Product _self);
/**
 * Gets the (sensing) start time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>
 */
ProductData_UTC Product_getStartTime(Product _self);
/**
 * Sets the (sensing) start time of this product.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>
 */
void Product_setStartTime(Product _self, ProductData_UTC startTime);
/**
 * Gets the (sensing) stop time associated with the last raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>
 */
ProductData_UTC Product_getEndTime(Product _self);
/**
 * Sets the (sensing) stop time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>
 */
void Product_setEndTime(Product _self, ProductData_UTC endTime);
/**
 * Gets the root element of the associated metadata.
 */
MetadataElement Product_getMetadataRoot(Product _self);
/**
 * Gets the band group of this product.
 */
ProductNodeGroup Product_getBandGroup(Product _self);
/**
 * Gets the tie-point grid group of this product.
 */
ProductNodeGroup Product_getTiePointGridGroup(Product _self);
/**
 * Adds the given tie-point grid to this product.
 */
void Product_addTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 * Removes the tie-point grid from this product.
 */
boolean Product_removeTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 * Returns the number of tie-point grids contained in this product
 */
int Product_getNumTiePointGrids(Product _self);
/**
 * Returns the tie-point grid at the given index.
 */
TiePointGrid Product_getTiePointGridAt(Product _self, int index);
/**
 * Returns a string array containing the names of the tie-point grids contained in this product
 */
char** Product_getTiePointGridNames(Product _self, size_t* resultArrayLength);
/**
 * Returns the tie-point grid with the given name.
 */
TiePointGrid Product_getTiePointGrid(Product _self, const char* name);
/**
 * Tests if a tie-point grid with the given name is contained in this product.
 */
boolean Product_containsTiePointGrid(Product _self, const char* name);
/**
 * Adds the given band to this product.
 */
void Product_addBand1(Product _self, Band band);
/**
 * Creates a new band with the given name and data type and adds it to this product and returns it.
 */
Band Product_addBand2(Product _self, const char* bandName, int dataType);
/**
 * Creates a new band with the given name and adds it to this product and returns it.
 The new band's data type is {@code float} and it's samples are computed from the given band maths expression.
 */
Band Product_addBand3(Product _self, const char* bandName, const char* expression);
/**
 * Creates a new band with the given name and data type and adds it to this product and returns it.
 The new band's samples are computed from the given band maths expression.
 */
Band Product_addBand4(Product _self, const char* bandName, const char* expression, int dataType);
/**
 * Removes the given band from this product.
 */
boolean Product_removeBand(Product _self, Band band);
/**
 * 
 */
int Product_getNumBands(Product _self);
/**
 * Returns the band at the given index.
 */
Band Product_getBandAt(Product _self, int index);
/**
 * Returns a string array containing the names of the bands contained in this product
 */
char** Product_getBandNames(Product _self, size_t* resultArrayLength);
/**
 * Returns the band with the given name.
 */
Band Product_getBand(Product _self, const char* name);
/**
 * Returns the index for the band with the given name.
 */
int Product_getBandIndex(Product _self, const char* name);
/**
 * Tests if a band with the given name is contained in this product.
 */
boolean Product_containsBand(Product _self, const char* name);
/**
 * Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or
 tie-point grids.
 */
boolean Product_containsRasterDataNode(Product _self, const char* name);
/**
 * Gets the raster data node with the given name. The method first searches for bands with the given name, then for
 tie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.
 */
RasterDataNode Product_getRasterDataNode(Product _self, const char* name);
/**
 * 
 */
ProductNodeGroup Product_getMaskGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getVectorDataGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getFlagCodingGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getIndexCodingGroup(Product _self);
/**
 * Tests if the given pixel position is within the product pixel bounds.
 */
boolean Product_containsPixel1(Product _self, float x, float y);
/**
 * Tests if the given pixel position is within the product pixel bounds.
 */
boolean Product_containsPixel2(Product _self, PixelPos pixelPos);
/**
 * Gets the group of ground-control points (GCPs).
 Note that this method will create the group, if none exists already.
 */
PlacemarkGroup Product_getGcpGroup(Product _self);
/**
 * Gets the group of pins.
 Note that this method will create the group, if none exists already.
 */
PlacemarkGroup Product_getPinGroup(Product _self);
/**
 * Checks whether or not the given product is compatible with this product.
 */
boolean Product_isCompatibleProduct(Product _self, Product product, float eps);
/**
 * Parses a mathematical expression given as a text string.
 */
Term Product_parseExpression(Product _self, const char* expression);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag
 codings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.
 */
void Product_acceptVisitor(Product _self, ProductVisitor visitor);
/**
 * Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each
 time a node in this product changes.
 */
boolean Product_addProductNodeListener(Product _self, ProductNodeListener listener);
/**
 * Removes a <code>ProductNodeListener</code> from this product.
 */
void Product_removeProductNodeListener(Product _self, ProductNodeListener listener);
/**
 * 
 */
int Product_getRefNo(Product _self);
/**
 * Sets the reference number.
 */
void Product_setRefNo(Product _self, int refNo);
/**
 * 
 */
void Product_resetRefNo(Product _self);
/**
 * Returns the product manager for this product.
 */
ProductManager Product_getProductManager(Product _self);
/**
 * Tests if the given band arithmetic expression can be computed using this product.
 */
boolean Product_isCompatibleBandArithmeticExpression1(Product _self, const char* expression);
/**
 * Tests if the given band arithmetic expression can be computed using this product and a given expression parser.
 */
boolean Product_isCompatibleBandArithmeticExpression2(Product _self, const char* expression, Parser parser);
/**
 * Creates a parser for band arithmetic expressions.
 The parser created will use a namespace comprising all tie-point grids, bands and flags of this product.
 */
Parser Product_createBandArithmeticParser(Product _self);
/**
 * Creates a namespace to be used by parsers for band arithmetic expressions.
 The namespace created comprises all tie-point grids, bands and flags of this product.
 */
WritableNamespace Product_createBandArithmeticDefaultNamespace(Product _self);
/**
 * Creates a subset of this product. The returned product represents a true spatial and spectral subset of this
 product, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the
 description from this product was used.
 */
Product Product_createSubset(Product _self, ProductSubsetDef subsetDef, const char* name, const char* desc);
/**
 * Creates a map-projected version of this product.
 */
Product Product_createProjectedProduct(Product _self, MapInfo mapInfo, const char* name, const char* desc);
/**
 * Creates flipped raster-data version of this product.
 */
Product Product_createFlippedProduct(Product _self, int flipType, const char* name, const char* desc);
/**
 * 
 */
void Product_setModified(Product _self, boolean modified);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong Product_getRawStorageSize(Product _self, ProductSubsetDef subsetDef);
/**
 * Gets the name of the band suitable for quicklook generation.
 */
char* Product_getQuicklookBandName(Product _self);
/**
 * Sets the name of the band suitable for quicklook generation.
 */
void Product_setQuicklookBandName(Product _self, const char* quicklookBandName);
/**
 * Creates a string containing all available information at the given pixel position. The string returned is a line
 separated text with each line containing a key/value pair.
 */
char* Product_createPixelInfoString(Product _self, int pixelX, int pixelY);
/**
 * Checks whether or not this product can be ortorectified.
 */
boolean Product_canBeOrthorectified(Product _self);
/**
 * Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
Dimension Product_getPreferredTileSize(Product _self);
/**
 * Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
void Product_setPreferredTileSize1(Product _self, int tileWidth, int tileHeight);
/**
 * Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
void Product_setPreferredTileSize2(Product _self, Dimension preferredTileSize);
/**
 * Returns the names of all flags of all flag datasets contained this product.
 <p/>
 <p>A flag name contains the dataset (a band of this product) and the actual flag name as defined in the
 flag-coding associated with the dataset. The general format for the flag name strings returned is therefore
 <code>"<i>dataset</i>.<i>flag_name</i>"</code>.
 </p>
 <p>The method is used to find out which flags a product has in order to use them in bit-mask expressions.
 */
char** Product_getAllFlagNames(Product _self, size_t* resultArrayLength);
/**
 * Gets the auto-grouping applicable to product nodes contained in this product.
 */
Product_AutoGrouping Product_getAutoGrouping(Product _self);
/**
 * Sets the auto-grouping applicable to product nodes contained in this product.
 */
void Product_setAutoGrouping1(Product _self, Product_AutoGrouping autoGrouping);
/**
 * Sets the auto-grouping applicable to product nodes contained in this product.
 A given {@code pattern} parameter is a textual representation of the auto-grouping.
 The syntax for the pattern is:
 <pre>
 pattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | "" (empty string)
 groupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}
 groupName  :=  any non-empty string without characters ':' and '/'
 </pre>
 An example for {@code pattern} applicable to Envisat AATSR data is
 <pre>
 nadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward
 </pre>
 */
void Product_setAutoGrouping2(Product _self, const char* pattern);
/**
 * Creates a new mask with the given name and image type and adds it to this product and returns it.
 The new mask's samples are computed from the given image type.
 */
Mask Product_addMask1(Product _self, const char* maskName, Mask_ImageType imageType);
/**
 * Creates a new mask using a band arithmetic expression
 and adds it to this product and returns it.
 */
Mask Product_addMask2(Product _self, const char* maskName, const char* expression, const char* description, Color color, double transparency);
/**
 * Creates a new mask based on the geometries contained in a vector data node,
 adds it to this product and returns it.
 */
Mask Product_addMask3(Product _self, const char* maskName, VectorDataNode vectorDataNode, const char* description, Color color, double transparency);

/* Functions for class ProductData */

/**
 * Factory method which creates a value instance of the given type and with exactly one element.
 */
ProductData ProductData_createInstance1(int type);
/**
 * Factory method which creates a value instance of the given type and with the specified number of elements.
 */
ProductData ProductData_createInstance2(int type, int numElems);
/**
 * Factory method which creates a value instance of the given type and with the specified number of elements.
 */
ProductData ProductData_createInstance3(int type, Object data);
/**
 * 
 */
ProductData ProductData_createInstance4(const char* strData);
/**
 * Returns this value's type ID.
 */
int ProductData_getType1(ProductData _self);
/**
 * Gets the element size of an element of the given type in bytes.
 */
int ProductData_getElemSize1(int type);
/**
 * Gets the element size of an element of this product data in bytes.
 */
int ProductData_getElemSize2(ProductData _self);
/**
 * Returns a textual representation of the given data type.
 */
char* ProductData_getTypeString1(int type);
/**
 * Returns a integer representation of the given data type string.
 */
int ProductData_getType2(const char* type);
/**
 * Returns this value's data type String.
 */
char* ProductData_getTypeString2(ProductData _self);
/**
 * Tests whether this value has an integer.
 */
boolean ProductData_isInt(ProductData _self);
/**
 * Tests whether the given value type is a signed or unsigned integer type.
 */
boolean ProductData_isIntType(int type);
/**
 * Tests whether the actual instance is an signed data type.
 */
boolean ProductData_isSigned(ProductData _self);
/**
 * Tests whether the actual instance is an unsigned data type.
 */
boolean ProductData_isUnsigned(ProductData _self);
/**
 * Tests whether the given value type is an unsigned integer type.
 */
boolean ProductData_isUIntType(int type);
/**
 * Tests whether the given value type is a floating point type.
 */
boolean ProductData_isFloatingPointType(int type);
/**
 * Tests if this value is a scalar.
 */
boolean ProductData_isScalar(ProductData _self);
/**
 * Returns the number of data elements this value has.
 */
int ProductData_getNumElems(ProductData _self);
/**
 * Returns the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 returns <code>getElemIntAt(0)</code>.
 */
int ProductData_getElemInt(ProductData _self);
/**
 * Returns the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.
 */
dlong ProductData_getElemUInt(ProductData _self);
/**
 * Returns the value as an <code>float</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemFloatAt(0)</code>.
 */
float ProductData_getElemFloat(ProductData _self);
/**
 * Returns the value as an <code>double</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemDoubleAt(0)</code>.
 */
double ProductData_getElemDouble(ProductData _self);
/**
 * Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained
 in this value.
 */
char* ProductData_getElemString(ProductData _self);
/**
 * Returns the value as an <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemBooleanAt(0)</code>.
 */
boolean ProductData_getElemBoolean(ProductData _self);
/**
 * Gets the value element with the given index as an <code>int</code>.
 */
int ProductData_getElemIntAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>long</code>.
 */
dlong ProductData_getElemUIntAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>float</code>.
 */
float ProductData_getElemFloatAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>double</code>.
 */
double ProductData_getElemDoubleAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>String</code>.
 */
char* ProductData_getElemStringAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>boolean</code>.
 */
boolean ProductData_getElemBooleanAt(ProductData _self, int index);
/**
 * Sets the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemInt(0, value)</code>.
 */
void ProductData_setElemInt(ProductData _self, int value);
/**
 * Sets the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.
 */
void ProductData_setElemUInt(ProductData _self, dlong value);
/**
 * Sets the value as a <code>float</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemFloatAt(0, value)</code>.
 */
void ProductData_setElemFloat(ProductData _self, float value);
/**
 * Sets the value as a <code>double</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.
 */
void ProductData_setElemDouble(ProductData _self, double value);
/**
 * Sets the value as a <code>String</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemStringAt(0)</code>.
 */
void ProductData_setElemString(ProductData _self, const char* value);
/**
 * Sets the value as a <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.
 */
void ProductData_setElemBoolean(ProductData _self, boolean value);
/**
 * Sets the value at the specified index as an <code>int</code>.
 */
void ProductData_setElemIntAt(ProductData _self, int index, int value);
/**
 * Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.
 */
void ProductData_setElemUIntAt(ProductData _self, int index, dlong value);
/**
 * Sets the value at the specified index as a <code>float</code>.
 */
void ProductData_setElemFloatAt(ProductData _self, int index, float value);
/**
 * Sets the value at the specified index as a <code>double</code>.
 */
void ProductData_setElemDoubleAt(ProductData _self, int index, double value);
/**
 * Sets the value at the specified index as a <code>String</code>.
 <p/>
 <p><i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>
 */
void ProductData_setElemStringAt(ProductData _self, int index, const char* value);
/**
 * Sets the value at the specified index as a <code>boolean</code>.
 */
void ProductData_setElemBooleanAt(ProductData _self, int index, boolean value);
/**
 * Returns the internal value. The actual type of the returned object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> </ol>
 */
Object ProductData_getElems(ProductData _self);
/**
 * Sets the internal value. The actual type of the given data object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>
 */
void ProductData_setElems(ProductData _self, Object data);
/**
 * Reads all elements of this <code>ProductData</code> instance from to the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position
 within the input stream.
 */
void ProductData_readFrom1(ProductData _self, ImageInputStream input);
/**
 * Reads a single element of this <code>ProductData</code> instance from to the given output stream.
 <p/>
 <p> The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given
 output stream.<br> Reading starts at the current seek position within the output stream.
 */
void ProductData_readFrom2(ProductData _self, int pos, ImageInputStream input);
/**
 * Reads elements of this <code>ProductData</code> instance from the given output stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek
 position of the input stream.
 */
void ProductData_readFrom3(ProductData _self, int startPos, int numElems, ImageInputStream input);
/**
 * Reads elements into this <code>ProductData</code> instance from the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>
 within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.
 */
void ProductData_readFrom4(ProductData _self, int startPos, int numElems, ImageInputStream input, dlong inputPos);
/**
 * Writes all elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position
 within the output stream.
 */
void ProductData_writeTo1(ProductData _self, ImageOutputStream output);
/**
 * Writes a single element of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given
 output stream.<br> Writing starts at the current seek position within the output stream.
 */
void ProductData_writeTo2(ProductData _self, int pos, ImageOutputStream output);
/**
 * Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek
 position within the output stream.
 */
void ProductData_writeTo3(ProductData _self, int startPos, int numElems, ImageOutputStream output);
/**
 * Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at
 <code>outputPos</code> within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.
 */
void ProductData_writeTo4(ProductData _self, int startPos, int numElems, ImageOutputStream output, dlong outputPos);
/**
 * Returns a string representation of this value which can be used for debugging purposes.
 */
char* ProductData_toString(ProductData _self);
/**
 * Returns {@link Object#hashCode()}.
 */
int ProductData_hashCode(ProductData _self);
/**
 * Returns {@link Object#equals(Object)}.
 Use {@link #equalElems} in order to perform an element-wise comparision.
 */
boolean ProductData_equals(ProductData _self, Object other);
/**
 * Tests whether this ProductData is equal to another one.
 Performs an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.
 Otherwise the method behaves like {@link Object#equals(Object)}.
 */
boolean ProductData_equalElems(ProductData _self, ProductData other);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 */
void ProductData_dispose(ProductData _self);

/* Functions for class ProductManager */

/**
 * Constructs an product manager with an empty list of products.
 */
ProductManager ProductManager_newProductManager();
/**
 * 
 */
int ProductManager_getProductCount(ProductManager _self);
/**
 * Gets the product at the given index.
 */
Product ProductManager_getProduct1(ProductManager _self, int index);
/**
 * Returns the display names of all products currently managed.
 */
char** ProductManager_getProductDisplayNames(ProductManager _self, size_t* resultArrayLength);
/**
 * Returns the names of all products currently managed.
 */
char** ProductManager_getProductNames(ProductManager _self, size_t* resultArrayLength);
/**
 * 
 */
Product ProductManager_getProductByDisplayName(ProductManager _self, const char* displayName);
/**
 * 
 */
Product ProductManager_getProductByRefNo(ProductManager _self, int refNo);
/**
 * 
 */
Product ProductManager_getProduct2(ProductManager _self, const char* name);
/**
 * 
 */
int ProductManager_getProductIndex(ProductManager _self, Product product);
/**
 * Tests whether a product with the given name is contained in this list.
 */
boolean ProductManager_containsProduct(ProductManager _self, const char* name);
/**
 * Tests whether the given product is contained in this list.
 */
boolean ProductManager_contains(ProductManager _self, Product product);
/**
 * Adds the given product to this product manager if it does not already exists and sets it's reference number one
 biger than the greatest reference number in this product manager.
 */
void ProductManager_addProduct(ProductManager _self, Product product);
/**
 * Removes the given product from this product manager if it exists.
 */
boolean ProductManager_removeProduct(ProductManager _self, Product product);
/**
 * Removes all product from this list.
 */
void ProductManager_removeAllProducts(ProductManager _self);
/**
 * Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is
 informed each time a product was added or removed.
 */
boolean ProductManager_addListener(ProductManager _self, ProductManager_Listener listener);
/**
 * Removes a <code>ProductManagerListener</code> from this product manager.
 */
boolean ProductManager_removeListener(ProductManager _self, ProductManager_Listener listener);

/* Functions for class ProductNodeGroup */

/**
 * Constructs a node group with no owner and which will not take ownership of added children.
 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup1(const char* name);
/**
 * Constructs a node group for the given owner.
 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup2(ProductNode owner, const char* name, boolean takingOverNodeOwnership);
/**
 * 
 */
boolean ProductNodeGroup_isTakingOverNodeOwnership(ProductNodeGroup _self);
/**
 * 
 */
int ProductNodeGroup_getNodeCount(ProductNodeGroup _self);
/**
 * 
 */
T ProductNodeGroup_get1(ProductNodeGroup _self, int index);
/**
 * Returns the display names of all products currently managed.
 */
char** ProductNodeGroup_getNodeDisplayNames(ProductNodeGroup _self, size_t* resultArrayLength);
/**
 * Returns the names of all products currently managed.
 */
char** ProductNodeGroup_getNodeNames(ProductNodeGroup _self, size_t* resultArrayLength);
/**
 * 
 */
int ProductNodeGroup_indexOf1(ProductNodeGroup _self, const char* name);
/**
 * 
 */
int ProductNodeGroup_indexOf2(ProductNodeGroup _self, T element);
/**
 * 
 */
T ProductNodeGroup_getByDisplayName(ProductNodeGroup _self, const char* displayName);
/**
 * 
 */
T ProductNodeGroup_get2(ProductNodeGroup _self, const char* name);
/**
 * Tests whether a node with the given name is contained in this group.
 */
boolean ProductNodeGroup_contains1(ProductNodeGroup _self, const char* name);
/**
 * Tests whether the given product is contained in this list.
 */
boolean ProductNodeGroup_contains2(ProductNodeGroup _self, T node);
/**
 * Adds the given node to this group.
 */
boolean ProductNodeGroup_add1(ProductNodeGroup _self, T node);
/**
 * Adds the given node to this group.
 */
void ProductNodeGroup_add2(ProductNodeGroup _self, int index, T node);
/**
 * Removes the given node from this group.
 */
boolean ProductNodeGroup_remove(ProductNodeGroup _self, T node);
/**
 * Removes all nodes from this group.
 */
void ProductNodeGroup_removeAll(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_clearRemovedList(ProductNodeGroup _self);
/**
 * Gets all removed node nodes.
 */
Collection ProductNodeGroup_getRemovedNodes(ProductNodeGroup _self);
/**
 * 
 */
dlong ProductNodeGroup_getRawStorageSize(ProductNodeGroup _self, ProductSubsetDef subsetDef);
/**
 * 
 */
void ProductNodeGroup_setModified(ProductNodeGroup _self, boolean modified);
/**
 * 
 */
void ProductNodeGroup_acceptVisitor(ProductNodeGroup _self, ProductVisitor visitor);
/**
 * 
 */
void ProductNodeGroup_dispose(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_updateExpression(ProductNodeGroup _self, const char* oldExternalName, const char* newExternalName);

/* Functions for class RGBChannelDef */

/**
 * 
 */
RGBChannelDef RGBChannelDef_newRGBChannelDef1();
/**
 * 
 */
RGBChannelDef RGBChannelDef_newRGBChannelDef2(const char** bandNamesElems, int bandNamesLength);
/**
 * 
 */
char* RGBChannelDef_getSourceName(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setSourceName(RGBChannelDef _self, int index, const char* sourceName);
/**
 * 
 */
char** RGBChannelDef_getSourceNames(RGBChannelDef _self, size_t* resultArrayLength);
/**
 * 
 */
void RGBChannelDef_setSourceNames(RGBChannelDef _self, const char** bandNamesElems, int bandNamesLength);
/**
 * 
 */
boolean RGBChannelDef_isAlphaUsed(RGBChannelDef _self);
/**
 * 
 */
boolean RGBChannelDef_isGammaUsed(RGBChannelDef _self, int index);
/**
 * 
 */
double RGBChannelDef_getGamma(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setGamma(RGBChannelDef _self, int index, double gamma);
/**
 * 
 */
double RGBChannelDef_getMinDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMinDisplaySample(RGBChannelDef _self, int index, double min);
/**
 * 
 */
double RGBChannelDef_getMaxDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMaxDisplaySample(RGBChannelDef _self, int index, double max);
/**
 * 
 */
Object RGBChannelDef_clone(RGBChannelDef _self);

/* Functions for class RasterDataNode */

/**
 * Returns the width in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterWidth()</code>.
 */
int RasterDataNode_getSceneRasterWidth(RasterDataNode _self);
/**
 * Returns the height in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterHeight()</code>.
 */
int RasterDataNode_getSceneRasterHeight(RasterDataNode _self);
/**
 * Returns the width of the raster used by this product raster.
 */
int RasterDataNode_getRasterWidth(RasterDataNode _self);
/**
 * Returns the height of the raster used by this product raster.
 */
int RasterDataNode_getRasterHeight(RasterDataNode _self);
/**
 * 
 */
void RasterDataNode_setModified(RasterDataNode _self, boolean modified);
/**
 * Returns the geo-coding of this {@link RasterDataNode}.
 */
GeoCoding RasterDataNode_getGeoCoding(RasterDataNode _self);
/**
 * Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>
 */
void RasterDataNode_setGeoCoding(RasterDataNode _self, GeoCoding geoCoding);
/**
 * Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.
 */
Pointing RasterDataNode_getPointing(RasterDataNode _self);
/**
 * Tests if this raster data node can be orthorectified.
 */
boolean RasterDataNode_canBeOrthorectified(RasterDataNode _self);
/**
 * Returns <code>true</code> if the pixel data contained in this band is "naturally" a floating point number type.
 */
boolean RasterDataNode_isFloatingPointType(RasterDataNode _self);
/**
 * Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.
 */
int RasterDataNode_getGeophysicalDataType(RasterDataNode _self);
/**
 * Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).
 */
double RasterDataNode_getScalingFactor(RasterDataNode _self);
/**
 * Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.
 */
void RasterDataNode_setScalingFactor(RasterDataNode _self, double scalingFactor);
/**
 * Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).
 */
double RasterDataNode_getScalingOffset(RasterDataNode _self);
/**
 * Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.
 */
void RasterDataNode_setScalingOffset(RasterDataNode _self, double scalingOffset);
/**
 * Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.
 */
boolean RasterDataNode_isLog10Scaled(RasterDataNode _self);
/**
 * Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.
 */
void RasterDataNode_setLog10Scaled(RasterDataNode _self, boolean log10Scaled);
/**
 * Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.
 */
boolean RasterDataNode_isScalingApplied(RasterDataNode _self);
/**
 * Tests if the given name is the name of a property which is relevant for the computation of the valid mask.
 */
boolean RasterDataNode_isValidMaskProperty(const char* propertyName);
/**
 * Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.
 */
boolean RasterDataNode_isNoDataValueSet(RasterDataNode _self);
/**
 * Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.
 */
void RasterDataNode_clearNoDataValue(RasterDataNode _self);
/**
 * Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean RasterDataNode_isNoDataValueUsed(RasterDataNode _self);
/**
 * Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.
 */
void RasterDataNode_setNoDataValueUsed(RasterDataNode _self, boolean noDataValueUsed);
/**
 * Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.
 */
double RasterDataNode_getNoDataValue(RasterDataNode _self);
/**
 * Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void RasterDataNode_setNoDataValue(RasterDataNode _self, double noDataValue);
/**
 * Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
double RasterDataNode_getGeophysicalNoDataValue(RasterDataNode _self);
/**
 * Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void RasterDataNode_setGeophysicalNoDataValue(RasterDataNode _self, double noDataValue);
/**
 * Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
char* RasterDataNode_getValidPixelExpression(RasterDataNode _self);
/**
 * Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.
 */
void RasterDataNode_setValidPixelExpression(RasterDataNode _self, const char* validPixelExpression);
/**
 * Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean RasterDataNode_isValidMaskUsed(RasterDataNode _self);
/**
 * Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.
 */
void RasterDataNode_resetValidMask(RasterDataNode _self);
/**
 * Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.
 */
char* RasterDataNode_getValidMaskExpression(RasterDataNode _self);
/**
 * {@inheritDoc}
 */
void RasterDataNode_updateExpression(RasterDataNode _self, const char* oldExternalName, const char* newExternalName);
/**
 * Gets a raster data holding this dataset's pixel data for an entire product scene. If the data has'nt been loaded
 so far the method returns <code>null</code>.
 <p/>
 <p>In oposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the
 scene's pixels.
 */
ProductData RasterDataNode_getSceneRasterData(RasterDataNode _self);
/**
 * Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.
 */
boolean RasterDataNode_hasRasterData(RasterDataNode _self);
/**
 * Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.
 */
ProductData RasterDataNode_getRasterData(RasterDataNode _self);
/**
 * Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!
 */
void RasterDataNode_setRasterData(RasterDataNode _self, ProductData rasterData);
/**
 * 
 */
void RasterDataNode_loadRasterData1(RasterDataNode _self);
/**
 * Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,
 <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should
 always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>
 elements (samples).
 <p/>
 <p>The default implementation of this method does nothing.
 */
void RasterDataNode_loadRasterData2(RasterDataNode _self, ProgressMonitor pm);
/**
 * Un-loads the raster data for this <code>RasterDataNode</code>.
 <p/>
 <p>It is up to the implementation whether after this method has been called successfully, the
 <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.
 <p/>
 <p>The default implementation of this method does nothing.
 */
void RasterDataNode_unloadRasterData(RasterDataNode _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void RasterDataNode_dispose(RasterDataNode _self);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>
 */
boolean RasterDataNode_isPixelValid1(RasterDataNode _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
int RasterDataNode_getSampleInt(RasterDataNode _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
float RasterDataNode_getSampleFloat(RasterDataNode _self, int x, int y);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 */
boolean RasterDataNode_isPixelValid2(RasterDataNode _self, int pixelIndex);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,
 and secondly, if the pixel is within the ROI (if any).
 */
boolean RasterDataNode_isPixelValid3(RasterDataNode _self, int x, int y, ROI roi);
/**
 * Returns the pixel located at (x,y) as an integer value.
 */
int RasterDataNode_getPixelInt(RasterDataNode _self, int x, int y);
/**
 * Returns the pixel located at (x,y) as a float value.
 */
float RasterDataNode_getPixelFloat(RasterDataNode _self, int x, int y);
/**
 * Returns the pixel located at (x,y) as a double value.
 */
double RasterDataNode_getPixelDouble(RasterDataNode _self, int x, int y);
/**
 * Sets the pixel located at (x,y) to the given integer value.
 */
void RasterDataNode_setPixelInt(RasterDataNode _self, int x, int y, int pixelValue);
/**
 * Sets the pixel located at (x,y) to the given float value.
 */
void RasterDataNode_setPixelFloat(RasterDataNode _self, int x, int y, float pixelValue);
/**
 * Sets the pixel located at (x,y) to the given double value.
 */
void RasterDataNode_setPixelDouble(RasterDataNode _self, int x, int y, double pixelValue);
/**
 * 
 */
void RasterDataNode_readRasterDataFully1(RasterDataNode _self);
/**
 * Reads the complete underlying raster data.
 <p/>
 <p>After this method has been called successfully, <code>hasRasterData()</code> should always return
 <code>true</code> and <code>getRasterData()</code> should always return a valid <code>ProductData</code> instance
 with at least <code>getRasterWidth()*getRasterHeight()</code> elements (samples).
 <p/>
 <p>In opposite to the <code>loadRasterData</code> method, the <code>readRasterDataFully</code> method always
 reloads the data of this product raster, independently of whether its has already been loaded or not.
 */
void RasterDataNode_readRasterDataFully2(RasterDataNode _self, ProgressMonitor pm);
/**
 * Reads raster data from the node's associated data source into the given data
 buffer.
 */
void RasterDataNode_readRasterData1(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * The method behaves exactly as {@link #readRasterData(int, int, int, int, ProductData)},
 but clients can additionally pass a {@link ProgressMonitor}.
 */
void RasterDataNode_readRasterData2(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writeRasterDataFully1(RasterDataNode _self);
/**
 * Writes the complete underlying raster data.
 */
void RasterDataNode_writeRasterDataFully2(RasterDataNode _self, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writeRasterData1(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * Writes data from this product raster into the specified region of the user-supplied raster.
 <p/>
 <p> It is important to know that this method does not change this product raster's internal state nor does it
 write into this product raster's internal raster.
 */
void RasterDataNode_writeRasterData2(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleRasterData1(RasterDataNode _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleSceneRasterData(RasterDataNode _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleRasterData2(RasterDataNode _self, int width, int height);
/**
 * Tests whether the given parameters specify a compatible raster or not.
 */
boolean RasterDataNode_isCompatibleRasterData(RasterDataNode _self, ProductData rasterData, int w, int h);
/**
 * Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.
 */
void RasterDataNode_checkCompatibleRasterData(RasterDataNode _self, ProductData rasterData, int w, int h);
/**
 * Determines whether this raster data node contains integer samples.
 */
boolean RasterDataNode_hasIntPixels(RasterDataNode _self);
/**
 * Creates a transect profile for the given shape (-outline).
 */
TransectProfileData RasterDataNode_createTransectProfileData(RasterDataNode _self, Shape shape);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 */
void RasterDataNode_acceptVisitor(RasterDataNode _self, ProductVisitor visitor);
/**
 * Gets the image information for image display.
 */
ImageInfo RasterDataNode_getImageInfo1(RasterDataNode _self);
/**
 * Sets the image information for image display.
 */
void RasterDataNode_setImageInfo(RasterDataNode _self, ImageInfo imageInfo);
/**
 * Notifies listeners that the image (display) information has changed.
 */
void RasterDataNode_fireImageInfoChanged(RasterDataNode _self);
/**
 * Returns the image information for this raster data node.
 <p/>
 <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.
 */
ImageInfo RasterDataNode_getImageInfo2(RasterDataNode _self, ProgressMonitor pm);
/**
 * 
 */
ProductNodeGroup RasterDataNode_getOverlayMaskGroup(RasterDataNode _self);
/**
 * Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.
 */
BufferedImage RasterDataNode_createColorIndexedImage(RasterDataNode _self, ProgressMonitor pm);
/**
 * Creates an RGB image for this raster data node.
 */
BufferedImage RasterDataNode_createRgbImage(RasterDataNode _self, ProgressMonitor pm);
/**
 * Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.
 */
IndexValidator RasterDataNode_createPixelValidator(RasterDataNode _self, int lineOffset, ROI roi);
/**
 * Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.
 */
double RasterDataNode_scale(RasterDataNode _self, double v);
/**
 * Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.
 */
double RasterDataNode_scaleInverse(RasterDataNode _self, double v);
/**
 * Returns the pixel located at (x,y) as a string value.
 */
char* RasterDataNode_getPixelString(RasterDataNode _self, int x, int y);
/**
 * Returns whether the source image is set on this {@code RasterDataNode}.
 */
boolean RasterDataNode_isSourceImageSet(RasterDataNode _self);
/**
 * Gets the source image associated with this {@code RasterDataNode}.
 */
MultiLevelImage RasterDataNode_getSourceImage(RasterDataNode _self);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void RasterDataNode_setSourceImage1(RasterDataNode _self, RenderedImage sourceImage);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void RasterDataNode_setSourceImage2(RasterDataNode _self, MultiLevelImage sourceImage);
/**
 * Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
boolean RasterDataNode_isGeophysicalImageSet(RasterDataNode _self);
/**
 * 
 */
MultiLevelImage RasterDataNode_getGeophysicalImage(RasterDataNode _self);
/**
 * Returns wether the valid mask image is set on this {@code RasterDataNode}.
 */
boolean RasterDataNode_isValidMaskImageSet(RasterDataNode _self);
/**
 * Gets the valid-mask image associated with this {@code RasterDataNode}.
 */
MultiLevelImage RasterDataNode_getValidMaskImage(RasterDataNode _self);
/**
 * 
 */
boolean RasterDataNode_isStxSet(RasterDataNode _self);
/**
 * Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx RasterDataNode_getStx1(RasterDataNode _self);
/**
 * Gets the statistics.
 If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx RasterDataNode_getStx2(RasterDataNode _self, boolean accurate, ProgressMonitor pm);
/**
 * Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
void RasterDataNode_setStx(RasterDataNode _self, Stx stx);
/**
 * Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.
 */
Shape RasterDataNode_getValidShape(RasterDataNode _self);

/* Functions for class SampleCoding */

/**
 * 
 */
SampleCoding SampleCoding_newSampleCoding(const char* name);
/**
 * Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.
 */
void SampleCoding_addElement(SampleCoding _self, MetadataElement element);
/**
 * Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.
 */
void SampleCoding_addAttribute(SampleCoding _self, MetadataAttribute attribute);
/**
 * Adds a new coding value to this sample coding.
 */
MetadataAttribute SampleCoding_addSample(SampleCoding _self, const char* name, int value, const char* description);
/**
 * Gets the number of coded sample values.
 */
int SampleCoding_getSampleCount(SampleCoding _self);
/**
 * Gets the sample name at the specified attribute index.
 */
char* SampleCoding_getSampleName(SampleCoding _self, int index);
/**
 * Gets the sample value at the specified attribute index.
 */
int SampleCoding_getSampleValue(SampleCoding _self, int index);

/* Functions for class TiePointGrid */

/**
 * Gets the angular discontinuity.
 */
int TiePointGrid_getDiscontinuity(TiePointGrid _self);
/**
 * Sets the angular discontinuity.
 */
void TiePointGrid_setDiscontinuity(TiePointGrid _self, int discontinuity);
/**
 * Returns <code>true</code>
 */
boolean TiePointGrid_isFloatingPointType(TiePointGrid _self);
/**
 * Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.
 */
int TiePointGrid_getGeophysicalDataType(TiePointGrid _self);
/**
 * Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. <p/>
 <p/>
 In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store
 the scene's pixels.
 */
ProductData TiePointGrid_getSceneRasterData(TiePointGrid _self);
/**
 * Returns the width in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>
 */
int TiePointGrid_getSceneRasterWidth(TiePointGrid _self);
/**
 * Returns the height in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>
 */
int TiePointGrid_getSceneRasterHeight(TiePointGrid _self);
/**
 * Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels.
 */
float TiePointGrid_getOffsetX(TiePointGrid _self);
/**
 * Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels.
 */
float TiePointGrid_getOffsetY(TiePointGrid _self);
/**
 * Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.
 */
float TiePointGrid_getSubSamplingX(TiePointGrid _self);
/**
 * Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.
 */
float TiePointGrid_getSubSamplingY(TiePointGrid _self);
/**
 * Gets the interpolated sample for the pixel located at (x,y) as an integer value. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
int TiePointGrid_getPixelInt(TiePointGrid _self, int x, int y);
/**
 * 
 */
void TiePointGrid_dispose(TiePointGrid _self);
/**
 * Computes the interpolated sample for the pixel located at (x,y). <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
float TiePointGrid_getPixelFloat1(TiePointGrid _self, int x, int y);
/**
 * Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
float TiePointGrid_getPixelFloat2(TiePointGrid _self, float x, float y);
/**
 * Gets the interpolated sample for the pixel located at (x,y) as a double value. <p/>
 <p/>
 If the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
double TiePointGrid_getPixelDouble(TiePointGrid _self, int x, int y);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelInt(TiePointGrid _self, int x, int y, int pixelValue);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelFloat(TiePointGrid _self, int x, int y, float pixelValue);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelDouble(TiePointGrid _self, int x, int y, double pixelValue);
/**
 * Reads raster data from this dataset into the user-supplied raster data buffer. <p/>
 <p/>
 This method always directly (re-)reads this band's data from its associated data source into the given data
 buffer.
 */
void TiePointGrid_readRasterData(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_readRasterDataFully(TiePointGrid _self, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_writeRasterData(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_writeRasterDataFully(TiePointGrid _self, ProgressMonitor pm);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor. <p/>
 <p/>
 The method simply calls <code>visitor.visit(this)</code>.
 */
void TiePointGrid_acceptVisitor(TiePointGrid _self, ProductVisitor visitor);
/**
 * 
 */
TiePointGrid TiePointGrid_cloneTiePointGrid(TiePointGrid _self);
/**
 * 
 */
TiePointGrid TiePointGrid_createZenithFromElevationAngleTiePointGrid(TiePointGrid elevationAngleGrid);
/**
 * 
 */
TiePointGrid TiePointGrid_createSubset(TiePointGrid sourceTiePointGrid, ProductSubsetDef subsetDef);

/* Functions for class VectorDataNode */

/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode1(const char* name, SimpleFeatureType featureType);
/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode2(const char* name, FeatureCollection featureCollection);
/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode3(const char* name, FeatureCollection featureCollection, PlacemarkDescriptor placemarkDescriptor);
/**
 * 
 */
PlacemarkDescriptor VectorDataNode_getPlacemarkDescriptor(VectorDataNode _self);
/**
 * 
 */
PlacemarkGroup VectorDataNode_getPlacemarkGroup(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setModified(VectorDataNode _self, boolean modified);
/**
 * 
 */
SimpleFeatureType VectorDataNode_getFeatureType(VectorDataNode _self);
/**
 * 
 */
FeatureCollection VectorDataNode_getFeatureCollection(VectorDataNode _self);
/**
 * Gets the bounding box for the features in this feature collection.
 */
ReferencedEnvelope VectorDataNode_getEnvelope(VectorDataNode _self);
/**
 * 
 */
dlong VectorDataNode_getRawStorageSize(VectorDataNode _self, ProductSubsetDef subsetDef);
/**
 * 
 */
char* VectorDataNode_getDefaultStyleCss(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setDefaultStyleCss(VectorDataNode _self, const char* defaultStyleCss);
/**
 * 
 */
char* VectorDataNode_getStyleCss(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setStyleCss(VectorDataNode _self, const char* styleCss);
/**
 * 
 */
void VectorDataNode_acceptVisitor(VectorDataNode _self, ProductVisitor visitor);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void VectorDataNode_dispose(VectorDataNode _self);
/**
 * Internal API. Don't use.
 */
boolean VectorDataNode_isPermanent(VectorDataNode _self);
/**
 * Internal API. Don't use.
 */
void VectorDataNode_setPermanent(VectorDataNode _self, boolean permanent);

/* Functions for class GPF */

/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct1(const char* operatorName, Map parameters);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct2(const char* operatorName, Map parameters, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct3(const char* operatorName, Map parameters, Product sourceProduct);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct4(const char* operatorName, Map parameters, Product sourceProduct, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct5(const char* operatorName, Map parameters, Map sourceProducts);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct6(const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 <p>All static {@code createProduct} methods delegate to this non-static (= NS) version.
 It can be overriden by clients in order to alter product creation behaviour of the static
 {@code createProduct} methods of the current GPF instance.</p>
 */
Product GPF_createProductNS(GPF _self, const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Creates an operator instance by using the given operator (alias) name.
 */
Operator GPF_createOperator(GPF _self, const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Gets the registry for operator SPIs.
 */
OperatorSpiRegistry GPF_getOperatorSpiRegistry(GPF _self);
/**
 * Sets the registry for operator SPIs.
 */
void GPF_setOperatorSpiRegistry(GPF _self, OperatorSpiRegistry spiRegistry);
/**
 * Gets the default GPF instance.
 */
GPF GPF_getDefaultInstance();
/**
 * Sets the default GPF instance.
 */
void GPF_setDefaultInstance(GPF defaultInstance);

/* Functions for class Operator */

/**
 * Initializes this operator and sets the one and only target product.
 <p>The target product can be either defined by a field of type {@link Product} annotated with the
 {@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation or
 by calling {@link #setTargetProduct} method.
 </p>
 <p> This method shall never be called directly. The framework calls this method after it has created
 an instance of this {@code Operator}. This will occur
 only once durting the lifetime of an {@code Operator} instance.
 If not already done, calling the {@link #getTargetProduct()} will always trigger
 a call to the {@code initialize()} method.
 </p>
 Any client code that must be performed before computation of tile data
 should be placed here.
 */
void Operator_initialize(Operator _self);
/**
 * Updates this operator forcing it to recreate the target product.
 <i>Warning: Experimental API added by nf (25.02.2010)</i><br/>
 */
void Operator_update(Operator _self);
/**
 * Called by the framework in order to compute a tile for the given target band.
 <p>The default implementation throws a runtime exception with the message "not implemented".</p>
 <p>This method shall never be called directly.
 </p>
 */
void Operator_computeTile(Operator _self, Band targetBand, Tile targetTile, ProgressMonitor pm);
/**
 * Called by the framework in order to compute the stack of tiles for the given target bands.
 <p>The default implementation throws a runtime exception with the message "not implemented".</p>
 <p>This method shall never be called directly.
 </p>
 */
void Operator_computeTileStack(Operator _self, Map targetTiles, Rectangle targetRectangle, ProgressMonitor pm);
/**
 * Releases the resources the operator has acquired during its lifetime.
 The default implementation does nothing.
 <p/>
 Overrides should make sure to call {@code super.dispose()} as well.
 */
void Operator_dispose(Operator _self);
/**
 * 
 */
char* Operator_getId(Operator _self);
/**
 * Gets a single source product. This method is a shortcut for
 {@code getSourceProduct("sourceProduct")}.
 */
Product Operator_getSourceProduct1(Operator _self);
/**
 * Sets a single source product. This method is a shortcut for
 {@code setSourceProduct("sourceProduct", sourceProduct)}.
 */
void Operator_setSourceProduct1(Operator _self, Product sourceProduct);
/**
 * Gets the source product using the specified name.
 */
Product Operator_getSourceProduct2(Operator _self, const char* id);
/**
 * Sets a source product.
 One product instance can be registered with different identifiers, e.g. "source", "source1" and "input"
 in consecutive calls.
 */
void Operator_setSourceProduct2(Operator _self, const char* id, Product product);
/**
 * Gets the identifier for the given source product.
 */
char* Operator_getSourceProductId(Operator _self, Product product);
/**
 * Gets the target product for the operator.
 <p/>
 <p>If the target product is not set, calling this method results in a
 call to {@link #initialize()}.</p>
 */
Product Operator_getTargetProduct(Operator _self);
/**
 * Gets a target property of the operator.
 <p/>
 <p>If the requested target property is not set, calling this method results in a
 call to {@link #initialize()}.</p>
 */
Object Operator_getTargetProperty(Operator _self, const char* name);
/**
 * Gets the value for the parameter with the given name.
 */
Object Operator_getParameter(Operator _self, const char* name);
/**
 * Sets the value for the parameter with the given name.
 */
void Operator_setParameter(Operator _self, const char* name, Object value);
/**
 * Gets a {@link Tile} for a given band and image region.
 */
Tile Operator_getSourceTile1(Operator _self, RasterDataNode rasterDataNode, Rectangle region);
/**
 * Gets a {@link Tile} for a given band and image region. The region can overlap the bounds of source image.
 This method is particulary useful if you need to compute target pixels from an n x m region around a corresponding source pixel.
 In this case an extended tile will need to be read from the source.
 */
Tile Operator_getSourceTile2(Operator _self, RasterDataNode rasterDataNode, Rectangle region, BorderExtender borderExtender);
/**
 * Gets the logger whuich can be used to log information during initialisation and tile computation.
 */
Logger Operator_getLogger(Operator _self);
/**
 * Non-API.
 */
void Operator_stopTileComputationObservation(Operator _self);
/**
 * Sets the logger which can be used to log information during initialisation and tile computation.
 */
void Operator_setLogger(Operator _self, Logger logger);
/**
 * Gets the SPI which was used to create this operator.
 If no operator has been explicitly set, the method will return an anonymous
 SPI.
 */
OperatorSpi Operator_getSpi(Operator _self);
/**
 * Sets the SPI which was used to create this operator.
 */
void Operator_setSpi(Operator _self, OperatorSpi operatorSpi);

/* Functions for class OperatorException */

/**
 * Constructs a new exception with the specified detail message.
 */
OperatorException OperatorException_newOperatorException1(const char* message);
/**
 * Constructs a new exception with the specified detail message and cause.
 */
OperatorException OperatorException_newOperatorException2(const char* message, Throwable cause);
/**
 * Constructs a new exception by delegating to
 {@link #OperatorException(String,Throwable) this(cause.getMessage(), cause)}.
 */
OperatorException OperatorException_newOperatorException3(Throwable cause);

/* Functions for class OperatorSpi */

/**
 * <p>Creates an operator instance with no arguments. The default implemrentation calls
 the default constructor. If no such is defined in the operator, an exception is thrown.</p>
 <p>This method may be overridden by clients in order to provide a no-argument instance of their operator.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator1(OperatorSpi _self);
/**
 * <p>Creates an operator instance for the given source products and processing parameters.</p>
 <p>This method may be overridden by clients in order to process the passed parameters and
 source products and optionally construct the operator in a specific way.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator2(OperatorSpi _self, Map parameters, Map sourceProducts);
/**
 * <p>Creates an operator instance for the given source products and processing parameters.</p>
 <p>This method may be overridden by clients in order to process the passed parameters and
 source products and optionally construct the operator in a specific way.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator3(OperatorSpi _self, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Gets the operator class.
 The operator class must be public and provide a public zero-argument constructor.
 */
Class OperatorSpi_getOperatorClass(OperatorSpi _self);
/**
 * The alias name under which the operator can be accessed.
 */
char* OperatorSpi_getOperatorAlias1(OperatorSpi _self);
/**
 * 
 */
char* OperatorSpi_getOperatorAlias2(Class operatorClass);

/* Functions for class OperatorSpiRegistry */

/**
 * Loads the SPI's defined in {@code META-INF/services}.
 */
void OperatorSpiRegistry_loadOperatorSpis(OperatorSpiRegistry _self);
/**
 * Gets the {@link ServiceRegistry ServiceRegistry}
 */
ServiceRegistry OperatorSpiRegistry_getServiceRegistry(OperatorSpiRegistry _self);
/**
 * Gets a registrered operator SPI. The given <code>operatorName</code> can be
 either the fully qualified class name of the {@link OperatorSpi}
 or an alias name.
 */
OperatorSpi OperatorSpiRegistry_getOperatorSpi(OperatorSpiRegistry _self, const char* operatorName);
/**
 * Adds the given {@link OperatorSpi operatorSpi} to this registry.
 */
boolean OperatorSpiRegistry_addOperatorSpi(OperatorSpiRegistry _self, OperatorSpi operatorSpi);
/**
 * Removes the given {@link OperatorSpi operatorSpi} this registry.
 */
boolean OperatorSpiRegistry_removeOperatorSpi(OperatorSpiRegistry _self, OperatorSpi operatorSpi);
/**
 * Sets an alias for the given SPI class name.
 */
void OperatorSpiRegistry_setAlias(OperatorSpiRegistry _self, const char* aliasName, const char* spiClassName);

/* Functions for class Tile */

/**
 * Gets the {@code RasterDataNode} associated with this tile,
 e.g. a {@link org.esa.beam.framework.datamodel.Band Band} for source and target tiles or
 {@link org.esa.beam.framework.datamodel.TiePointGrid TiePointGrid} for a source tile.
 */
RasterDataNode Tile_getRasterDataNode(Tile _self);
/**
 * Checks if this is a target tile. Non-target tiles are read only.
 */
boolean Tile_isTarget(Tile _self);
/**
 * Converts a raw sample value (e.g. digital counts) to a (geo-)physically scaled sample value
 of type {@code float}.
 */
float Tile_toGeoPhysical1(Tile _self, float rawSample);
/**
 * Converts a raw sample value (e.g. digital counts) to a (geo-)physically scaled sample value
 of type {@code double}.
 */
double Tile_toGeoPhysical2(Tile _self, double rawSample);
/**
 * Converts a (geo-)physically scaled sample value of type {@code float} to a
 its corresponding raw sample value (e.g. digital counts).
 */
float Tile_toRaw1(Tile _self, float sample);
/**
 * Converts a (geo-)physically scaled sample value of type {@code double} to a
 its corresponding raw sample value (e.g. digital counts).
 */
double Tile_toRaw2(Tile _self, double sample);
/**
 * Gets the tile rectangle in pixel coordinates within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 Simply returns <code>new Rectangle(
 {@link #getMinX() minX},
 {@link #getMinY() minY},
 {@link #getWidth() width},
 {@link #getHeight() height})</code>.
 */
Rectangle Tile_getRectangle(Tile _self);
/**
 * Gets the minimum pixel x-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMinX(Tile _self);
/**
 * Gets the maximum pixel x-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMaxX(Tile _self);
/**
 * Gets the minimum pixel y-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMinY(Tile _self);
/**
 * Gets the maximum pixel y-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMaxY(Tile _self);
/**
 * Gets the width in pixels within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getWidth(Tile _self);
/**
 * Gets the height in pixels within the scene covered by the tile's {@link RasterDataNode}.
 */
int Tile_getHeight(Tile _self);
/**
 * Gets the index into the underlying raw sample buffer for the given pixel coordinates.
 <p>The pixel coordinates are absolute; meaning they are defined in the scene raster coordinate system
 of this tile's {@link #getRasterDataNode()  RasterDataNode}.
 </p>
 <p>The returned index is computed as follows:
 <pre>
   int dx = x - {@link #getMinX()};
   int dy = y - {@link #getMinY()};
   int index = {@link #getScanlineOffset()} + dy * {@link #getScanlineStride()} + dx;
 </pre>
 </p>
 */
int Tile_getDataBufferIndex(Tile _self, int x, int y);
/**
 * <p>Obtains access to the underlying raw sample buffer. The data buffer holds the
 raw (unscaled, uncalibrated) sample data (e.g. detector counts).</p>
 Elements in this array must be addressed
 by an index computed via the {@link #getScanlineStride() scanlineStride} and
 {@link #getScanlineOffset() scanlineOffset} properties.
 The index can also be directly computed using the  {@link #getDataBufferIndex(int, int)} method.
 <p/>
 <p>The most efficient way to access and/or modify the samples in the raw data buffer is using
 the following nested loops:</p>
 <pre>
   int lineStride = tile.{@link #getScanlineStride()};
   int lineOffset = tile.{@link #getScanlineOffset()};
   for (int y = tile.{@link #getMinY()}; y &lt;= tile.{@link #getMaxY()}; y++) {
      int index = lineOffset;
      for (int x = tile.{@link #getMinX()}; x &lt;= tile.{@link #getMaxX()}; x++) {
           // use index here to access raw data buffer...
           index++;
       }
       lineOffset += lineStride;
   }
 </pre>
 <p/>
 <p>If the absolute x,y pixel coordinates are not required, the following construct maybe more
 readable:</p>
 <pre>
   int lineStride = tile.{@link #getScanlineStride()};
   int lineOffset = tile.{@link #getScanlineOffset()};
   for (int y = 0; y &lt; tile.{@link #getHeight()}; y++) {
      int index = lineOffset;
      for (int x = 0; x &lt; tile.{@link #getWidth()}; x++) {
           // use index here to access raw data buffer...
           index++;
       }
       lineOffset += lineStride;
   }
 </pre>
 */
ProductData Tile_getDataBuffer(Tile _self);
/**
 * Gets the scanline offset.
 The scanline offset is the index to the first valid sample element in the data buffer.
 */
int Tile_getScanlineOffset(Tile _self);
/**
 * Gets the raster scanline stride for addressing the internal data buffer.
 The scanline stride is added to the scanline offset in order to compute offsets of subsequent scanlines.
 */
int Tile_getScanlineStride(Tile _self);
/**
 * Gets the raw (unscaled, uncalibrated) samples, e.g. detector counts, copied from or wrapping the underlying
 data buffer. In contradiction to the {@link #getDataBuffer()} method, the returned samples
 will cover exactly the region {@link #getRectangle()} rectangle} of this tile. Thus, the number
 of returned samples will always equal {@link #getWidth() width} {@code *} {@link #getHeight() height}.
 <p>In order to apply changes of the samples values to this tile, it is mandatory to call
 {@link #setRawSamples(org.esa.beam.framework.datamodel.ProductData)} with the modified
 {@code ProductData} instance.</p>
 */
ProductData Tile_getRawSamples(Tile _self);
/**
 * Sets this tile's raw (unscaled, uncalibrated) samples.
 The number of given samples must be equal {@link #getWidth() width} {@code *} {@link #getHeight() height}
 of this tile.
 <p>This method must be used
 in order to apply changes made to the samples returned by the {@link #getRawSamples()} method.</p>
 */
void Tile_setRawSamples(Tile _self, ProductData rawSamples);
/**
 * Checks whether or not the sample value exists and is valid at a given image pixel position.
 */
boolean Tile_isSampleValid(Tile _self, int x, int y);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
boolean Tile_getSampleBoolean(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample1(Tile _self, int x, int y, boolean sample);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code int} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
int Tile_getSampleInt(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code int} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample2(Tile _self, int x, int y, int sample);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code float} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
float Tile_getSampleFloat(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code float} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample3(Tile _self, int x, int y, float sample);
/**
 * Gets the (geo-)physically scaled sample value for the given pixel coordinate as {@code double}.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
double Tile_getSampleDouble(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code double} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample4(Tile _self, int x, int y, double sample);
/**
 * Gets the bit-coded sample value for the given pixel coordinate and the specified bit index as a {@code boolean}.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
boolean Tile_getSampleBit(Tile _self, int x, int y, int bitIndex);
/**
 * Sets the bit-coded sample at the given pixel coordinate and the specified bit index from a {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
void Tile_setSample5(Tile _self, int x, int y, int bitIndex, boolean sample);
/**
 * Gets an iterator which can be used to visit all pixels in the tile.
 The method allows this tile to be the target of the Java "foreach" statement.
 Using the tile as an iterator in a single loop
 <pre>
 for (Tile.Pos pos: tile) {
    int x = pos.x;
    int y = pos.y;
    // ...
 }
 </pre>
 is equivalent to iterating over all pixels using two nested loops
 <pre>
 for (int y = tile.getMinY(); y <= tile.getMaxY(); y++) {
     for (int x = tile.getMinX(); x <= tile.getMaxX(); x++) {
         // ...
     }
 }
 </pre>
 */
Iterator Tile_iterator(Tile _self);

/* Functions for class Tile_Pos */

/**
 * 
 */
Tile_Pos Tile_Pos_newTile_Pos(int x, int y);
/**
 * 
 */
boolean Tile_Pos_equals(Tile_Pos _self, Object obj);
/**
 * 
 */
int Tile_Pos_hashCode(Tile_Pos _self);
/**
 * 
 */
char* Tile_Pos_toString(Tile_Pos _self);

/* Functions for class ProductUtils */

/**
 * 
 */
ProductUtils ProductUtils_newProductUtils();
/**
 * Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.
 <p/>
 <p>The method uses the given raster data node's image information (an instance of <code>{@link
 ImageInfo}</code>) to create the image.
 */
BufferedImage ProductUtils_createColorIndexedImage(RasterDataNode rasterDataNode, ProgressMonitor pm);
/**
 * Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be
 the upper left pixel's center (0.5, 0.5).
 */
MapInfo ProductUtils_createSuitableMapInfo1(Product product, Rectangle rect, MapProjection mapProjection);
/**
 * Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.
 */
MapInfo ProductUtils_createSuitableMapInfo2(Product product, MapProjection mapProjection, double orientation, double noDataValue);
/**
 * 
 */
Dimension ProductUtils_getOutputRasterSize(Product product, Rectangle rect, MapTransform mapTransform, double pixelSizeX, double pixelSizeY);
/**
 * Copies the flag codings from the source product to the target.
 */
void ProductUtils_copyFlagCodings(Product source, Product target);
/**
 * Copies the given source flag coding to the target product.
 If it exists already, the method simply returns the existing instance.
 */
FlagCoding ProductUtils_copyFlagCoding(FlagCoding sourceFlagCoding, Product target);
/**
 * Copies the given source index coding to the target product
 If it exists already, the method simply returns the existing instance.
 */
IndexCoding ProductUtils_copyIndexCoding(IndexCoding sourceIndexCoding, Product target);
/**
 * Copies the {@link Mask}s from the source product to the target product.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks from the source bands to the target bands. Also
 note that a source mask is not copied to the target product, when there already
 is a mask in the target product with the same name as the source mask.
 */
void ProductUtils_copyMasks(Product sourceProduct, Product targetProduct);
/**
 * Copies the overlay {@link Mask}s from the source product's raster data nodes to
 the target product's raster data nodes.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks, which are not contained in the target product's
 mask group.
 */
void ProductUtils_copyOverlayMasks(Product sourceProduct, Product targetProduct);
/**
 * Copies all bands which contain a flagcoding from the source product to the target product.
 */
void ProductUtils_copyFlagBands(Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 * Copies the named tie-point grid from the source product to the target product.
 */
TiePointGrid ProductUtils_copyTiePointGrid(const char* gridName, Product sourceProduct, Product targetProduct);
/**
 * Copies the named band from the source product to the target product.
 */
Band ProductUtils_copyBand1(const char* sourceBandName, Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 * Copies the named band from the source product to the target product.
 */
Band ProductUtils_copyBand2(const char* sourceBandName, Product sourceProduct, const char* targetBandName, Product targetProduct, boolean copySourceImage);
/**
 * Copies all properties from source band to the target band.
 */
void ProductUtils_copyRasterDataNodeProperties(RasterDataNode sourceRaster, RasterDataNode targetRaster);
/**
 * Copies the spectral properties from source band to target band. These properties are:
 <ul>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandIndex() spectral band index},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralWavelength() the central wavelength},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandwidth() the spectral bandwidth} and</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSolarFlux() the solar spectral flux}.</li>
 </ul>
 */
void ProductUtils_copySpectralBandProperties(Band sourceBand, Band targetBand);
/**
 * Copies the geocoding from the source product to target product.
 <p/>
 <p>If the geo-coding in the source product is a {@link TiePointGeoCoding} or a {@link PixelGeoCoding},
 the method expects existing latitude and longitude tie-point grids respectively existing latitude and longitude
 bands in the target product. The method will NOT automatically copy them as well.
 This behaviour may change in the future.</p>
 */
void ProductUtils_copyGeoCoding(Product sourceProduct, Product targetProduct);
/**
 * Copies all tie point grids from one product to another.
 */
void ProductUtils_copyTiePointGrids(Product sourceProduct, Product targetProduct);
/**
 * 
 */
void ProductUtils_copyVectorData(Product sourceProduct, Product targetProduct);
/**
 * Returns whether or not a product can return a pixel position from a given geographical position.
 */
boolean ProductUtils_canGetPixelPos1(Product product);
/**
 * Returns whether or not a raster can return a pixel position from a given geographical position.
 */
boolean ProductUtils_canGetPixelPos2(RasterDataNode raster);
/**
 * Creates a density plot image from two raster data nodes.
 */
BufferedImage ProductUtils_createDensityPlotImage(RasterDataNode raster1, float sampleMin1, float sampleMax1, RasterDataNode raster2, float sampleMin2, float sampleMax2, Mask roiMask, int width, int height, Color background, BufferedImage image, ProgressMonitor pm);
/**
 * Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.
 */
BufferedImage ProductUtils_overlayMasks(RasterDataNode raster, BufferedImage overlayBIm, ProgressMonitor pm);
/**
 * 
 */
GeoPos ProductUtils_getCenterGeoPos(Product product);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos(GeoPos geoPos);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos_old(GeoPos geoPos);
/**
 * Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in
 pixel coordinates using the supplied geo coding.
 */
GeneralPath ProductUtils_convertToPixelPath(GeneralPath geoPath, GeoCoding geoCoding);
/**
 * Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic
 coordinates using the supplied geo coding.
 */
GeneralPath ProductUtils_convertToGeoPath(Shape shape, GeoCoding geoCoding);
/**
 * Copies all metadata elements and attributes of the source product to the target product.
 The copied elements and attributes are deeply cloned.
 */
void ProductUtils_copyMetadata1(Product source, Product target);
/**
 * Copies all metadata elements and attributes of the source element to the target element.
 The copied elements and attributes are deeply cloned.
 */
void ProductUtils_copyMetadata2(MetadataElement source, MetadataElement target);
/**
 * Copies the source product's preferred tile size (if any) to the target product.
 */
void ProductUtils_copyPreferredTileSize(Product sourceProduct, Product targetProduct);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata1(Product product);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata2(GeoCoding geoCoding, int width, int height);
/**
 * 
 */
GeneralPath ProductUtils_areaToPath(Area negativeArea, double deltaX);
/**
 * Adds a given elem to the history of the given product. If the products metadata root
 does not contain a history entry a new one will be created.
 */
void ProductUtils_addElementToHistory(Product product, MetadataElement elem);
/**
 * Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given
 product, the related element is removed.
 */
char** ProductUtils_removeInvalidExpressions(Product product, size_t* resultArrayLength);
/**
 * Finds the name of a band in the given product which is suitable to product a good quicklook.
 The method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.
 */
char* ProductUtils_findSuitableQuicklookBandName(Product product);
/**
 * Copies only the bands from source to target.
 */
void ProductUtils_copyBandsForGeomTransform1(Product sourceProduct, Product targetProduct, double defaultNoDataValue, Map addedRasterDataNodes);
/**
 * Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target
 product is a geometric transformation (e.g. map-projection) of the source product.
 <p>If
 {@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,
 this method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},
 regardless which raw data type the source band has.
 In this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}
 will always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}
 will always be 0.0 and
 {@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.
 This ensures that source pixel resampling methods operating on floating point
 data can be stored without loss in accuracy in the target band.
 <p/>
 <p>Furthermore, the
 {@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}
 and {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}
 properties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},
 will be either the one from the source band, if any, or otherwise the one passed into this method.
 */
void ProductUtils_copyBandsForGeomTransform2(Product sourceProduct, Product targetProduct, boolean includeTiePointGrids, double defaultNoDataValue, Map targetToSourceMap);
/**
 * 
 */
ProductData_UTC ProductUtils_getScanLineTime(Product product, double y);
/**
 * 
 */
double ProductUtils_getGeophysicalSampleDouble(Band band, int pixelX, int pixelY, int level);
/**
 * 
 */
dlong ProductUtils_getGeophysicalSampleLong(Band band, int pixelX, int pixelY, int level);

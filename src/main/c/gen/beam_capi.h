/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * File created at Fri Nov 09 15:28:03 CET 2012 using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */


typedef char byte;
typedef unsigned char boolean;
typedef long long dlong;



/* Wrapped API classes */
typedef void* GeoCoding;
typedef void* ProductWriter;
typedef void* IndexCoding;
typedef void* PixelPos;
typedef void* ProductIO;
typedef void* Placemark;
typedef void* MetadataElement;
typedef void* Product;
typedef void* ColorPaletteDef;
typedef void* ImageInfo;
typedef void* ProductManager;
typedef void* ImageGeometry;
typedef void* Band;
typedef void* PlacemarkGroup;
typedef void* TiePointGrid;
typedef void* AngularDirection;
typedef void* FlagCoding;
typedef void* ProductReader;
typedef void* RGBChannelDef;
typedef void* ProductData;
typedef void* GeoPos;
typedef void* ProductNodeGroup;
typedef void* ProductUtils;
typedef void* MetadataAttribute;


/* Non-API classes used in the API */
typedef void* String;
typedef void* Shape;
typedef void* MapTransform;
typedef void* Parser;
typedef void* AffineTransform;
typedef void* Mask;
typedef void* Double;
typedef void* Term;
typedef void* RasterDataNode;
typedef void* Class;
typedef void* Product_AutoGrouping;
typedef void* Dimension;
typedef void* ProductNode;
typedef void* ImageOutputStream;
typedef void* Stx;
typedef void* Rectangle;
typedef void* SimpleFeatureType;
typedef void* SampleCoding;
typedef void* Object;
typedef void* ProductData_UTC;
typedef void* Integer;
typedef void* ProductReaderPlugIn;
typedef void* ColorPaletteDef_Point;
typedef void* RenderedImage;
typedef void* IndexValidator;
typedef void* Area;
typedef void* ComponentColorModel;
typedef void* Iterator;
typedef void* MathTransform;
typedef void* CoordinateReferenceSystem;
typedef void* ProductWriterPlugIn;
typedef void* File;
typedef void* MapProjection;
typedef void* E;
typedef void* IndexColorModel;
typedef void* ImageInfo_HistogramMatching;
typedef void* ProductNodeListener;
typedef void* Map;
typedef void* Pointing;
typedef void* Color;
typedef void* PlacemarkDescriptor;
typedef void* PointingFactory;
typedef void* TransectProfileData;
typedef void* Point2D;
typedef void* T;
typedef void* ProductVisitor;
typedef void* Scaling;
typedef void* WritableNamespace;
typedef void* MultiLevelImage;
typedef void* ROI;
typedef void* Collection;
typedef void* ProductManager_Listener;
typedef void* GeoTIFFMetadata;
typedef void* MapInfo;
typedef void* Histogram;
typedef void* BufferedImage;
typedef void* SimpleFeature;
typedef void* ProductSubsetDef;
typedef void* ProgressMonitor;
typedef void* VectorDataNode;
typedef void* GeneralPath;
typedef void* ImageInputStream;



/*
 * Java VM functions that must be used if this module is used in stand-alone
 * mode (= not loaded as shared library by a Java VM).
 */

boolean beam_is_jvm_created();
boolean beam_create_jvm(const char* option_strings[], int option_count);
boolean beam_create_jvm_with_defaults();
boolean beam_destroy_jvm();

String String_newString(const char* chars);


/* Functions for class GeoCoding */

/**
 *  Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.

 @return <code>true</code>, if so

 */
boolean GeoCoding_isCrossingMeridianAt180(GeoCoding _self);
/**
 *  Checks whether or not this geo-coding can determine the pixel position from a geodetic position.

 @return <code>true</code>, if so

 */
boolean GeoCoding_canGetPixelPos(GeoCoding _self);
/**
 *  Checks whether or not this geo-coding can determine the geodetic position from a pixel position.

 @return <code>true</code>, if so

 */
boolean GeoCoding_canGetGeoPos(GeoCoding _self);
/**
 *  Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.

 @param geoPos   the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}
 @param pixelPos an instance of <code>Point</code> to be used as retun value. If this parameter is
                 <code>null</code>, the method creates a new instance which it then returns.

 @return the pixel co-ordinates as x/y

 */
PixelPos GeoCoding_getPixelPos(GeoCoding _self, GeoPos geoPos, PixelPos pixelPos);
/**
 *  Returns the latitude and longitude value for a given pixel co-ordinate.

 @param pixelPos the pixel's co-ordinates given as x,y
 @param geoPos   an instance of <code>GeoPos</code> to be used as retun value. If this parameter is
                 <code>null</code>, the method creates a new instance which it then returns.

 @return the geographical position as lat/lon in the coodinate system determined by {@link #getDatum()}

 */
GeoPos GeoCoding_getGeoPos(GeoCoding _self, PixelPos pixelPos, GeoPos geoPos);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.

 */
void GeoCoding_dispose(GeoCoding _self);
/**
 *  @return The image coordinate reference system (CRS). It is usually derived from the base CRS by including
         a linear or non-linear transformation from base (geodetic) coordinates to image coordinates.

 */
CoordinateReferenceSystem GeoCoding_getImageCRS(GeoCoding _self);
/**
 *  @return The map coordinate reference system (CRS). It may be either a geographical CRS (nominal case is
         "WGS-84") or a derived projected CRS, e.g. "UTM 32 - North".

 */
CoordinateReferenceSystem GeoCoding_getMapCRS(GeoCoding _self);
/**
 *  @return The geographical coordinate reference system (CRS). It may be either "WGS-84" (nominal case) or
         any other geographical CRS.

 */
CoordinateReferenceSystem GeoCoding_getGeoCRS(GeoCoding _self);
/**
 *  @return The math transformation used to convert image coordinates to map coordinates.

 */
MathTransform GeoCoding_getImageToMapTransform(GeoCoding _self);

/* Functions for class ProductWriter */

/**
 *  Returns the plug-in which created this product writer.

 @return the product writer plug-in, should never be <code>null</code>

 */
ProductWriterPlugIn ProductWriter_getWriterPlugIn(ProductWriter _self);
/**
 *  Retrives the current output destination object. Thie return value might be <code>null</code> if the
 <code>setOutput</code> has not been called so far.

 @return the output

 */
Object ProductWriter_getOutput(ProductWriter _self);
/**
 *  Writes the in-memory representation of a data product.
 <p/>
 <p> Whether the band data - the actual pixel values - is written out immediately or later when pixels are
 flushed, is up to the implementation.

 @param product the in-memory representation of the data product
 @param output  an object representing a valid output for this writer, might be a <code>ImageInputStream</code> or
                other <code>Object</code> to use for future decoding.

 @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is not one of the
                                  supported output sources.
 @throws IOException              if an I/O error occurs

 */
void ProductWriter_writeProductNodes(ProductWriter _self, Product product, Object output);
/**
 *  Writes raster data from the given in-memory source buffer into the data sink specified by the given source band
 and region.
 <p/>
 <h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample
 values given in the source buffer. The method does not modify the pixel data of the given source band at all.
 <p/>
 <h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>
 and <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data
 and <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be
 <code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in
 line-by-line order, so the raster X co-ordinate varies faster than the Y.
 <p/>
 <h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,
 <code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the
 source band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates
 since product writers do not support spectral or spatial subsets.

 @param sourceBand    the source band which identifies the data sink to which to write the sample values
 @param sourceOffsetX the X-offset in the band's raster co-ordinates
 @param sourceOffsetY the Y-offset in the band's raster co-ordinates
 @param sourceWidth   the width of region to be written given in the band's raster co-ordinates
 @param sourceHeight  the height of region to be written given in the band's raster co-ordinates
 @param sourceBuffer  the source buffer which provides the sample values to be written
 @param pm            a monitor to inform the user about progress

 @throws IOException              if an I/O error occurs
 @throws IllegalArgumentException if the number of elements source buffer not equals <code>sourceWidth *
                                  sourceHeight</code> or the source region is out of the band's raster
 @see org.esa.beam.framework.datamodel.Band#getRasterWidth()
 @see org.esa.beam.framework.datamodel.Band#getRasterHeight()

 */
void ProductWriter_writeBandRasterData(ProductWriter _self, Band sourceBand, int sourceOffsetX, int sourceOffsetY, int sourceWidth, int sourceHeight, ProductData sourceBuffer, ProgressMonitor pm);
/**
 *  Writes all data in memory to the data sink(s) associated with this writer.

 @throws IOException if an I/O error occurs

 */
void ProductWriter_flush(ProductWriter _self);
/**
 *  Closes all output streams currently open. A concrete implementation should call <code>flush</code> before
 performing the actual close-operation.

 @throws IOException if an I/O error occurs

 */
void ProductWriter_close(ProductWriter _self);
/**
 *  Returns wether the given product node is to be written.

 @param node the product node

 @return <code>true</code> if so

 */
boolean ProductWriter_shouldWrite(ProductWriter _self, ProductNode node);
/**
 *  Returns whether this product writer writes only modified product nodes.

 @return <code>true</code> if so

 */
boolean ProductWriter_isIncrementalMode(ProductWriter _self);
/**
 *  Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress
 listening.

 @param enabled enables or disables progress listening.

 */
void ProductWriter_setIncrementalMode(ProductWriter _self, boolean enabled);
/**
 *  Complete deletes the physical representation of the given product from the file system.

 @throws IOException if an I/O error occurs

 */
void ProductWriter_deleteOutput(ProductWriter _self);
/**
 *  Physically deletes a <code>Band</code> in a product writer's output.

 @param band The band to delete.

 */
void ProductWriter_removeBand(ProductWriter _self, Band band);

/* Functions for class IndexCoding */

/**
 *  Constructs a new index coding object with the given name.

 @param name the name

 */
IndexCoding IndexCoding_newIndexCoding(const char* name);
/**
 *  Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to
 getPropertyValue(String).

 @param name the flag name
 @return a metadata attribute wich is the representation of the flag with the given name

 */
MetadataAttribute IndexCoding_getIndex(IndexCoding _self, const char* name);
/**
 *  Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.

 @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this
         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned

 */
char** IndexCoding_getIndexNames(IndexCoding _self, int* resultArrayLength);
/**
 *  Adds a new index definition to this flags coding.

 @param name        the index name
 @param value       the index value
 @param description the description text
 @throws IllegalArgumentException if <code>name</code> is null
 @return A new attribute representing the coded index. 

 */
MetadataAttribute IndexCoding_addIndex(IndexCoding _self, const char* name, int value, const char* description);
/**
 *  Returns the flag mask value for the specified flag name.

 @param name the flag name
 @return flagMask the flag's bit mask as a 32 bit integer
 @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist

 */
int IndexCoding_getIndexValue(IndexCoding _self, const char* name);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.

 @param visitor the visitor, must not be <code>null</code>

 */
void IndexCoding_acceptVisitor(IndexCoding _self, ProductVisitor visitor);
/**
 *  Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.

 @param element the element to be added, always ignored

 */
void IndexCoding_addElement(IndexCoding _self, MetadataElement element);
/**
 *  Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.

 @param attribute the attribute to be added
 @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value

 */
void IndexCoding_addAttribute(IndexCoding _self, MetadataAttribute attribute);
/**
 *  Adds a new coding value to this sample coding.

 @param name        the coding name
 @param value       the value
 @param description the description text
 @throws IllegalArgumentException if <code>name</code> is null
 @return A new attribute representing the coded sample.

 */
MetadataAttribute IndexCoding_addSample(IndexCoding _self, const char* name, int value, const char* description);
/**
 *  Gets the number of coded sample values.

 @return the number of coded sample values

 */
int IndexCoding_getSampleCount(IndexCoding _self);
/**
 *  Gets the sample name at the specified attribute index.

 @param index the attribute index.
 @return the sample name.

 */
char* IndexCoding_getSampleName(IndexCoding _self, int index);
/**
 *  Gets the sample value at the specified attribute index.

 @param index the attribute index.
 @return the sample value.

 */
int IndexCoding_getSampleValue(IndexCoding _self, int index);
/**
 *  Gets the group of child elements. The method returns null, if this element has no children.
 @return The child element group, may be null.

 */
ProductNodeGroup IndexCoding_getElementGroup(IndexCoding _self);
/**
 * 
 */
MetadataElement IndexCoding_getParentElement(IndexCoding _self);
/**
 *  Adds the given element to this element at index.

 @param element the element to added, ignored if <code>null</code>
 @param index   where to put it

 */
void IndexCoding_addElementAt(IndexCoding _self, MetadataElement element, int index);
/**
 *  Removes the given element from this element.

 @param element the element to be removed, ignored if <code>null</code>
 @return true, if so

 */
boolean IndexCoding_removeElement(IndexCoding _self, MetadataElement element);
/**
 *  @return the number of elements contained in this element.

 */
int IndexCoding_getNumElements(IndexCoding _self);
/**
 *  Returns the element at the given index.

 @param index the element index
 @return the element at the given index
 @throws IndexOutOfBoundsException if the index is out of bounds

 */
MetadataElement IndexCoding_getElementAt(IndexCoding _self, int index);
/**
 *  Returns a string array containing the names of the groups contained in this element

 @return a string array containing the names of the groups contained in this element. If this element has no
         groups a zero-length-array is returned.

 */
char** IndexCoding_getElementNames(IndexCoding _self, int* resultArrayLength);
/**
 *  Returns an array of elements contained in this element.

 @return an array of elements contained in this product. If this element has no elements a zero-length-array is
         returned.

 */
MetadataElement* IndexCoding_getElements(IndexCoding _self, int* resultArrayLength);
/**
 *  Returns the element with the given name.

 @param name the element name
 @return the element with the given name or <code>null</code> if a element with the given name is not contained in
         this element.

 */
MetadataElement IndexCoding_getElement(IndexCoding _self, const char* name);
/**
 *  Tests if a element with the given name is contained in this element.

 @param name the name, must not be <code>null</code>
 @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>
         otherwise

 */
boolean IndexCoding_containsElement(IndexCoding _self, const char* name);
/**
 *  Gets the index of the given element.
 @param element  The element .
 @return The element's index, or -1.
 @since BEAM 4.7

 */
int IndexCoding_getElementIndex(IndexCoding _self, MetadataElement element);
/**
 *  Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.

 @param attribute the attribute to be removed, <code>null</code> is ignored
 @return <code>true</code> if it was removed

 */
boolean IndexCoding_removeAttribute(IndexCoding _self, MetadataAttribute attribute);
/**
 *  Returns the number of attributes attaached to this node.

 @return the number of attributes

 */
int IndexCoding_getNumAttributes(IndexCoding _self);
/**
 *  Returns the attribute at the given index.

 @param index the attribute index
 @return the attribute, or <code>null</code> if this node does not contain attributes
 @throws IndexOutOfBoundsException

 */
MetadataAttribute IndexCoding_getAttributeAt(IndexCoding _self, int index);
/**
 *  Returns the names of all attributes of this node.

 @return the attribute name array, never <code>null</code>

 */
char** IndexCoding_getAttributeNames(IndexCoding _self, int* resultArrayLength);
/**
 *  Returns an array of attributes contained in this element.

 @return an array of attributes contained in this product. If this element has no attributes a zero-length-array
         is returned.

 */
MetadataAttribute* IndexCoding_getAttributes(IndexCoding _self, int* resultArrayLength);
/**
 *  Returns the attribute with the given name.

 @param name the attribute name
 @return the attribute with the given name or <code>null</code> if it could not be found

 */
MetadataAttribute IndexCoding_getAttribute(IndexCoding _self, const char* name);
/**
 *  Checks whether this node has an element with the given name.

 @param name the attribute name
 @return <code>true</code> if so

 */
boolean IndexCoding_containsAttribute(IndexCoding _self, const char* name);
/**
 *  Gets the index of the given attribute.
 @param attribute  The attribute.
 @return The attribute's index, or -1.
 @since BEAM 4.7

 */
int IndexCoding_getAttributeIndex(IndexCoding _self, MetadataAttribute attribute);
/**
 *  Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as double.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
double IndexCoding_getAttributeDouble(IndexCoding _self, const char* name, double defaultValue);
/**
 *  Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as UTC.

 */
ProductData_UTC IndexCoding_getAttributeUTC(IndexCoding _self, const char* name, ProductData_UTC defaultValue);
/**
 *  Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
int IndexCoding_getAttributeInt(IndexCoding _self, const char* name, int defaultValue);
/**
 *  Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void IndexCoding_setAttributeInt(IndexCoding _self, const char* name, int value);
/**
 *  Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void IndexCoding_setAttributeDouble(IndexCoding _self, const char* name, double value);
/**
 *  Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void IndexCoding_setAttributeUTC(IndexCoding _self, const char* name, ProductData_UTC value);
/**
 *  Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.

 */
char* IndexCoding_getAttributeString(IndexCoding _self, const char* name, const char* defaultValue);
/**
 *  Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void IndexCoding_setAttributeString(IndexCoding _self, const char* name, const char* value);
/**
 * 
 */
void IndexCoding_setModified(IndexCoding _self, boolean modified);
/**
 * 
 */
MetadataElement IndexCoding_createDeepClone(IndexCoding _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void IndexCoding_dispose(IndexCoding _self);
/**
 *  @return The owner node of this node.

 */
ProductNode IndexCoding_getOwner(IndexCoding _self);
/**
 *  @return This node's name.

 */
char* IndexCoding_getName(IndexCoding _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void IndexCoding_setName(IndexCoding _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* IndexCoding_getDescription(IndexCoding _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void IndexCoding_setDescription(IndexCoding _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean IndexCoding_isModified(IndexCoding _self);
/**
 * 
 */
char* IndexCoding_toString(IndexCoding _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean IndexCoding_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product IndexCoding_getProduct(IndexCoding _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader IndexCoding_getProductReader(IndexCoding _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter IndexCoding_getProductWriter(IndexCoding _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* IndexCoding_getDisplayName(IndexCoding _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* IndexCoding_getProductRefString(IndexCoding _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void IndexCoding_updateExpression(IndexCoding _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void IndexCoding_removeFromFile(IndexCoding _self, ProductWriter productWriter);
/**
 * 
 */
E IndexCoding_getExtension(IndexCoding _self, Class arg0);

/* Functions for class PixelPos */

/**
 *  Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0).

 */
PixelPos PixelPos_newPixelPos1();
/**
 *  Constructs and initializes a <code>PixelPos</code> with the specified coordinate.

 @param x the x component of the coordinate
 @param y the y component of the coordinate

 */
PixelPos PixelPos_newPixelPos2(float x, float y);
/**
 *  Tests whether or not this pixel position is valid.

 @return true, if so

 */
boolean PixelPos_isValid(PixelPos _self);
/**
 *  Sets this pixel position so that is becomes invalid.

 */
void PixelPos_setInvalid(PixelPos _self);
/**
 * 
 */
double PixelPos_getX(PixelPos _self);
/**
 * 
 */
double PixelPos_getY(PixelPos _self);
/**
 * 
 */
void PixelPos_setLocation1(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
void PixelPos_setLocation2(PixelPos _self, float arg0, float arg1);
/**
 * 
 */
char* PixelPos_toString(PixelPos _self);
/**
 * 
 */
void PixelPos_setLocation3(PixelPos _self, Point2D arg0);
/**
 * 
 */
double PixelPos_distanceSq2(double arg0, double arg1, double arg2, double arg3);
/**
 * 
 */
double PixelPos_distance2(double arg0, double arg1, double arg2, double arg3);
/**
 * 
 */
double PixelPos_distanceSq1(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
double PixelPos_distanceSq3(PixelPos _self, Point2D arg0);
/**
 * 
 */
double PixelPos_distance1(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
double PixelPos_distance3(PixelPos _self, Point2D arg0);
/**
 * 
 */
Object PixelPos_clone(PixelPos _self);
/**
 * 
 */
int PixelPos_hashCode(PixelPos _self);
/**
 * 
 */
boolean PixelPos_equals(PixelPos _self, Object arg0);

/* Functions for class ProductIO */

/**
 *  Gets a product reader for the given format name.

 @param formatName the product format name
 @return a suitable product reader or <code>null</code> if none was found

 */
ProductReader ProductIO_getProductReader(const char* formatName);
/**
 *  Gets an array of writer product file extensions for the given format name.

 @param formatName the format name
 @return an array of extensions or null if the format does not exist

 */
char** ProductIO_getProductWriterExtensions(const char* formatName, int* resultArrayLength);
/**
 *  Gets a product writer for the given format name.

 @param formatName the product format name
 @return a suitable product writer or <code>null</code> if none was found

 */
ProductWriter ProductIO_getProductWriter(const char* formatName);
/**
 *  Reads the data product specified by the given file path.
 <p>The product returned will be associated with the reader appropriate for the given
 file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>
 <p>The method does not automatically read band data, thus
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>

 @param filePath the data product file path
 @return a data model as an in-memory representation of the given product file or <code>null</code> if no
         appropriate reader was found for the given product file
 @throws IOException if an I/O error occurs
 @see #readProduct(File)

 */
Product ProductIO_readProduct(const char* filePath);
/**
 *  Tries to find a product reader instance suitable for the given input.
 The method returns {@code null}, if no
 registered product reader can handle the given {@code input} value.
 <p/>
 The {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or
 {@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.

 @param input the input object.
 @return a product reader for the given {@code input} or {@code null} if no registered reader can handle
         the it.
 @see ProductReaderPlugIn#getDecodeQualification(Object)
 @see ProductReader#readProductNodes(Object, ProductSubsetDef)

 */
ProductReader ProductIO_getProductReaderForInput(Object input);
/**
 *  Writes a product with the specified format to the given file path.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.

 @param product    the product, must not be <code>null</code>
 @param filePath   the file path
 @param formatName the name of a supported product format, e.g. "HDF5". If <code>null</code>, the default format
                   "BEAM-DIMAP" will be used
 @throws IOException if an IOException occurs

 */
void ProductIO_writeProduct(Product product, const char* filePath, const char* formatName);

/* Functions for class Placemark */

/**
 *  Constructor.

 @param descriptor The placemark descriptor that created this placemark.
 @param feature    The wrapped feature.

 */
Placemark Placemark_newPlacemark(PlacemarkDescriptor descriptor, SimpleFeature feature);
/**
 *  Creates a point placemark.

 @param descriptor The placemark descriptor that created this placemark.
 @param name       The placemark's name.
 @param label      The placemark's label. May be {@code null}.
 @param text       The placemark's (XHTML) text. May be {@code null}.
 @param pixelPos   The placemark's pixel position. May be {@code null}, if {@code geoPos} is given.
 @param geoPos     The placemark's pixel position. May be {@code null}, if {@code pixelPos} is given.
 @param geoCoding  The placemark's geo-coding. Used to compute {@code pixelPos} from {@code geoPos}, if {@code pixelPos} is {@code null}.
 @return A new point placemark.

 */
Placemark Placemark_createPointPlacemark(PlacemarkDescriptor descriptor, const char* name, const char* label, const char* text, PixelPos pixelPos, GeoPos geoPos, GeoCoding geoCoding);
/**
 *  @return The placemark descriptor that created this placemark.
 @since BEAM 4.10

 */
PlacemarkDescriptor Placemark_getDescriptor(Placemark _self);
/**
 *  @return The wrapped {@link SimpleFeature} underlying this placemark.
 @since BEAM 4.7

 */
SimpleFeature Placemark_getFeature(Placemark _self);
/**
 *  Gets the attribute value of the underlying feature.

 @param attributeName The feature's attribute name.
 @return The feature's attribute value, may be {@code null}.

 */
Object Placemark_getAttributeValue(Placemark _self, const char* attributeName);
/**
 *  Sets the attribute value of the underlying feature.

 @param attributeName  The feature's attribute name.
 @param attributeValue The feature's attribute value, may be {@code null}.

 */
void Placemark_setAttributeValue(Placemark _self, const char* attributeName, Object attributeValue);
/**
 *  Sets this placemark's label.

 @param label the label, if {@code null} an empty label is set.

 */
void Placemark_setLabel(Placemark _self, const char* label);
/**
 *  @return This placemark's label, cannot be {@code null}.

 */
char* Placemark_getLabel(Placemark _self);
/**
 *  Sets this placemark's (XHTML) text.

 @param text The text, if {@code null} an empty text is set.

 */
void Placemark_setText(Placemark _self, const char* text);
/**
 *  @return This placemark's (XHTML) text, cannot be {@code null}.

 */
char* Placemark_getText(Placemark _self);
/**
 *  Sets this placemark's CSS style.

 @param styleCss The text, if {@code null} an empty text is set.
 @since BEAM 4.10

 */
void Placemark_setStyleCss(Placemark _self, const char* styleCss);
/**
 *  @return This placemark's CSS style, cannot be {@code null}.
 @since BEAM 4.10

 */
char* Placemark_getStyleCss(Placemark _self);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.

 @param visitor the visitor

 */
void Placemark_acceptVisitor(Placemark _self, ProductVisitor visitor);
/**
 * 
 */
PixelPos Placemark_getPixelPos(Placemark _self);
/**
 * 
 */
void Placemark_setPixelPos(Placemark _self, PixelPos pixelPos);
/**
 * 
 */
GeoPos Placemark_getGeoPos(Placemark _self);
/**
 * 
 */
void Placemark_setGeoPos(Placemark _self, GeoPos geoPos);
/**
 *  Updates pixel and geo position according to the current geometry (model coordinates).

 */
void Placemark_updatePositions(Placemark _self);
/**
 * 
 */
SimpleFeatureType Placemark_createPinFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGcpFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGeometryFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createPointFeatureType(const char* name);
/**
 *  @return The owner node of this node.

 */
ProductNode Placemark_getOwner(Placemark _self);
/**
 *  @return This node's name.

 */
char* Placemark_getName(Placemark _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void Placemark_setName(Placemark _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* Placemark_getDescription(Placemark _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void Placemark_setDescription(Placemark _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean Placemark_isModified(Placemark _self);
/**
 *  Sets this node's modified flag.
 <p/>
 If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to
 true.

 @param modified whether or not this node is beeing marked as modified.
 @see org.esa.beam.framework.datamodel.Product#fireNodeChanged

 */
void Placemark_setModified(Placemark _self, boolean modified);
/**
 * 
 */
char* Placemark_toString(Placemark _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void Placemark_dispose(Placemark _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean Placemark_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product Placemark_getProduct(Placemark _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader Placemark_getProductReader(Placemark _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter Placemark_getProductWriter(Placemark _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* Placemark_getDisplayName(Placemark _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* Placemark_getProductRefString(Placemark _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void Placemark_updateExpression(Placemark _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void Placemark_removeFromFile(Placemark _self, ProductWriter productWriter);
/**
 * 
 */
E Placemark_getExtension(Placemark _self, Class arg0);

/* Functions for class MetadataElement */

/**
 *  Constructs a new metadata element.

 @param name the element name

 */
MetadataElement MetadataElement_newMetadataElement(const char* name);
/**
 *  Gets the group of child elements. The method returns null, if this element has no children.
 @return The child element group, may be null.

 */
ProductNodeGroup MetadataElement_getElementGroup(MetadataElement _self);
/**
 * 
 */
MetadataElement MetadataElement_getParentElement(MetadataElement _self);
/**
 *  Adds the given element to this element.

 @param element the element to added, ignored if <code>null</code>

 */
void MetadataElement_addElement(MetadataElement _self, MetadataElement element);
/**
 *  Adds the given element to this element at index.

 @param element the element to added, ignored if <code>null</code>
 @param index   where to put it

 */
void MetadataElement_addElementAt(MetadataElement _self, MetadataElement element, int index);
/**
 *  Removes the given element from this element.

 @param element the element to be removed, ignored if <code>null</code>
 @return true, if so

 */
boolean MetadataElement_removeElement(MetadataElement _self, MetadataElement element);
/**
 *  @return the number of elements contained in this element.

 */
int MetadataElement_getNumElements(MetadataElement _self);
/**
 *  Returns the element at the given index.

 @param index the element index
 @return the element at the given index
 @throws IndexOutOfBoundsException if the index is out of bounds

 */
MetadataElement MetadataElement_getElementAt(MetadataElement _self, int index);
/**
 *  Returns a string array containing the names of the groups contained in this element

 @return a string array containing the names of the groups contained in this element. If this element has no
         groups a zero-length-array is returned.

 */
char** MetadataElement_getElementNames(MetadataElement _self, int* resultArrayLength);
/**
 *  Returns an array of elements contained in this element.

 @return an array of elements contained in this product. If this element has no elements a zero-length-array is
         returned.

 */
MetadataElement* MetadataElement_getElements(MetadataElement _self, int* resultArrayLength);
/**
 *  Returns the element with the given name.

 @param name the element name
 @return the element with the given name or <code>null</code> if a element with the given name is not contained in
         this element.

 */
MetadataElement MetadataElement_getElement(MetadataElement _self, const char* name);
/**
 *  Tests if a element with the given name is contained in this element.

 @param name the name, must not be <code>null</code>
 @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>
         otherwise

 */
boolean MetadataElement_containsElement(MetadataElement _self, const char* name);
/**
 *  Gets the index of the given element.
 @param element  The element .
 @return The element's index, or -1.
 @since BEAM 4.7

 */
int MetadataElement_getElementIndex(MetadataElement _self, MetadataElement element);
/**
 *  Adds an attribute to this node.

 @param attribute the attribute to be added, <code>null</code> is ignored

 */
void MetadataElement_addAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 *  Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.

 @param attribute the attribute to be removed, <code>null</code> is ignored
 @return <code>true</code> if it was removed

 */
boolean MetadataElement_removeAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 *  Returns the number of attributes attaached to this node.

 @return the number of attributes

 */
int MetadataElement_getNumAttributes(MetadataElement _self);
/**
 *  Returns the attribute at the given index.

 @param index the attribute index
 @return the attribute, or <code>null</code> if this node does not contain attributes
 @throws IndexOutOfBoundsException

 */
MetadataAttribute MetadataElement_getAttributeAt(MetadataElement _self, int index);
/**
 *  Returns the names of all attributes of this node.

 @return the attribute name array, never <code>null</code>

 */
char** MetadataElement_getAttributeNames(MetadataElement _self, int* resultArrayLength);
/**
 *  Returns an array of attributes contained in this element.

 @return an array of attributes contained in this product. If this element has no attributes a zero-length-array
         is returned.

 */
MetadataAttribute* MetadataElement_getAttributes(MetadataElement _self, int* resultArrayLength);
/**
 *  Returns the attribute with the given name.

 @param name the attribute name
 @return the attribute with the given name or <code>null</code> if it could not be found

 */
MetadataAttribute MetadataElement_getAttribute(MetadataElement _self, const char* name);
/**
 *  Checks whether this node has an element with the given name.

 @param name the attribute name
 @return <code>true</code> if so

 */
boolean MetadataElement_containsAttribute(MetadataElement _self, const char* name);
/**
 *  Gets the index of the given attribute.
 @param attribute  The attribute.
 @return The attribute's index, or -1.
 @since BEAM 4.7

 */
int MetadataElement_getAttributeIndex(MetadataElement _self, MetadataAttribute attribute);
/**
 *  Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as double.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
double MetadataElement_getAttributeDouble(MetadataElement _self, const char* name, double defaultValue);
/**
 *  Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as UTC.

 */
ProductData_UTC MetadataElement_getAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC defaultValue);
/**
 *  Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
int MetadataElement_getAttributeInt(MetadataElement _self, const char* name, int defaultValue);
/**
 *  Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void MetadataElement_setAttributeInt(MetadataElement _self, const char* name, int value);
/**
 *  Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void MetadataElement_setAttributeDouble(MetadataElement _self, const char* name, double value);
/**
 *  Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void MetadataElement_setAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC value);
/**
 *  Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.

 */
char* MetadataElement_getAttributeString(MetadataElement _self, const char* name, const char* defaultValue);
/**
 *  Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void MetadataElement_setAttributeString(MetadataElement _self, const char* name, const char* value);
/**
 * 
 */
void MetadataElement_setModified(MetadataElement _self, boolean modified);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then
 visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.

 @param visitor the visitor

 */
void MetadataElement_acceptVisitor(MetadataElement _self, ProductVisitor visitor);
/**
 * 
 */
MetadataElement MetadataElement_createDeepClone(MetadataElement _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void MetadataElement_dispose(MetadataElement _self);
/**
 *  @return The owner node of this node.

 */
ProductNode MetadataElement_getOwner(MetadataElement _self);
/**
 *  @return This node's name.

 */
char* MetadataElement_getName(MetadataElement _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void MetadataElement_setName(MetadataElement _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* MetadataElement_getDescription(MetadataElement _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void MetadataElement_setDescription(MetadataElement _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean MetadataElement_isModified(MetadataElement _self);
/**
 * 
 */
char* MetadataElement_toString(MetadataElement _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean MetadataElement_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product MetadataElement_getProduct(MetadataElement _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader MetadataElement_getProductReader(MetadataElement _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter MetadataElement_getProductWriter(MetadataElement _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* MetadataElement_getDisplayName(MetadataElement _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* MetadataElement_getProductRefString(MetadataElement _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void MetadataElement_updateExpression(MetadataElement _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void MetadataElement_removeFromFile(MetadataElement _self, ProductWriter productWriter);
/**
 * 
 */
E MetadataElement_getExtension(MetadataElement _self, Class arg0);

/* Functions for class Product */

/**
 *  Creates a new product without any reader (in-memory product)

 @param name              the product name
 @param type              the product type
 @param sceneRasterWidth  the scene width in pixels for this data product
 @param sceneRasterHeight the scene height in pixels for this data product

 */
Product Product_newProduct(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight);
/**
 *  Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no
 disk location (pure virtual memory product)

 @return the file location, may be <code>null</code>

 */
File Product_getFileLocation(Product _self);
/**
 *  Sets the file location for this product.

 @param fileLocation the file location, may be <code>null</code>

 */
void Product_setFileLocation(Product _self, File fileLocation);
/**
 *  Gets the product type string.

 @return the product type string

 */
char* Product_getProductType(Product _self);
/**
 *  Sets the product type of this product.

 @param productType the product type.

 */
void Product_setProductType(Product _self, const char* productType);
/**
 *  Sets the product reader which will be used to create this product in-memory represention from an external source
 and which will be used to (re-)load band rasters.

 @param reader the product reader.

 @throws IllegalArgumentException if the given reader is null.

 */
void Product_setProductReader(Product _self, ProductReader reader);
/**
 *  Returns the reader which was used to create this product in-memory represention from an external source and which
 will be used to (re-)load band rasters.

 @return the product reader, can be <code>null</code>

 */
ProductReader Product_getProductReader(Product _self);
/**
 *  Sets the writer which will be used to write modifications of this product's in-memory represention to an external
 destination.

 @param writer the product writer, can be <code>null</code>

 */
void Product_setProductWriter(Product _self, ProductWriter writer);
/**
 *  Returns the writer which will be used to write modifications of this product's in-memory represention to an
 external destination.

 @return the product writer, can be <code>null</code>

 */
ProductWriter Product_getProductWriter(Product _self);
/**
 *  <p>Writes the header of a data product.<p/>

 @param output an object representing a valid output for this writer, might be a <code>ImageOutputStream</code>
               or a <code>File</code> or other <code>Object</code> to use for future decoding.

 @throws IllegalArgumentException if <code>output</code> is <code>null</code> or it's type is none of the
                                  supported output types.
 @throws IOException              if an I/O error occurs

 */
void Product_writeHeader(Product _self, Object output);
/**
 *  Closes and clears this product's reader (if any).

 @throws IOException if an I/O error occurs
 @see #closeIO

 */
void Product_closeProductReader(Product _self);
/**
 *  Closes and clears this product's writer (if any).

 @throws IOException if an I/O error occurs
 @see #closeIO

 */
void Product_closeProductWriter(Product _self);
/**
 *  Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and
 <code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but
 should be called if the product instance is no longer in use.

 @throws IOException if an I/O error occurs
 @see #closeProductReader
 @see #closeProductWriter
 @see #dispose

 */
void Product_closeIO(Product _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 </p>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 </p>
 <p>This implementation also calls the <code>closeIO</code> in order to release all open I/O resources.

 */
void Product_dispose(Product _self);
/**
 *  Gets the pointing factory associated with this data product.

 @return the pointing factory or null, if none

 */
PointingFactory Product_getPointingFactory(Product _self);
/**
 *  Sets the pointing factory for this data product.

 @param pointingFactory the pointing factory

 */
void Product_setPointingFactory(Product _self, PointingFactory pointingFactory);
/**
 *  Geo-codes this data product.

 @param geoCoding the geo-coding, if <code>null</code> geo-coding is removed

 @throws IllegalArgumentException <br>- if the given <code>GeoCoding</code> is a <code>TiePointGeoCoding</code>
                                  and <code>latGrid</code> or <code>lonGrid</code> are not instances of tie point
                                  grids in this product. <br>- if the given <code>GeoCoding</code> is a
                                  <code>MapGeoCoding</code> and its <code>MapInfo</code> is <code>null</code>
                                  <br>- if the given <code>GeoCoding</code> is a <code>MapGeoCoding</code> and the
                                  <code>sceneWith</code> or <code>sceneHeight</code> of its <code>MapInfo</code>
                                  is not equal to this products <code>sceneRasterWidth</code> or
                                  <code>sceneRasterHeight</code>

 */
void Product_setGeoCoding(Product _self, GeoCoding geoCoding);
/**
 *  Returns the geo-coding used for this data product.

 @return the geo-coding, can be <code>null</code> if this product is not geo-coded.

 */
GeoCoding Product_getGeoCoding(Product _self);
/**
 *  Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing
 the band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.
 If this product does not have a geo-coding, the method returns false.

 @return true, if so

 */
boolean Product_isUsingSingleGeoCoding(Product _self);
/**
 *  Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to
 the given {@link ProductSubsetDef subsetDef}.

 @param destProduct the destination product
 @param subsetDef   the definition of the subset, may be <code>null</code>

 @return true, if the geo-coding could be transferred.

 */
boolean Product_transferGeoCodingTo(Product _self, Product destProduct, ProductSubsetDef subsetDef);
/**
 *  Returns the scene width in pixels for this data product.

 @return the scene width in pixels for this data product.

 */
int Product_getSceneRasterWidth(Product _self);
/**
 *  Returns the scene height in pixels for this data product.

 @return the scene height in pixels for this data product.

 */
int Product_getSceneRasterHeight(Product _self);
/**
 *  Gets the (sensing) start time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>

 @return the sensing start time, can be null e.g. for non-swath products

 */
ProductData_UTC Product_getStartTime(Product _self);
/**
 *  Sets the (sensing) start time of this product.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>

 @param startTime the sensing start time, can be null

 */
void Product_setStartTime(Product _self, ProductData_UTC startTime);
/**
 *  Gets the (sensing) stop time associated with the last raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>

 @return the stop time , can be null e.g. for non-swath products

 */
ProductData_UTC Product_getEndTime(Product _self);
/**
 *  Sets the (sensing) stop time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>

 @param endTime the sensing stop time, can be null

 */
void Product_setEndTime(Product _self, ProductData_UTC endTime);
/**
 *  Gets the root element of the associated metadata.

 @return the metadata root element

 */
MetadataElement Product_getMetadataRoot(Product _self);
/**
 *  Gets the band group of this product.

 @return The group of all bands.

 @since BEAM 4.7

 */
ProductNodeGroup Product_getBandGroup(Product _self);
/**
 *  Gets the tie-point grid group of this product.

 @return The group of all tie-point grids.

 @since BEAM 4.7

 */
ProductNodeGroup Product_getTiePointGridGroup(Product _self);
/**
 *  Adds the given tie-point grid to this product.

 @param tiePointGrid the tie-point grid to added, ignored if <code>null</code>

 */
void Product_addTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 *  Removes the tie-point grid from this product.

 @param tiePointGrid the tie-point grid to be removed, ignored if <code>null</code>

 @return <code>true</code> if node could be removed

 */
boolean Product_removeTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 *  Returns the number of tie-point grids contained in this product

 @return the number of tie-point grids

 */
int Product_getNumTiePointGrids(Product _self);
/**
 *  Returns the tie-point grid at the given index.

 @param index the tie-point grid index

 @return the tie-point grid at the given index

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
TiePointGrid Product_getTiePointGridAt(Product _self, int index);
/**
 *  Returns a string array containing the names of the tie-point grids contained in this product

 @return a string array containing the names of the tie-point grids contained in this product. If this product has
         no tie-point grids a zero-length-array is returned.

 */
char** Product_getTiePointGridNames(Product _self, int* resultArrayLength);
/**
 *  Returns an array of tie-point grids contained in this product

 @return an array of tie-point grids contained in this product. If this product has no  tie-point grids a
         zero-length-array is returned.

 */
TiePointGrid* Product_getTiePointGrids(Product _self, int* resultArrayLength);
/**
 *  Returns the tie-point grid with the given name.

 @param name the tie-point grid name

 @return the tie-point grid with the given name or <code>null</code> if a tie-point grid with the given name is
         not contained in this product.

 */
TiePointGrid Product_getTiePointGrid(Product _self, const char* name);
/**
 *  Tests if a tie-point grid with the given name is contained in this product.

 @param name the name, must not be <code>null</code>

 @return <code>true</code> if a tie-point grid with the given name is contained in this product,
         <code>false</code> otherwise

 */
boolean Product_containsTiePointGrid(Product _self, const char* name);
/**
 *  Adds the given band to this product.

 @param band the band to added, must not be <code>null</code>

 */
void Product_addBand(Product _self, Band band);
/**
 *  Creates a new band with the given name and data type and adds it to this product and returns it.

 @param bandName the new band's name
 @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>
                 constants

 @return the new band which has just been added

 */
Band Product_addNewBand(Product _self, const char* bandName, int dataType);
/**
 *  Creates a new band with the given name and adds it to this product and returns it.
 The new band's data type is {@code float} and it's samples are computed from the given band maths expression.

 @param bandName   the new band's name
 @param expression the band maths expression

 @return the new band which has just been added

 @since BEAM 4.9

 */
Band Product_addComputedBand(Product _self, const char* bandName, const char* expression);
/**
 *  Removes the given band from this product.

 @param band the band to be removed, ignored if <code>null</code>

 @return {@code true} if removed succesfully, otherwise {@code false}

 */
boolean Product_removeBand(Product _self, Band band);
/**
 *  @return the number of bands contained in this product.

 */
int Product_getNumBands(Product _self);
/**
 *  Returns the band at the given index.

 @param index the band index

 @return the band at the given index

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
Band Product_getBandAt(Product _self, int index);
/**
 *  Returns a string array containing the names of the bands contained in this product

 @return a string array containing the names of the bands contained in this product. If this product has no bands
         a zero-length-array is returned.

 */
char** Product_getBandNames(Product _self, int* resultArrayLength);
/**
 *  Returns an array of bands contained in this product

 @return an array of bands contained in this product. If this product has no bands a zero-length-array is
         returned.

 */
Band* Product_getBands(Product _self, int* resultArrayLength);
/**
 *  Returns the band with the given name.

 @param name the band name

 @return the band with the given name or <code>null</code> if a band with the given name is not contained in this
         product.

 @throws IllegalArgumentException if the given name is <code>null</code> or empty.

 */
Band Product_getBand(Product _self, const char* name);
/**
 *  Returns the index for the band with the given name.

 @param name the band name

 @return the band index or <code>-1</code> if a band with the given name is not contained in this product.

 @throws IllegalArgumentException if the given name is <code>null</code> or empty.

 */
int Product_getBandIndex(Product _self, const char* name);
/**
 *  Tests if a band with the given name is contained in this product.

 @param name the name, must not be <code>null</code>

 @return <code>true</code> if a band with the given name is contained in this product, <code>false</code>
         otherwise

 @throws IllegalArgumentException if the given name is <code>null</code> or empty.

 */
boolean Product_containsBand(Product _self, const char* name);
/**
 *  Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or
 tie-point grids.

 @param name the name, must not be <code>null</code>

 @return <code>true</code> if a raster data node with the given name is contained in this product,
         <code>false</code> otherwise

 */
boolean Product_containsRasterDataNode(Product _self, const char* name);
/**
 *  Gets the raster data node with the given name. The method first searches for bands with the given name, then for
 tie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.

 @param name the name, must not be <code>null</code>

 @return the raster data node with the given name or <code>null</code> if a raster data node with the given name
         is not contained in this product.

 */
RasterDataNode Product_getRasterDataNode(Product _self, const char* name);
/**
 * 
 */
ProductNodeGroup Product_getMaskGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getVectorDataGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getFlagCodingGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getIndexCodingGroup(Product _self);
/**
 *  Tests if the given pixel position is within the product pixel bounds.

 @param x the x coordinate of the pixel position
 @param y the y coordinate of the pixel position

 @return true, if so

 @see #containsPixel(PixelPos)

 */
boolean Product_containsPixel(Product _self, float x, float y);
/**
 *  Gets the group of ground-control points (GCPs).
 Note that this method will create the group, if none exists already.

 @return the GCP group.

 */
PlacemarkGroup Product_getGcpGroup(Product _self);
/**
 *  Gets the group of pins.
 Note that this method will create the group, if none exists already.

 @return the pin group.

 */
PlacemarkGroup Product_getPinGroup(Product _self);
/**
 *  Checks whether or not the given product is compatible with this product.

 @param product the product to compare with
 @param eps     the maximum lat/lon error in degree

 @return <code>false</code> if the scene dimensions or geocoding are different, <code>true</code> otherwise.

 */
boolean Product_isCompatibleProduct(Product _self, Product product, float eps);
/**
 *  Parses a mathematical expression given as a text string.

 @param expression a expression given as a text string, e.g. "radiance_4 / (1.0 + radiance_11)".

 @return a term parsed from the given expression string

 @throws ParseException if the expression could not successfully be parsed

 */
Term Product_parseExpression(Product _self, const char* expression);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag
 codings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.

 @param visitor the visitor, must not be <code>null</code>

 */
void Product_acceptVisitor(Product _self, ProductVisitor visitor);
/**
 *  Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each
 time a node in this product changes.

 @param listener the listener to be added

 @return boolean if listener was added or not

 */
boolean Product_addProductNodeListener(Product _self, ProductNodeListener listener);
/**
 *  Removes a <code>ProductNodeListener</code> from this product.

 @param listener the listener to be removed.

 */
void Product_removeProductNodeListener(Product _self, ProductNodeListener listener);
/**
 * 
 */
ProductNodeListener* Product_getProductNodeListeners(Product _self, int* resultArrayLength);
/**
 *  @return The reference number of this product.

 */
int Product_getRefNo(Product _self);
/**
 *  Sets the reference number.

 @param refNo the reference number to set must be in the range 1 .. Integer.MAX_VALUE

 @throws IllegalArgumentException if the refNo is out of range
 @throws IllegalStateException

 */
void Product_setRefNo(Product _self, int refNo);
/**
 * 
 */
void Product_resetRefNo(Product _self);
/**
 *  Returns the product manager for this product.

 @return this product's manager, can be <code>null</code>

 */
ProductManager Product_getProductManager(Product _self);
/**
 *  Creates a parser for band arithmetic expressions.
 The parser created will use a namespace comprising all tie-point grids, bands and flags of this product.

 @return a parser for band arithmetic expressions for this product, never null

 */
Parser Product_createBandArithmeticParser(Product _self);
/**
 *  Creates a namespace to be used by parsers for band arithmetic expressions.
 The namespace created comprises all tie-point grids, bands and flags of this product.

 @return a namespace, never null

 */
WritableNamespace Product_createBandArithmeticDefaultNamespace(Product _self);
/**
 *  Creates a subset of this product. The returned product represents a true spatial and spectral subset of this
 product, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the
 description from this product was used.

 @param subsetDef the product subset definition
 @param name      the name for the new product
 @param desc      the description for the new product

 @return the product subset, or <code>null</code> if the product/subset combination is not valid

 @throws IOException if an I/O error occurs

 */
Product Product_createSubset(Product _self, ProductSubsetDef subsetDef, const char* name, const char* desc);
/**
 *  Creates a map-projected version of this product.

 @param mapInfo the map information
 @param name    the name for the new product
 @param desc    the description for the new product

 @return the product subset, or <code>null</code> if the product/subset combination is not valid

 @throws IOException if an I/O error occurs

 */
Product Product_createProjectedProduct(Product _self, MapInfo mapInfo, const char* name, const char* desc);
/**
 *  Creates flipped raster-data version of this product.

 @param flipType the flip type, see <code>{@link org.esa.beam.framework.dataio.ProductFlipper}</code>
 @param name     the name for the new product
 @param desc     the description for the new product

 @return the product subset, or <code>null</code> if the product/subset combination is not valid

 @throws IOException if an I/O error occurs

 */
Product Product_createFlippedProduct(Product _self, int flipType, const char* name, const char* desc);
/**
 * 
 */
void Product_setModified(Product _self, boolean modified);
/**
 *  Gets the name of the band suitable for quicklook generation.

 @return the name of the quicklook band, or null if none has been defined

 */
char* Product_getQuicklookBandName(Product _self);
/**
 *  Sets the name of the band suitable for quicklook generation.

 @param quicklookBandName the name of the quicklook band, or null

 */
void Product_setQuicklookBandName(Product _self, const char* quicklookBandName);
/**
 *  Creates a string containing all available information at the given pixel position. The string returned is a line
 separated text with each line containing a key/value pair.

 @param pixelX the pixel X co-ordinate
 @param pixelY the pixel Y co-ordinate

 @return the info string at the given position

 */
char* Product_createPixelInfoString(Product _self, int pixelX, int pixelY);
/**
 *  @return All removed child nodes. Array may be empty.

 */
ProductNode* Product_getRemovedChildNodes(Product _self, int* resultArrayLength);
/**
 *  Checks whether or not this product can be ortorectified.

 @return true if {@link Band#canBeOrthorectified()} returns true for all bands, false otherwise

 */
boolean Product_canBeOrthorectified(Product _self);
/**
 *  Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.

 @return the preferred tile size, may be <code>null</null> if not specified

 @see RasterDataNode#getSourceImage()
 @see RasterDataNode# setSourceImage (java.awt.image.RenderedImage)

 */
Dimension Product_getPreferredTileSize(Product _self);
/**
 *  Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.

 @param tileWidth  the preferred tile width
 @param tileHeight the preferred tile height

 @see #setPreferredTileSize(java.awt.Dimension)

 */
void Product_setPreferredTileSize(Product _self, int tileWidth, int tileHeight);
/**
 *  Returns the names of all flags of all flag datasets contained this product.
 <p/>
 <p>A flag name contains the dataset (a band of this product) and the actual flag name as defined in the
 flag-coding associated with the dataset. The general format for the flag name strings returned is therefore
 <code>"<i>dataset</i>.<i>flag_name</i>"</code>.
 </p>
 <p>The method is used to find out which flags a product has in order to use them in bit-mask expressions.

 @return the array of all flag names. If this product does not support flags, an empty array is returned, but
         never <code>null</code>.

 @see #parseExpression(String)

 */
char** Product_getAllFlagNames(Product _self, int* resultArrayLength);
/**
 *  Gets the auto-grouping applicable to product nodes contained in this product.

 @return The auto-grouping or {@code null}.

 @since BEAM 4.8

 */
Product_AutoGrouping Product_getAutoGrouping(Product _self);
/**
 *  Sets the auto-grouping applicable to product nodes contained in this product.
 A given {@code pattern} parameter is a textual representation of the auto-grouping.
 The syntax for the pattern is:
 <pre>
 pattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | "" (empty string)
 groupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}
 groupName  :=  any non-empty string without characters ':' and '/'
 </pre>
 An example for {@code pattern} applicable to Envisat AATSR data is
 <pre>
 nadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward
 </pre>

 @param pattern The auto-grouping pattern.

 @since BEAM 4.8

 */
void Product_setAutoGrouping(Product _self, const char* pattern);
/**
 *  Creates a new mask using a band arithmetic expression
 and adds it to this product and returns it.

 @param maskName     the new mask's name
 @param expression   the band arithmetic expression
 @param description  the mask's description
 @param color        the display color
 @param transparency the display transparency

 @return the new mask which has just been added

 @since BEAM 4.10

 */
Mask Product_addComputedMask(Product _self, const char* maskName, const char* expression, const char* description, Color color, double transparency);
/**
 *  @return The owner node of this node.

 */
ProductNode Product_getOwner(Product _self);
/**
 *  @return This node's name.

 */
char* Product_getName(Product _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void Product_setName(Product _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* Product_getDescription(Product _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void Product_setDescription(Product _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean Product_isModified(Product _self);
/**
 * 
 */
char* Product_toString(Product _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean Product_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product Product_getProduct(Product _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* Product_getDisplayName(Product _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* Product_getProductRefString(Product _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void Product_updateExpression(Product _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void Product_removeFromFile(Product _self, ProductWriter productWriter);
/**
 * 
 */
E Product_getExtension(Product _self, Class arg0);

/* Functions for class ColorPaletteDef */

/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDefFromRange(double minSample, double maxSample);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDefFromPoints(const ColorPaletteDef_Point* pointsElems, int pointsLength, int numColors);
/**
 * 
 */
boolean ColorPaletteDef_isDiscrete(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setDiscrete(ColorPaletteDef _self, boolean discrete);
/**
 * 
 */
int ColorPaletteDef_getNumColors(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumColors(ColorPaletteDef _self, int numColors);
/**
 * 
 */
int ColorPaletteDef_getNumPoints(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumPoints(ColorPaletteDef _self, int numPoints);
/**
 * 
 */
boolean ColorPaletteDef_isAutoDistribute(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setAutoDistribute(ColorPaletteDef _self, boolean autoDistribute);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getPointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getFirstPoint(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getLastPoint(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMinDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMaxDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_insertPointAfter(ColorPaletteDef _self, int index, ColorPaletteDef_Point point);
/**
 *  creates a new point between the point at the given index

 @param index   the index
 @param scaling the scaling

 @return true, if a point has been inserted

 */
boolean ColorPaletteDef_createPointAfter(ColorPaletteDef _self, int index, Scaling scaling);
/**
 *  Creates the center color between the given two colors.

 @param c1 1st color
 @param c2 2nd color

 @return the center color

 */
Color ColorPaletteDef_getCenterColor(Color c1, Color c2);
/**
 * 
 */
void ColorPaletteDef_removePointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
void ColorPaletteDef_addPoint(ColorPaletteDef _self, ColorPaletteDef_Point point);
/**
 * 
 */
ColorPaletteDef_Point* ColorPaletteDef_getPoints(ColorPaletteDef _self, int* resultArrayLength);
/**
 * 
 */
void ColorPaletteDef_setPoints(ColorPaletteDef _self, const ColorPaletteDef_Point* pointsElems, int pointsLength);
/**
 * 
 */
Iterator ColorPaletteDef_getIterator(ColorPaletteDef _self);
/**
 * 
 */
Object ColorPaletteDef_clone(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_createDeepCopy(ColorPaletteDef _self);
/**
 *  Loads a color palette definition from the given file

 @param file the file

 @return the color palette definition, never null

 @throws IOException if an I/O error occurs

 */
ColorPaletteDef ColorPaletteDef_loadColorPaletteDef(File file);
/**
 *  Stores this color palette definition in the given file

 @param colorPaletteDef thje color palette definition
 @param file            the file

 @throws IOException if an I/O error occurs

 */
void ColorPaletteDef_storeColorPaletteDef(ColorPaletteDef colorPaletteDef, File file);
/**
 *  Releases all of the resources used by this color palette definition and all of its owned children. Its primary
 use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void ColorPaletteDef_dispose(ColorPaletteDef _self);
/**
 * 
 */
Color* ColorPaletteDef_getColors(ColorPaletteDef _self, int* resultArrayLength);
/**
 * 
 */
Color* ColorPaletteDef_createColorPalette(ColorPaletteDef _self, Scaling scaling, int* resultArrayLength);
/**
 * 
 */
Color ColorPaletteDef_computeColor(ColorPaletteDef _self, Scaling scaling, double sample);

/* Functions for class ImageInfo */

/**
 *  Constructs a new image information instance.

 @param colorPaletteDef the color palette definition

 */
ImageInfo ImageInfo_newImageInfoPalette(ColorPaletteDef colorPaletteDef);
/**
 *  Constructs a new RGB image information instance.

 @param rgbChannelDef the RGB channel definition

 */
ImageInfo ImageInfo_newImageInfoRGB(RGBChannelDef rgbChannelDef);
/**
 *  Gets the color palette definition as used for images created from single bands.

 @return The color palette definition. Can be {@code null}.
         In this case {@link #getRgbChannelDef()} is non-null.

 */
ColorPaletteDef ImageInfo_getColorPaletteDef(ImageInfo _self);
/**
 *  Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.

 @return The RGB(A) channel definition.
         Can be {@code null}. In this case {@link #getColorPaletteDef()} is non-null.

 */
RGBChannelDef ImageInfo_getRgbChannelDef(ImageInfo _self);
/**
 * 
 */
Color ImageInfo_getNoDataColor(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setNoDataColor(ImageInfo _self, Color noDataColor);
/**
 * 
 */
void ImageInfo_setHistogramMatching(ImageInfo _self, ImageInfo_HistogramMatching histogramMatching);
/**
 * 
 */
boolean ImageInfo_isLogScaled(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setLogScaled(ImageInfo _self, boolean logScaled);
/**
 * 
 */
Color* ImageInfo_getColors(ImageInfo _self, int* resultArrayLength);
/**
 *  Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.

 @return {@code 3} for RGB images, {@code 4} for RGB images with an alpha channel (transparency)

 */
int ImageInfo_getColorComponentCount(ImageInfo _self);
/**
 * 
 */
IndexColorModel ImageInfo_createIndexColorModel(ImageInfo _self, Scaling scaling);
/**
 * 
 */
ComponentColorModel ImageInfo_createComponentColorModel(ImageInfo _self);
/**
 *  Creates and returns a copy of this object.

 @return a copy of this object

 */
Object ImageInfo_clone(ImageInfo _self);
/**
 *  Creates and returns a "deep" copy of this object. The method simply returns the value of
 {@link #clone()}.

 @return a copy of this object

 */
ImageInfo ImageInfo_createDeepCopy(ImageInfo _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void ImageInfo_dispose(ImageInfo _self);
/**
 *  Sets the colours of the colour palette of this image info.

 @param colors the new colours

 */
void ImageInfo_setColors(ImageInfo _self, const Color* colorsElems, int colorsLength);
/**
 *  Transfers the colour palette into this image info.

 @param colorPaletteDef another colour palette
 @param minSample       the minium allowed sample value in the new colour palette
 @param maxSample       the maximum allowed sample value in the new colour palette
 @param autoDistribute  if true, points are distributed between minSample/maxSample.

 */
void ImageInfo_setColorPaletteDef(ImageInfo _self, ColorPaletteDef colorPaletteDef, double minSample, double maxSample, boolean autoDistribute);
/**
 *  Converts a string to a histogram matching.

 @param mode the histogram matching string
 @return the histogram matching. {@link ImageInfo.HistogramMatching#None} if {@code maode} is not "Equalize" or "Normalize".

 */
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching(const char* mode);

/* Functions for class ProductManager */

/**
 *  Constructs an product manager with an empty list of products.

 */
ProductManager ProductManager_newProductManager();
/**
 *  @return The number of products in this product manager.

 */
int ProductManager_getProductCount(ProductManager _self);
/**
 *  Gets the product at the given index.

 @param index the index

 @return The product at the given index.

 */
Product ProductManager_getProduct(ProductManager _self, int index);
/**
 *  Returns the display names of all products currently managed.

 @return an array containing the display names, never <code>null</code>, but the array can have zero length

 @see ProductNode#getDisplayName()

 */
char** ProductManager_getProductDisplayNames(ProductManager _self, int* resultArrayLength);
/**
 *  Returns the names of all products currently managed.

 @return an array containing the names, never <code>null</code>, but the array can have zero length

 */
char** ProductManager_getProductNames(ProductManager _self, int* resultArrayLength);
/**
 *  Returns an array of all products currently managed.

 @return an array containing the products, never <code>null</code>, but the array can have zero length

 */
Product* ProductManager_getProducts(ProductManager _self, int* resultArrayLength);
/**
 *  @param displayName The product's display name.

 @return The product with the given display name.

 */
Product ProductManager_getProductByDisplayName(ProductManager _self, const char* displayName);
/**
 *  @param refNo The reference number.

 @return The product with the given reference number.

 */
Product ProductManager_getProductByRefNo(ProductManager _self, int refNo);
/**
 *  @param name The product name.

 @return The product with the given name.

 */
Product ProductManager_getProductByName(ProductManager _self, const char* name);
/**
 * 
 */
int ProductManager_getProductIndex(ProductManager _self, Product product);
/**
 *  Tests whether a product with the given name is contained in this list.

 @param name the product name

 @return true, if so

 */
boolean ProductManager_containsProduct(ProductManager _self, const char* name);
/**
 *  Tests whether the given product is contained in this list.

 @param product The product.

 @return {@code true} if so.

 */
boolean ProductManager_contains(ProductManager _self, Product product);
/**
 *  Adds the given product to this product manager if it does not already exists and sets it's reference number one
 biger than the greatest reference number in this product manager.

 @param product the product to be added, ignored if <code>null</code>

 */
void ProductManager_addProduct(ProductManager _self, Product product);
/**
 *  Removes the given product from this product manager if it exists.

 @param product the product to be removed, ignored if <code>null</code>

 @return true, if the product was removed

 */
boolean ProductManager_removeProduct(ProductManager _self, Product product);
/**
 *  Removes all product from this list.

 */
void ProductManager_removeAllProducts(ProductManager _self);
/**
 *  Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is
 informed each time a product was added or removed.

 @param listener the listener to be added.

 @return true if the listener was added, otherwise false.

 */
boolean ProductManager_addListener(ProductManager _self, ProductManager_Listener listener);
/**
 *  Removes a <code>ProductManagerListener</code> from this product manager.

 @param listener The listener.

 @return true, if the listener was removed, otherwise false.

 */
boolean ProductManager_removeListener(ProductManager _self, ProductManager_Listener listener);

/* Functions for class ImageGeometry */

/**
 * 
 */
ImageGeometry ImageGeometry_newImageGeometry(Rectangle bounds, CoordinateReferenceSystem mapCrs, AffineTransform image2map);
/**
 * 
 */
AffineTransform ImageGeometry_getImage2MapTransform(ImageGeometry _self);
/**
 * 
 */
Rectangle ImageGeometry_getImageRect(ImageGeometry _self);
/**
 * 
 */
CoordinateReferenceSystem ImageGeometry_getMapCrs(ImageGeometry _self);
/**
 * 
 */
void ImageGeometry_changeYAxisDirection(ImageGeometry _self);
/**
 * 
 */
Point2D ImageGeometry_calculateEastingNorthing(Product sourceProduct, CoordinateReferenceSystem targetCrs, double referencePixelX, double referencePixelY, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
Rectangle ImageGeometry_calculateProductSize(Product sourceProduct, CoordinateReferenceSystem targetCrs, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
ImageGeometry ImageGeometry_createTargetGeometry(Product sourceProduct, CoordinateReferenceSystem targetCrs, Double pixelSizeX, Double pixelSizeY, Integer width, Integer height, Double orientation, Double easting, Double northing, Double referencePixelX, Double referencePixelY);
/**
 * 
 */
ImageGeometry ImageGeometry_createCollocationTargetGeometry(Product targetProduct, Product collocationProduct);

/* Functions for class Band */

/**
 *  Constructs a new <code>Band</code>.

 @param name     the name of the new object
 @param dataType the raster data type, must be one of the multiple <code>ProductData.TYPE_<i>X</i></code>
                 constants, with the exception of <code>ProductData.TYPE_UINT32</code>
 @param width    the width of the raster in pixels
 @param height   the height of the raster in pixels

 */
Band Band_newBand(const char* name, int dataType, int width, int height);
/**
 *  Gets the flag coding for this band.

 @return a non-null value if this band is a flag dataset, <code>null</code> otherwise

 */
FlagCoding Band_getFlagCoding(Band _self);
/**
 *  Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).

 @return <code>true</code> if so

 */
boolean Band_isFlagBand(Band _self);
/**
 *  Gets the index coding for this band.

 @return a non-null value if this band is a flag dataset, <code>null</code> otherwise

 */
IndexCoding Band_getIndexCoding(Band _self);
/**
 *  Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).

 @return <code>true</code> if so

 */
boolean Band_isIndexBand(Band _self);
/**
 *  Gets the sample coding.

 @return the sample coding, or {@value null} if not set.

 */
SampleCoding Band_getSampleCoding(Band _self);
/**
 *  Sets the sample coding for this band.

 @param sampleCoding the sample coding
 @throws IllegalArgumentException if this band does not contain integer pixels

 */
void Band_setSampleCoding(Band _self, SampleCoding sampleCoding);
/**
 *  Gets the (zero-based) spectral band index.

 @return the (zero-based) spectral band index or <code>-1</code> if it is unknown

 */
int Band_getSpectralBandIndex(Band _self);
/**
 *  Sets the (zero-based) spectral band index.

 @param spectralBandIndex the (zero-based) spectral band index or <code>-1</code> if it is unknown

 */
void Band_setSpectralBandIndex(Band _self, int spectralBandIndex);
/**
 *  Gets the spectral wavelength in <code>nm</code> (nanomater) units.

 @return the wave length in nanometers of this band, or zero if this is not a spectral band or the wave length is
         not known.

 */
float Band_getSpectralWavelength(Band _self);
/**
 *  Sets the spectral wavelength in <code>nm</code> (nanomater) units.

 @param spectralWavelength the wavelength in nanometers of this band, or zero if this is not a spectral band or
                           the wavelength is not known.

 */
void Band_setSpectralWavelength(Band _self, float spectralWavelength);
/**
 *  Gets the spectral bandwidth in <code>nm</code> (nanomater) units.

 @return the bandwidth in nanometers of this band, or zero if this is not a spectral band or the bandwidth is not
         known.

 */
float Band_getSpectralBandwidth(Band _self);
/**
 *  Sets the spectral bandwidth in <code>nm</code> (nanomater) units.

 @param spectralBandwidth the spectral bandwidth in nanometers of this band, or zero if this is not a spectral band
                          or the spectral bandwidth is not known.

 */
void Band_setSpectralBandwidth(Band _self, float spectralBandwidth);
/**
 *  Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.

 @return the solar flux for the wavelength of this band, or zero if this is not a spectral band or the solar flux
         is not known.

 */
float Band_getSolarFlux(Band _self);
/**
 *  Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.

 @param solarFlux the solar flux for the wavelength of this band, or zero if this is not a spectral band or the
                  solar flux is not known.

 */
void Band_setSolarFlux(Band _self, float solarFlux);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.

 @param visitor the visitor, must not be <code>null</code>

 */
void Band_acceptVisitor(Band _self, ProductVisitor visitor);
/**
 *  Creates a string defining this band object.

 */
char* Band_toString(Band _self);
/**
 * 
 */
void Band_removeFromFile(Band _self, ProductWriter productWriter);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void Band_dispose(Band _self);
/**
 *  Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so
 far the method returns <code>null</code>.
 <p/>
 <p>In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the
 scene's pixels.

 @return raster data covering the pixels for a complete scene
 @see #getRasterData
 @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterWidth
 @see org.esa.beam.framework.datamodel.RasterDataNode#getSceneRasterHeight

 */
ProductData Band_getSceneRasterData(Band _self);
/**
 *  Gets the sample for the pixel located at (x,y) as an integer value.

 @param x The X co-ordinate of the pixel location
 @param y The Y co-ordinate of the pixel location
 @throws NullPointerException if this band has no raster data
 @throws java.lang.ArrayIndexOutOfBoundsException
                              if the co-ordinates are not in bounds

 */
int Band_getPixelInt(Band _self, int x, int y);
/**
 *  Gets the sample for the pixel located at (x,y) as a float value.

 @param x The X co-ordinate of the pixel location
 @param y The Y co-ordinate of the pixel location
 @throws NullPointerException if this band has no raster data
 @throws java.lang.ArrayIndexOutOfBoundsException
                              if the co-ordinates are not in bounds

 */
float Band_getPixelFloat(Band _self, int x, int y);
/**
 *  Gets the sample for the pixel located at (x,y) as a double value.

 @param x The X co-ordinate of the pixel location
 @param y The Y co-ordinate of the pixel location
 @throws NullPointerException if this band has no raster data
 @throws java.lang.ArrayIndexOutOfBoundsException
                              if the co-ordinates are not in bounds

 */
double Band_getPixelDouble(Band _self, int x, int y);
/**
 *  Sets the pixel at the given pixel co-ordinate to the given pixel value.

 @param x          The X co-ordinate of the pixel location
 @param y          The Y co-ordinate of the pixel location
 @param pixelValue the new pixel value
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelInt(Band _self, int x, int y, int pixelValue);
/**
 *  Sets the pixel at the given pixel coordinate to the given pixel value.

 @param x          The X co-ordinate of the pixel location
 @param y          The Y co-ordinate of the pixel location
 @param pixelValue the new pixel value
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelFloat(Band _self, int x, int y, float pixelValue);
/**
 *  Sets the pixel value at the given pixel coordinate to the given pixel value.

 @param x          The X co-ordinate of the pixel location
 @param y          The Y co-ordinate of the pixel location
 @param pixelValue the new pixel value
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelDouble(Band _self, int x, int y, double pixelValue);
/**
 *  Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of
 data at the specified location. Throws exception when the target buffer is not in memory.

 @param x      x offset into the band
 @param y      y offset into the band
 @param w      width of the pixel array to be written
 @param h      height of the pixel array to be written.
 @param pixels integer array to be written
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 *  Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.

 @param x      x offset into the band
 @param y      y offset into the band
 @param w      width of the pixel array to be written
 @param h      height of the pixel array to be written.
 @param pixels float array to be written
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 *  Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.

 @param x      x offset into the band
 @param y      y offset into the band
 @param w      width of the pixel array to be written
 @param h      height of the pixel array to be written.
 @param pixels double array to be written
 @throws NullPointerException if this band has no raster data

 */
void Band_setPixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 *  Ensures that raster data exists

 */
void Band_ensureRasterData(Band _self);
/**
 *  Un-loads the raster data for this band.
 <p/>
 <p>After this method has been called successfully, the <code>hasRasterData()</code> method returns
 <code>false</code> and <code>getRasterData()</code> returns <code>null</code>.
 <p/>

 @see #loadRasterData()

 */
void Band_unloadRasterData(Band _self);
/**
 * 
 */
char* Band_getViewModeId(Band _self, const char* bandName);
/**
 *  Returns the width in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterWidth()</code>.

 @return the scene width in pixels

 */
int Band_getSceneRasterWidth(Band _self);
/**
 *  Returns the height in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterHeight()</code>.

 @return the scene height in pixels

 */
int Band_getSceneRasterHeight(Band _self);
/**
 *  Returns the width of the raster used by this product raster.

 @return the width of the raster

 */
int Band_getRasterWidth(Band _self);
/**
 *  Returns the height of the raster used by this product raster.

 @return the height of the raster

 */
int Band_getRasterHeight(Band _self);
/**
 * 
 */
void Band_setModified(Band _self, boolean modified);
/**
 *  Returns the geo-coding of this {@link RasterDataNode}.

 @return the geo-coding

 */
GeoCoding Band_getGeoCoding(Band _self);
/**
 *  Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>

 @param geoCoding the new geo-coding
 @see Product#setGeoCoding(GeoCoding)

 */
void Band_setGeoCoding(Band _self, GeoCoding geoCoding);
/**
 *  Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.

 @return the pointing object, or null if a pointing is not available

 */
Pointing Band_getPointing(Band _self);
/**
 *  Tests if this raster data node can be orthorectified.

 @return true, if so

 */
boolean Band_canBeOrthorectified(Band _self);
/**
 *  Returns <code>true</code> if the pixel data contained in this band is "naturally" a floating point number type.

 @return true, if so

 */
boolean Band_isFloatingPointType(Band _self);
/**
 *  Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.

 @return the geophysical data type
 @see ProductData
 @see #isScalingApplied()

 */
int Band_getGeophysicalDataType(Band _self);
/**
 *  Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).

 @return the scaling factor
 @see #isScalingApplied()

 */
double Band_getScalingFactor(Band _self);
/**
 *  Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.

 @param scalingFactor the scaling factor
 @see #isScalingApplied()

 */
void Band_setScalingFactor(Band _self, double scalingFactor);
/**
 *  Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).

 @return the scaling offset
 @see #isScalingApplied()

 */
double Band_getScalingOffset(Band _self);
/**
 *  Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.

 @param scalingOffset the scaling offset
 @see #isScalingApplied()

 */
void Band_setScalingOffset(Band _self, double scalingOffset);
/**
 *  Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.

 @return whether or not the data is logging-10 scaled
 @see #isScalingApplied()

 */
boolean Band_isLog10Scaled(Band _self);
/**
 *  Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.

 @param log10Scaled whether or not the data is logging-10 scaled
 @see #isScalingApplied()

 */
void Band_setLog10Scaled(Band _self, boolean log10Scaled);
/**
 *  Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.

 @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.
 @see #getScalingOffset
 @see #getScalingFactor
 @see #isLog10Scaled

 */
boolean Band_isScalingApplied(Band _self);
/**
 *  Tests if the given name is the name of a property which is relevant for the computation of the valid mask.

 @param propertyName the  name to test
 @return {@code true}, if so.
 @since BEAM 4.2

 */
boolean Band_isValidMaskProperty(const char* propertyName);
/**
 *  Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.

 @return true, if so
 @see #isNoDataValueUsed()
 @see #setNoDataValue(double)

 */
boolean Band_isNoDataValueSet(Band _self);
/**
 *  Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.

 */
void Band_clearNoDataValue(Band _self);
/**
 *  Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return true, if so
 @see #setNoDataValueUsed(boolean)
 @see #isNoDataValueSet()

 */
boolean Band_isNoDataValueUsed(Band _self);
/**
 *  Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.

 @param noDataValueUsed true, if so
 @see #isNoDataValueUsed()

 */
void Band_setNoDataValueUsed(Band _self, boolean noDataValueUsed);
/**
 *  Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.

 @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.
 @see #setNoDataValue(double)
 @see #isNoDataValueSet()

 */
double Band_getNoDataValue(Band _self);
/**
 *  Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.

 @param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.
 @see #getNoDataValue()
 @see #isNoDataValueSet()

 */
void Band_setNoDataValue(Band _self, double noDataValue);
/**
 *  Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return the geophysical no-data value
 @see #setGeophysicalNoDataValue(double)

 */
double Band_getGeophysicalNoDataValue(Band _self);
/**
 *  Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.

 @param noDataValue the new geophysical no-data value
 @see #setGeophysicalNoDataValue(double)
 @see #isNoDataValueSet()

 */
void Band_setGeophysicalNoDataValue(Band _self, double noDataValue);
/**
 *  Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return the valid mask expression.

 */
char* Band_getValidPixelExpression(Band _self);
/**
 *  Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.

 @param validPixelExpression the valid mask expression, can be null

 */
void Band_setValidPixelExpression(Band _self, const char* validPixelExpression);
/**
 *  Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return true, if so

 */
boolean Band_isValidMaskUsed(Band _self);
/**
 *  Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.

 */
void Band_resetValidMask(Band _self);
/**
 *  Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.

 @return The expression used for the computation of the mask which identifies valid pixel values,
         or {@code null}.
 @see #getValidPixelExpression()
 @see #getNoDataValue()
 @since BEAM 4.2

 */
char* Band_getValidMaskExpression(Band _self);
/**
 *  {@inheritDoc}

 */
void Band_updateExpression(Band _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.

 @return true, if so.

 */
boolean Band_hasRasterData(Band _self);
/**
 *  Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.

 @return the raster data for this band, or <code>null</code> if data has not been loaded

 */
ProductData Band_getRasterData(Band _self);
/**
 *  Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!

 @param rasterData the raster data for this dataset
 @see #getRasterData()

 */
void Band_setRasterData(Band _self, ProductData rasterData);
/**
 *  @throws java.io.IOException if an I/O error occurs
 @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)

 */
void Band_loadRasterData(Band _self);
/**
 *  Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>

 @param x the X co-ordinate of the pixel location
 @param y the Y co-ordinate of the pixel location
 @return <code>true</code> if the pixel is valid
 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds
 @see #isPixelValid(int, int, javax.media.jai.ROI)
 @see #setNoDataValueUsed(boolean)
 @see #setNoDataValue(double)
 @see #setValidPixelExpression(String)

 */
boolean Band_isPixelValid(Band _self, int x, int y);
/**
 *  Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>

 @param x pixel X coordinate
 @param y pixel Y coordinate
 @return The geo-physical sample value.

 */
int Band_getSampleInt(Band _self, int x, int y);
/**
 *  Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>

 @param x pixel X coordinate
 @param y pixel Y coordinate
 @return The geo-physical sample value.

 */
float Band_getSampleFloat(Band _self, int x, int y);
/**
 *  @see #getPixels(int, int, int, int, int[], ProgressMonitor)

 */
int* Band_getPixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #getPixels(int, int, int, int, float[], ProgressMonitor)

 */
float* Band_getPixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #getPixels(int, int, int, int, double[], ProgressMonitor)

 */
double* Band_getPixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, int[], ProgressMonitor)

 */
int* Band_readPixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, float[], ProgressMonitor)

 */
float* Band_readPixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, double[], ProgressMonitor)

 */
double* Band_readPixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #writePixels(int, int, int, int, int[], ProgressMonitor)

 */
void Band_writePixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 *  @see #writePixels(int, int, int, int, float[], ProgressMonitor)

 */
void Band_writePixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 *  @see #writePixels(int, int, int, int, double[], ProgressMonitor)

 */
void Band_writePixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * 
 */
boolean* Band_readValidMask(Band _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
/**
 *  @throws java.io.IOException if an I/O error occurs
 @see #readRasterDataFully(ProgressMonitor)

 */
void Band_readRasterDataFully(Band _self);
/**
 *  Reads raster data from the node's associated data source into the given data
 buffer.

 @param offsetX    the X-offset in the raster co-ordinates where reading starts
 @param offsetY    the Y-offset in the raster co-ordinates where reading starts
 @param width      the width of the raster data buffer
 @param height     the height of the raster data buffer
 @param rasterData a raster data buffer receiving the pixels to be read
 @throws java.io.IOException      if an I/O error occurs
 @throws IllegalArgumentException if the raster is null
 @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to
                                  which this product raster belongs to, has no associated product reader
 @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)

 */
void Band_readRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * 
 */
void Band_writeRasterDataFully(Band _self);
/**
 * 
 */
void Band_writeRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.

 @return raster data compatible with this product raster
 @see #createCompatibleSceneRasterData

 */
ProductData Band_createCompatibleRasterData(Band _self);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.

 @return raster data compatible with this product raster
 @see #createCompatibleRasterData

 */
ProductData Band_createCompatibleSceneRasterData(Band _self);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.

 @param width  the width of the raster data to be created
 @param height the height of the raster data to be created
 @return raster data compatible with this product raster
 @see #createCompatibleRasterData
 @see #createCompatibleSceneRasterData

 */
ProductData Band_createCompatibleRasterDataForRect(Band _self, int width, int height);
/**
 *  Tests whether the given parameters specify a compatible raster or not.

 @param rasterData the raster data
 @param w          the raster width
 @param h          the raster height
 @return {@code true} if so

 */
boolean Band_isCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
/**
 *  Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.

 @param rasterData the raster data
 @param w          the raster width
 @param h          the raster height

 */
void Band_checkCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
/**
 *  Determines whether this raster data node contains integer samples.

 @return true if this raster data node contains integer samples.

 */
boolean Band_hasIntPixels(Band _self);
/**
 *  Creates a transect profile for the given shape (-outline).

 @param shape the shape
 @return the profile data
 @throws IOException if an I/O error occurs

 */
TransectProfileData Band_createTransectProfileData(Band _self, Shape shape);
/**
 *  Gets the image information for image display.

 @return the image info or null

 */
ImageInfo Band_getImageInfo(Band _self);
/**
 *  Sets the image information for image display.

 @param imageInfo the image info, can be null

 */
void Band_setImageInfo(Band _self, ImageInfo imageInfo);
/**
 *  Notifies listeners that the image (display) information has changed.

 @since BEAM 4.7

 */
void Band_fireImageInfoChanged(Band _self);
/**
 *  Creates an instance of a default image information.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.

 @param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data
                       histogram to be excluded when determining the value range for a linear constrast
                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of
                       the entire area is skipped.
 @param histogram      the histogram to create the image information.
 @return a valid image information instance, never <code>null</code>.

 */
ImageInfo Band_createDefaultImageInfo(Band _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
/**
 *  @return The overlay mask group.

 */
ProductNodeGroup Band_getOverlayMaskGroup(Band _self);
/**
 *  Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.

 @param pm a monitor to inform the user about progress
 @return a greyscale/palette-based image for this raster data node
 @throws IOException if the raster data is not loaded so far and reload causes an I/O error
 @see #setImageInfo(ImageInfo)

 */
BufferedImage Band_createColorIndexedImage(Band _self, ProgressMonitor pm);
/**
 *  Creates an RGB image for this raster data node.

 @param pm a monitor to inform the user about progress
 @return a greyscale/palette-based image for this raster data node
 @throws IOException if the raster data is not loaded so far and reload causes an I/O error
 @see #setImageInfo(ImageInfo)

 */
BufferedImage Band_createRgbImage(Band _self, ProgressMonitor pm);
/**
 *  Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.

 @param lineOffset the absolute line offset, zero based
 @param roi        an optional ROI
 @return a new validator instance, never null
 @throws IOException if an I/O error occurs

 */
IndexValidator Band_createPixelValidator(Band _self, int lineOffset, ROI roi);
/**
 *  Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.

 @param v the input value
 @return the scaled value

 */
double Band_scale(Band _self, double v);
/**
 *  Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.

 @param v the input value
 @return the scaled value

 */
double Band_scaleInverse(Band _self, double v);
/**
 *  Returns the pixel located at (x,y) as a string value.

 @param x the X co-ordinate of the pixel location
 @param y the Y co-ordinate of the pixel location
 @return the pixel value at (x,y) as string or an error message text

 */
char* Band_getPixelString(Band _self, int x, int y);
/**
 *  Returns whether the source image is set on this {@code RasterDataNode}.

 @return whether the source image is set.
 @see #getSourceImage()
 @see #setSourceImage(java.awt.image.RenderedImage)
 @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)
 @see #createSourceImage()
 @since BEAM 4.5

 */
boolean Band_isSourceImageSet(Band _self);
/**
 *  Gets the source image associated with this {@code RasterDataNode}.

 @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},
         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.
 @see #createSourceImage()
 @see #isSourceImageSet()
 @since BEAM 4.2

 */
MultiLevelImage Band_getSourceImage(Band _self);
/**
 *  Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.

 @return whether the geophysical image is set.
 @since BEAM 4.6

 */
boolean Band_isGeophysicalImageSet(Band _self);
/**
 *  @return The geophysical source image.
 @since BEAM 4.5

 */
MultiLevelImage Band_getGeophysicalImage(Band _self);
/**
 *  Returns wether the valid mask image is set on this {@code RasterDataNode}.

 @return Wether the source image is set.
 @since BEAM 4.5

 */
boolean Band_isValidMaskImageSet(Band _self);
/**
 *  Gets the valid-mask image associated with this {@code RasterDataNode}.

 @return The rendered image.
 @since BEAM 4.2

 */
MultiLevelImage Band_getValidMaskImage(Band _self);
/**
 * 
 */
boolean Band_isStxSet(Band _self);
/**
 *  Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.

 @return The statistics.
 @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)
 @see #setStx(Stx)
 @since BEAM 4.2, revised in BEAM 4.5

 */
Stx Band_getStx(Band _self);
/**
 *  Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.

 @param stx The statistics.
 @since BEAM 4.2, revised in BEAM 4.5

 */
void Band_setStx(Band _self, Stx stx);
/**
 *  Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.

 @return The shape of the area where the raster data has samples, can be {@code null}.
 @since BEAM 4.7

 */
Shape Band_getValidShape(Band _self);
/**
 *  Gets the data type of this data node.

 @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants

 */
int Band_getDataType(Band _self);
/**
 *  Gets the number of data elements in this data node.

 */
dlong Band_getNumDataElems(Band _self);
/**
 *  Sets the data of this data node.

 */
void Band_setData(Band _self, ProductData data);
/**
 *  Gets the data of this data node.

 */
ProductData Band_getData(Band _self);
/**
 *  Sets the data elements of this data node.

 @see ProductData#setElems(Object)

 */
void Band_setDataElems(Band _self, Object elems);
/**
 *  Gets the data elements of this data node.

 @see ProductData#getElems()

 */
Object Band_getDataElems(Band _self);
/**
 *  Gets the data element size in bytes.

 @see ProductData#getElemSize(int)

 */
int Band_getDataElemSize(Band _self);
/**
 * 
 */
void Band_setReadOnly(Band _self, boolean readOnly);
/**
 * 
 */
boolean Band_isReadOnly(Band _self);
/**
 * 
 */
void Band_setUnit(Band _self, const char* unit);
/**
 * 
 */
char* Band_getUnit(Band _self);
/**
 *  Fires a node data changed event. This method is called after the data of this data node changed.

 */
void Band_fireProductNodeDataChanged(Band _self);
/**
 *  Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.

 @param numElems the number of elements, must not be less than one
 @return product data compatible with this data node

 */
ProductData Band_createCompatibleProductData(Band _self, int numElems);
/**
 *  @return The owner node of this node.

 */
ProductNode Band_getOwner(Band _self);
/**
 *  @return This node's name.

 */
char* Band_getName(Band _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void Band_setName(Band _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* Band_getDescription(Band _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void Band_setDescription(Band _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean Band_isModified(Band _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean Band_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product Band_getProduct(Band _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader Band_getProductReader(Band _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter Band_getProductWriter(Band _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* Band_getDisplayName(Band _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* Band_getProductRefString(Band _self);
/**
 * 
 */
E Band_getExtension(Band _self, Class arg0);

/* Functions for class PlacemarkGroup */

/**
 * 
 */
VectorDataNode PlacemarkGroup_getVectorDataNode(PlacemarkGroup _self);
/**
 * 
 */
Placemark PlacemarkGroup_getPlacemark(PlacemarkGroup _self, SimpleFeature feature);
/**
 * 
 */
boolean PlacemarkGroup_add4(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_add2(PlacemarkGroup _self, int index, Placemark placemark);
/**
 * 
 */
boolean PlacemarkGroup_remove2(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_dispose(PlacemarkGroup _self);
/**
 *  @return {@code true}, if child nodes will have this group as owner after adding.

 */
boolean PlacemarkGroup_isTakingOverNodeOwnership(PlacemarkGroup _self);
/**
 *  @return The number of product nodes in this product group.

 */
int PlacemarkGroup_getNodeCount(PlacemarkGroup _self);
/**
 *  @param index The node index.
 @return The product node at the given index.

 */
T PlacemarkGroup_get1(PlacemarkGroup _self, int index);
/**
 *  Returns the display names of all products currently managed.

 @return an array containing the display names, never <code>null</code>, but the array can have zero length
 @see ProductNode#getDisplayName()

 */
char** PlacemarkGroup_getNodeDisplayNames(PlacemarkGroup _self, int* resultArrayLength);
/**
 *  Returns the names of all products currently managed.

 @return an array containing the names, never <code>null</code>, but the array can have zero length

 */
char** PlacemarkGroup_getNodeNames(PlacemarkGroup _self, int* resultArrayLength);
/**
 *  Returns an array of all products currently managed.

 @return an array containing the products, never <code>null</code>, but the array can have zero length

 */
ProductNode* PlacemarkGroup_toArray1(PlacemarkGroup _self, int* resultArrayLength);
/**
 *  @param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a
              new array of the same runtime type is allocated for this purpose.
 @return an array containing the product nodes, never <code>null</code>, but the array can have zero length

 */
T* PlacemarkGroup_toArray2(PlacemarkGroup _self, const T* arrayElems, int arrayLength, int* resultArrayLength);
/**
 * 
 */
int PlacemarkGroup_indexOf2(PlacemarkGroup _self, const char* name);
/**
 * 
 */
int PlacemarkGroup_indexOf1(PlacemarkGroup _self, T element);
/**
 *  @param displayName the display name
 @return the product node with the given display name.

 */
T PlacemarkGroup_getByDisplayName(PlacemarkGroup _self, const char* displayName);
/**
 *  @param name the name
 @return the product node with the given name.

 */
T PlacemarkGroup_get2(PlacemarkGroup _self, const char* name);
/**
 *  Tests whether a node with the given name is contained in this group.

 @param name the name
 @return true, if so

 */
boolean PlacemarkGroup_contains2(PlacemarkGroup _self, const char* name);
/**
 *  Tests whether the given product is contained in this list.

 @param node the node
 @return true, if so

 */
boolean PlacemarkGroup_contains1(PlacemarkGroup _self, T node);
/**
 *  Adds the given node to this group.

 @param node the node to be added, ignored if <code>null</code>
 @return true, if the node has been added

 */
boolean PlacemarkGroup_add3(PlacemarkGroup _self, T node);
/**
 *  Adds the given node to this group.

 @param index the index.
 @param node  the node to be added, ignored if <code>null</code>

 */
void PlacemarkGroup_add1(PlacemarkGroup _self, int index, T node);
/**
 *  Removes the given node from this group.

 @param node the node to be removed
 @return true, if the node was removed

 */
boolean PlacemarkGroup_remove1(PlacemarkGroup _self, T node);
/**
 *  Removes all nodes from this group.

 */
void PlacemarkGroup_removeAll(PlacemarkGroup _self);
/**
 * 
 */
void PlacemarkGroup_clearRemovedList(PlacemarkGroup _self);
/**
 *  Gets all removed node nodes.

 @return a collection of all removed node nodes.

 */
Collection PlacemarkGroup_getRemovedNodes(PlacemarkGroup _self);
/**
 * 
 */
dlong PlacemarkGroup_getRawStorageSize2(PlacemarkGroup _self, ProductSubsetDef subsetDef);
/**
 * 
 */
void PlacemarkGroup_setModified(PlacemarkGroup _self, boolean modified);
/**
 * 
 */
void PlacemarkGroup_acceptVisitor(PlacemarkGroup _self, ProductVisitor visitor);
/**
 * 
 */
void PlacemarkGroup_updateExpression(PlacemarkGroup _self, const char* oldExternalName, const char* newExternalName);
/**
 *  @return The owner node of this node.

 */
ProductNode PlacemarkGroup_getOwner(PlacemarkGroup _self);
/**
 *  @return This node's name.

 */
char* PlacemarkGroup_getName(PlacemarkGroup _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void PlacemarkGroup_setName(PlacemarkGroup _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* PlacemarkGroup_getDescription(PlacemarkGroup _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void PlacemarkGroup_setDescription(PlacemarkGroup _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean PlacemarkGroup_isModified(PlacemarkGroup _self);
/**
 * 
 */
char* PlacemarkGroup_toString(PlacemarkGroup _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean PlacemarkGroup_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product PlacemarkGroup_getProduct(PlacemarkGroup _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader PlacemarkGroup_getProductReader(PlacemarkGroup _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter PlacemarkGroup_getProductWriter(PlacemarkGroup _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* PlacemarkGroup_getDisplayName(PlacemarkGroup _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* PlacemarkGroup_getProductRefString(PlacemarkGroup _self);
/**
 *  Gets an estimated, raw storage size in bytes of this product node.

 @return the size in bytes.

 */
dlong PlacemarkGroup_getRawStorageSize1(PlacemarkGroup _self);
/**
 * 
 */
void PlacemarkGroup_fireProductNodeChanged1(PlacemarkGroup _self, const char* propertyName);
/**
 * 
 */
void PlacemarkGroup_fireProductNodeChanged2(PlacemarkGroup _self, const char* propertyName, Object oldValue, Object newValue);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void PlacemarkGroup_removeFromFile(PlacemarkGroup _self, ProductWriter productWriter);
/**
 * 
 */
E PlacemarkGroup_getExtension(PlacemarkGroup _self, Class arg0);

/* Functions for class TiePointGrid */

/**
 *  Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.

 @param name         the name of the new object
 @param gridWidth    the width of the tie-point grid in pixels
 @param gridHeight   the height of the tie-point grid in pixels
 @param offsetX      the X co-ordinate of the first (upper-left) tie-point in pixels
 @param offsetY      the Y co-ordinate of the first (upper-left) tie-point in pixels
 @param subSamplingX the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                     this tie-pint grid belongs to. Must not be less than one.
 @param subSamplingY the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                     this tie-pint grid belongs to. Must not be less than one.
 @param tiePoints    the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>

 */
TiePointGrid TiePointGrid_newTiePointGrid1(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength);
/**
 *  Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.

 @param name          the name of the new object
 @param gridWidth     the width of the tie-point grid in pixels
 @param gridHeight    the height of the tie-point grid in pixels
 @param offsetX       the X co-ordinate of the first (upper-left) tie-point in pixels
 @param offsetY       the Y co-ordinate of the first (upper-left) tie-point in pixels
 @param subSamplingX  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                      this tie-pint grid belongs to. Must not be less than one.
 @param subSamplingY  the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                      this tie-pint grid belongs to. Must not be less than one.
 @param tiePoints     the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>
 @param discontinuity the discontinuity mode, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180}
                      {@link #DISCONT_AT_360}

 */
TiePointGrid TiePointGrid_newTiePointGrid2(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, int discontinuity);
/**
 *  Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.

 @param name           the name of the new object
 @param gridWidth      the width of the tie-point grid in pixels
 @param gridHeight     the height of the tie-point grid in pixels
 @param offsetX        the X co-ordinate of the first (upper-left) tie-point in pixels
 @param offsetY        the Y co-ordinate of the first (upper-left) tie-point in pixels
 @param subSamplingX   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                       this tie-pint grid belongs to. Must not be less than one.
 @param subSamplingY   the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which
                       this tie-pint grid belongs to. Must not be less than one.
 @param tiePoints      the tie-point data values, must be an array of the size <code>gridWidth * gridHeight</code>
 @param containsAngles if true, the {@link #getDiscontinuity() angular discontinuity} is derived from the provided tie-point data values

 */
TiePointGrid TiePointGrid_newTiePointGrid3(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, boolean containsAngles);
/**
 *  Determines the angular discontinuity of the given tie point values.

 @return the angular discontinuity, will always be either {@link #DISCONT_AT_180} or
         {@link #DISCONT_AT_360}

 */
int TiePointGrid_getDiscontinuity2(const float* tiePointsElems, int tiePointsLength);
/**
 *  Gets the angular discontinuity.

 @return the angular discontinuity, will always be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or
         {@link #DISCONT_AT_360}

 */
int TiePointGrid_getDiscontinuity1(TiePointGrid _self);
/**
 *  Sets the angular discontinuity.

 @param discontinuity angular discontinuity, can be either {@link #DISCONT_NONE} or {@link #DISCONT_AT_180} or
                      {@link #DISCONT_AT_360}

 */
void TiePointGrid_setDiscontinuity(TiePointGrid _self, int discontinuity);
/**
 *  Returns <code>true</code>

 @return true

 */
boolean TiePointGrid_isFloatingPointType(TiePointGrid _self);
/**
 *  Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.

 @return the geophysical data type

 @see ProductData

 */
int TiePointGrid_getGeophysicalDataType(TiePointGrid _self);
/**
 *  Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. <p/>
 <p/>
 In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store
 the scene's pixels.

 @return raster data covering the pixels for a complete scene

 @see #getRasterData
 @see #getRasterWidth
 @see #getRasterHeight
 @see #getSceneRasterWidth
 @see #getSceneRasterHeight

 */
ProductData TiePointGrid_getSceneRasterData(TiePointGrid _self);
/**
 *  Returns the width in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>

 @return the scene width in pixels

 */
int TiePointGrid_getSceneRasterWidth(TiePointGrid _self);
/**
 *  Returns the height in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>

 @return the scene height in pixels

 */
int TiePointGrid_getSceneRasterHeight(TiePointGrid _self);
/**
 *  Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels.

 */
float TiePointGrid_getOffsetX(TiePointGrid _self);
/**
 *  Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels.

 */
float TiePointGrid_getOffsetY(TiePointGrid _self);
/**
 *  Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.

 @return the sub-sampling in X-direction, never less than one.

 */
float TiePointGrid_getSubSamplingX(TiePointGrid _self);
/**
 *  Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.

 @return the sub-sampling in Y-direction, never less than one.

 */
float TiePointGrid_getSubSamplingY(TiePointGrid _self);
/**
 *  Gets the data array holding this band's pixel samples.

 @return the data array for this band, or <code>null</code> if no data has been loaded

 @see ProductData#getElems

 */
float* TiePointGrid_getTiePoints(TiePointGrid _self, int* resultArrayLength);
/**
 *  Gets the interpolated sample for the pixel located at (x,y) as an integer value. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.

 @param x The X co-ordinate of the pixel location
 @param y The Y co-ordinate of the pixel location

 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds

 */
int TiePointGrid_getPixelInt(TiePointGrid _self, int x, int y);
/**
 * 
 */
void TiePointGrid_dispose(TiePointGrid _self);
/**
 *  Computes the interpolated sample for the pixel located at (x,y). <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.

 @param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.
 @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.

 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds

 */
float TiePointGrid_getPixelFloat2(TiePointGrid _self, int x, int y);
/**
 *  Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.

 @param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.
 @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.

 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds

 */
float TiePointGrid_getPixelFloat1(TiePointGrid _self, float x, float y);
/**
 *  Gets the interpolated sample for the pixel located at (x,y) as a double value. <p/>
 <p/>
 If the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.

 @param x The X co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.
 @param y The Y co-ordinate of the pixel location, given in the pixel co-ordinates of the data product to which
          this tie-pint grid belongs to.

 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds

 */
double TiePointGrid_getPixelDouble(TiePointGrid _self, int x, int y);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixelInt(TiePointGrid _self, int x, int y, int pixelValue);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixelFloat(TiePointGrid _self, int x, int y, float pixelValue);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixelDouble(TiePointGrid _self, int x, int y, double pixelValue);
/**
 *  Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given
 array is <code>null</code> a new one was created and returned.

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the integer array to be filled with data
 @param pm     a monitor to inform the user about progress

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
int* TiePointGrid_getPixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  Retrieves an array of tie point data interpolated to the product width and height as float array. If the given
 array is <code>null</code> a new one is created and returned.

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the float array to be filled with data
 @param pm     a monitor to inform the user about progress

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
float* TiePointGrid_getPixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  Retrieves an array of tie point data interpolated to the product with and height as double array. If the given
 array is <code>null</code> a new one was created and returned.

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the double array to be filled with data

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
double* TiePointGrid_getPixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixels3(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_setPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 *  Retrieves an array of tie point data interpolated to the product with and height as float array. If the given
 array is <code>null</code> a new one was created and returned.

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the integer array to be filled with data

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
int* TiePointGrid_readPixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  Retrieves an array of tie point data interpolated to the product with and height as float array. If the given
 array is <code>null</code> a new one was created and returned. *

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the float array to be filled with data
 @param pm     a monitor to inform the user about progress

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
float* TiePointGrid_readPixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  Retrieves an array of tie point data interpolated to the product with and height as double array. If the given
 array is <code>null</code> a new one was created and returned.

 @param x      the x coordinate of the array to be read
 @param y      the y coordinate of the array to be read
 @param w      the width of the array to be read
 @param h      the height of the array to be read
 @param pixels the double array to be filled with data
 @param pm     a monitor to inform the user about progress

 @throws IllegalArgumentException if the length of the given array is less than <code>w*h</code>.

 */
double* TiePointGrid_readPixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_writePixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_writePixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 *  This method is not implemented because pixels are read-only in tie-point grids.

 */
void TiePointGrid_writePixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 *  Reads raster data from this dataset into the user-supplied raster data buffer. <p/>
 <p/>
 This method always directly (re-)reads this band's data from its associated data source into the given data
 buffer.

 @param offsetX    the X-offset in the raster co-ordinates where reading starts
 @param offsetY    the Y-offset in the raster co-ordinates where reading starts
 @param width      the width of the raster data buffer
 @param height     the height of the raster data buffer
 @param rasterData a raster data buffer receiving the pixels to be read
 @param pm         a monitor to inform the user about progress

 @throws java.io.IOException      if an I/O error occurs
 @throws IllegalArgumentException if the raster is null
 @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to
                                  which this product raster belongs to, has no associated product reader
 @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor) 

 */
void TiePointGrid_readRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 *  {@inheritDoc}

 */
void TiePointGrid_readRasterDataFully2(TiePointGrid _self, ProgressMonitor pm);
/**
 *  {@inheritDoc}

 */
void TiePointGrid_writeRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 *  {@inheritDoc}

 */
void TiePointGrid_writeRasterDataFully2(TiePointGrid _self, ProgressMonitor pm);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor. <p/>
 <p/>
 The method simply calls <code>visitor.visit(this)</code>.

 @param visitor the visitor

 */
void TiePointGrid_acceptVisitor(TiePointGrid _self, ProductVisitor visitor);
/**
 * 
 */
TiePointGrid TiePointGrid_cloneTiePointGrid(TiePointGrid _self);
/**
 * 
 */
TiePointGrid TiePointGrid_createZenithFromElevationAngleTiePointGrid(TiePointGrid elevationAngleGrid);
/**
 * 
 */
TiePointGrid TiePointGrid_createSubset(TiePointGrid sourceTiePointGrid, ProductSubsetDef subsetDef);
/**
 *  Returns the width of the raster used by this product raster.

 @return the width of the raster

 */
int TiePointGrid_getRasterWidth(TiePointGrid _self);
/**
 *  Returns the height of the raster used by this product raster.

 @return the height of the raster

 */
int TiePointGrid_getRasterHeight(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setModified(TiePointGrid _self, boolean modified);
/**
 *  Returns the geo-coding of this {@link RasterDataNode}.

 @return the geo-coding

 */
GeoCoding TiePointGrid_getGeoCoding(TiePointGrid _self);
/**
 *  Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>

 @param geoCoding the new geo-coding
 @see Product#setGeoCoding(GeoCoding)

 */
void TiePointGrid_setGeoCoding(TiePointGrid _self, GeoCoding geoCoding);
/**
 *  Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.

 @return the pointing object, or null if a pointing is not available

 */
Pointing TiePointGrid_getPointing(TiePointGrid _self);
/**
 *  Tests if this raster data node can be orthorectified.

 @return true, if so

 */
boolean TiePointGrid_canBeOrthorectified(TiePointGrid _self);
/**
 *  Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).

 @return the scaling factor
 @see #isScalingApplied()

 */
double TiePointGrid_getScalingFactor(TiePointGrid _self);
/**
 *  Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.

 @param scalingFactor the scaling factor
 @see #isScalingApplied()

 */
void TiePointGrid_setScalingFactor(TiePointGrid _self, double scalingFactor);
/**
 *  Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).

 @return the scaling offset
 @see #isScalingApplied()

 */
double TiePointGrid_getScalingOffset(TiePointGrid _self);
/**
 *  Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.

 @param scalingOffset the scaling offset
 @see #isScalingApplied()

 */
void TiePointGrid_setScalingOffset(TiePointGrid _self, double scalingOffset);
/**
 *  Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.

 @return whether or not the data is logging-10 scaled
 @see #isScalingApplied()

 */
boolean TiePointGrid_isLog10Scaled(TiePointGrid _self);
/**
 *  Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.

 @param log10Scaled whether or not the data is logging-10 scaled
 @see #isScalingApplied()

 */
void TiePointGrid_setLog10Scaled(TiePointGrid _self, boolean log10Scaled);
/**
 *  Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.

 @return <code>true</code> if a conversion is applyied to raw data samples before the are retuned.
 @see #getScalingOffset
 @see #getScalingFactor
 @see #isLog10Scaled

 */
boolean TiePointGrid_isScalingApplied(TiePointGrid _self);
/**
 *  Tests if the given name is the name of a property which is relevant for the computation of the valid mask.

 @param propertyName the  name to test
 @return {@code true}, if so.
 @since BEAM 4.2

 */
boolean TiePointGrid_isValidMaskProperty(const char* propertyName);
/**
 *  Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.

 @return true, if so
 @see #isNoDataValueUsed()
 @see #setNoDataValue(double)

 */
boolean TiePointGrid_isNoDataValueSet(TiePointGrid _self);
/**
 *  Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.

 */
void TiePointGrid_clearNoDataValue(TiePointGrid _self);
/**
 *  Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return true, if so
 @see #setNoDataValueUsed(boolean)
 @see #isNoDataValueSet()

 */
boolean TiePointGrid_isNoDataValueUsed(TiePointGrid _self);
/**
 *  Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.

 @param noDataValueUsed true, if so
 @see #isNoDataValueUsed()

 */
void TiePointGrid_setNoDataValueUsed(TiePointGrid _self, boolean noDataValueUsed);
/**
 *  Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.

 @return the no-data value. It is returned as a <code>double</code> in order to cover all other numeric types.
 @see #setNoDataValue(double)
 @see #isNoDataValueSet()

 */
double TiePointGrid_getNoDataValue(TiePointGrid _self);
/**
 *  Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.

 @param noDataValue the no-data value. It is passed as a <code>double</code> in order to cover all other numeric types.
 @see #getNoDataValue()
 @see #isNoDataValueSet()

 */
void TiePointGrid_setNoDataValue(TiePointGrid _self, double noDataValue);
/**
 *  Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return the geophysical no-data value
 @see #setGeophysicalNoDataValue(double)

 */
double TiePointGrid_getGeophysicalNoDataValue(TiePointGrid _self);
/**
 *  Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.

 @param noDataValue the new geophysical no-data value
 @see #setGeophysicalNoDataValue(double)
 @see #isNoDataValueSet()

 */
void TiePointGrid_setGeophysicalNoDataValue(TiePointGrid _self, double noDataValue);
/**
 *  Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return the valid mask expression.

 */
char* TiePointGrid_getValidPixelExpression(TiePointGrid _self);
/**
 *  Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.

 @param validPixelExpression the valid mask expression, can be null

 */
void TiePointGrid_setValidPixelExpression(TiePointGrid _self, const char* validPixelExpression);
/**
 *  Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.

 @return true, if so

 */
boolean TiePointGrid_isValidMaskUsed(TiePointGrid _self);
/**
 *  Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.

 */
void TiePointGrid_resetValidMask(TiePointGrid _self);
/**
 *  Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.

 @return The expression used for the computation of the mask which identifies valid pixel values,
         or {@code null}.
 @see #getValidPixelExpression()
 @see #getNoDataValue()
 @since BEAM 4.2

 */
char* TiePointGrid_getValidMaskExpression(TiePointGrid _self);
/**
 *  {@inheritDoc}

 */
void TiePointGrid_updateExpression(TiePointGrid _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.

 @return true, if so.

 */
boolean TiePointGrid_hasRasterData(TiePointGrid _self);
/**
 *  Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.

 @return the raster data for this band, or <code>null</code> if data has not been loaded

 */
ProductData TiePointGrid_getRasterData(TiePointGrid _self);
/**
 *  Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!

 @param rasterData the raster data for this dataset
 @see #getRasterData()

 */
void TiePointGrid_setRasterData(TiePointGrid _self, ProductData rasterData);
/**
 *  @throws java.io.IOException if an I/O error occurs
 @see #loadRasterData(com.bc.ceres.core.ProgressMonitor)

 */
void TiePointGrid_loadRasterData1(TiePointGrid _self);
/**
 *  Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,
 <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should
 always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>
 elements (samples).
 <p/>
 <p>The default implementation of this method does nothing.

 @param pm a monitor to inform the user about progress
 @throws IOException if an I/O error occurs
 @see #unloadRasterData()

 */
void TiePointGrid_loadRasterData2(TiePointGrid _self, ProgressMonitor pm);
/**
 *  Un-loads the raster data for this <code>RasterDataNode</code>.
 <p/>
 <p>It is up to the implementation whether after this method has been called successfully, the
 <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.
 <p/>
 <p>The default implementation of this method does nothing.

 @see #loadRasterData()

 */
void TiePointGrid_unloadRasterData(TiePointGrid _self);
/**
 *  Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>

 @param x the X co-ordinate of the pixel location
 @param y the Y co-ordinate of the pixel location
 @return <code>true</code> if the pixel is valid
 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds
 @see #isPixelValid(int, int, javax.media.jai.ROI)
 @see #setNoDataValueUsed(boolean)
 @see #setNoDataValue(double)
 @see #setValidPixelExpression(String)

 */
boolean TiePointGrid_isPixelValid2(TiePointGrid _self, int x, int y);
/**
 *  Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>

 @param x pixel X coordinate
 @param y pixel Y coordinate
 @return The geo-physical sample value.

 */
int TiePointGrid_getSampleInt(TiePointGrid _self, int x, int y);
/**
 *  Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>

 @param x pixel X coordinate
 @param y pixel Y coordinate
 @return The geo-physical sample value.

 */
float TiePointGrid_getSampleFloat(TiePointGrid _self, int x, int y);
/**
 *  Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.

 @param pixelIndex the linear pixel index in the range 0 to width * height - 1
 @return <code>true</code> if the pixel is valid
 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds
 @see #isPixelValid(int, int, javax.media.jai.ROI)
 @see #setNoDataValueUsed(boolean)
 @see #setNoDataValue(double)
 @see #setValidPixelExpression(String)
 @since 4.1

 */
boolean TiePointGrid_isPixelValid1(TiePointGrid _self, int pixelIndex);
/**
 *  Checks whether or not the pixel located at (x,y) is valid.
 The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,
 and secondly, if the pixel is within the ROI (if any).

 @param x   the X co-ordinate of the pixel location
 @param y   the Y co-ordinate of the pixel location
 @param roi the ROI, if null the method returns {@link #isPixelValid(int, int)}
 @return <code>true</code> if the pixel is valid
 @throws ArrayIndexOutOfBoundsException if the co-ordinates are not in bounds
 @see #isPixelValid(int, int)
 @see #setNoDataValueUsed(boolean)
 @see #setNoDataValue(double)
 @see #setValidPixelExpression(String)

 */
boolean TiePointGrid_isPixelValid3(TiePointGrid _self, int x, int y, ROI roi);
/**
 *  @see #getPixels(int, int, int, int, int[], ProgressMonitor)

 */
int* TiePointGrid_getPixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #getPixels(int, int, int, int, float[], ProgressMonitor)

 */
float* TiePointGrid_getPixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #getPixels(int, int, int, int, double[], ProgressMonitor)

 */
double* TiePointGrid_getPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, int[], ProgressMonitor)

 */
int* TiePointGrid_readPixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, float[], ProgressMonitor)

 */
float* TiePointGrid_readPixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #readPixels(int, int, int, int, double[], ProgressMonitor)

 */
double* TiePointGrid_readPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 *  @see #writePixels(int, int, int, int, int[], ProgressMonitor)

 */
void TiePointGrid_writePixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 *  @see #writePixels(int, int, int, int, float[], ProgressMonitor)

 */
void TiePointGrid_writePixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 *  @see #writePixels(int, int, int, int, double[], ProgressMonitor)

 */
void TiePointGrid_writePixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * 
 */
boolean* TiePointGrid_readValidMask(TiePointGrid _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
/**
 *  @throws java.io.IOException if an I/O error occurs
 @see #readRasterDataFully(ProgressMonitor)

 */
void TiePointGrid_readRasterDataFully1(TiePointGrid _self);
/**
 *  Reads raster data from the node's associated data source into the given data
 buffer.

 @param offsetX    the X-offset in the raster co-ordinates where reading starts
 @param offsetY    the Y-offset in the raster co-ordinates where reading starts
 @param width      the width of the raster data buffer
 @param height     the height of the raster data buffer
 @param rasterData a raster data buffer receiving the pixels to be read
 @throws java.io.IOException      if an I/O error occurs
 @throws IllegalArgumentException if the raster is null
 @throws IllegalStateException    if this product raster was not added to a product so far, or if the product to
                                  which this product raster belongs to, has no associated product reader
 @see org.esa.beam.framework.dataio.ProductReader#readBandRasterData(Band, int, int, int, int, ProductData, com.bc.ceres.core.ProgressMonitor)

 */
void TiePointGrid_readRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * 
 */
void TiePointGrid_writeRasterDataFully1(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_writeRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.

 @return raster data compatible with this product raster
 @see #createCompatibleSceneRasterData

 */
ProductData TiePointGrid_createCompatibleRasterData1(TiePointGrid _self);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.

 @return raster data compatible with this product raster
 @see #createCompatibleRasterData

 */
ProductData TiePointGrid_createCompatibleSceneRasterData(TiePointGrid _self);
/**
 *  Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.

 @param width  the width of the raster data to be created
 @param height the height of the raster data to be created
 @return raster data compatible with this product raster
 @see #createCompatibleRasterData
 @see #createCompatibleSceneRasterData

 */
ProductData TiePointGrid_createCompatibleRasterData2(TiePointGrid _self, int width, int height);
/**
 *  Tests whether the given parameters specify a compatible raster or not.

 @param rasterData the raster data
 @param w          the raster width
 @param h          the raster height
 @return {@code true} if so

 */
boolean TiePointGrid_isCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
/**
 *  Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.

 @param rasterData the raster data
 @param w          the raster width
 @param h          the raster height

 */
void TiePointGrid_checkCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
/**
 *  Determines whether this raster data node contains integer samples.

 @return true if this raster data node contains integer samples.

 */
boolean TiePointGrid_hasIntPixels(TiePointGrid _self);
/**
 *  Creates a transect profile for the given shape (-outline).

 @param shape the shape
 @return the profile data
 @throws IOException if an I/O error occurs

 */
TransectProfileData TiePointGrid_createTransectProfileData(TiePointGrid _self, Shape shape);
/**
 *  Gets the image information for image display.

 @return the image info or null

 */
ImageInfo TiePointGrid_getImageInfo1(TiePointGrid _self);
/**
 *  Sets the image information for image display.

 @param imageInfo the image info, can be null

 */
void TiePointGrid_setImageInfo(TiePointGrid _self, ImageInfo imageInfo);
/**
 *  Notifies listeners that the image (display) information has changed.

 @since BEAM 4.7

 */
void TiePointGrid_fireImageInfoChanged(TiePointGrid _self);
/**
 *  Returns the image information for this raster data node.
 <p/>
 <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.

 @param pm A progress monitor.
 @return A valid image information instance.
 @see #getImageInfo(double[], ProgressMonitor)
 @since BEAM 4.2

 */
ImageInfo TiePointGrid_getImageInfo2(TiePointGrid _self, ProgressMonitor pm);
/**
 *  Gets the image creation information.
 <p/>
 <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is
 called with the given parameters passed to this method.

 @param histoSkipAreas Only used, if new image info is created (see <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code>
                       method).
 @param pm             A progress monitor.
 @return The image creation information.
 @since BEAM 4.2

 */
ImageInfo TiePointGrid_getImageInfo3(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 *  Creates a default image information instance.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.

 @param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data
                       histogram to be excluded when determining the value range for a linear constrast
                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of
                       the entire area is skipped.
 @param pm             a monitor to inform the user about progress
 @return a valid image information instance, never <code>null</code>.

 */
ImageInfo TiePointGrid_createDefaultImageInfo1(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 *  Creates an instance of a default image information.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.

 @param histoSkipAreas the left (at index 0) and right (at index 1) normalized areas of the raster data
                       histogram to be excluded when determining the value range for a linear constrast
                       stretching. Can be <code>null</code>, in this case <code>{0.01, 0.04}</code> resp. 5% of
                       the entire area is skipped.
 @param histogram      the histogram to create the image information.
 @return a valid image information instance, never <code>null</code>.

 */
ImageInfo TiePointGrid_createDefaultImageInfo2(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
/**
 *  @return The overlay mask group.

 */
ProductNodeGroup TiePointGrid_getOverlayMaskGroup(TiePointGrid _self);
/**
 *  Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.

 @param pm a monitor to inform the user about progress
 @return a greyscale/palette-based image for this raster data node
 @throws IOException if the raster data is not loaded so far and reload causes an I/O error
 @see #setImageInfo(ImageInfo)

 */
BufferedImage TiePointGrid_createColorIndexedImage(TiePointGrid _self, ProgressMonitor pm);
/**
 *  Creates an RGB image for this raster data node.

 @param pm a monitor to inform the user about progress
 @return a greyscale/palette-based image for this raster data node
 @throws IOException if the raster data is not loaded so far and reload causes an I/O error
 @see #setImageInfo(ImageInfo)

 */
BufferedImage TiePointGrid_createRgbImage(TiePointGrid _self, ProgressMonitor pm);
/**
 * 
 */
byte* TiePointGrid_quantizeRasterData1(TiePointGrid _self, double newMin, double newMax, double gamma, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
void TiePointGrid_quantizeRasterData2(TiePointGrid _self, double newMin, double newMax, double gamma, const byte* samplesElems, int samplesLength, int offset, int stride, ProgressMonitor pm);
/**
 *  Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.

 @param lineOffset the absolute line offset, zero based
 @param roi        an optional ROI
 @return a new validator instance, never null
 @throws IOException if an I/O error occurs

 */
IndexValidator TiePointGrid_createPixelValidator(TiePointGrid _self, int lineOffset, ROI roi);
/**
 *  Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.

 @param v the input value
 @return the scaled value

 */
double TiePointGrid_scale(TiePointGrid _self, double v);
/**
 *  Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.

 @param v the input value
 @return the scaled value

 */
double TiePointGrid_scaleInverse(TiePointGrid _self, double v);
/**
 *  Returns the pixel located at (x,y) as a string value.

 @param x the X co-ordinate of the pixel location
 @param y the Y co-ordinate of the pixel location
 @return the pixel value at (x,y) as string or an error message text

 */
char* TiePointGrid_getPixelString(TiePointGrid _self, int x, int y);
/**
 *  Returns whether the source image is set on this {@code RasterDataNode}.

 @return whether the source image is set.
 @see #getSourceImage()
 @see #setSourceImage(java.awt.image.RenderedImage)
 @see #setSourceImage(com.bc.ceres.glevel.MultiLevelImage)
 @see #createSourceImage()
 @since BEAM 4.5

 */
boolean TiePointGrid_isSourceImageSet(TiePointGrid _self);
/**
 *  Gets the source image associated with this {@code RasterDataNode}.

 @return The source image. Never {@code null}. In the case that {@link #isSourceImageSet()} returns {@code false},
         the method {@link #createSourceImage()} will be called in order to set and return a valid source image.
 @see #createSourceImage()
 @see #isSourceImageSet()
 @since BEAM 4.2

 */
MultiLevelImage TiePointGrid_getSourceImage(TiePointGrid _self);
/**
 *  Sets the source image associated with this {@code RasterDataNode}.

 @param sourceImage The source image.
                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.
 @since BEAM 4.2

 */
void TiePointGrid_setSourceImage2(TiePointGrid _self, RenderedImage sourceImage);
/**
 *  Sets the source image associated with this {@code RasterDataNode}.

 @param sourceImage The source image.
                    Can be {@code null}. If so, {@link #isSourceImageSet()} will return {@code false}.
 @since BEAM 4.6

 */
void TiePointGrid_setSourceImage1(TiePointGrid _self, MultiLevelImage sourceImage);
/**
 *  Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.

 @return whether the geophysical image is set.
 @since BEAM 4.6

 */
boolean TiePointGrid_isGeophysicalImageSet(TiePointGrid _self);
/**
 *  @return The geophysical source image.
 @since BEAM 4.5

 */
MultiLevelImage TiePointGrid_getGeophysicalImage(TiePointGrid _self);
/**
 *  Returns wether the valid mask image is set on this {@code RasterDataNode}.

 @return Wether the source image is set.
 @since BEAM 4.5

 */
boolean TiePointGrid_isValidMaskImageSet(TiePointGrid _self);
/**
 *  Gets the valid-mask image associated with this {@code RasterDataNode}.

 @return The rendered image.
 @since BEAM 4.2

 */
MultiLevelImage TiePointGrid_getValidMaskImage(TiePointGrid _self);
/**
 * 
 */
boolean TiePointGrid_isStxSet(TiePointGrid _self);
/**
 *  Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.

 @return The statistics.
 @see #getStx(boolean, com.bc.ceres.core.ProgressMonitor)
 @see #setStx(Stx)
 @since BEAM 4.2, revised in BEAM 4.5

 */
Stx TiePointGrid_getStx1(TiePointGrid _self);
/**
 *  Gets the statistics.
 If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.
 This method belongs to preliminary API and may be removed or changed in the future.

 @param accurate If true, accurate statistics are computed.
 @param pm       A progress monitor which is used to compute the new statistics, if required.
 @return The statistics.
 @since since BEAM 4.5

 */
Stx TiePointGrid_getStx2(TiePointGrid _self, boolean accurate, ProgressMonitor pm);
/**
 *  Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.

 @param stx The statistics.
 @since BEAM 4.2, revised in BEAM 4.5

 */
void TiePointGrid_setStx(TiePointGrid _self, Stx stx);
/**
 *  Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.

 @return The shape of the area where the raster data has samples, can be {@code null}.
 @since BEAM 4.7

 */
Shape TiePointGrid_getValidShape(TiePointGrid _self);
/**
 *  Gets the data type of this data node.

 @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants

 */
int TiePointGrid_getDataType(TiePointGrid _self);
/**
 *  Gets the number of data elements in this data node.

 */
dlong TiePointGrid_getNumDataElems(TiePointGrid _self);
/**
 *  Sets the data of this data node.

 */
void TiePointGrid_setData(TiePointGrid _self, ProductData data);
/**
 *  Gets the data of this data node.

 */
ProductData TiePointGrid_getData(TiePointGrid _self);
/**
 *  Sets the data elements of this data node.

 @see ProductData#setElems(Object)

 */
void TiePointGrid_setDataElems(TiePointGrid _self, Object elems);
/**
 *  Gets the data elements of this data node.

 @see ProductData#getElems()

 */
Object TiePointGrid_getDataElems(TiePointGrid _self);
/**
 *  Gets the data element size in bytes.

 @see ProductData#getElemSize(int)

 */
int TiePointGrid_getDataElemSize(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setReadOnly(TiePointGrid _self, boolean readOnly);
/**
 * 
 */
boolean TiePointGrid_isReadOnly(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setUnit(TiePointGrid _self, const char* unit);
/**
 * 
 */
char* TiePointGrid_getUnit(TiePointGrid _self);
/**
 *  Fires a node data changed event. This method is called after the data of this data node changed.

 */
void TiePointGrid_fireProductNodeDataChanged(TiePointGrid _self);
/**
 *  Gets the estimated size in bytes of this product node.

 @param subsetDef if not <code>null</code> the subset may limit the size returned
 @return the size in bytes.

 */
dlong TiePointGrid_getRawStorageSize2(TiePointGrid _self, ProductSubsetDef subsetDef);
/**
 *  Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.

 @param numElems the number of elements, must not be less than one
 @return product data compatible with this data node

 */
ProductData TiePointGrid_createCompatibleProductData(TiePointGrid _self, int numElems);
/**
 *  @return The owner node of this node.

 */
ProductNode TiePointGrid_getOwner(TiePointGrid _self);
/**
 *  @return This node's name.

 */
char* TiePointGrid_getName(TiePointGrid _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void TiePointGrid_setName(TiePointGrid _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* TiePointGrid_getDescription(TiePointGrid _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void TiePointGrid_setDescription(TiePointGrid _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean TiePointGrid_isModified(TiePointGrid _self);
/**
 * 
 */
char* TiePointGrid_toString(TiePointGrid _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean TiePointGrid_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product TiePointGrid_getProduct(TiePointGrid _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader TiePointGrid_getProductReader(TiePointGrid _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter TiePointGrid_getProductWriter(TiePointGrid _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* TiePointGrid_getDisplayName(TiePointGrid _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* TiePointGrid_getProductRefString(TiePointGrid _self);
/**
 *  Gets an estimated, raw storage size in bytes of this product node.

 @return the size in bytes.

 */
dlong TiePointGrid_getRawStorageSize1(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_fireProductNodeChanged1(TiePointGrid _self, const char* propertyName);
/**
 * 
 */
void TiePointGrid_fireProductNodeChanged2(TiePointGrid _self, const char* propertyName, Object oldValue, Object newValue);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void TiePointGrid_removeFromFile(TiePointGrid _self, ProductWriter productWriter);
/**
 * 
 */
E TiePointGrid_getExtension(TiePointGrid _self, Class arg0);

/* Functions for class AngularDirection */

/**
 * 
 */
AngularDirection AngularDirection_newAngularDirection(double azimuth, double zenith);
/**
 * 
 */
boolean AngularDirection_equals(AngularDirection _self, Object obj);
/**
 * 
 */
char* AngularDirection_toString(AngularDirection _self);

/* Functions for class FlagCoding */

/**
 *  Constructs a new flag coding object with the given name.

 @param name the name

 */
FlagCoding FlagCoding_newFlagCoding(const char* name);
/**
 *  Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to
 getPropertyValue(String).

 @param name the flag name
 @return a metadata attribute wich is the representation of the flag with the given name

 */
MetadataAttribute FlagCoding_getFlag(FlagCoding _self, const char* name);
/**
 *  Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.

 @return a string array which contains all names of this <code>FlagCoding</code>.<br> If this
         <code>FlagCoding</code> does not contain any flag, <code>null</code> is returned

 */
char** FlagCoding_getFlagNames(FlagCoding _self, int* resultArrayLength);
/**
 *  Adds a new flag definition to this flags coding.

 @param name        the flag name
 @param flagMask    the flag's bit mask
 @param description the description text
 @throws IllegalArgumentException if <code>name</code> is null
 @return A new attribute representing the flag.

 */
MetadataAttribute FlagCoding_addFlag(FlagCoding _self, const char* name, int flagMask, const char* description);
/**
 *  Returns the flag mask value for the specified flag name.

 @param name the flag name
 @return flagMask the flag's bit mask as a 32 bit integer
 @throws IllegalArgumentException if <code>name</code> is null, or a flag with the name does not exist

 */
int FlagCoding_getFlagMask(FlagCoding _self, const char* name);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.

 @param visitor the visitor, must not be <code>null</code>

 */
void FlagCoding_acceptVisitor(FlagCoding _self, ProductVisitor visitor);
/**
 *  Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.

 @param element the element to be added, always ignored

 */
void FlagCoding_addElement(FlagCoding _self, MetadataElement element);
/**
 *  Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.

 @param attribute the attribute to be added
 @throws IllegalArgumentException if the attribute added is not an integer or does not have a scalar value

 */
void FlagCoding_addAttribute(FlagCoding _self, MetadataAttribute attribute);
/**
 *  Adds a new coding value to this sample coding.

 @param name        the coding name
 @param value       the value
 @param description the description text
 @throws IllegalArgumentException if <code>name</code> is null
 @return A new attribute representing the coded sample.

 */
MetadataAttribute FlagCoding_addSample(FlagCoding _self, const char* name, int value, const char* description);
/**
 *  Gets the number of coded sample values.

 @return the number of coded sample values

 */
int FlagCoding_getSampleCount(FlagCoding _self);
/**
 *  Gets the sample name at the specified attribute index.

 @param index the attribute index.
 @return the sample name.

 */
char* FlagCoding_getSampleName(FlagCoding _self, int index);
/**
 *  Gets the sample value at the specified attribute index.

 @param index the attribute index.
 @return the sample value.

 */
int FlagCoding_getSampleValue(FlagCoding _self, int index);
/**
 *  Gets the group of child elements. The method returns null, if this element has no children.
 @return The child element group, may be null.

 */
ProductNodeGroup FlagCoding_getElementGroup(FlagCoding _self);
/**
 * 
 */
MetadataElement FlagCoding_getParentElement(FlagCoding _self);
/**
 *  Adds the given element to this element at index.

 @param element the element to added, ignored if <code>null</code>
 @param index   where to put it

 */
void FlagCoding_addElementAt(FlagCoding _self, MetadataElement element, int index);
/**
 *  Removes the given element from this element.

 @param element the element to be removed, ignored if <code>null</code>
 @return true, if so

 */
boolean FlagCoding_removeElement(FlagCoding _self, MetadataElement element);
/**
 *  @return the number of elements contained in this element.

 */
int FlagCoding_getNumElements(FlagCoding _self);
/**
 *  Returns the element at the given index.

 @param index the element index
 @return the element at the given index
 @throws IndexOutOfBoundsException if the index is out of bounds

 */
MetadataElement FlagCoding_getElementAt(FlagCoding _self, int index);
/**
 *  Returns a string array containing the names of the groups contained in this element

 @return a string array containing the names of the groups contained in this element. If this element has no
         groups a zero-length-array is returned.

 */
char** FlagCoding_getElementNames(FlagCoding _self, int* resultArrayLength);
/**
 *  Returns an array of elements contained in this element.

 @return an array of elements contained in this product. If this element has no elements a zero-length-array is
         returned.

 */
MetadataElement* FlagCoding_getElements(FlagCoding _self, int* resultArrayLength);
/**
 *  Returns the element with the given name.

 @param name the element name
 @return the element with the given name or <code>null</code> if a element with the given name is not contained in
         this element.

 */
MetadataElement FlagCoding_getElement(FlagCoding _self, const char* name);
/**
 *  Tests if a element with the given name is contained in this element.

 @param name the name, must not be <code>null</code>
 @return <code>true</code> if a element with the given name is contained in this element, <code>false</code>
         otherwise

 */
boolean FlagCoding_containsElement(FlagCoding _self, const char* name);
/**
 *  Gets the index of the given element.
 @param element  The element .
 @return The element's index, or -1.
 @since BEAM 4.7

 */
int FlagCoding_getElementIndex(FlagCoding _self, MetadataElement element);
/**
 *  Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.

 @param attribute the attribute to be removed, <code>null</code> is ignored
 @return <code>true</code> if it was removed

 */
boolean FlagCoding_removeAttribute(FlagCoding _self, MetadataAttribute attribute);
/**
 *  Returns the number of attributes attaached to this node.

 @return the number of attributes

 */
int FlagCoding_getNumAttributes(FlagCoding _self);
/**
 *  Returns the attribute at the given index.

 @param index the attribute index
 @return the attribute, or <code>null</code> if this node does not contain attributes
 @throws IndexOutOfBoundsException

 */
MetadataAttribute FlagCoding_getAttributeAt(FlagCoding _self, int index);
/**
 *  Returns the names of all attributes of this node.

 @return the attribute name array, never <code>null</code>

 */
char** FlagCoding_getAttributeNames(FlagCoding _self, int* resultArrayLength);
/**
 *  Returns an array of attributes contained in this element.

 @return an array of attributes contained in this product. If this element has no attributes a zero-length-array
         is returned.

 */
MetadataAttribute* FlagCoding_getAttributes(FlagCoding _self, int* resultArrayLength);
/**
 *  Returns the attribute with the given name.

 @param name the attribute name
 @return the attribute with the given name or <code>null</code> if it could not be found

 */
MetadataAttribute FlagCoding_getAttribute(FlagCoding _self, const char* name);
/**
 *  Checks whether this node has an element with the given name.

 @param name the attribute name
 @return <code>true</code> if so

 */
boolean FlagCoding_containsAttribute(FlagCoding _self, const char* name);
/**
 *  Gets the index of the given attribute.
 @param attribute  The attribute.
 @return The attribute's index, or -1.
 @since BEAM 4.7

 */
int FlagCoding_getAttributeIndex(FlagCoding _self, MetadataAttribute attribute);
/**
 *  Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as double.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
double FlagCoding_getAttributeDouble(FlagCoding _self, const char* name, double defaultValue);
/**
 *  Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as UTC.

 */
ProductData_UTC FlagCoding_getAttributeUTC(FlagCoding _self, const char* name, ProductData_UTC defaultValue);
/**
 *  Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.
 @throws NumberFormatException if the attribute type is ASCII but cannot be converted to a number

 */
int FlagCoding_getAttributeInt(FlagCoding _self, const char* name, int defaultValue);
/**
 *  Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void FlagCoding_setAttributeInt(FlagCoding _self, const char* name, int value);
/**
 *  Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void FlagCoding_setAttributeDouble(FlagCoding _self, const char* name, double value);
/**
 *  Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void FlagCoding_setAttributeUTC(FlagCoding _self, const char* name, ProductData_UTC value);
/**
 *  Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.

 @param name         the attribute name
 @param defaultValue the default value
 @return the attribute value as integer.

 */
char* FlagCoding_getAttributeString(FlagCoding _self, const char* name, const char* defaultValue);
/**
 *  Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.

 @param name  the attribute name
 @param value the new value

 */
void FlagCoding_setAttributeString(FlagCoding _self, const char* name, const char* value);
/**
 * 
 */
void FlagCoding_setModified(FlagCoding _self, boolean modified);
/**
 * 
 */
MetadataElement FlagCoding_createDeepClone(FlagCoding _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void FlagCoding_dispose(FlagCoding _self);
/**
 *  @return The owner node of this node.

 */
ProductNode FlagCoding_getOwner(FlagCoding _self);
/**
 *  @return This node's name.

 */
char* FlagCoding_getName(FlagCoding _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void FlagCoding_setName(FlagCoding _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* FlagCoding_getDescription(FlagCoding _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void FlagCoding_setDescription(FlagCoding _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean FlagCoding_isModified(FlagCoding _self);
/**
 * 
 */
char* FlagCoding_toString(FlagCoding _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean FlagCoding_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product FlagCoding_getProduct(FlagCoding _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader FlagCoding_getProductReader(FlagCoding _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter FlagCoding_getProductWriter(FlagCoding _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* FlagCoding_getDisplayName(FlagCoding _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* FlagCoding_getProductRefString(FlagCoding _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void FlagCoding_updateExpression(FlagCoding _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void FlagCoding_removeFromFile(FlagCoding _self, ProductWriter productWriter);
/**
 * 
 */
E FlagCoding_getExtension(FlagCoding _self, Class arg0);

/* Functions for class ProductReader */

/**
 *  Returns the plug-in which created this product reader.

 @return the product reader plug-in, should never be <code>null</code>

 */
ProductReaderPlugIn ProductReader_getReaderPlugIn(ProductReader _self);
/**
 *  Retrives the current input destination object. Thie return value might be <code>null</code> if the
 <code>setInput</code> has not been called so far.

 */
Object ProductReader_getInput(ProductReader _self);
/**
 *  Returns the subset information with which this a data product is read from its physical source.

 @return the subset information, can be <code>null</code>

 */
ProductSubsetDef ProductReader_getSubsetDef(ProductReader _self);
/**
 *  Reads a data product and returns a in-memory representation of it.
 <p/>
 <p> The given subset info can be used to specify spatial and spectral portions of the original proudct. If the
 subset is omitted, the complete product is read in.
 <p/>
 <p> Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,
 is up to the implementation.

 @param input     an object representing a valid output for this product reader, might be a
                  <code>ImageInputStream</code> or other <code>Object</code> to use for future decoding.
 @param subsetDef a spectral or spatial subset (or both) of the product. If <code>null</code>, the entire product
                  is read in
 @throws IllegalArgumentException   if <code>input</code> is <code>null</code> or it's type is not one of the
                                    supported input sources.
 @throws IOException                if an I/O error occurs
 @throws IllegalFileFormatException if the file format is illegal

 */
Product ProductReader_readProductNodes(ProductReader _self, Object input, ProductSubsetDef subsetDef);
/**
 *  Reads raster data from the data source specified by the given destination band into the given in-memory buffer
 and region.
 <p/>
 <h3>Destination band</h3> The destination band is used to identify the data source from which this method
 transfers the sample values into the given destination buffer. The method does not modify the given destination
 band at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method
 should also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.
 <p/>
 <h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,
 <code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's
 raster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and
 sub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset
 and sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The
 destination region should always specify a sub-region of the band's scene raster.
 <p/>
 <h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given
 <code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are
 <b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *
 destHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies
 faster than the Y co-ordinate.

 @param destBand    the destination band which identifies the data source from which to read the sample values
 @param destOffsetX the X-offset in the band's raster co-ordinates
 @param destOffsetY the Y-offset in the band's raster co-ordinates
 @param destWidth   the width of region to be read given in the band's raster co-ordinates
 @param destHeight  the height of region to be read given in the band's raster co-ordinates
 @param destBuffer  the destination buffer which receives the sample values to be read
 @throws IOException              if an I/O error occurs
 @throws IllegalArgumentException if the number of elements destination buffer not equals <code>destWidth *
                                  destHeight</code> or the destination region is out of the band's scene raster
 @see org.esa.beam.framework.datamodel.Band#getSceneRasterWidth()
 @see org.esa.beam.framework.datamodel.Band#getSceneRasterHeight()

 */
void ProductReader_readBandRasterData(ProductReader _self, Band destBand, int destOffsetX, int destOffsetY, int destWidth, int destHeight, ProductData destBuffer, ProgressMonitor pm);
/**
 *  Closes the access to all currently opened resources such as file input streams and all resources of this children
 directly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>close()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.close();</code> after disposing this instance.

 @throws IOException if an I/O error occurs

 */
void ProductReader_close(ProductReader _self);

/* Functions for class RGBChannelDef */

/**
 * 
 */
RGBChannelDef RGBChannelDef_newRGBChannelDef();
/**
 * 
 */
char* RGBChannelDef_getSourceName(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setSourceName(RGBChannelDef _self, int index, const char* sourceName);
/**
 * 
 */
char** RGBChannelDef_getSourceNames(RGBChannelDef _self, int* resultArrayLength);
/**
 * 
 */
void RGBChannelDef_setSourceNames(RGBChannelDef _self, const char** bandNamesElems, int bandNamesLength);
/**
 * 
 */
boolean RGBChannelDef_isAlphaUsed(RGBChannelDef _self);
/**
 * 
 */
boolean RGBChannelDef_isGammaUsed(RGBChannelDef _self, int index);
/**
 * 
 */
double RGBChannelDef_getGamma(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setGamma(RGBChannelDef _self, int index, double gamma);
/**
 * 
 */
double RGBChannelDef_getMinDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMinDisplaySample(RGBChannelDef _self, int index, double min);
/**
 * 
 */
double RGBChannelDef_getMaxDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMaxDisplaySample(RGBChannelDef _self, int index, double max);
/**
 * 
 */
Object RGBChannelDef_clone(RGBChannelDef _self);

/* Functions for class ProductData */

/**
 *  Factory method which creates a value instance of the given type and with exactly one element.

 @param type the value's type

 @return a new value instance, <code>null</code> if the given type is not known

 */
ProductData ProductData_createInstance1(int type);
/**
 *  Factory method which creates a value instance of the given type and with the specified number of elements.

 @param type     the value's type
 @param numElems the number of elements, must be greater than zero if type is not {@link ProductData#TYPE_UTC}

 @return a new value instance, <code>null</code> if the given type is not known

 @throws IllegalArgumentException if one of the arguments is invalid

 */
ProductData ProductData_createInstance2(int type, int numElems);
/**
 *  Factory method which creates a value instance of the given type and with the specified number of elements.

 @param type the value's type
 @param data if <code>type</code> is <code>TYPE_ASCII</code> the <code>String</code>, otherwise the primitive array type corresponding to <code>type</code>

 @return a new value instance, <code>null</code> if the given type is not known

 @throws IllegalArgumentException if one of the arguments is invalid

 */
ProductData ProductData_createInstance3(int type, Object data);
/**
 * 
 */
ProductData ProductData_createInstance5(const byte* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance1(const byte* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance10(const short* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance3(const short* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance8(const int* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance2(const int* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance9(const long* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance4(const char* strData);
/**
 * 
 */
ProductData ProductData_createInstance7(const float* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance6(const double* elemsElems, int elemsLength);
/**
 *  Returns this value's type ID.

 */
int ProductData_getType1(ProductData _self);
/**
 *  Gets the element size of an element of the given type in bytes.

 @param type the element type

 @return the size of a single element in bytes.

 @throws IllegalArgumentException if the type is not supported.

 */
int ProductData_getElemSize2(int type);
/**
 *  Gets the element size of an element of this product data in bytes.

 @return the size of a single element in bytes

 */
int ProductData_getElemSize1(ProductData _self);
/**
 *  Returns a textual representation of the given data type.

 @return a data type string, <code>null</code> if the type is unknown

 */
char* ProductData_getTypeString2(int type);
/**
 *  Returns a integer representation of the given data type string.

 @return a data type integer, <code>null</code> if the type is unknown

 */
int ProductData_getType2(const char* type);
/**
 *  Returns this value's data type String.

 */
char* ProductData_getTypeString1(ProductData _self);
/**
 *  Tests whether this value has an integer.

 @return true, if so

 */
boolean ProductData_isInt(ProductData _self);
/**
 *  Tests whether the given value type is a signed or unsigned integer type.

 @return true, if so

 */
boolean ProductData_isIntType(int type);
/**
 *  Tests whether the actual instance is an signed data type.

 @return true, if so

 */
boolean ProductData_isSigned(ProductData _self);
/**
 *  Tests whether the actual instance is an unsigned data type.

 @return true, if so

 */
boolean ProductData_isUnsigned(ProductData _self);
/**
 *  Tests whether the given value type is an unsigned integer type.

 @return true, if so

 */
boolean ProductData_isUIntType(int type);
/**
 *  Tests whether the given value type is a floating point type.

 @return true, if so

 */
boolean ProductData_isFloatingPointType(int type);
/**
 *  Tests if this value is a scalar.

 @return true, if so

 */
boolean ProductData_isScalar(ProductData _self);
/**
 *  Returns the number of data elements this value has.

 */
int ProductData_getNumElems(ProductData _self);
/**
 *  Returns the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 returns <code>getElemIntAt(0)</code>.

 @see #getElemIntAt(int index)

 */
int ProductData_getElemInt(ProductData _self);
/**
 *  Returns the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.

 @see #getElemUIntAt(int index)

 */
dlong ProductData_getElemUInt(ProductData _self);
/**
 *  Returns the value as an <code>float</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemFloatAt(0)</code>.

 @see #getElemFloatAt(int index)

 */
float ProductData_getElemFloat(ProductData _self);
/**
 *  Returns the value as an <code>double</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemDoubleAt(0)</code>.

 @see #getElemDoubleAt(int index)

 */
double ProductData_getElemDouble(ProductData _self);
/**
 *  Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained
 in this value.

 @return a text representing this fields value, never <code>null</code>

 */
char* ProductData_getElemString(ProductData _self);
/**
 *  Returns the value as an <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemBooleanAt(0)</code>.

 @see #getElemBooleanAt(int index)

 */
boolean ProductData_getElemBoolean(ProductData _self);
/**
 *  Gets the value element with the given index as an <code>int</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
int ProductData_getElemIntAt(ProductData _self, int index);
/**
 *  Gets the value element with the given index as a <code>long</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
dlong ProductData_getElemUIntAt(ProductData _self, int index);
/**
 *  Gets the value element with the given index as a <code>float</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
float ProductData_getElemFloatAt(ProductData _self, int index);
/**
 *  Gets the value element with the given index as a <code>double</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
double ProductData_getElemDoubleAt(ProductData _self, int index);
/**
 *  Gets the value element with the given index as a <code>String</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
char* ProductData_getElemStringAt(ProductData _self, int index);
/**
 *  Gets the value element with the given index as a <code>boolean</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
boolean ProductData_getElemBooleanAt(ProductData _self, int index);
/**
 *  Sets the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemInt(0, value)</code>.

 @param value the value to be set

 @see #setElemIntAt(int index, int value)

 */
void ProductData_setElemInt(ProductData _self, int value);
/**
 *  Sets the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.

 @param value the value to be set

 @see #setElemUIntAt(int index, long value)

 */
void ProductData_setElemUInt(ProductData _self, dlong value);
/**
 *  Sets the value as a <code>float</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemFloatAt(0, value)</code>.

 @param value the value to be set

 @see #setElemFloatAt(int index, float value)

 */
void ProductData_setElemFloat(ProductData _self, float value);
/**
 *  Sets the value as a <code>double</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.

 @param value the value to be set

 @see #setElemDoubleAt(int index, double value)

 */
void ProductData_setElemDouble(ProductData _self, double value);
/**
 *  Sets the value as a <code>String</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemStringAt(0)</code>.

 @param value the value to be set

 @see #setElemStringAt

 */
void ProductData_setElemString(ProductData _self, const char* value);
/**
 *  Sets the value as a <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.

 @param value the value to be set

 @see #setElemBooleanAt(int index, boolean value)

 */
void ProductData_setElemBoolean(ProductData _self, boolean value);
/**
 *  Sets the value at the specified index as an <code>int</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemIntAt(ProductData _self, int index, int value);
/**
 *  Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemUIntAt(ProductData _self, int index, dlong value);
/**
 *  Sets the value at the specified index as a <code>float</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemFloatAt(ProductData _self, int index, float value);
/**
 *  Sets the value at the specified index as a <code>double</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemDoubleAt(ProductData _self, int index, double value);
/**
 *  Sets the value at the specified index as a <code>String</code>.
 <p/>
 <p><i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemStringAt(ProductData _self, int index, const char* value);
/**
 *  Sets the value at the specified index as a <code>boolean</code>.

 @param index the value index, must be <code>&gt;=0</code> and <code>&lt;getNumDataElems()</code>
 @param value the value to be set

 @throws IndexOutOfBoundsException if the index is out of bounds

 */
void ProductData_setElemBooleanAt(ProductData _self, int index, boolean value);
/**
 *  Returns the internal value. The actual type of the returned object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> </ol>

 @return an array of one of the described types

 */
Object ProductData_getElems(ProductData _self);
/**
 *  Sets the internal value. The actual type of the given data object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>

 @param data an array of one of the described types

 */
void ProductData_setElems(ProductData _self, Object data);
/**
 *  Reads all elements of this <code>ProductData</code> instance from to the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position
 within the input stream.

 @param input a seekable data input stream

 @throws IOException if an I/O error occurs

 */
void ProductData_readFrom4(ProductData _self, ImageInputStream input);
/**
 *  Reads a single element of this <code>ProductData</code> instance from to the given output stream.
 <p/>
 <p> The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given
 output stream.<br> Reading starts at the current seek position within the output stream.

 @param pos   the destination position (zero-based)
 @param input a seekable data input stream

 @throws IOException if an I/O error occurs

 */
void ProductData_readFrom3(ProductData _self, int pos, ImageInputStream input);
/**
 *  Reads elements of this <code>ProductData</code> instance from the given output stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek
 position of the input stream.

 @param startPos the destination start position (zero-based)
 @param numElems the number of elements to read
 @param input    a seekable data input stream

 @throws IOException if an I/O error occurs

 */
void ProductData_readFrom1(ProductData _self, int startPos, int numElems, ImageInputStream input);
/**
 *  Reads elements into this <code>ProductData</code> instance from the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>
 within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.

 @param startPos the destination start position (zero-based)
 @param numElems the number of elements to read
 @param input    a seekable data input stream
 @param inputPos the (zero-based) position in the data output stream where reading starts

 @throws IOException if an I/O error occurs

 */
void ProductData_readFrom2(ProductData _self, int startPos, int numElems, ImageInputStream input, dlong inputPos);
/**
 *  Writes all elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position
 within the output stream.

 @param output a seekable data output stream

 @throws IOException if an I/O error occurs

 */
void ProductData_writeTo4(ProductData _self, ImageOutputStream output);
/**
 *  Writes a single element of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given
 output stream.<br> Writing starts at the current seek position within the output stream.

 @param pos    the source position (zero-based)
 @param output a seekable data output stream

 @throws IOException if an I/O error occurs

 */
void ProductData_writeTo3(ProductData _self, int pos, ImageOutputStream output);
/**
 *  Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek
 position within the output stream.

 @param startPos the source start position (zero-based)
 @param numElems the number of elements to be written
 @param output   a seekable data output stream

 @throws IOException if an I/O error occurs

 */
void ProductData_writeTo1(ProductData _self, int startPos, int numElems, ImageOutputStream output);
/**
 *  Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at
 <code>outputPos</code> within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.

 @param startPos  the source start position (zero-based)
 @param numElems  the number of elements to be written
 @param output    a seekable data output stream
 @param outputPos the position in the data output stream where writing starts

 @throws IOException if an I/O error occurs

 */
void ProductData_writeTo2(ProductData _self, int startPos, int numElems, ImageOutputStream output, dlong outputPos);
/**
 *  Returns a string representation of this value which can be used for debugging purposes.

 */
char* ProductData_toString(ProductData _self);
/**
 *  Returns {@link Object#hashCode()}.

 */
int ProductData_hashCode(ProductData _self);
/**
 *  Returns {@link Object#equals(Object)}.
 Use {@link #equalElems} in order to perform an element-wise comparision.

 */
boolean ProductData_equals(ProductData _self, Object other);
/**
 *  Tests whether this ProductData is equal to another one.
 Performs an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.
 Otherwise the method behaves like {@link Object#equals(Object)}.

 @param other the other one

 */
boolean ProductData_equalElems(ProductData _self, ProductData other);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.

 */
void ProductData_dispose(ProductData _self);

/* Functions for class GeoPos */

/**
 *  Constructs a new geo-position with the given latitude and longitude values.

 @param lat the geographical latitude in decimal degree, valid range is -90 to +90
 @param lon the geographical longitude in decimal degree, valid range is -180 to +180

 */
GeoPos GeoPos_newGeoPos(float lat, float lon);
/**
 *  Gets the latitude value.

 @return the geographical latitude in decimal degree

 */
float GeoPos_getLat(GeoPos _self);
/**
 *  Gets the longitude value.

 @return the geographical longitude in decimal degree

 */
float GeoPos_getLon(GeoPos _self);
/**
 *  Sets the geographical location of this point.

 @param lat the geographical latitude in decimal degree, valid range is -90 to +90
 @param lon the geographical longitude in decimal degree, valid range is -180 to +180

 */
void GeoPos_setLocation(GeoPos _self, float lat, float lon);
/**
 *  Tests whether or not this geo-position is valid.

 @return true, if so

 */
boolean GeoPos_isValid(GeoPos _self);
/**
 *  Tests whether or not all given geo-positions are valid.

 @return true, if so

 */
boolean GeoPos_areValid(const GeoPos* aElems, int aLength);
/**
 *  Sets the lat/lon fields so that {@link #isValid()} will return false.

 */
void GeoPos_setInvalid(GeoPos _self);
/**
 *  Indicates whether some other object is "equal to" this one.

 @param obj the reference object with which to compare.

 @return <code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.

 */
boolean GeoPos_equals(GeoPos _self, Object obj);
/**
 *  Returns a hash code value for the object.

 @return a hash code value for this object.

 */
int GeoPos_hashCode(GeoPos _self);
/**
 *  Returns a string representation of the object. In general, the <code>toString</code> method returns a string that
 "textually represents" this object.

 @return a string representation of the object.

 */
char* GeoPos_toString(GeoPos _self);
/**
 *  Normalizes this position so that its longitude is in the range -180 to +180 degree.

 */
void GeoPos_normalize(GeoPos _self);
/**
 *  Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.
 Note that -180 will remain as is, although -180 is equivalent to +180 degrees.

 @param lon the longitude in degree

 @return the normalized longitude in the range

 */
float GeoPos_normalizeLon(float lon);
/**
 *  Returns a string representation of the latitude value.

 @return a string of the form DDD°[MM'[SS"]] [N|S].

 */
char* GeoPos_getLatString(GeoPos _self);
/**
 *  Returns a string representation of the latitude value.

 @return a string of the form DDD°[MM'[SS"]] [W|E].

 */
char* GeoPos_getLonString(GeoPos _self);

/* Functions for class ProductNodeGroup */

/**
 *  Constructs a node group with no owner and which will not take ownership of added children.

 @param name The group name.
 @since BEAM 4.8

 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup1(const char* name);
/**
 *  Constructs a node group for the given owner.

 @param owner                   The owner of the group.
 @param name                    The group name.
 @param takingOverNodeOwnership If {@code true}, child nodes will have this group as owner after adding.

 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup2(ProductNode owner, const char* name, boolean takingOverNodeOwnership);
/**
 *  @return {@code true}, if child nodes will have this group as owner after adding.

 */
boolean ProductNodeGroup_isTakingOverNodeOwnership(ProductNodeGroup _self);
/**
 *  @return The number of product nodes in this product group.

 */
int ProductNodeGroup_getNodeCount(ProductNodeGroup _self);
/**
 *  @param index The node index.
 @return The product node at the given index.

 */
T ProductNodeGroup_get1(ProductNodeGroup _self, int index);
/**
 *  Returns the display names of all products currently managed.

 @return an array containing the display names, never <code>null</code>, but the array can have zero length
 @see ProductNode#getDisplayName()

 */
char** ProductNodeGroup_getNodeDisplayNames(ProductNodeGroup _self, int* resultArrayLength);
/**
 *  Returns the names of all products currently managed.

 @return an array containing the names, never <code>null</code>, but the array can have zero length

 */
char** ProductNodeGroup_getNodeNames(ProductNodeGroup _self, int* resultArrayLength);
/**
 *  Returns an array of all products currently managed.

 @return an array containing the products, never <code>null</code>, but the array can have zero length

 */
ProductNode* ProductNodeGroup_toArray1(ProductNodeGroup _self, int* resultArrayLength);
/**
 *  @param array the array into which the elements of the list are to be stored, if it is big enough; otherwise, a
              new array of the same runtime type is allocated for this purpose.
 @return an array containing the product nodes, never <code>null</code>, but the array can have zero length

 */
T* ProductNodeGroup_toArray2(ProductNodeGroup _self, const T* arrayElems, int arrayLength, int* resultArrayLength);
/**
 * 
 */
int ProductNodeGroup_indexOf2(ProductNodeGroup _self, const char* name);
/**
 * 
 */
int ProductNodeGroup_indexOf1(ProductNodeGroup _self, T element);
/**
 *  @param displayName the display name
 @return the product node with the given display name.

 */
T ProductNodeGroup_getByDisplayName(ProductNodeGroup _self, const char* displayName);
/**
 *  @param name the name
 @return the product node with the given name.

 */
T ProductNodeGroup_get2(ProductNodeGroup _self, const char* name);
/**
 *  Tests whether a node with the given name is contained in this group.

 @param name the name
 @return true, if so

 */
boolean ProductNodeGroup_contains2(ProductNodeGroup _self, const char* name);
/**
 *  Tests whether the given product is contained in this list.

 @param node the node
 @return true, if so

 */
boolean ProductNodeGroup_contains1(ProductNodeGroup _self, T node);
/**
 *  Adds the given node to this group.

 @param node the node to be added, ignored if <code>null</code>
 @return true, if the node has been added

 */
boolean ProductNodeGroup_add2(ProductNodeGroup _self, T node);
/**
 *  Adds the given node to this group.

 @param index the index.
 @param node  the node to be added, ignored if <code>null</code>

 */
void ProductNodeGroup_add1(ProductNodeGroup _self, int index, T node);
/**
 *  Removes the given node from this group.

 @param node the node to be removed
 @return true, if the node was removed

 */
boolean ProductNodeGroup_remove(ProductNodeGroup _self, T node);
/**
 *  Removes all nodes from this group.

 */
void ProductNodeGroup_removeAll(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_clearRemovedList(ProductNodeGroup _self);
/**
 *  Gets all removed node nodes.

 @return a collection of all removed node nodes.

 */
Collection ProductNodeGroup_getRemovedNodes(ProductNodeGroup _self);
/**
 * 
 */
dlong ProductNodeGroup_getRawStorageSize2(ProductNodeGroup _self, ProductSubsetDef subsetDef);
/**
 * 
 */
void ProductNodeGroup_setModified(ProductNodeGroup _self, boolean modified);
/**
 * 
 */
void ProductNodeGroup_acceptVisitor(ProductNodeGroup _self, ProductVisitor visitor);
/**
 * 
 */
void ProductNodeGroup_dispose(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_updateExpression(ProductNodeGroup _self, const char* oldExternalName, const char* newExternalName);
/**
 *  @return The owner node of this node.

 */
ProductNode ProductNodeGroup_getOwner(ProductNodeGroup _self);
/**
 *  @return This node's name.

 */
char* ProductNodeGroup_getName(ProductNodeGroup _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void ProductNodeGroup_setName(ProductNodeGroup _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* ProductNodeGroup_getDescription(ProductNodeGroup _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void ProductNodeGroup_setDescription(ProductNodeGroup _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean ProductNodeGroup_isModified(ProductNodeGroup _self);
/**
 * 
 */
char* ProductNodeGroup_toString(ProductNodeGroup _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean ProductNodeGroup_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product ProductNodeGroup_getProduct(ProductNodeGroup _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader ProductNodeGroup_getProductReader(ProductNodeGroup _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter ProductNodeGroup_getProductWriter(ProductNodeGroup _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* ProductNodeGroup_getDisplayName(ProductNodeGroup _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* ProductNodeGroup_getProductRefString(ProductNodeGroup _self);
/**
 *  Gets an estimated, raw storage size in bytes of this product node.

 @return the size in bytes.

 */
dlong ProductNodeGroup_getRawStorageSize1(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_fireProductNodeChanged1(ProductNodeGroup _self, const char* propertyName);
/**
 * 
 */
void ProductNodeGroup_fireProductNodeChanged2(ProductNodeGroup _self, const char* propertyName, Object oldValue, Object newValue);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void ProductNodeGroup_removeFromFile(ProductNodeGroup _self, ProductWriter productWriter);
/**
 * 
 */
E ProductNodeGroup_getExtension(ProductNodeGroup _self, Class arg0);

/* Functions for class ProductUtils */

/**
 * 
 */
ProductUtils ProductUtils_newProductUtils();
/**
 *  Creates image creation information.

 @param rasters                 The raster data nodes.
 @param assignMissingImageInfos if {@code true}, it is ensured that to all {@code RasterDataNode}s a valid {@code ImageInfo} will be assigned.
 @param pm                      The progress monitor.
 @return image information
 @throws IOException if an I/O error occurs
 @since BEAM 4.2

 */
ImageInfo ProductUtils_createImageInfo(const RasterDataNode* rastersElems, int rastersLength, boolean assignMissingImageInfos, ProgressMonitor pm);
/**
 *  Creates a RGB image from the given array of <code>{@link RasterDataNode}</code>s.
 The given array <code>rasters</code> containing one or three raster data nodes. If three rasters are given
 RGB image is created, if only one raster is provided a gray scale image created.

 @param rasters   an array of one or three raster nodes.
 @param imageInfo the image info provides the information how to create the image
 @param pm        a monitor to inform the user about progress
 @return the created image
 @throws IOException if the given raster data is not loaded and reload causes an I/O error
 @see RasterDataNode#setImageInfo(org.esa.beam.framework.datamodel.ImageInfo)

 */
BufferedImage ProductUtils_createRgbImage(const RasterDataNode* rastersElems, int rastersLength, ImageInfo imageInfo, ProgressMonitor pm);
/**
 *  Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.
 <p/>
 <p>The method uses the given raster data node's image information (an instance of <code>{@link
 ImageInfo}</code>) to create the image.

 @param rasterDataNode the raster data node, must not be <code>null</code>
 @param pm             a monitor to inform the user about progress
 @return the color indexed image
 @throws IOException if the given raster data is not loaded and reload causes an I/O error
 @see org.esa.beam.framework.datamodel.RasterDataNode#getImageInfo()

 */
BufferedImage ProductUtils_createColorIndexedImage(RasterDataNode rasterDataNode, ProgressMonitor pm);
/**
 *  Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be
 the upper left pixel's center (0.5, 0.5).

 @param product       the product, must not be <code>null</code>
 @param rect          the rectangle in pixel coordinates of the product, if <code>null</code> the entire region is
                      considered
 @param mapProjection the map projection, must not be <code>null</code>
 @return the map information instance

 */
MapInfo ProductUtils_createSuitableMapInfo1(Product product, Rectangle rect, MapProjection mapProjection);
/**
 *  Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.

 @param product       the product, must not be <code>null</code>
 @param mapProjection the map projection, must not be <code>null</code>
 @param orientation   the orientation angle
 @param noDataValue   the no-data value to be used
 @return the map information instance

 */
MapInfo ProductUtils_createSuitableMapInfo2(Product product, MapProjection mapProjection, double orientation, double noDataValue);
/**
 * 
 */
Dimension ProductUtils_getOutputRasterSize(Product product, Rectangle rect, MapTransform mapTransform, double pixelSizeX, double pixelSizeY);
/**
 *  Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)
 and the given map transfromation. The method delegates to {@link #createMapEnvelope(org.esa.beam.framework.datamodel.Product,
 java.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,
 step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene raster width and
 height.

 @param product      The product.
 @param rect         The rectangle in pixel coordinates.
 @param mapTransform The map transformation.
 @return The boundary in map coordinates for the given product.

 */
Point2D* ProductUtils_createMapEnvelope2(Product product, Rectangle rect, MapTransform mapTransform, int* resultArrayLength);
/**
 *  Creates the boundary in map coordinates for the given product, source rectangle (in product
 pixel coordinates) and the given map transfromation. The method delegates to
 {@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,
 step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene
 raster width and height.

 @param product      The product.
 @param rect         The rectangle in pixel coordinates.
 @param step         The step size in pixels.
 @param mapTransform The map transformation.
 @return The boundary in map coordinates for the given product.

 */
Point2D* ProductUtils_createMapEnvelope1(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
/**
 * 
 */
Point2D* ProductUtils_getMinMax(const Point2D* boundaryElems, int boundaryLength, int* resultArrayLength);
/**
 * 
 */
Point2D* ProductUtils_createMapBoundary(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
/**
 *  Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.

 @param product the input product, must not be null
 @param step    the step given in pixels
 @return an array of geographical coordinates
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null

 */
GeoPos* ProductUtils_createGeoBoundary1(Product product, int step, int* resultArrayLength);
/**
 *  Creates the geographical boundary of the given region within the given product and returns it as a list of
 geographical coordinates.
 <p> This method delegates to {@link #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.

 @param product the input product, must not be null
 @param region  the region rectangle in product pixel coordinates, can be null for entire product
 @param step    the step given in pixels
 @return an array of geographical coordinates
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null
 @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)

 */
GeoPos* ProductUtils_createGeoBoundary2(Product product, Rectangle region, int step, int* resultArrayLength);
/**
 *  Creates the geographical boundary of the given region within the given product and returns it as a list of
 geographical coordinates.

 @param product        the input product, must not be null
 @param region         the region rectangle in product pixel coordinates, can be null for entire product
 @param step           the step given in pixels
 @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary
 @return an array of geographical coordinates
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null
 @see #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)

 */
GeoPos* ProductUtils_createGeoBoundary3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 *  Creates the geographical boundary of the given region within the given raster and returns it as a list of
 geographical coordinates.

 @param raster the input raster, must not be null
 @param region the region rectangle in raster pixel coordinates, can be null for entire raster
 @param step   the step given in pixels
 @return an array of geographical coordinates
 @throws IllegalArgumentException if raster is null or if the raster has no {@link GeoCoding} is null
 @see #createPixelBoundary(org.esa.beam.framework.datamodel.RasterDataNode, java.awt.Rectangle, int)

 */
GeoPos* ProductUtils_createGeoBoundary4(RasterDataNode raster, Rectangle region, int step, int* resultArrayLength);
/**
 *  Converts the geographic boundary entire product into one, two or three shape objects. If the product does not
 intersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created
 and returned in the order from west to east.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.

 @param product the input product
 @return an array of shape objects
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null
 @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, int)

 */
GeneralPath* ProductUtils_createGeoBoundaryPaths1(Product product, int* resultArrayLength);
/**
 *  Converts the geographic boundary of the region within the given product into one, two or three shape objects. If
 the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three
 shapes are created and returned in the order from west to east.
 <p/>
 This method delegates to {@link #createGeoBoundaryPaths(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}
 and the additional parameter <code>usePixelCenter</code> is <code>true</code>.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.

 @param product the input product
 @param region  the region rectangle in product pixel coordinates, can be null for entire product
 @param step    the step given in pixels
 @return an array of shape objects
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null
 @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int)

 */
GeneralPath* ProductUtils_createGeoBoundaryPaths2(Product product, Rectangle region, int step, int* resultArrayLength);
/**
 *  Converts the geographic boundary of the region within the given product into one, two or three shape objects. If
 the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three
 shapes are created and returned in the order from west to east.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.

 @param product        the input product
 @param region         the region rectangle in product pixel coordinates, can be null for entire product
 @param step           the step given in pixels
 @param usePixelCenter <code>true</code> if the pixel center should be used to create the pathes
 @return an array of shape objects
 @throws IllegalArgumentException if product is null or if the product's {@link GeoCoding} is null
 @see #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean)

 */
GeneralPath* ProductUtils_createGeoBoundaryPaths3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 *  Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p> This method delegates to {@link #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.

 @param product the product
 @param rect    the source rectangle
 @param step    the mean distance from one pixel position to the other in the returned array
 @return the rectangular boundary

 */
PixelPos* ProductUtils_createPixelBoundary1(Product product, Rectangle rect, int step, int* resultArrayLength);
/**
 *  Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.

 @param product        the product
 @param rect           the source rectangle
 @param step           the mean distance from one pixel position to the other in the returned array
 @param usePixelCenter <code>true</code> if the pixel center should be used to create the boundary
 @return the rectangular boundary

 */
PixelPos* ProductUtils_createPixelBoundary2(Product product, Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 *  Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a raster boundary expressed in geographical
 co-ordinates.

 @param raster the raster
 @param rect   the source rectangle
 @param step   the mean distance from one pixel position to the other in the returned array
 @return the rectangular boundary

 */
PixelPos* ProductUtils_createPixelBoundary3(RasterDataNode raster, Rectangle rect, int step, int* resultArrayLength);
/**
 *  Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p> This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.

 @param rect the source rectangle
 @param step the mean distance from one pixel position to the other in the returned array
 @return the rectangular boundary

 */
PixelPos* ProductUtils_createRectBoundary1(Rectangle rect, int step, int* resultArrayLength);
/**
 *  Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p/>

 @param rect           the source rectangle
 @param step           the mean distance from one pixel position to the other in the returned array
 @param usePixelCenter <code>true</code> if the pixel center should be used
 @return the rectangular boundary

 */
PixelPos* ProductUtils_createRectBoundary2(Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 *  Copies the flag codings from the source product to the target.

 @param source the source product
 @param target the target product

 */
void ProductUtils_copyFlagCodings(Product source, Product target);
/**
 *  Copies the given source flag coding to the target product.
 If it exists already, the method simply returns the existing instance.

 @param sourceFlagCoding the source flag coding
 @param target           the target product
 @return The flag coding.

 */
FlagCoding ProductUtils_copyFlagCoding(FlagCoding sourceFlagCoding, Product target);
/**
 *  Copies the given source index coding to the target product
 If it exists already, the method simply returns the existing instance.

 @param sourceIndexCoding the source index coding
 @param target            the target product
 @return The index coding.

 */
IndexCoding ProductUtils_copyIndexCoding(IndexCoding sourceIndexCoding, Product target);
/**
 *  Copies the {@link Mask}s from the source product to the target product.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks from the source bands to the target bands. Also
 note that a source mask is not copied to the target product, when there already
 is a mask in the target product with the same name as the source mask.

 @param sourceProduct the source product
 @param targetProduct the target product

 */
void ProductUtils_copyMasks(Product sourceProduct, Product targetProduct);
/**
 *  Copies the overlay {@link Mask}s from the source product's raster data nodes to
 the target product's raster data nodes.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks, which are not contained in the target product's
 mask group.

 @param sourceProduct the source product
 @param targetProduct the target product

 */
void ProductUtils_copyOverlayMasks(Product sourceProduct, Product targetProduct);
/**
 *  Copies all bands which contain a flagcoding from the source product to the target product.

 @param sourceProduct   the source product
 @param targetProduct   the target product
 @param copySourceImage whether the source image of the source band should be copied.
 @since BEAM 4.10

 */
void ProductUtils_copyFlagBands(Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 *  Copies the named tie-point grid from the source product to the target product.

 @param gridName      the name of the tie-point grid to be copied.
 @param sourceProduct the source product
 @param targetProduct the target product
 @return the copied tie-point grid, or <code>null</code> if the sourceProduct does not contain a tie-point grid with the given name.

 */
TiePointGrid ProductUtils_copyTiePointGrid(const char* gridName, Product sourceProduct, Product targetProduct);
/**
 *  Copies the named band from the source product to the target product.

 @param sourceBandName  the name of the band to be copied.
 @param sourceProduct   the source product.
 @param targetProduct   the target product.
 @param copySourceImage whether the source image of the source band should be copied.
 @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.
 @since BEAM 4.10

 */
Band ProductUtils_copyBand2(const char* sourceBandName, Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 *  Copies the named band from the source product to the target product.

 @param sourceBandName  the name of the band to be copied.
 @param sourceProduct   the source product.
 @param targetBandName  the name of the band copied.
 @param targetProduct   the target product.
 @param copySourceImage whether the source image of the source band should be copied.
 @return the copy of the band, or <code>null</code> if the sourceProduct does not contain a band with the given name.
 @since BEAM 4.10

 */
Band ProductUtils_copyBand1(const char* sourceBandName, Product sourceProduct, const char* targetBandName, Product targetProduct, boolean copySourceImage);
/**
 *  Copies all properties from source band to the target band.

 @param sourceRaster the source band
 @param targetRaster the target band
 @see #copySpectralBandProperties(org.esa.beam.framework.datamodel.Band, org.esa.beam.framework.datamodel.Band)

 */
void ProductUtils_copyRasterDataNodeProperties(RasterDataNode sourceRaster, RasterDataNode targetRaster);
/**
 *  Copies the spectral properties from source band to target band. These properties are:
 <ul>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandIndex() spectral band index},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralWavelength() the central wavelength},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandwidth() the spectral bandwidth} and</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSolarFlux() the solar spectral flux}.</li>
 </ul>

 @param sourceBand the source band
 @param targetBand the target band
 @see #copyRasterDataNodeProperties(org.esa.beam.framework.datamodel.RasterDataNode, org.esa.beam.framework.datamodel.RasterDataNode)

 */
void ProductUtils_copySpectralBandProperties(Band sourceBand, Band targetBand);
/**
 *  Copies the geocoding from the source product to target product.
 <p/>
 <p>If the geo-coding in the source product is a {@link TiePointGeoCoding} or a {@link PixelGeoCoding},
 the method expects existing latitude and longitude tie-point grids respectively existing latitude and longitude
 bands in the target product. The method will NOT automatically copy them as well.
 This behaviour may change in the future.</p>

 @param sourceProduct the source product
 @param targetProduct the target product
 @throws IllegalArgumentException if one of the params is <code>null</code>.

 */
void ProductUtils_copyGeoCoding(Product sourceProduct, Product targetProduct);
/**
 *  Copies all tie point grids from one product to another.

 @param sourceProduct the source product
 @param targetProduct the target product

 */
void ProductUtils_copyTiePointGrids(Product sourceProduct, Product targetProduct);
/**
 * 
 */
void ProductUtils_copyVectorData(Product sourceProduct, Product targetProduct);
/**
 *  Returns whether or not a product can return a pixel position from a given geographical position.

 @param product the product to be checked
 @return <code>true</code> if the given product can return a pixel position

 */
boolean ProductUtils_canGetPixelPos1(Product product);
/**
 *  Returns whether or not a raster can return a pixel position from a given geographical position.

 @param raster the raster to be checked
 @return <code>true</code> if the given raster can return a pixel position

 */
boolean ProductUtils_canGetPixelPos2(RasterDataNode raster);
/**
 *  Creates a density plot image from two raster data nodes.

 @param raster1    the first raster data node
 @param sampleMin1 the minimum sample value to be considered in the first raster
 @param sampleMax1 the maximum sample value to be considered in the first raster
 @param raster2    the second raster data node
 @param sampleMin2 the minimum sample value to be considered in the second raster
 @param sampleMax2 the maximum sample value to be considered in the second raster
 @param roiMask    an optional mask to be used as a ROI for the computation
 @param width      the width of the output image
 @param height     the height of the output image
 @param background the background color of the output image
 @param image      an image to be used as output image, if <code>null</code> a new image is created
 @param pm         the progress monitor
 @return the density plot image
 @throws java.io.IOException when an error occurred.

 */
BufferedImage ProductUtils_createDensityPlotImage(RasterDataNode raster1, float sampleMin1, float sampleMax1, RasterDataNode raster2, float sampleMin2, float sampleMax2, Mask roiMask, int width, int height, Color background, BufferedImage image, ProgressMonitor pm);
/**
 *  Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.

 @param raster     the raster data node which contains all the activated bitmask definitions
 @param overlayBIm the source image which is used as base image for all the overlays.
 @param pm         a monitor to inform the user about progress
 @return the modified given overlayBImm which contains all the activated masks.
 @see RasterDataNode#getOverlayMaskGroup()

 */
BufferedImage ProductUtils_overlayMasks(RasterDataNode raster, BufferedImage overlayBIm, ProgressMonitor pm);
/**
 * 
 */
GeoPos ProductUtils_getCenterGeoPos(Product product);
/**
 *  Normalizes the given geographical polygon so that maximum longitude differences between two points are 180
 degrees. The method operates only on the longitude values of the given polygon.

 @param polygon a geographical, closed polygon
 @return 0 if normalizing has not been applied , -1 if negative normalizing has been applied, 1 if positive
         normalizing has been applied, 2 if positive and negative normalising has been applied
 @see #denormalizeGeoPolygon(GeoPos[])

 */
int ProductUtils_normalizeGeoPolygon(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
int ProductUtils_normalizeGeoPolygon_old(const GeoPos* polygonElems, int polygonLength);
/**
 *  Denormalizes the longitude values which have been normalized using the
 {@link #normalizeGeoPolygon(org.esa.beam.framework.datamodel.GeoPos[])} method. The
 method operates only on the longitude values of the given polygon.

 @param polygon a geographical, closed polygon

 */
void ProductUtils_denormalizeGeoPolygon(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos(GeoPos geoPos);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos_old(GeoPos geoPos);
/**
 * 
 */
int ProductUtils_getRotationDirection(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
double ProductUtils_getAngleSum(const GeoPos* polygonElems, int polygonLength);
/**
 *  Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in
 pixel coordinates using the supplied geo coding.

 @param geoPath   a <code>GeneralPath</code> given in geographic lon/lat coordinates, as returned by the {@link
                  #convertToGeoPath(Shape, GeoCoding)} method
 @param geoCoding the geocoding used to convert the geographic coordinates into pixel coordinates.
 @return a <code>GeneralPath</code> given in pixel coordinates.
 @throws IllegalArgumentException if one of the given parameter is null.
 @throws IllegalStateException    if the given geoPath is not a geo referenced <code>GeneralPath</code> wich
                                  contains only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.
 @see #convertToGeoPath(Shape, GeoCoding)

 */
GeneralPath ProductUtils_convertToPixelPath(GeneralPath geoPath, GeoCoding geoCoding);
/**
 *  Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic
 coordinates using the supplied geo coding.

 @param shape     a <code>Shape</code> given in pixel X/Y coordinates
 @param geoCoding the geo coding used to convert the pixel coordinates into geografic coordinates.
 @return a <code>GeneralPath</code> given in geografic coordinates
 @throws IllegalArgumentException if one of the given parameter is <code>null</code> or the given geo coding can
                                  not get geografic coordinates.
 @throws IllegalStateException    if this method was used with a java runtime version in which it is not guaranted
                                  that a <code>PathIterator</code> returned by {@link Shape#getPathIterator(java.awt.geom.AffineTransform,
                                  double)} returnes only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types.
 @see GeoCoding#canGetGeoPos()

 */
GeneralPath ProductUtils_convertToGeoPath(Shape shape, GeoCoding geoCoding);
/**
 *  Copies all metadata elements and attributes of the source product to the target product.
 The copied elements and attributes are deeply cloned.

 @param source the source product.
 @param target the target product.
 @throws NullPointerException if the source or the target product is {@code null}.

 */
void ProductUtils_copyMetadata2(Product source, Product target);
/**
 *  Copies all metadata elements and attributes of the source element to the target element.
 The copied elements and attributes are deeply cloned.

 @param source the source element.
 @param target the target element.
 @throws NullPointerException if the source or the target element is {@code null}.

 */
void ProductUtils_copyMetadata1(MetadataElement source, MetadataElement target);
/**
 *  Copies the source product's preferred tile size (if any) to the target product.

 @param sourceProduct The source product.
 @param targetProduct The target product.

 */
void ProductUtils_copyPreferredTileSize(Product sourceProduct, Product targetProduct);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata2(Product product);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata1(GeoCoding geoCoding, int width, int height);
/**
 * 
 */
GeneralPath ProductUtils_areaToPath(Area negativeArea, double deltaX);
/**
 *  Adds a given elem to the history of the given product. If the products metadata root
 does not contain a history entry a new one will be created.

 @param product the product to add the history element.
 @param elem    the element to add to the products history. If <code>null</code> nothing will be added.

 */
void ProductUtils_addElementToHistory(Product product, MetadataElement elem);
/**
 *  Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given
 product, the related element is removed.

 @param product the (output) product to be cleaned up
 @return an array of messages which changes are done to the given product.

 */
char** ProductUtils_removeInvalidExpressions(Product product, int* resultArrayLength);
/**
 *  Finds the name of a band in the given product which is suitable to product a good quicklook.
 The method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.

 @param product the product to be searched
 @return the name of a suitable band or null if the given product does not contain any bands

 */
char* ProductUtils_findSuitableQuicklookBandName(Product product);
/**
 * 
 */
PixelPos* ProductUtils_computeSourcePixelCoordinates(GeoCoding sourceGeoCoding, int sourceWidth, int sourceHeight, GeoCoding destGeoCoding, Rectangle destArea, int* resultArrayLength);
/**
 *  Computes the minimum and maximum y value of the given {@link PixelPos} array.

 @param pixelPositions the {@link PixelPos} array
 @return an int array which containes the minimum and maximum y value of the given {@link PixelPos} array in the
         order:<br> &nbsp;&nbsp;&nbsp;&nbsp;[0] - the minimum value<br>&nbsp;&nbsp;&nbsp;&nbsp;[1] - the maximum
         value<br><br>or <code>null</code> if no minimum or maximum can be retrieved because there given array is
         empty.
 @throws IllegalArgumentException if the given pixelPositions are <code>null</code>.

 */
float* ProductUtils_computeMinMaxY(const PixelPos* pixelPositionsElems, int pixelPositionsLength, int* resultArrayLength);
/**
 *  Copies only the bands from source to target.

 @see #copyBandsForGeomTransform(org.esa.beam.framework.datamodel.Product, org.esa.beam.framework.datamodel.Product, boolean, double, java.util.Map)

 */
void ProductUtils_copyBandsForGeomTransform1(Product sourceProduct, Product targetProduct, double defaultNoDataValue, Map addedRasterDataNodes);
/**
 *  Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target
 product is a geometric transformation (e.g. map-projection) of the source product.
 <p>If
 {@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,
 this method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},
 regardless which raw data type the source band has.
 In this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}
 will always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}
 will always be 0.0 and
 {@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.
 This ensures that source pixel resampling methods operating on floating point
 data can be stored without loss in accuracy in the target band.
 <p/>
 <p>Furthermore, the
 {@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}
 and {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}
 properties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},
 will be either the one from the source band, if any, or otherwise the one passed into this method.

 @param sourceProduct        the source product as the source for the band specifications. Must be not
                             <code>null</code>.
 @param targetProduct        the destination product to receive the bands created. Must be not <code>null</code>.
 @param includeTiePointGrids if {@code true}, tie-point grids of source product will be included as bands in target product
 @param defaultNoDataValue   the default, geophysical no-data value to be used if no no-data value is used by the source band.
 @param targetToSourceMap    a mapping from a target band to a source raster data node, can be {@code null}

 */
void ProductUtils_copyBandsForGeomTransform2(Product sourceProduct, Product targetProduct, boolean includeTiePointGrids, double defaultNoDataValue, Map targetToSourceMap);
/**
 * 
 */
ProductData_UTC ProductUtils_getScanLineTime(Product product, double y);
/**
 * 
 */
double ProductUtils_getGeophysicalSampleDouble(Band band, int pixelX, int pixelY, int level);
/**
 * 
 */
dlong ProductUtils_getGeophysicalSampleLong(Band band, int pixelX, int pixelY, int level);

/* Functions for class MetadataAttribute */

/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute(const char* name, ProductData data, boolean readOnly);
/**
 * 
 */
MetadataElement MetadataAttribute_getParentElement(MetadataAttribute _self);
/**
 * 
 */
boolean MetadataAttribute_equals(MetadataAttribute _self, Object object);
/**
 *  Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.

 @param visitor the visitor

 */
void MetadataAttribute_acceptVisitor(MetadataAttribute _self, ProductVisitor visitor);
/**
 * 
 */
MetadataAttribute MetadataAttribute_createDeepClone(MetadataAttribute _self);
/**
 *  Gets the data type of this data node.

 @return the data type which is always one of the multiple <code>ProductData.TYPE_<i>X</i></code> constants

 */
int MetadataAttribute_getDataType(MetadataAttribute _self);
/**
 *  Tests whether the data type of this node is a floating point type.

 @return true, if so

 */
boolean MetadataAttribute_isFloatingPointType(MetadataAttribute _self);
/**
 *  Gets the number of data elements in this data node.

 */
dlong MetadataAttribute_getNumDataElems(MetadataAttribute _self);
/**
 *  Sets the data of this data node.

 */
void MetadataAttribute_setData(MetadataAttribute _self, ProductData data);
/**
 *  Gets the data of this data node.

 */
ProductData MetadataAttribute_getData(MetadataAttribute _self);
/**
 *  Sets the data elements of this data node.

 @see ProductData#setElems(Object)

 */
void MetadataAttribute_setDataElems(MetadataAttribute _self, Object elems);
/**
 *  Gets the data elements of this data node.

 @see ProductData#getElems()

 */
Object MetadataAttribute_getDataElems(MetadataAttribute _self);
/**
 *  Gets the data element size in bytes.

 @see ProductData#getElemSize(int)

 */
int MetadataAttribute_getDataElemSize(MetadataAttribute _self);
/**
 * 
 */
void MetadataAttribute_setReadOnly(MetadataAttribute _self, boolean readOnly);
/**
 * 
 */
boolean MetadataAttribute_isReadOnly(MetadataAttribute _self);
/**
 * 
 */
void MetadataAttribute_setUnit(MetadataAttribute _self, const char* unit);
/**
 * 
 */
char* MetadataAttribute_getUnit(MetadataAttribute _self);
/**
 *  Fires a node data changed event. This method is called after the data of this data node changed.

 */
void MetadataAttribute_fireProductNodeDataChanged(MetadataAttribute _self);
/**
 *  Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.

 */
void MetadataAttribute_dispose(MetadataAttribute _self);
/**
 *  Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.

 @param numElems the number of elements, must not be less than one
 @return product data compatible with this data node

 */
ProductData MetadataAttribute_createCompatibleProductData(MetadataAttribute _self, int numElems);
/**
 *  @return The owner node of this node.

 */
ProductNode MetadataAttribute_getOwner(MetadataAttribute _self);
/**
 *  @return This node's name.

 */
char* MetadataAttribute_getName(MetadataAttribute _self);
/**
 *  Sets this product's name.

 @param name The name.

 */
void MetadataAttribute_setName(MetadataAttribute _self, const char* name);
/**
 *  Returns a short textual description for this products node.

 @return a description or <code>null</code>

 */
char* MetadataAttribute_getDescription(MetadataAttribute _self);
/**
 *  Sets a short textual description for this products node.

 @param description a description, can be <code>null</code>

 */
void MetadataAttribute_setDescription(MetadataAttribute _self, const char* description);
/**
 *  Returns whether or not this node is modified.

 @return <code>true</code> if so

 */
boolean MetadataAttribute_isModified(MetadataAttribute _self);
/**
 *  Sets this node's modified flag.
 <p/>
 If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to
 true.

 @param modified whether or not this node is beeing marked as modified.
 @see org.esa.beam.framework.datamodel.Product#fireNodeChanged

 */
void MetadataAttribute_setModified(MetadataAttribute _self, boolean modified);
/**
 * 
 */
char* MetadataAttribute_toString(MetadataAttribute _self);
/**
 *  Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>

 @param name the name to test
 @return <code>true</code> if the name is a valid node ifentifier, <code>false</code> otherwise

 */
boolean MetadataAttribute_isValidNodeName(const char* name);
/**
 *  Returns the product to which this node belongs to.

 @return the product, or <code>null</code> if this node was not owned by a product at the time this method was
         called

 */
Product MetadataAttribute_getProduct(MetadataAttribute _self);
/**
 *  Returns the product reader for the product to which this node belongs to.

 @return the product reader, or <code>null</code> if no such exists

 */
ProductReader MetadataAttribute_getProductReader(MetadataAttribute _self);
/**
 *  Returns the product writer for the product to which this node belongs to.

 @return the product writer, or <code>null</code> if no such exists

 */
ProductWriter MetadataAttribute_getProductWriter(MetadataAttribute _self);
/**
 *  Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.

 @return this node's name with a product prefix <br>or this node's name only if this node's product prefix is
         <code>null</code>
 @see #getProductRefString

 */
char* MetadataAttribute_getDisplayName(MetadataAttribute _self);
/**
 *  Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.

 @return the product reference string. <br>or <code>null</code> if this node has no product <br>or
         <code>null</code> if its product reference number was inactive

 */
char* MetadataAttribute_getProductRefString(MetadataAttribute _self);
/**
 *  Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.

 @param oldExternalName The old node name.
 @param newExternalName The new node name.

 */
void MetadataAttribute_updateExpression(MetadataAttribute _self, const char* oldExternalName, const char* newExternalName);
/**
 *  Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.

 @param productWriter the product writer to be used to remove this node from the underlying file.

 */
void MetadataAttribute_removeFromFile(MetadataAttribute _self, ProductWriter productWriter);
/**
 * 
 */
E MetadataAttribute_getExtension(MetadataAttribute _self, Class arg0);

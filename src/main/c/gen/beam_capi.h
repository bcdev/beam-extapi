/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * File created at Mon Nov 12 17:12:09 CET 2012 using org.esa.beam.extapi.gen.ApiGeneratorDoclet
 */


typedef char byte;
typedef unsigned char boolean;
typedef long long dlong;



/* Wrapped API classes */
typedef void* GeoCoding;
typedef void* ProductWriter;
typedef void* IndexCoding;
typedef void* PixelPos;
typedef void* ProductIO;
typedef void* Placemark;
typedef void* MetadataElement;
typedef void* Product;
typedef void* ColorPaletteDef;
typedef void* ImageInfo;
typedef void* ProductManager;
typedef void* ImageGeometry;
typedef void* Band;
typedef void* PlacemarkGroup;
typedef void* TiePointGrid;
typedef void* AngularDirection;
typedef void* FlagCoding;
typedef void* ProductReader;
typedef void* RGBChannelDef;
typedef void* ProductData;
typedef void* GeoPos;
typedef void* ProductNodeGroup;
typedef void* ProductUtils;
typedef void* MetadataAttribute;


/* Non-API classes used in the API */
typedef void* String;
typedef void* Shape;
typedef void* MapTransform;
typedef void* Parser;
typedef void* AffineTransform;
typedef void* Mask;
typedef void* Double;
typedef void* Term;
typedef void* RasterDataNode;
typedef void* Product_AutoGrouping;
typedef void* Dimension;
typedef void* ImageOutputStream;
typedef void* Stx;
typedef void* Rectangle;
typedef void* ProductNode;
typedef void* SimpleFeatureType;
typedef void* SampleCoding;
typedef void* Object;
typedef void* ProductData_UTC;
typedef void* Integer;
typedef void* ProductReaderPlugIn;
typedef void* ColorPaletteDef_Point;
typedef void* RenderedImage;
typedef void* IndexValidator;
typedef void* Area;
typedef void* ComponentColorModel;
typedef void* Iterator;
typedef void* MathTransform;
typedef void* CoordinateReferenceSystem;
typedef void* ProductWriterPlugIn;
typedef void* File;
typedef void* MapProjection;
typedef void* IndexColorModel;
typedef void* ProductNodeListener;
typedef void* ImageInfo_HistogramMatching;
typedef void* Map;
typedef void* Pointing;
typedef void* Color;
typedef void* PlacemarkDescriptor;
typedef void* PointingFactory;
typedef void* TransectProfileData;
typedef void* Point2D;
typedef void* T;
typedef void* ProductVisitor;
typedef void* Scaling;
typedef void* WritableNamespace;
typedef void* MultiLevelImage;
typedef void* ROI;
typedef void* Collection;
typedef void* ProductManager_Listener;
typedef void* GeoTIFFMetadata;
typedef void* MapInfo;
typedef void* Histogram;
typedef void* BufferedImage;
typedef void* SimpleFeature;
typedef void* ProductSubsetDef;
typedef void* ProgressMonitor;
typedef void* VectorDataNode;
typedef void* GeneralPath;
typedef void* ImageInputStream;





/*
 * Java VM functions that must be used if this module is used in stand-alone
 * mode (= not loaded as shared library by a Java VM).
 */

boolean beam_is_jvm_created();
boolean beam_create_jvm(const char* option_strings[], int option_count);
boolean beam_create_jvm_with_defaults();
boolean beam_destroy_jvm();

String String_newString(const char* chars);


/* Functions for class GeoCoding */

boolean GeoCoding_isCrossingMeridianAt180(GeoCoding _self);
boolean GeoCoding_canGetPixelPos(GeoCoding _self);
boolean GeoCoding_canGetGeoPos(GeoCoding _self);
PixelPos GeoCoding_getPixelPos(GeoCoding _self, GeoPos geoPos, PixelPos pixelPos);
GeoPos GeoCoding_getGeoPos(GeoCoding _self, PixelPos pixelPos, GeoPos geoPos);
void GeoCoding_dispose(GeoCoding _self);
CoordinateReferenceSystem GeoCoding_getImageCRS(GeoCoding _self);
CoordinateReferenceSystem GeoCoding_getMapCRS(GeoCoding _self);
CoordinateReferenceSystem GeoCoding_getGeoCRS(GeoCoding _self);
MathTransform GeoCoding_getImageToMapTransform(GeoCoding _self);

/* Functions for class ProductWriter */

ProductWriterPlugIn ProductWriter_getWriterPlugIn(ProductWriter _self);
Object ProductWriter_getOutput(ProductWriter _self);
void ProductWriter_writeProductNodes(ProductWriter _self, Product product, Object output);
void ProductWriter_writeBandRasterData(ProductWriter _self, Band sourceBand, int sourceOffsetX, int sourceOffsetY, int sourceWidth, int sourceHeight, ProductData sourceBuffer, ProgressMonitor pm);
void ProductWriter_flush(ProductWriter _self);
void ProductWriter_close(ProductWriter _self);
boolean ProductWriter_shouldWrite(ProductWriter _self, ProductNode node);
boolean ProductWriter_isIncrementalMode(ProductWriter _self);
void ProductWriter_setIncrementalMode(ProductWriter _self, boolean enabled);
void ProductWriter_deleteOutput(ProductWriter _self);
void ProductWriter_removeBand(ProductWriter _self, Band band);

/* Constants of IndexCoding */
extern const char* IndexCoding_PROPERTY_NAME_NAME;
extern const char* IndexCoding_PROPERTY_NAME_DESCRIPTION;

/* Functions for class IndexCoding */

IndexCoding IndexCoding_newIndexCoding(const char* name);
MetadataAttribute IndexCoding_getIndex(IndexCoding _self, const char* name);
char** IndexCoding_getIndexNames(IndexCoding _self, int* resultArrayLength);
MetadataAttribute IndexCoding_addIndex(IndexCoding _self, const char* name, int value, const char* description);
int IndexCoding_getIndexValue(IndexCoding _self, const char* name);
void IndexCoding_acceptVisitor(IndexCoding _self, ProductVisitor visitor);
void IndexCoding_addElement(IndexCoding _self, MetadataElement element);
void IndexCoding_addAttribute(IndexCoding _self, MetadataAttribute attribute);
MetadataAttribute IndexCoding_addSample(IndexCoding _self, const char* name, int value, const char* description);
int IndexCoding_getSampleCount(IndexCoding _self);
char* IndexCoding_getSampleName(IndexCoding _self, int index);
int IndexCoding_getSampleValue(IndexCoding _self, int index);
ProductNodeGroup IndexCoding_getElementGroup(IndexCoding _self);
MetadataElement IndexCoding_getParentElement(IndexCoding _self);
void IndexCoding_addElementAt(IndexCoding _self, MetadataElement element, int index);
boolean IndexCoding_removeElement(IndexCoding _self, MetadataElement element);
int IndexCoding_getNumElements(IndexCoding _self);
MetadataElement IndexCoding_getElementAt(IndexCoding _self, int index);
char** IndexCoding_getElementNames(IndexCoding _self, int* resultArrayLength);
MetadataElement* IndexCoding_getElements(IndexCoding _self, int* resultArrayLength);
MetadataElement IndexCoding_getElement(IndexCoding _self, const char* name);
boolean IndexCoding_containsElement(IndexCoding _self, const char* name);
int IndexCoding_getElementIndex(IndexCoding _self, MetadataElement element);
boolean IndexCoding_removeAttribute(IndexCoding _self, MetadataAttribute attribute);
int IndexCoding_getNumAttributes(IndexCoding _self);
MetadataAttribute IndexCoding_getAttributeAt(IndexCoding _self, int index);
char** IndexCoding_getAttributeNames(IndexCoding _self, int* resultArrayLength);
MetadataAttribute* IndexCoding_getAttributes(IndexCoding _self, int* resultArrayLength);
MetadataAttribute IndexCoding_getAttribute(IndexCoding _self, const char* name);
boolean IndexCoding_containsAttribute(IndexCoding _self, const char* name);
int IndexCoding_getAttributeIndex(IndexCoding _self, MetadataAttribute attribute);
double IndexCoding_getAttributeDouble(IndexCoding _self, const char* name, double defaultValue);
ProductData_UTC IndexCoding_getAttributeUTC(IndexCoding _self, const char* name, ProductData_UTC defaultValue);
int IndexCoding_getAttributeInt(IndexCoding _self, const char* name, int defaultValue);
void IndexCoding_setAttributeInt(IndexCoding _self, const char* name, int value);
void IndexCoding_setAttributeDouble(IndexCoding _self, const char* name, double value);
void IndexCoding_setAttributeUTC(IndexCoding _self, const char* name, ProductData_UTC value);
char* IndexCoding_getAttributeString(IndexCoding _self, const char* name, const char* defaultValue);
void IndexCoding_setAttributeString(IndexCoding _self, const char* name, const char* value);
void IndexCoding_setModified(IndexCoding _self, boolean modified);
MetadataElement IndexCoding_createDeepClone(IndexCoding _self);
void IndexCoding_dispose(IndexCoding _self);
ProductNode IndexCoding_getOwner(IndexCoding _self);
char* IndexCoding_getName(IndexCoding _self);
void IndexCoding_setName(IndexCoding _self, const char* name);
char* IndexCoding_getDescription(IndexCoding _self);
void IndexCoding_setDescription(IndexCoding _self, const char* description);
boolean IndexCoding_isModified(IndexCoding _self);
char* IndexCoding_toString(IndexCoding _self);
boolean IndexCoding_isValidNodeName(const char* name);
Product IndexCoding_getProduct(IndexCoding _self);
ProductReader IndexCoding_getProductReader(IndexCoding _self);
ProductWriter IndexCoding_getProductWriter(IndexCoding _self);
char* IndexCoding_getDisplayName(IndexCoding _self);
char* IndexCoding_getProductRefString(IndexCoding _self);
void IndexCoding_updateExpression(IndexCoding _self, const char* oldExternalName, const char* newExternalName);
void IndexCoding_removeFromFile(IndexCoding _self, ProductWriter productWriter);

/* Functions for class PixelPos */

PixelPos PixelPos_newPixelPos1();
PixelPos PixelPos_newPixelPos2(float x, float y);
boolean PixelPos_isValid(PixelPos _self);
void PixelPos_setInvalid(PixelPos _self);
double PixelPos_getX(PixelPos _self);
double PixelPos_getY(PixelPos _self);
void PixelPos_setLocation1(PixelPos _self, double arg0, double arg1);
void PixelPos_setLocation2(PixelPos _self, float arg0, float arg1);
char* PixelPos_toString(PixelPos _self);
void PixelPos_setLocation3(PixelPos _self, Point2D arg0);
double PixelPos_distanceSq2(double arg0, double arg1, double arg2, double arg3);
double PixelPos_distance2(double arg0, double arg1, double arg2, double arg3);
double PixelPos_distanceSq1(PixelPos _self, double arg0, double arg1);
double PixelPos_distanceSq3(PixelPos _self, Point2D arg0);
double PixelPos_distance1(PixelPos _self, double arg0, double arg1);
double PixelPos_distance3(PixelPos _self, Point2D arg0);
Object PixelPos_clone(PixelPos _self);
int PixelPos_hashCode(PixelPos _self);
boolean PixelPos_equals(PixelPos _self, Object arg0);

/* Constants of ProductIO */
extern const char* ProductIO_DEFAULT_FORMAT_NAME;

/* Functions for class ProductIO */

ProductReader ProductIO_getProductReader(const char* formatName);
char** ProductIO_getProductWriterExtensions(const char* formatName, int* resultArrayLength);
ProductWriter ProductIO_getProductWriter(const char* formatName);
Product ProductIO_readProduct(const char* filePath);
ProductReader ProductIO_getProductReaderForInput(Object input);
void ProductIO_writeProduct(Product product, const char* filePath, const char* formatName);

/* Constants of Placemark */
extern const char* Placemark_PLACEMARK_FEATURE_TYPE_NAME;
extern const char* Placemark_PROPERTY_NAME_LABEL;
extern const char* Placemark_PROPERTY_NAME_TEXT;
extern const char* Placemark_PROPERTY_NAME_PIXELPOS;
extern const char* Placemark_PROPERTY_NAME_GEOPOS;
extern const char* Placemark_PROPERTY_NAME_DATETIME;
extern const char* Placemark_PROPERTY_NAME_STYLE_CSS;
extern const char* Placemark_PROPERTY_NAME_NAME;
extern const char* Placemark_PROPERTY_NAME_DESCRIPTION;

/* Functions for class Placemark */

Placemark Placemark_newPlacemark(PlacemarkDescriptor descriptor, SimpleFeature feature);
Placemark Placemark_createPointPlacemark(PlacemarkDescriptor descriptor, const char* name, const char* label, const char* text, PixelPos pixelPos, GeoPos geoPos, GeoCoding geoCoding);
PlacemarkDescriptor Placemark_getDescriptor(Placemark _self);
SimpleFeature Placemark_getFeature(Placemark _self);
Object Placemark_getAttributeValue(Placemark _self, const char* attributeName);
void Placemark_setAttributeValue(Placemark _self, const char* attributeName, Object attributeValue);
void Placemark_setLabel(Placemark _self, const char* label);
char* Placemark_getLabel(Placemark _self);
void Placemark_setText(Placemark _self, const char* text);
char* Placemark_getText(Placemark _self);
void Placemark_setStyleCss(Placemark _self, const char* styleCss);
char* Placemark_getStyleCss(Placemark _self);
void Placemark_acceptVisitor(Placemark _self, ProductVisitor visitor);
PixelPos Placemark_getPixelPos(Placemark _self);
void Placemark_setPixelPos(Placemark _self, PixelPos pixelPos);
GeoPos Placemark_getGeoPos(Placemark _self);
void Placemark_setGeoPos(Placemark _self, GeoPos geoPos);
void Placemark_updatePositions(Placemark _self);
SimpleFeatureType Placemark_createPinFeatureType();
SimpleFeatureType Placemark_createGcpFeatureType();
SimpleFeatureType Placemark_createGeometryFeatureType();
SimpleFeatureType Placemark_createPointFeatureType(const char* name);
ProductNode Placemark_getOwner(Placemark _self);
char* Placemark_getName(Placemark _self);
void Placemark_setName(Placemark _self, const char* name);
char* Placemark_getDescription(Placemark _self);
void Placemark_setDescription(Placemark _self, const char* description);
boolean Placemark_isModified(Placemark _self);
void Placemark_setModified(Placemark _self, boolean modified);
char* Placemark_toString(Placemark _self);
void Placemark_dispose(Placemark _self);
boolean Placemark_isValidNodeName(const char* name);
Product Placemark_getProduct(Placemark _self);
ProductReader Placemark_getProductReader(Placemark _self);
ProductWriter Placemark_getProductWriter(Placemark _self);
char* Placemark_getDisplayName(Placemark _self);
char* Placemark_getProductRefString(Placemark _self);
void Placemark_updateExpression(Placemark _self, const char* oldExternalName, const char* newExternalName);
void Placemark_removeFromFile(Placemark _self, ProductWriter productWriter);

/* Constants of MetadataElement */
extern const char* MetadataElement_PROPERTY_NAME_NAME;
extern const char* MetadataElement_PROPERTY_NAME_DESCRIPTION;

/* Functions for class MetadataElement */

MetadataElement MetadataElement_newMetadataElement(const char* name);
ProductNodeGroup MetadataElement_getElementGroup(MetadataElement _self);
MetadataElement MetadataElement_getParentElement(MetadataElement _self);
void MetadataElement_addElement(MetadataElement _self, MetadataElement element);
void MetadataElement_addElementAt(MetadataElement _self, MetadataElement element, int index);
boolean MetadataElement_removeElement(MetadataElement _self, MetadataElement element);
int MetadataElement_getNumElements(MetadataElement _self);
MetadataElement MetadataElement_getElementAt(MetadataElement _self, int index);
char** MetadataElement_getElementNames(MetadataElement _self, int* resultArrayLength);
MetadataElement* MetadataElement_getElements(MetadataElement _self, int* resultArrayLength);
MetadataElement MetadataElement_getElement(MetadataElement _self, const char* name);
boolean MetadataElement_containsElement(MetadataElement _self, const char* name);
int MetadataElement_getElementIndex(MetadataElement _self, MetadataElement element);
void MetadataElement_addAttribute(MetadataElement _self, MetadataAttribute attribute);
boolean MetadataElement_removeAttribute(MetadataElement _self, MetadataAttribute attribute);
int MetadataElement_getNumAttributes(MetadataElement _self);
MetadataAttribute MetadataElement_getAttributeAt(MetadataElement _self, int index);
char** MetadataElement_getAttributeNames(MetadataElement _self, int* resultArrayLength);
MetadataAttribute* MetadataElement_getAttributes(MetadataElement _self, int* resultArrayLength);
MetadataAttribute MetadataElement_getAttribute(MetadataElement _self, const char* name);
boolean MetadataElement_containsAttribute(MetadataElement _self, const char* name);
int MetadataElement_getAttributeIndex(MetadataElement _self, MetadataAttribute attribute);
double MetadataElement_getAttributeDouble(MetadataElement _self, const char* name, double defaultValue);
ProductData_UTC MetadataElement_getAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC defaultValue);
int MetadataElement_getAttributeInt(MetadataElement _self, const char* name, int defaultValue);
void MetadataElement_setAttributeInt(MetadataElement _self, const char* name, int value);
void MetadataElement_setAttributeDouble(MetadataElement _self, const char* name, double value);
void MetadataElement_setAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC value);
char* MetadataElement_getAttributeString(MetadataElement _self, const char* name, const char* defaultValue);
void MetadataElement_setAttributeString(MetadataElement _self, const char* name, const char* value);
void MetadataElement_setModified(MetadataElement _self, boolean modified);
void MetadataElement_acceptVisitor(MetadataElement _self, ProductVisitor visitor);
MetadataElement MetadataElement_createDeepClone(MetadataElement _self);
void MetadataElement_dispose(MetadataElement _self);
ProductNode MetadataElement_getOwner(MetadataElement _self);
char* MetadataElement_getName(MetadataElement _self);
void MetadataElement_setName(MetadataElement _self, const char* name);
char* MetadataElement_getDescription(MetadataElement _self);
void MetadataElement_setDescription(MetadataElement _self, const char* description);
boolean MetadataElement_isModified(MetadataElement _self);
char* MetadataElement_toString(MetadataElement _self);
boolean MetadataElement_isValidNodeName(const char* name);
Product MetadataElement_getProduct(MetadataElement _self);
ProductReader MetadataElement_getProductReader(MetadataElement _self);
ProductWriter MetadataElement_getProductWriter(MetadataElement _self);
char* MetadataElement_getDisplayName(MetadataElement _self);
char* MetadataElement_getProductRefString(MetadataElement _self);
void MetadataElement_updateExpression(MetadataElement _self, const char* oldExternalName, const char* newExternalName);
void MetadataElement_removeFromFile(MetadataElement _self, ProductWriter productWriter);

/* Constants of Product */
extern const char* Product_METADATA_ROOT_NAME;
extern const char* Product_HISTORY_ROOT_NAME;
extern const char* Product_PIN_MASK_NAME;
extern const char* Product_GCP_MASK_NAME;
extern const char* Product_PROPERTY_NAME_GEOCODING;
extern const char* Product_PROPERTY_NAME_PRODUCT_TYPE;
extern const char* Product_GEOMETRY_FEATURE_TYPE_NAME;
extern const char* Product_PROPERTY_NAME_NAME;
extern const char* Product_PROPERTY_NAME_DESCRIPTION;

/* Functions for class Product */

Product Product_newProduct(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight);
File Product_getFileLocation(Product _self);
void Product_setFileLocation(Product _self, File fileLocation);
char* Product_getProductType(Product _self);
void Product_setProductType(Product _self, const char* productType);
void Product_setProductReader(Product _self, ProductReader reader);
ProductReader Product_getProductReader(Product _self);
void Product_setProductWriter(Product _self, ProductWriter writer);
ProductWriter Product_getProductWriter(Product _self);
void Product_writeHeader(Product _self, Object output);
void Product_closeProductReader(Product _self);
void Product_closeProductWriter(Product _self);
void Product_closeIO(Product _self);
void Product_dispose(Product _self);
PointingFactory Product_getPointingFactory(Product _self);
void Product_setPointingFactory(Product _self, PointingFactory pointingFactory);
void Product_setGeoCoding(Product _self, GeoCoding geoCoding);
GeoCoding Product_getGeoCoding(Product _self);
boolean Product_isUsingSingleGeoCoding(Product _self);
boolean Product_transferGeoCodingTo(Product _self, Product destProduct, ProductSubsetDef subsetDef);
int Product_getSceneRasterWidth(Product _self);
int Product_getSceneRasterHeight(Product _self);
ProductData_UTC Product_getStartTime(Product _self);
void Product_setStartTime(Product _self, ProductData_UTC startTime);
ProductData_UTC Product_getEndTime(Product _self);
void Product_setEndTime(Product _self, ProductData_UTC endTime);
MetadataElement Product_getMetadataRoot(Product _self);
ProductNodeGroup Product_getBandGroup(Product _self);
ProductNodeGroup Product_getTiePointGridGroup(Product _self);
void Product_addTiePointGrid(Product _self, TiePointGrid tiePointGrid);
boolean Product_removeTiePointGrid(Product _self, TiePointGrid tiePointGrid);
int Product_getNumTiePointGrids(Product _self);
TiePointGrid Product_getTiePointGridAt(Product _self, int index);
char** Product_getTiePointGridNames(Product _self, int* resultArrayLength);
TiePointGrid* Product_getTiePointGrids(Product _self, int* resultArrayLength);
TiePointGrid Product_getTiePointGrid(Product _self, const char* name);
boolean Product_containsTiePointGrid(Product _self, const char* name);
void Product_addBand(Product _self, Band band);
Band Product_addNewBand(Product _self, const char* bandName, int dataType);
Band Product_addComputedBand(Product _self, const char* bandName, const char* expression);
boolean Product_removeBand(Product _self, Band band);
int Product_getNumBands(Product _self);
Band Product_getBandAt(Product _self, int index);
char** Product_getBandNames(Product _self, int* resultArrayLength);
Band* Product_getBands(Product _self, int* resultArrayLength);
Band Product_getBand(Product _self, const char* name);
int Product_getBandIndex(Product _self, const char* name);
boolean Product_containsBand(Product _self, const char* name);
boolean Product_containsRasterDataNode(Product _self, const char* name);
RasterDataNode Product_getRasterDataNode(Product _self, const char* name);
ProductNodeGroup Product_getMaskGroup(Product _self);
ProductNodeGroup Product_getVectorDataGroup(Product _self);
ProductNodeGroup Product_getFlagCodingGroup(Product _self);
ProductNodeGroup Product_getIndexCodingGroup(Product _self);
boolean Product_containsPixel(Product _self, float x, float y);
PlacemarkGroup Product_getGcpGroup(Product _self);
PlacemarkGroup Product_getPinGroup(Product _self);
boolean Product_isCompatibleProduct(Product _self, Product product, float eps);
Term Product_parseExpression(Product _self, const char* expression);
void Product_acceptVisitor(Product _self, ProductVisitor visitor);
boolean Product_addProductNodeListener(Product _self, ProductNodeListener listener);
void Product_removeProductNodeListener(Product _self, ProductNodeListener listener);
ProductNodeListener* Product_getProductNodeListeners(Product _self, int* resultArrayLength);
int Product_getRefNo(Product _self);
void Product_setRefNo(Product _self, int refNo);
void Product_resetRefNo(Product _self);
ProductManager Product_getProductManager(Product _self);
Parser Product_createBandArithmeticParser(Product _self);
WritableNamespace Product_createBandArithmeticDefaultNamespace(Product _self);
Product Product_createSubset(Product _self, ProductSubsetDef subsetDef, const char* name, const char* desc);
Product Product_createProjectedProduct(Product _self, MapInfo mapInfo, const char* name, const char* desc);
Product Product_createFlippedProduct(Product _self, int flipType, const char* name, const char* desc);
void Product_setModified(Product _self, boolean modified);
char* Product_getQuicklookBandName(Product _self);
void Product_setQuicklookBandName(Product _self, const char* quicklookBandName);
char* Product_createPixelInfoString(Product _self, int pixelX, int pixelY);
ProductNode* Product_getRemovedChildNodes(Product _self, int* resultArrayLength);
boolean Product_canBeOrthorectified(Product _self);
Dimension Product_getPreferredTileSize(Product _self);
void Product_setPreferredTileSize(Product _self, int tileWidth, int tileHeight);
char** Product_getAllFlagNames(Product _self, int* resultArrayLength);
Product_AutoGrouping Product_getAutoGrouping(Product _self);
void Product_setAutoGrouping(Product _self, const char* pattern);
Mask Product_addComputedMask(Product _self, const char* maskName, const char* expression, const char* description, Color color, double transparency);
ProductNode Product_getOwner(Product _self);
char* Product_getName(Product _self);
void Product_setName(Product _self, const char* name);
char* Product_getDescription(Product _self);
void Product_setDescription(Product _self, const char* description);
boolean Product_isModified(Product _self);
char* Product_toString(Product _self);
boolean Product_isValidNodeName(const char* name);
Product Product_getProduct(Product _self);
char* Product_getDisplayName(Product _self);
char* Product_getProductRefString(Product _self);
void Product_updateExpression(Product _self, const char* oldExternalName, const char* newExternalName);
void Product_removeFromFile(Product _self, ProductWriter productWriter);

/* Functions for class ColorPaletteDef */

ColorPaletteDef ColorPaletteDef_newColorPaletteDefFromRange(double minSample, double maxSample);
ColorPaletteDef ColorPaletteDef_newColorPaletteDefFromPoints(const ColorPaletteDef_Point pointsElems, int pointsLength, int numColors);
boolean ColorPaletteDef_isDiscrete(ColorPaletteDef _self);
void ColorPaletteDef_setDiscrete(ColorPaletteDef _self, boolean discrete);
int ColorPaletteDef_getNumColors(ColorPaletteDef _self);
void ColorPaletteDef_setNumColors(ColorPaletteDef _self, int numColors);
int ColorPaletteDef_getNumPoints(ColorPaletteDef _self);
void ColorPaletteDef_setNumPoints(ColorPaletteDef _self, int numPoints);
boolean ColorPaletteDef_isAutoDistribute(ColorPaletteDef _self);
void ColorPaletteDef_setAutoDistribute(ColorPaletteDef _self, boolean autoDistribute);
ColorPaletteDef_Point ColorPaletteDef_getPointAt(ColorPaletteDef _self, int index);
ColorPaletteDef_Point ColorPaletteDef_getFirstPoint(ColorPaletteDef _self);
ColorPaletteDef_Point ColorPaletteDef_getLastPoint(ColorPaletteDef _self);
double ColorPaletteDef_getMinDisplaySample(ColorPaletteDef _self);
double ColorPaletteDef_getMaxDisplaySample(ColorPaletteDef _self);
void ColorPaletteDef_insertPointAfter(ColorPaletteDef _self, int index, ColorPaletteDef_Point point);
boolean ColorPaletteDef_createPointAfter(ColorPaletteDef _self, int index, Scaling scaling);
Color ColorPaletteDef_getCenterColor(Color c1, Color c2);
void ColorPaletteDef_removePointAt(ColorPaletteDef _self, int index);
void ColorPaletteDef_addPoint(ColorPaletteDef _self, ColorPaletteDef_Point point);
ColorPaletteDef_Point* ColorPaletteDef_getPoints(ColorPaletteDef _self, int* resultArrayLength);
void ColorPaletteDef_setPoints(ColorPaletteDef _self, const ColorPaletteDef_Point pointsElems, int pointsLength);
Iterator ColorPaletteDef_getIterator(ColorPaletteDef _self);
Object ColorPaletteDef_clone(ColorPaletteDef _self);
ColorPaletteDef ColorPaletteDef_createDeepCopy(ColorPaletteDef _self);
ColorPaletteDef ColorPaletteDef_loadColorPaletteDef(File file);
void ColorPaletteDef_storeColorPaletteDef(ColorPaletteDef colorPaletteDef, File file);
void ColorPaletteDef_dispose(ColorPaletteDef _self);
Color* ColorPaletteDef_getColors(ColorPaletteDef _self, int* resultArrayLength);
Color* ColorPaletteDef_createColorPalette(ColorPaletteDef _self, Scaling scaling, int* resultArrayLength);
Color ColorPaletteDef_computeColor(ColorPaletteDef _self, Scaling scaling, double sample);

/* Constants of ImageInfo */
extern const Color ImageInfo_NO_COLOR;
extern const char* ImageInfo_HISTOGRAM_MATCHING_OFF;
extern const char* ImageInfo_HISTOGRAM_MATCHING_EQUALIZE;
extern const char* ImageInfo_HISTOGRAM_MATCHING_NORMALIZE;

/* Functions for class ImageInfo */

ImageInfo ImageInfo_newImageInfoPalette(ColorPaletteDef colorPaletteDef);
ImageInfo ImageInfo_newImageInfoRGB(RGBChannelDef rgbChannelDef);
ColorPaletteDef ImageInfo_getColorPaletteDef(ImageInfo _self);
RGBChannelDef ImageInfo_getRgbChannelDef(ImageInfo _self);
Color ImageInfo_getNoDataColor(ImageInfo _self);
void ImageInfo_setNoDataColor(ImageInfo _self, Color noDataColor);
void ImageInfo_setHistogramMatching(ImageInfo _self, ImageInfo_HistogramMatching histogramMatching);
boolean ImageInfo_isLogScaled(ImageInfo _self);
void ImageInfo_setLogScaled(ImageInfo _self, boolean logScaled);
Color* ImageInfo_getColors(ImageInfo _self, int* resultArrayLength);
int ImageInfo_getColorComponentCount(ImageInfo _self);
IndexColorModel ImageInfo_createIndexColorModel(ImageInfo _self, Scaling scaling);
ComponentColorModel ImageInfo_createComponentColorModel(ImageInfo _self);
Object ImageInfo_clone(ImageInfo _self);
ImageInfo ImageInfo_createDeepCopy(ImageInfo _self);
void ImageInfo_dispose(ImageInfo _self);
void ImageInfo_setColors(ImageInfo _self, const Color colorsElems, int colorsLength);
void ImageInfo_setColorPaletteDef(ImageInfo _self, ColorPaletteDef colorPaletteDef, double minSample, double maxSample, boolean autoDistribute);
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching(const char* mode);

/* Functions for class ProductManager */

ProductManager ProductManager_newProductManager();
int ProductManager_getProductCount(ProductManager _self);
Product ProductManager_getProduct(ProductManager _self, int index);
char** ProductManager_getProductDisplayNames(ProductManager _self, int* resultArrayLength);
char** ProductManager_getProductNames(ProductManager _self, int* resultArrayLength);
Product* ProductManager_getProducts(ProductManager _self, int* resultArrayLength);
Product ProductManager_getProductByDisplayName(ProductManager _self, const char* displayName);
Product ProductManager_getProductByRefNo(ProductManager _self, int refNo);
Product ProductManager_getProductByName(ProductManager _self, const char* name);
int ProductManager_getProductIndex(ProductManager _self, Product product);
boolean ProductManager_containsProduct(ProductManager _self, const char* name);
boolean ProductManager_contains(ProductManager _self, Product product);
void ProductManager_addProduct(ProductManager _self, Product product);
boolean ProductManager_removeProduct(ProductManager _self, Product product);
void ProductManager_removeAllProducts(ProductManager _self);
boolean ProductManager_addListener(ProductManager _self, ProductManager_Listener listener);
boolean ProductManager_removeListener(ProductManager _self, ProductManager_Listener listener);

/* Functions for class ImageGeometry */

ImageGeometry ImageGeometry_newImageGeometry(Rectangle bounds, CoordinateReferenceSystem mapCrs, AffineTransform image2map);
AffineTransform ImageGeometry_getImage2MapTransform(ImageGeometry _self);
Rectangle ImageGeometry_getImageRect(ImageGeometry _self);
CoordinateReferenceSystem ImageGeometry_getMapCrs(ImageGeometry _self);
void ImageGeometry_changeYAxisDirection(ImageGeometry _self);
Point2D ImageGeometry_calculateEastingNorthing(Product sourceProduct, CoordinateReferenceSystem targetCrs, double referencePixelX, double referencePixelY, double pixelSizeX, double pixelSizeY);
Rectangle ImageGeometry_calculateProductSize(Product sourceProduct, CoordinateReferenceSystem targetCrs, double pixelSizeX, double pixelSizeY);
ImageGeometry ImageGeometry_createTargetGeometry(Product sourceProduct, CoordinateReferenceSystem targetCrs, Double pixelSizeX, Double pixelSizeY, Integer width, Integer height, Double orientation, Double easting, Double northing, Double referencePixelX, Double referencePixelY);
ImageGeometry ImageGeometry_createCollocationTargetGeometry(Product targetProduct, Product collocationProduct);

/* Constants of Band */
extern const char* Band_PROPERTY_NAME_SAMPLE_CODING;
extern const char* Band_PROPERTY_NAME_SOLAR_FLUX;
extern const char* Band_PROPERTY_NAME_SPECTRAL_BAND_INDEX;
extern const char* Band_PROPERTY_NAME_SPECTRAL_BANDWIDTH;
extern const char* Band_PROPERTY_NAME_SPECTRAL_WAVELENGTH;
extern const char* Band_VIEW_MODE_ORTHO;
extern const char* Band_VIEW_MODE_FORWARD;
extern const char* Band_VIEW_MODE_NADIR;
extern const char* Band_PROPERTY_NAME_IMAGE_INFO;
extern const char* Band_PROPERTY_NAME_LOG_10_SCALED;
extern const char* Band_PROPERTY_NAME_ROI_DEFINITION;
extern const char* Band_PROPERTY_NAME_SCALING_FACTOR;
extern const char* Band_PROPERTY_NAME_SCALING_OFFSET;
extern const char* Band_PROPERTY_NAME_NO_DATA_VALUE;
extern const char* Band_PROPERTY_NAME_NO_DATA_VALUE_USED;
extern const char* Band_PROPERTY_NAME_VALID_PIXEL_EXPRESSION;
extern const char* Band_PROPERTY_NAME_GEOCODING;
extern const char* Band_PROPERTY_NAME_STX;
extern const char* Band_NO_DATA_TEXT;
extern const char* Band_INVALID_POS_TEXT;
extern const char* Band_NOT_LOADED_TEXT;
extern const char* Band_IO_ERROR_TEXT;
extern const char* Band_PROPERTY_NAME_DATA;
extern const char* Band_PROPERTY_NAME_READ_ONLY;
extern const char* Band_PROPERTY_NAME_SYNTHETIC;
extern const char* Band_PROPERTY_NAME_UNIT;
extern const char* Band_PROPERTY_NAME_NAME;
extern const char* Band_PROPERTY_NAME_DESCRIPTION;

/* Functions for class Band */

Band Band_newBand(const char* name, int dataType, int width, int height);
FlagCoding Band_getFlagCoding(Band _self);
boolean Band_isFlagBand(Band _self);
IndexCoding Band_getIndexCoding(Band _self);
boolean Band_isIndexBand(Band _self);
SampleCoding Band_getSampleCoding(Band _self);
void Band_setSampleCoding(Band _self, SampleCoding sampleCoding);
int Band_getSpectralBandIndex(Band _self);
void Band_setSpectralBandIndex(Band _self, int spectralBandIndex);
float Band_getSpectralWavelength(Band _self);
void Band_setSpectralWavelength(Band _self, float spectralWavelength);
float Band_getSpectralBandwidth(Band _self);
void Band_setSpectralBandwidth(Band _self, float spectralBandwidth);
float Band_getSolarFlux(Band _self);
void Band_setSolarFlux(Band _self, float solarFlux);
void Band_acceptVisitor(Band _self, ProductVisitor visitor);
char* Band_toString(Band _self);
void Band_removeFromFile(Band _self, ProductWriter productWriter);
void Band_dispose(Band _self);
ProductData Band_getSceneRasterData(Band _self);
int Band_getPixelInt(Band _self, int x, int y);
float Band_getPixelFloat(Band _self, int x, int y);
double Band_getPixelDouble(Band _self, int x, int y);
void Band_setPixelInt(Band _self, int x, int y, int pixelValue);
void Band_setPixelFloat(Band _self, int x, int y, float pixelValue);
void Band_setPixelDouble(Band _self, int x, int y, double pixelValue);
void Band_setPixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
void Band_setPixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
void Band_setPixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
void Band_ensureRasterData(Band _self);
void Band_unloadRasterData(Band _self);
char* Band_getViewModeId(Band _self, const char* bandName);
int Band_getSceneRasterWidth(Band _self);
int Band_getSceneRasterHeight(Band _self);
int Band_getRasterWidth(Band _self);
int Band_getRasterHeight(Band _self);
void Band_setModified(Band _self, boolean modified);
GeoCoding Band_getGeoCoding(Band _self);
void Band_setGeoCoding(Band _self, GeoCoding geoCoding);
Pointing Band_getPointing(Band _self);
boolean Band_canBeOrthorectified(Band _self);
boolean Band_isFloatingPointType(Band _self);
int Band_getGeophysicalDataType(Band _self);
double Band_getScalingFactor(Band _self);
void Band_setScalingFactor(Band _self, double scalingFactor);
double Band_getScalingOffset(Band _self);
void Band_setScalingOffset(Band _self, double scalingOffset);
boolean Band_isLog10Scaled(Band _self);
void Band_setLog10Scaled(Band _self, boolean log10Scaled);
boolean Band_isScalingApplied(Band _self);
boolean Band_isValidMaskProperty(const char* propertyName);
boolean Band_isNoDataValueSet(Band _self);
void Band_clearNoDataValue(Band _self);
boolean Band_isNoDataValueUsed(Band _self);
void Band_setNoDataValueUsed(Band _self, boolean noDataValueUsed);
double Band_getNoDataValue(Band _self);
void Band_setNoDataValue(Band _self, double noDataValue);
double Band_getGeophysicalNoDataValue(Band _self);
void Band_setGeophysicalNoDataValue(Band _self, double noDataValue);
char* Band_getValidPixelExpression(Band _self);
void Band_setValidPixelExpression(Band _self, const char* validPixelExpression);
boolean Band_isValidMaskUsed(Band _self);
void Band_resetValidMask(Band _self);
char* Band_getValidMaskExpression(Band _self);
void Band_updateExpression(Band _self, const char* oldExternalName, const char* newExternalName);
boolean Band_hasRasterData(Band _self);
ProductData Band_getRasterData(Band _self);
void Band_setRasterData(Band _self, ProductData rasterData);
void Band_loadRasterData(Band _self);
boolean Band_isPixelValid(Band _self, int x, int y);
int Band_getSampleInt(Band _self, int x, int y);
float Band_getSampleFloat(Band _self, int x, int y);
int* Band_getPixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
float* Band_getPixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
double* Band_getPixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
int* Band_readPixelsInt(Band _self, int x, int y, int w, int h, int* pixelsElems, int pixelsLength, int* resultArrayLength);
float* Band_readPixelsFloat(Band _self, int x, int y, int w, int h, float* pixelsElems, int pixelsLength, int* resultArrayLength);
double* Band_readPixelsDouble(Band _self, int x, int y, int w, int h, double* pixelsElems, int pixelsLength, int* resultArrayLength);
void Band_writePixelsInt(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
void Band_writePixelsFloat(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
void Band_writePixelsDouble(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
boolean* Band_readValidMask(Band _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
void Band_readRasterDataFully(Band _self);
void Band_readRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
void Band_writeRasterDataFully(Band _self);
void Band_writeRasterData(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
ProductData Band_createCompatibleRasterData(Band _self);
ProductData Band_createCompatibleSceneRasterData(Band _self);
ProductData Band_createCompatibleRasterDataForRect(Band _self, int width, int height);
boolean Band_isCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
void Band_checkCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
boolean Band_hasIntPixels(Band _self);
TransectProfileData Band_createTransectProfileData(Band _self, Shape shape);
ImageInfo Band_getImageInfo(Band _self);
void Band_setImageInfo(Band _self, ImageInfo imageInfo);
void Band_fireImageInfoChanged(Band _self);
ImageInfo Band_createDefaultImageInfo(Band _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
ProductNodeGroup Band_getOverlayMaskGroup(Band _self);
BufferedImage Band_createColorIndexedImage(Band _self, ProgressMonitor pm);
BufferedImage Band_createRgbImage(Band _self, ProgressMonitor pm);
IndexValidator Band_createPixelValidator(Band _self, int lineOffset, ROI roi);
double Band_scale(Band _self, double v);
double Band_scaleInverse(Band _self, double v);
char* Band_getPixelString(Band _self, int x, int y);
boolean Band_isSourceImageSet(Band _self);
MultiLevelImage Band_getSourceImage(Band _self);
boolean Band_isGeophysicalImageSet(Band _self);
MultiLevelImage Band_getGeophysicalImage(Band _self);
boolean Band_isValidMaskImageSet(Band _self);
MultiLevelImage Band_getValidMaskImage(Band _self);
boolean Band_isStxSet(Band _self);
Stx Band_getStx(Band _self);
void Band_setStx(Band _self, Stx stx);
Shape Band_getValidShape(Band _self);
int Band_getDataType(Band _self);
dlong Band_getNumDataElems(Band _self);
void Band_setData(Band _self, ProductData data);
ProductData Band_getData(Band _self);
void Band_setDataElems(Band _self, Object elems);
Object Band_getDataElems(Band _self);
int Band_getDataElemSize(Band _self);
void Band_setReadOnly(Band _self, boolean readOnly);
boolean Band_isReadOnly(Band _self);
void Band_setUnit(Band _self, const char* unit);
char* Band_getUnit(Band _self);
void Band_fireProductNodeDataChanged(Band _self);
ProductData Band_createCompatibleProductData(Band _self, int numElems);
ProductNode Band_getOwner(Band _self);
char* Band_getName(Band _self);
void Band_setName(Band _self, const char* name);
char* Band_getDescription(Band _self);
void Band_setDescription(Band _self, const char* description);
boolean Band_isModified(Band _self);
boolean Band_isValidNodeName(const char* name);
Product Band_getProduct(Band _self);
ProductReader Band_getProductReader(Band _self);
ProductWriter Band_getProductWriter(Band _self);
char* Band_getDisplayName(Band _self);
char* Band_getProductRefString(Band _self);

/* Constants of PlacemarkGroup */
extern const char* PlacemarkGroup_PROPERTY_NAME_NAME;
extern const char* PlacemarkGroup_PROPERTY_NAME_DESCRIPTION;

/* Functions for class PlacemarkGroup */

VectorDataNode PlacemarkGroup_getVectorDataNode(PlacemarkGroup _self);
Placemark PlacemarkGroup_getPlacemark(PlacemarkGroup _self, SimpleFeature feature);
boolean PlacemarkGroup_add4(PlacemarkGroup _self, Placemark placemark);
void PlacemarkGroup_add2(PlacemarkGroup _self, int index, Placemark placemark);
boolean PlacemarkGroup_remove2(PlacemarkGroup _self, Placemark placemark);
void PlacemarkGroup_dispose(PlacemarkGroup _self);
boolean PlacemarkGroup_isTakingOverNodeOwnership(PlacemarkGroup _self);
int PlacemarkGroup_getNodeCount(PlacemarkGroup _self);
T PlacemarkGroup_get1(PlacemarkGroup _self, int index);
char** PlacemarkGroup_getNodeDisplayNames(PlacemarkGroup _self, int* resultArrayLength);
char** PlacemarkGroup_getNodeNames(PlacemarkGroup _self, int* resultArrayLength);
ProductNode* PlacemarkGroup_toArray1(PlacemarkGroup _self, int* resultArrayLength);
T* PlacemarkGroup_toArray2(PlacemarkGroup _self, const T arrayElems, int arrayLength, int* resultArrayLength);
int PlacemarkGroup_indexOf2(PlacemarkGroup _self, const char* name);
int PlacemarkGroup_indexOf1(PlacemarkGroup _self, T element);
T PlacemarkGroup_getByDisplayName(PlacemarkGroup _self, const char* displayName);
T PlacemarkGroup_get2(PlacemarkGroup _self, const char* name);
boolean PlacemarkGroup_contains2(PlacemarkGroup _self, const char* name);
boolean PlacemarkGroup_contains1(PlacemarkGroup _self, T node);
boolean PlacemarkGroup_add3(PlacemarkGroup _self, T node);
void PlacemarkGroup_add1(PlacemarkGroup _self, int index, T node);
boolean PlacemarkGroup_remove1(PlacemarkGroup _self, T node);
void PlacemarkGroup_removeAll(PlacemarkGroup _self);
void PlacemarkGroup_clearRemovedList(PlacemarkGroup _self);
Collection PlacemarkGroup_getRemovedNodes(PlacemarkGroup _self);
dlong PlacemarkGroup_getRawStorageSize2(PlacemarkGroup _self, ProductSubsetDef subsetDef);
void PlacemarkGroup_setModified(PlacemarkGroup _self, boolean modified);
void PlacemarkGroup_acceptVisitor(PlacemarkGroup _self, ProductVisitor visitor);
void PlacemarkGroup_updateExpression(PlacemarkGroup _self, const char* oldExternalName, const char* newExternalName);
ProductNode PlacemarkGroup_getOwner(PlacemarkGroup _self);
char* PlacemarkGroup_getName(PlacemarkGroup _self);
void PlacemarkGroup_setName(PlacemarkGroup _self, const char* name);
char* PlacemarkGroup_getDescription(PlacemarkGroup _self);
void PlacemarkGroup_setDescription(PlacemarkGroup _self, const char* description);
boolean PlacemarkGroup_isModified(PlacemarkGroup _self);
char* PlacemarkGroup_toString(PlacemarkGroup _self);
boolean PlacemarkGroup_isValidNodeName(const char* name);
Product PlacemarkGroup_getProduct(PlacemarkGroup _self);
ProductReader PlacemarkGroup_getProductReader(PlacemarkGroup _self);
ProductWriter PlacemarkGroup_getProductWriter(PlacemarkGroup _self);
char* PlacemarkGroup_getDisplayName(PlacemarkGroup _self);
char* PlacemarkGroup_getProductRefString(PlacemarkGroup _self);
dlong PlacemarkGroup_getRawStorageSize1(PlacemarkGroup _self);
void PlacemarkGroup_fireProductNodeChanged1(PlacemarkGroup _self, const char* propertyName);
void PlacemarkGroup_fireProductNodeChanged2(PlacemarkGroup _self, const char* propertyName, Object oldValue, Object newValue);
void PlacemarkGroup_removeFromFile(PlacemarkGroup _self, ProductWriter productWriter);

/* Constants of TiePointGrid */
extern const char* TiePointGrid_PROPERTY_NAME_IMAGE_INFO;
extern const char* TiePointGrid_PROPERTY_NAME_LOG_10_SCALED;
extern const char* TiePointGrid_PROPERTY_NAME_ROI_DEFINITION;
extern const char* TiePointGrid_PROPERTY_NAME_SCALING_FACTOR;
extern const char* TiePointGrid_PROPERTY_NAME_SCALING_OFFSET;
extern const char* TiePointGrid_PROPERTY_NAME_NO_DATA_VALUE;
extern const char* TiePointGrid_PROPERTY_NAME_NO_DATA_VALUE_USED;
extern const char* TiePointGrid_PROPERTY_NAME_VALID_PIXEL_EXPRESSION;
extern const char* TiePointGrid_PROPERTY_NAME_GEOCODING;
extern const char* TiePointGrid_PROPERTY_NAME_STX;
extern const char* TiePointGrid_NO_DATA_TEXT;
extern const char* TiePointGrid_INVALID_POS_TEXT;
extern const char* TiePointGrid_NOT_LOADED_TEXT;
extern const char* TiePointGrid_IO_ERROR_TEXT;
extern const char* TiePointGrid_PROPERTY_NAME_DATA;
extern const char* TiePointGrid_PROPERTY_NAME_READ_ONLY;
extern const char* TiePointGrid_PROPERTY_NAME_SYNTHETIC;
extern const char* TiePointGrid_PROPERTY_NAME_UNIT;
extern const char* TiePointGrid_PROPERTY_NAME_NAME;
extern const char* TiePointGrid_PROPERTY_NAME_DESCRIPTION;

/* Functions for class TiePointGrid */

TiePointGrid TiePointGrid_newTiePointGrid1(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength);
TiePointGrid TiePointGrid_newTiePointGrid2(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, int discontinuity);
TiePointGrid TiePointGrid_newTiePointGrid3(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, boolean containsAngles);
int TiePointGrid_getDiscontinuity2(const float* tiePointsElems, int tiePointsLength);
int TiePointGrid_getDiscontinuity1(TiePointGrid _self);
void TiePointGrid_setDiscontinuity(TiePointGrid _self, int discontinuity);
boolean TiePointGrid_isFloatingPointType(TiePointGrid _self);
int TiePointGrid_getGeophysicalDataType(TiePointGrid _self);
ProductData TiePointGrid_getSceneRasterData(TiePointGrid _self);
int TiePointGrid_getSceneRasterWidth(TiePointGrid _self);
int TiePointGrid_getSceneRasterHeight(TiePointGrid _self);
float TiePointGrid_getOffsetX(TiePointGrid _self);
float TiePointGrid_getOffsetY(TiePointGrid _self);
float TiePointGrid_getSubSamplingX(TiePointGrid _self);
float TiePointGrid_getSubSamplingY(TiePointGrid _self);
float* TiePointGrid_getTiePoints(TiePointGrid _self, int* resultArrayLength);
int TiePointGrid_getPixelInt(TiePointGrid _self, int x, int y);
void TiePointGrid_dispose(TiePointGrid _self);
float TiePointGrid_getPixelFloat2(TiePointGrid _self, int x, int y);
float TiePointGrid_getPixelFloat1(TiePointGrid _self, float x, float y);
double TiePointGrid_getPixelDouble(TiePointGrid _self, int x, int y);
void TiePointGrid_setPixelInt(TiePointGrid _self, int x, int y, int pixelValue);
void TiePointGrid_setPixelFloat(TiePointGrid _self, int x, int y, float pixelValue);
void TiePointGrid_setPixelDouble(TiePointGrid _self, int x, int y, double pixelValue);
int* TiePointGrid_getPixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
float* TiePointGrid_getPixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
double* TiePointGrid_getPixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
void TiePointGrid_setPixels3(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
void TiePointGrid_setPixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
void TiePointGrid_setPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
int* TiePointGrid_readPixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
float* TiePointGrid_readPixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
double* TiePointGrid_readPixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
void TiePointGrid_writePixels6(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm);
void TiePointGrid_writePixels4(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm);
void TiePointGrid_writePixels2(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm);
void TiePointGrid_readRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
void TiePointGrid_readRasterDataFully2(TiePointGrid _self, ProgressMonitor pm);
void TiePointGrid_writeRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
void TiePointGrid_writeRasterDataFully2(TiePointGrid _self, ProgressMonitor pm);
void TiePointGrid_acceptVisitor(TiePointGrid _self, ProductVisitor visitor);
TiePointGrid TiePointGrid_cloneTiePointGrid(TiePointGrid _self);
TiePointGrid TiePointGrid_createZenithFromElevationAngleTiePointGrid(TiePointGrid elevationAngleGrid);
TiePointGrid TiePointGrid_createSubset(TiePointGrid sourceTiePointGrid, ProductSubsetDef subsetDef);
int TiePointGrid_getRasterWidth(TiePointGrid _self);
int TiePointGrid_getRasterHeight(TiePointGrid _self);
void TiePointGrid_setModified(TiePointGrid _self, boolean modified);
GeoCoding TiePointGrid_getGeoCoding(TiePointGrid _self);
void TiePointGrid_setGeoCoding(TiePointGrid _self, GeoCoding geoCoding);
Pointing TiePointGrid_getPointing(TiePointGrid _self);
boolean TiePointGrid_canBeOrthorectified(TiePointGrid _self);
double TiePointGrid_getScalingFactor(TiePointGrid _self);
void TiePointGrid_setScalingFactor(TiePointGrid _self, double scalingFactor);
double TiePointGrid_getScalingOffset(TiePointGrid _self);
void TiePointGrid_setScalingOffset(TiePointGrid _self, double scalingOffset);
boolean TiePointGrid_isLog10Scaled(TiePointGrid _self);
void TiePointGrid_setLog10Scaled(TiePointGrid _self, boolean log10Scaled);
boolean TiePointGrid_isScalingApplied(TiePointGrid _self);
boolean TiePointGrid_isValidMaskProperty(const char* propertyName);
boolean TiePointGrid_isNoDataValueSet(TiePointGrid _self);
void TiePointGrid_clearNoDataValue(TiePointGrid _self);
boolean TiePointGrid_isNoDataValueUsed(TiePointGrid _self);
void TiePointGrid_setNoDataValueUsed(TiePointGrid _self, boolean noDataValueUsed);
double TiePointGrid_getNoDataValue(TiePointGrid _self);
void TiePointGrid_setNoDataValue(TiePointGrid _self, double noDataValue);
double TiePointGrid_getGeophysicalNoDataValue(TiePointGrid _self);
void TiePointGrid_setGeophysicalNoDataValue(TiePointGrid _self, double noDataValue);
char* TiePointGrid_getValidPixelExpression(TiePointGrid _self);
void TiePointGrid_setValidPixelExpression(TiePointGrid _self, const char* validPixelExpression);
boolean TiePointGrid_isValidMaskUsed(TiePointGrid _self);
void TiePointGrid_resetValidMask(TiePointGrid _self);
char* TiePointGrid_getValidMaskExpression(TiePointGrid _self);
void TiePointGrid_updateExpression(TiePointGrid _self, const char* oldExternalName, const char* newExternalName);
boolean TiePointGrid_hasRasterData(TiePointGrid _self);
ProductData TiePointGrid_getRasterData(TiePointGrid _self);
void TiePointGrid_setRasterData(TiePointGrid _self, ProductData rasterData);
void TiePointGrid_loadRasterData1(TiePointGrid _self);
void TiePointGrid_loadRasterData2(TiePointGrid _self, ProgressMonitor pm);
void TiePointGrid_unloadRasterData(TiePointGrid _self);
boolean TiePointGrid_isPixelValid2(TiePointGrid _self, int x, int y);
int TiePointGrid_getSampleInt(TiePointGrid _self, int x, int y);
float TiePointGrid_getSampleFloat(TiePointGrid _self, int x, int y);
boolean TiePointGrid_isPixelValid1(TiePointGrid _self, int pixelIndex);
boolean TiePointGrid_isPixelValid3(TiePointGrid _self, int x, int y, ROI roi);
int* TiePointGrid_getPixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
float* TiePointGrid_getPixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
double* TiePointGrid_getPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
int* TiePointGrid_readPixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
float* TiePointGrid_readPixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
double* TiePointGrid_readPixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
void TiePointGrid_writePixels5(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
void TiePointGrid_writePixels3(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
void TiePointGrid_writePixels1(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
boolean* TiePointGrid_readValidMask(TiePointGrid _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
void TiePointGrid_readRasterDataFully1(TiePointGrid _self);
void TiePointGrid_readRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
void TiePointGrid_writeRasterDataFully1(TiePointGrid _self);
void TiePointGrid_writeRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
ProductData TiePointGrid_createCompatibleRasterData1(TiePointGrid _self);
ProductData TiePointGrid_createCompatibleSceneRasterData(TiePointGrid _self);
ProductData TiePointGrid_createCompatibleRasterData2(TiePointGrid _self, int width, int height);
boolean TiePointGrid_isCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
void TiePointGrid_checkCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
boolean TiePointGrid_hasIntPixels(TiePointGrid _self);
TransectProfileData TiePointGrid_createTransectProfileData(TiePointGrid _self, Shape shape);
ImageInfo TiePointGrid_getImageInfo1(TiePointGrid _self);
void TiePointGrid_setImageInfo(TiePointGrid _self, ImageInfo imageInfo);
void TiePointGrid_fireImageInfoChanged(TiePointGrid _self);
ImageInfo TiePointGrid_getImageInfo2(TiePointGrid _self, ProgressMonitor pm);
ImageInfo TiePointGrid_getImageInfo3(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
ImageInfo TiePointGrid_createDefaultImageInfo1(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
ImageInfo TiePointGrid_createDefaultImageInfo2(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
ProductNodeGroup TiePointGrid_getOverlayMaskGroup(TiePointGrid _self);
BufferedImage TiePointGrid_createColorIndexedImage(TiePointGrid _self, ProgressMonitor pm);
BufferedImage TiePointGrid_createRgbImage(TiePointGrid _self, ProgressMonitor pm);
byte* TiePointGrid_quantizeRasterData1(TiePointGrid _self, double newMin, double newMax, double gamma, ProgressMonitor pm, int* resultArrayLength);
void TiePointGrid_quantizeRasterData2(TiePointGrid _self, double newMin, double newMax, double gamma, const byte* samplesElems, int samplesLength, int offset, int stride, ProgressMonitor pm);
IndexValidator TiePointGrid_createPixelValidator(TiePointGrid _self, int lineOffset, ROI roi);
double TiePointGrid_scale(TiePointGrid _self, double v);
double TiePointGrid_scaleInverse(TiePointGrid _self, double v);
char* TiePointGrid_getPixelString(TiePointGrid _self, int x, int y);
boolean TiePointGrid_isSourceImageSet(TiePointGrid _self);
MultiLevelImage TiePointGrid_getSourceImage(TiePointGrid _self);
void TiePointGrid_setSourceImage2(TiePointGrid _self, RenderedImage sourceImage);
void TiePointGrid_setSourceImage1(TiePointGrid _self, MultiLevelImage sourceImage);
boolean TiePointGrid_isGeophysicalImageSet(TiePointGrid _self);
MultiLevelImage TiePointGrid_getGeophysicalImage(TiePointGrid _self);
boolean TiePointGrid_isValidMaskImageSet(TiePointGrid _self);
MultiLevelImage TiePointGrid_getValidMaskImage(TiePointGrid _self);
boolean TiePointGrid_isStxSet(TiePointGrid _self);
Stx TiePointGrid_getStx1(TiePointGrid _self);
Stx TiePointGrid_getStx2(TiePointGrid _self, boolean accurate, ProgressMonitor pm);
void TiePointGrid_setStx(TiePointGrid _self, Stx stx);
Shape TiePointGrid_getValidShape(TiePointGrid _self);
int TiePointGrid_getDataType(TiePointGrid _self);
dlong TiePointGrid_getNumDataElems(TiePointGrid _self);
void TiePointGrid_setData(TiePointGrid _self, ProductData data);
ProductData TiePointGrid_getData(TiePointGrid _self);
void TiePointGrid_setDataElems(TiePointGrid _self, Object elems);
Object TiePointGrid_getDataElems(TiePointGrid _self);
int TiePointGrid_getDataElemSize(TiePointGrid _self);
void TiePointGrid_setReadOnly(TiePointGrid _self, boolean readOnly);
boolean TiePointGrid_isReadOnly(TiePointGrid _self);
void TiePointGrid_setUnit(TiePointGrid _self, const char* unit);
char* TiePointGrid_getUnit(TiePointGrid _self);
void TiePointGrid_fireProductNodeDataChanged(TiePointGrid _self);
dlong TiePointGrid_getRawStorageSize2(TiePointGrid _self, ProductSubsetDef subsetDef);
ProductData TiePointGrid_createCompatibleProductData(TiePointGrid _self, int numElems);
ProductNode TiePointGrid_getOwner(TiePointGrid _self);
char* TiePointGrid_getName(TiePointGrid _self);
void TiePointGrid_setName(TiePointGrid _self, const char* name);
char* TiePointGrid_getDescription(TiePointGrid _self);
void TiePointGrid_setDescription(TiePointGrid _self, const char* description);
boolean TiePointGrid_isModified(TiePointGrid _self);
char* TiePointGrid_toString(TiePointGrid _self);
boolean TiePointGrid_isValidNodeName(const char* name);
Product TiePointGrid_getProduct(TiePointGrid _self);
ProductReader TiePointGrid_getProductReader(TiePointGrid _self);
ProductWriter TiePointGrid_getProductWriter(TiePointGrid _self);
char* TiePointGrid_getDisplayName(TiePointGrid _self);
char* TiePointGrid_getProductRefString(TiePointGrid _self);
dlong TiePointGrid_getRawStorageSize1(TiePointGrid _self);
void TiePointGrid_fireProductNodeChanged1(TiePointGrid _self, const char* propertyName);
void TiePointGrid_fireProductNodeChanged2(TiePointGrid _self, const char* propertyName, Object oldValue, Object newValue);
void TiePointGrid_removeFromFile(TiePointGrid _self, ProductWriter productWriter);

/* Functions for class AngularDirection */

AngularDirection AngularDirection_newAngularDirection(double azimuth, double zenith);
boolean AngularDirection_equals(AngularDirection _self, Object obj);
char* AngularDirection_toString(AngularDirection _self);

/* Constants of FlagCoding */
extern const char* FlagCoding_PROPERTY_NAME_NAME;
extern const char* FlagCoding_PROPERTY_NAME_DESCRIPTION;

/* Functions for class FlagCoding */

FlagCoding FlagCoding_newFlagCoding(const char* name);
MetadataAttribute FlagCoding_getFlag(FlagCoding _self, const char* name);
char** FlagCoding_getFlagNames(FlagCoding _self, int* resultArrayLength);
MetadataAttribute FlagCoding_addFlag(FlagCoding _self, const char* name, int flagMask, const char* description);
int FlagCoding_getFlagMask(FlagCoding _self, const char* name);
void FlagCoding_acceptVisitor(FlagCoding _self, ProductVisitor visitor);
void FlagCoding_addElement(FlagCoding _self, MetadataElement element);
void FlagCoding_addAttribute(FlagCoding _self, MetadataAttribute attribute);
MetadataAttribute FlagCoding_addSample(FlagCoding _self, const char* name, int value, const char* description);
int FlagCoding_getSampleCount(FlagCoding _self);
char* FlagCoding_getSampleName(FlagCoding _self, int index);
int FlagCoding_getSampleValue(FlagCoding _self, int index);
ProductNodeGroup FlagCoding_getElementGroup(FlagCoding _self);
MetadataElement FlagCoding_getParentElement(FlagCoding _self);
void FlagCoding_addElementAt(FlagCoding _self, MetadataElement element, int index);
boolean FlagCoding_removeElement(FlagCoding _self, MetadataElement element);
int FlagCoding_getNumElements(FlagCoding _self);
MetadataElement FlagCoding_getElementAt(FlagCoding _self, int index);
char** FlagCoding_getElementNames(FlagCoding _self, int* resultArrayLength);
MetadataElement* FlagCoding_getElements(FlagCoding _self, int* resultArrayLength);
MetadataElement FlagCoding_getElement(FlagCoding _self, const char* name);
boolean FlagCoding_containsElement(FlagCoding _self, const char* name);
int FlagCoding_getElementIndex(FlagCoding _self, MetadataElement element);
boolean FlagCoding_removeAttribute(FlagCoding _self, MetadataAttribute attribute);
int FlagCoding_getNumAttributes(FlagCoding _self);
MetadataAttribute FlagCoding_getAttributeAt(FlagCoding _self, int index);
char** FlagCoding_getAttributeNames(FlagCoding _self, int* resultArrayLength);
MetadataAttribute* FlagCoding_getAttributes(FlagCoding _self, int* resultArrayLength);
MetadataAttribute FlagCoding_getAttribute(FlagCoding _self, const char* name);
boolean FlagCoding_containsAttribute(FlagCoding _self, const char* name);
int FlagCoding_getAttributeIndex(FlagCoding _self, MetadataAttribute attribute);
double FlagCoding_getAttributeDouble(FlagCoding _self, const char* name, double defaultValue);
ProductData_UTC FlagCoding_getAttributeUTC(FlagCoding _self, const char* name, ProductData_UTC defaultValue);
int FlagCoding_getAttributeInt(FlagCoding _self, const char* name, int defaultValue);
void FlagCoding_setAttributeInt(FlagCoding _self, const char* name, int value);
void FlagCoding_setAttributeDouble(FlagCoding _self, const char* name, double value);
void FlagCoding_setAttributeUTC(FlagCoding _self, const char* name, ProductData_UTC value);
char* FlagCoding_getAttributeString(FlagCoding _self, const char* name, const char* defaultValue);
void FlagCoding_setAttributeString(FlagCoding _self, const char* name, const char* value);
void FlagCoding_setModified(FlagCoding _self, boolean modified);
MetadataElement FlagCoding_createDeepClone(FlagCoding _self);
void FlagCoding_dispose(FlagCoding _self);
ProductNode FlagCoding_getOwner(FlagCoding _self);
char* FlagCoding_getName(FlagCoding _self);
void FlagCoding_setName(FlagCoding _self, const char* name);
char* FlagCoding_getDescription(FlagCoding _self);
void FlagCoding_setDescription(FlagCoding _self, const char* description);
boolean FlagCoding_isModified(FlagCoding _self);
char* FlagCoding_toString(FlagCoding _self);
boolean FlagCoding_isValidNodeName(const char* name);
Product FlagCoding_getProduct(FlagCoding _self);
ProductReader FlagCoding_getProductReader(FlagCoding _self);
ProductWriter FlagCoding_getProductWriter(FlagCoding _self);
char* FlagCoding_getDisplayName(FlagCoding _self);
char* FlagCoding_getProductRefString(FlagCoding _self);
void FlagCoding_updateExpression(FlagCoding _self, const char* oldExternalName, const char* newExternalName);
void FlagCoding_removeFromFile(FlagCoding _self, ProductWriter productWriter);

/* Functions for class ProductReader */

ProductReaderPlugIn ProductReader_getReaderPlugIn(ProductReader _self);
Object ProductReader_getInput(ProductReader _self);
ProductSubsetDef ProductReader_getSubsetDef(ProductReader _self);
Product ProductReader_readProductNodes(ProductReader _self, Object input, ProductSubsetDef subsetDef);
void ProductReader_readBandRasterData(ProductReader _self, Band destBand, int destOffsetX, int destOffsetY, int destWidth, int destHeight, ProductData destBuffer, ProgressMonitor pm);
void ProductReader_close(ProductReader _self);

/* Functions for class RGBChannelDef */

RGBChannelDef RGBChannelDef_newRGBChannelDef();
char* RGBChannelDef_getSourceName(RGBChannelDef _self, int index);
void RGBChannelDef_setSourceName(RGBChannelDef _self, int index, const char* sourceName);
char** RGBChannelDef_getSourceNames(RGBChannelDef _self, int* resultArrayLength);
void RGBChannelDef_setSourceNames(RGBChannelDef _self, const char** bandNamesElems, int bandNamesLength);
boolean RGBChannelDef_isAlphaUsed(RGBChannelDef _self);
boolean RGBChannelDef_isGammaUsed(RGBChannelDef _self, int index);
double RGBChannelDef_getGamma(RGBChannelDef _self, int index);
void RGBChannelDef_setGamma(RGBChannelDef _self, int index, double gamma);
double RGBChannelDef_getMinDisplaySample(RGBChannelDef _self, int index);
void RGBChannelDef_setMinDisplaySample(RGBChannelDef _self, int index, double min);
double RGBChannelDef_getMaxDisplaySample(RGBChannelDef _self, int index);
void RGBChannelDef_setMaxDisplaySample(RGBChannelDef _self, int index, double max);
Object RGBChannelDef_clone(RGBChannelDef _self);

/* Constants of ProductData */
extern const int ProductData_TYPE_UNDEFINED;
extern const int ProductData_TYPE_INT8;
extern const int ProductData_TYPE_INT16;
extern const int ProductData_TYPE_INT32;
extern const int ProductData_TYPE_UINT8;
extern const int ProductData_TYPE_UINT16;
extern const int ProductData_TYPE_UINT32;
extern const int ProductData_TYPE_FLOAT32;
extern const int ProductData_TYPE_FLOAT64;
extern const int ProductData_TYPE_ASCII;
extern const int ProductData_TYPE_UTC;
extern const char* ProductData_TYPESTRING_INT8;
extern const char* ProductData_TYPESTRING_INT16;
extern const char* ProductData_TYPESTRING_INT32;
extern const char* ProductData_TYPESTRING_UINT8;
extern const char* ProductData_TYPESTRING_UINT16;
extern const char* ProductData_TYPESTRING_UINT32;
extern const char* ProductData_TYPESTRING_FLOAT32;
extern const char* ProductData_TYPESTRING_FLOAT64;
extern const char* ProductData_TYPESTRING_ASCII;
extern const char* ProductData_TYPESTRING_UTC;

/* Functions for class ProductData */

ProductData ProductData_createInstance1(int type);
ProductData ProductData_createInstance2(int type, int numElems);
ProductData ProductData_createInstance3(int type, Object data);
ProductData ProductData_createInstance5(const byte* elemsElems, int elemsLength);
ProductData ProductData_createUnsignedInstance1(const byte* elemsElems, int elemsLength);
ProductData ProductData_createInstance10(const short* elemsElems, int elemsLength);
ProductData ProductData_createUnsignedInstance3(const short* elemsElems, int elemsLength);
ProductData ProductData_createInstance8(const int* elemsElems, int elemsLength);
ProductData ProductData_createUnsignedInstance2(const int* elemsElems, int elemsLength);
ProductData ProductData_createInstance9(const long* elemsElems, int elemsLength);
ProductData ProductData_createInstance4(const char* strData);
ProductData ProductData_createInstance7(const float* elemsElems, int elemsLength);
ProductData ProductData_createInstance6(const double* elemsElems, int elemsLength);
int ProductData_getType1(ProductData _self);
int ProductData_getElemSize2(int type);
int ProductData_getElemSize1(ProductData _self);
char* ProductData_getTypeString2(int type);
int ProductData_getType2(const char* type);
char* ProductData_getTypeString1(ProductData _self);
boolean ProductData_isInt(ProductData _self);
boolean ProductData_isIntType(int type);
boolean ProductData_isSigned(ProductData _self);
boolean ProductData_isUnsigned(ProductData _self);
boolean ProductData_isUIntType(int type);
boolean ProductData_isFloatingPointType(int type);
boolean ProductData_isScalar(ProductData _self);
int ProductData_getNumElems(ProductData _self);
int ProductData_getElemInt(ProductData _self);
dlong ProductData_getElemUInt(ProductData _self);
float ProductData_getElemFloat(ProductData _self);
double ProductData_getElemDouble(ProductData _self);
char* ProductData_getElemString(ProductData _self);
boolean ProductData_getElemBoolean(ProductData _self);
int ProductData_getElemIntAt(ProductData _self, int index);
dlong ProductData_getElemUIntAt(ProductData _self, int index);
float ProductData_getElemFloatAt(ProductData _self, int index);
double ProductData_getElemDoubleAt(ProductData _self, int index);
char* ProductData_getElemStringAt(ProductData _self, int index);
boolean ProductData_getElemBooleanAt(ProductData _self, int index);
void ProductData_setElemInt(ProductData _self, int value);
void ProductData_setElemUInt(ProductData _self, dlong value);
void ProductData_setElemFloat(ProductData _self, float value);
void ProductData_setElemDouble(ProductData _self, double value);
void ProductData_setElemString(ProductData _self, const char* value);
void ProductData_setElemBoolean(ProductData _self, boolean value);
void ProductData_setElemIntAt(ProductData _self, int index, int value);
void ProductData_setElemUIntAt(ProductData _self, int index, dlong value);
void ProductData_setElemFloatAt(ProductData _self, int index, float value);
void ProductData_setElemDoubleAt(ProductData _self, int index, double value);
void ProductData_setElemStringAt(ProductData _self, int index, const char* value);
void ProductData_setElemBooleanAt(ProductData _self, int index, boolean value);
Object ProductData_getElems(ProductData _self);
void ProductData_setElems(ProductData _self, Object data);
void ProductData_readFrom4(ProductData _self, ImageInputStream input);
void ProductData_readFrom3(ProductData _self, int pos, ImageInputStream input);
void ProductData_readFrom1(ProductData _self, int startPos, int numElems, ImageInputStream input);
void ProductData_readFrom2(ProductData _self, int startPos, int numElems, ImageInputStream input, dlong inputPos);
void ProductData_writeTo4(ProductData _self, ImageOutputStream output);
void ProductData_writeTo3(ProductData _self, int pos, ImageOutputStream output);
void ProductData_writeTo1(ProductData _self, int startPos, int numElems, ImageOutputStream output);
void ProductData_writeTo2(ProductData _self, int startPos, int numElems, ImageOutputStream output, dlong outputPos);
char* ProductData_toString(ProductData _self);
int ProductData_hashCode(ProductData _self);
boolean ProductData_equals(ProductData _self, Object other);
boolean ProductData_equalElems(ProductData _self, ProductData other);
void ProductData_dispose(ProductData _self);

/* Functions for class GeoPos */

GeoPos GeoPos_newGeoPos(float lat, float lon);
float GeoPos_getLat(GeoPos _self);
float GeoPos_getLon(GeoPos _self);
void GeoPos_setLocation(GeoPos _self, float lat, float lon);
boolean GeoPos_isValid(GeoPos _self);
boolean GeoPos_areValid(const GeoPos aElems, int aLength);
void GeoPos_setInvalid(GeoPos _self);
boolean GeoPos_equals(GeoPos _self, Object obj);
int GeoPos_hashCode(GeoPos _self);
char* GeoPos_toString(GeoPos _self);
void GeoPos_normalize(GeoPos _self);
float GeoPos_normalizeLon(float lon);
char* GeoPos_getLatString(GeoPos _self);
char* GeoPos_getLonString(GeoPos _self);

/* Constants of ProductNodeGroup */
extern const char* ProductNodeGroup_PROPERTY_NAME_NAME;
extern const char* ProductNodeGroup_PROPERTY_NAME_DESCRIPTION;

/* Functions for class ProductNodeGroup */

ProductNodeGroup ProductNodeGroup_newProductNodeGroup1(const char* name);
ProductNodeGroup ProductNodeGroup_newProductNodeGroup2(ProductNode owner, const char* name, boolean takingOverNodeOwnership);
boolean ProductNodeGroup_isTakingOverNodeOwnership(ProductNodeGroup _self);
int ProductNodeGroup_getNodeCount(ProductNodeGroup _self);
T ProductNodeGroup_get1(ProductNodeGroup _self, int index);
char** ProductNodeGroup_getNodeDisplayNames(ProductNodeGroup _self, int* resultArrayLength);
char** ProductNodeGroup_getNodeNames(ProductNodeGroup _self, int* resultArrayLength);
ProductNode* ProductNodeGroup_toArray1(ProductNodeGroup _self, int* resultArrayLength);
T* ProductNodeGroup_toArray2(ProductNodeGroup _self, const T arrayElems, int arrayLength, int* resultArrayLength);
int ProductNodeGroup_indexOf2(ProductNodeGroup _self, const char* name);
int ProductNodeGroup_indexOf1(ProductNodeGroup _self, T element);
T ProductNodeGroup_getByDisplayName(ProductNodeGroup _self, const char* displayName);
T ProductNodeGroup_get2(ProductNodeGroup _self, const char* name);
boolean ProductNodeGroup_contains2(ProductNodeGroup _self, const char* name);
boolean ProductNodeGroup_contains1(ProductNodeGroup _self, T node);
boolean ProductNodeGroup_add2(ProductNodeGroup _self, T node);
void ProductNodeGroup_add1(ProductNodeGroup _self, int index, T node);
boolean ProductNodeGroup_remove(ProductNodeGroup _self, T node);
void ProductNodeGroup_removeAll(ProductNodeGroup _self);
void ProductNodeGroup_clearRemovedList(ProductNodeGroup _self);
Collection ProductNodeGroup_getRemovedNodes(ProductNodeGroup _self);
dlong ProductNodeGroup_getRawStorageSize2(ProductNodeGroup _self, ProductSubsetDef subsetDef);
void ProductNodeGroup_setModified(ProductNodeGroup _self, boolean modified);
void ProductNodeGroup_acceptVisitor(ProductNodeGroup _self, ProductVisitor visitor);
void ProductNodeGroup_dispose(ProductNodeGroup _self);
void ProductNodeGroup_updateExpression(ProductNodeGroup _self, const char* oldExternalName, const char* newExternalName);
ProductNode ProductNodeGroup_getOwner(ProductNodeGroup _self);
char* ProductNodeGroup_getName(ProductNodeGroup _self);
void ProductNodeGroup_setName(ProductNodeGroup _self, const char* name);
char* ProductNodeGroup_getDescription(ProductNodeGroup _self);
void ProductNodeGroup_setDescription(ProductNodeGroup _self, const char* description);
boolean ProductNodeGroup_isModified(ProductNodeGroup _self);
char* ProductNodeGroup_toString(ProductNodeGroup _self);
boolean ProductNodeGroup_isValidNodeName(const char* name);
Product ProductNodeGroup_getProduct(ProductNodeGroup _self);
ProductReader ProductNodeGroup_getProductReader(ProductNodeGroup _self);
ProductWriter ProductNodeGroup_getProductWriter(ProductNodeGroup _self);
char* ProductNodeGroup_getDisplayName(ProductNodeGroup _self);
char* ProductNodeGroup_getProductRefString(ProductNodeGroup _self);
dlong ProductNodeGroup_getRawStorageSize1(ProductNodeGroup _self);
void ProductNodeGroup_fireProductNodeChanged1(ProductNodeGroup _self, const char* propertyName);
void ProductNodeGroup_fireProductNodeChanged2(ProductNodeGroup _self, const char* propertyName, Object oldValue, Object newValue);
void ProductNodeGroup_removeFromFile(ProductNodeGroup _self, ProductWriter productWriter);

/* Functions for class ProductUtils */

ProductUtils ProductUtils_newProductUtils();
ImageInfo ProductUtils_createImageInfo(const RasterDataNode rastersElems, int rastersLength, boolean assignMissingImageInfos, ProgressMonitor pm);
BufferedImage ProductUtils_createRgbImage(const RasterDataNode rastersElems, int rastersLength, ImageInfo imageInfo, ProgressMonitor pm);
BufferedImage ProductUtils_createColorIndexedImage(RasterDataNode rasterDataNode, ProgressMonitor pm);
MapInfo ProductUtils_createSuitableMapInfo1(Product product, Rectangle rect, MapProjection mapProjection);
MapInfo ProductUtils_createSuitableMapInfo2(Product product, MapProjection mapProjection, double orientation, double noDataValue);
Dimension ProductUtils_getOutputRasterSize(Product product, Rectangle rect, MapTransform mapTransform, double pixelSizeX, double pixelSizeY);
Point2D* ProductUtils_createMapEnvelope2(Product product, Rectangle rect, MapTransform mapTransform, int* resultArrayLength);
Point2D* ProductUtils_createMapEnvelope1(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
Point2D* ProductUtils_getMinMax(const Point2D boundaryElems, int boundaryLength, int* resultArrayLength);
Point2D* ProductUtils_createMapBoundary(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
GeoPos* ProductUtils_createGeoBoundary1(Product product, int step, int* resultArrayLength);
GeoPos* ProductUtils_createGeoBoundary2(Product product, Rectangle region, int step, int* resultArrayLength);
GeoPos* ProductUtils_createGeoBoundary3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
GeoPos* ProductUtils_createGeoBoundary4(RasterDataNode raster, Rectangle region, int step, int* resultArrayLength);
GeneralPath* ProductUtils_createGeoBoundaryPaths1(Product product, int* resultArrayLength);
GeneralPath* ProductUtils_createGeoBoundaryPaths2(Product product, Rectangle region, int step, int* resultArrayLength);
GeneralPath* ProductUtils_createGeoBoundaryPaths3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
PixelPos* ProductUtils_createPixelBoundary1(Product product, Rectangle rect, int step, int* resultArrayLength);
PixelPos* ProductUtils_createPixelBoundary2(Product product, Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
PixelPos* ProductUtils_createPixelBoundary3(RasterDataNode raster, Rectangle rect, int step, int* resultArrayLength);
PixelPos* ProductUtils_createRectBoundary1(Rectangle rect, int step, int* resultArrayLength);
PixelPos* ProductUtils_createRectBoundary2(Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
void ProductUtils_copyFlagCodings(Product source, Product target);
FlagCoding ProductUtils_copyFlagCoding(FlagCoding sourceFlagCoding, Product target);
IndexCoding ProductUtils_copyIndexCoding(IndexCoding sourceIndexCoding, Product target);
void ProductUtils_copyMasks(Product sourceProduct, Product targetProduct);
void ProductUtils_copyOverlayMasks(Product sourceProduct, Product targetProduct);
void ProductUtils_copyFlagBands(Product sourceProduct, Product targetProduct, boolean copySourceImage);
TiePointGrid ProductUtils_copyTiePointGrid(const char* gridName, Product sourceProduct, Product targetProduct);
Band ProductUtils_copyBand2(const char* sourceBandName, Product sourceProduct, Product targetProduct, boolean copySourceImage);
Band ProductUtils_copyBand1(const char* sourceBandName, Product sourceProduct, const char* targetBandName, Product targetProduct, boolean copySourceImage);
void ProductUtils_copyRasterDataNodeProperties(RasterDataNode sourceRaster, RasterDataNode targetRaster);
void ProductUtils_copySpectralBandProperties(Band sourceBand, Band targetBand);
void ProductUtils_copyGeoCoding(Product sourceProduct, Product targetProduct);
void ProductUtils_copyTiePointGrids(Product sourceProduct, Product targetProduct);
void ProductUtils_copyVectorData(Product sourceProduct, Product targetProduct);
boolean ProductUtils_canGetPixelPos1(Product product);
boolean ProductUtils_canGetPixelPos2(RasterDataNode raster);
BufferedImage ProductUtils_createDensityPlotImage(RasterDataNode raster1, float sampleMin1, float sampleMax1, RasterDataNode raster2, float sampleMin2, float sampleMax2, Mask roiMask, int width, int height, Color background, BufferedImage image, ProgressMonitor pm);
BufferedImage ProductUtils_overlayMasks(RasterDataNode raster, BufferedImage overlayBIm, ProgressMonitor pm);
GeoPos ProductUtils_getCenterGeoPos(Product product);
int ProductUtils_normalizeGeoPolygon(const GeoPos polygonElems, int polygonLength);
int ProductUtils_normalizeGeoPolygon_old(const GeoPos polygonElems, int polygonLength);
void ProductUtils_denormalizeGeoPolygon(const GeoPos polygonElems, int polygonLength);
void ProductUtils_denormalizeGeoPos(GeoPos geoPos);
void ProductUtils_denormalizeGeoPos_old(GeoPos geoPos);
int ProductUtils_getRotationDirection(const GeoPos polygonElems, int polygonLength);
double ProductUtils_getAngleSum(const GeoPos polygonElems, int polygonLength);
GeneralPath ProductUtils_convertToPixelPath(GeneralPath geoPath, GeoCoding geoCoding);
GeneralPath ProductUtils_convertToGeoPath(Shape shape, GeoCoding geoCoding);
void ProductUtils_copyMetadata2(Product source, Product target);
void ProductUtils_copyMetadata1(MetadataElement source, MetadataElement target);
void ProductUtils_copyPreferredTileSize(Product sourceProduct, Product targetProduct);
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata2(Product product);
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata1(GeoCoding geoCoding, int width, int height);
GeneralPath ProductUtils_areaToPath(Area negativeArea, double deltaX);
void ProductUtils_addElementToHistory(Product product, MetadataElement elem);
char** ProductUtils_removeInvalidExpressions(Product product, int* resultArrayLength);
char* ProductUtils_findSuitableQuicklookBandName(Product product);
PixelPos* ProductUtils_computeSourcePixelCoordinates(GeoCoding sourceGeoCoding, int sourceWidth, int sourceHeight, GeoCoding destGeoCoding, Rectangle destArea, int* resultArrayLength);
float* ProductUtils_computeMinMaxY(const PixelPos pixelPositionsElems, int pixelPositionsLength, int* resultArrayLength);
void ProductUtils_copyBandsForGeomTransform1(Product sourceProduct, Product targetProduct, double defaultNoDataValue, Map addedRasterDataNodes);
void ProductUtils_copyBandsForGeomTransform2(Product sourceProduct, Product targetProduct, boolean includeTiePointGrids, double defaultNoDataValue, Map targetToSourceMap);
ProductData_UTC ProductUtils_getScanLineTime(Product product, double y);
double ProductUtils_getGeophysicalSampleDouble(Band band, int pixelX, int pixelY, int level);
dlong ProductUtils_getGeophysicalSampleLong(Band band, int pixelX, int pixelY, int level);

/* Constants of MetadataAttribute */
extern const char* MetadataAttribute_PROPERTY_NAME_DATA;
extern const char* MetadataAttribute_PROPERTY_NAME_READ_ONLY;
extern const char* MetadataAttribute_PROPERTY_NAME_SYNTHETIC;
extern const char* MetadataAttribute_PROPERTY_NAME_UNIT;
extern const char* MetadataAttribute_PROPERTY_NAME_NAME;
extern const char* MetadataAttribute_PROPERTY_NAME_DESCRIPTION;

/* Functions for class MetadataAttribute */

MetadataAttribute MetadataAttribute_newMetadataAttribute(const char* name, ProductData data, boolean readOnly);
MetadataElement MetadataAttribute_getParentElement(MetadataAttribute _self);
boolean MetadataAttribute_equals(MetadataAttribute _self, Object object);
void MetadataAttribute_acceptVisitor(MetadataAttribute _self, ProductVisitor visitor);
MetadataAttribute MetadataAttribute_createDeepClone(MetadataAttribute _self);
int MetadataAttribute_getDataType(MetadataAttribute _self);
boolean MetadataAttribute_isFloatingPointType(MetadataAttribute _self);
dlong MetadataAttribute_getNumDataElems(MetadataAttribute _self);
void MetadataAttribute_setData(MetadataAttribute _self, ProductData data);
ProductData MetadataAttribute_getData(MetadataAttribute _self);
void MetadataAttribute_setDataElems(MetadataAttribute _self, Object elems);
Object MetadataAttribute_getDataElems(MetadataAttribute _self);
int MetadataAttribute_getDataElemSize(MetadataAttribute _self);
void MetadataAttribute_setReadOnly(MetadataAttribute _self, boolean readOnly);
boolean MetadataAttribute_isReadOnly(MetadataAttribute _self);
void MetadataAttribute_setUnit(MetadataAttribute _self, const char* unit);
char* MetadataAttribute_getUnit(MetadataAttribute _self);
void MetadataAttribute_fireProductNodeDataChanged(MetadataAttribute _self);
void MetadataAttribute_dispose(MetadataAttribute _self);
ProductData MetadataAttribute_createCompatibleProductData(MetadataAttribute _self, int numElems);
ProductNode MetadataAttribute_getOwner(MetadataAttribute _self);
char* MetadataAttribute_getName(MetadataAttribute _self);
void MetadataAttribute_setName(MetadataAttribute _self, const char* name);
char* MetadataAttribute_getDescription(MetadataAttribute _self);
void MetadataAttribute_setDescription(MetadataAttribute _self, const char* description);
boolean MetadataAttribute_isModified(MetadataAttribute _self);
void MetadataAttribute_setModified(MetadataAttribute _self, boolean modified);
char* MetadataAttribute_toString(MetadataAttribute _self);
boolean MetadataAttribute_isValidNodeName(const char* name);
Product MetadataAttribute_getProduct(MetadataAttribute _self);
ProductReader MetadataAttribute_getProductReader(MetadataAttribute _self);
ProductWriter MetadataAttribute_getProductWriter(MetadataAttribute _self);
char* MetadataAttribute_getDisplayName(MetadataAttribute _self);
char* MetadataAttribute_getProductRefString(MetadataAttribute _self);
void MetadataAttribute_updateExpression(MetadataAttribute _self, const char* oldExternalName, const char* newExternalName);
void MetadataAttribute_removeFromFile(MetadataAttribute _self, ProductWriter productWriter);

/*
 * DO NOT EDIT THIS FILE, IT IS MACHINE-GENERATED
 * File created at Sun Nov 04 17:03:58 CET 2012 using org.esa.beam.extapi.gen.GeneratorDoclet
 */


typedef char byte;
typedef unsigned char boolean;
typedef long long dlong;


/* Java VM functions that must be used if this module is used in stand-alone mode (= not loaded as shared library by a Java VM) */

boolean beam_is_jvm_created();
boolean beam_create_jvm(const char* option_strings[], int option_count);
boolean beam_create_jvm_with_defaults();
boolean beam_destroy_jvm();


/* Wrapped API classes */
typedef jobject GeoCoding;
typedef jobject OperatorException;
typedef jobject ProductWriter;
typedef jobject GPF;
typedef jobject IndexCoding;
typedef jobject PixelPos;
typedef jobject ProductIO;
typedef jobject SampleCoding;
typedef jobject Placemark;
typedef jobject MetadataElement;
typedef jobject Product;
typedef jobject ColorPaletteDef;
typedef jobject ImageInfo;
typedef jobject Tile_Pos;
typedef jobject ProductManager;
typedef jobject OperatorSpiRegistry;
typedef jobject ImageGeometry;
typedef jobject Band;
typedef jobject PlacemarkGroup;
typedef jobject ColorPaletteDef_Point;
typedef jobject TiePointGrid;
typedef jobject VectorDataNode;
typedef jobject OperatorSpi;
typedef jobject RasterDataNode;
typedef jobject AngularDirection;
typedef jobject FlagCoding;
typedef jobject ProductReader;
typedef jobject RGBChannelDef;
typedef jobject Tile;
typedef jobject ProductData;
typedef jobject GeoPos;
typedef jobject ProductNodeGroup;
typedef jobject Operator;
typedef jobject ProductUtils;
typedef jobject MetadataAttribute;


/* Non-API classes used in the API */
typedef jobject StackTraceElement;
typedef jobject ProductManager_Listener;
typedef jobject Shape;
typedef jobject MapTransform;
typedef jobject Parser;
typedef jobject ImageInfo_HistogramMatching;
typedef jobject AffineTransform;
typedef jobject Mask;
typedef jobject PrintWriter;
typedef jobject Double;
typedef jobject Term;
typedef jobject Throwable;
typedef jobject Class;
typedef jobject ServiceRegistry;
typedef jobject FeatureCollection;
typedef jobject ProductNode;
typedef jobject Rectangle;
typedef jobject Dimension;
typedef jobject Stx;
typedef jobject ImageOutputStream;
typedef jobject SimpleFeatureType;
typedef jobject ProductData_UTC;
typedef jobject Object;
typedef jobject ReferencedEnvelope;
typedef jobject Integer;
typedef jobject ProductReaderPlugIn;
typedef jobject RenderedImage;
typedef jobject IndexValidator;
typedef jobject Area;
typedef jobject Iterator;
typedef jobject ComponentColorModel;
typedef jobject MathTransform;
typedef jobject CoordinateReferenceSystem;
typedef jobject ProductWriterPlugIn;
typedef jobject File;
typedef jobject MapProjection;
typedef jobject E;
typedef jobject IndexColorModel;
typedef jobject ProductNodeListener;
typedef jobject Map;
typedef jobject Pointing;
typedef jobject Color;
typedef jobject Product_AutoGrouping;
typedef jobject PlacemarkDescriptor;
typedef jobject PointingFactory;
typedef jobject PrintStream;
typedef jobject TransectProfileData;
typedef jobject Point2D;
typedef jobject ProductVisitor;
typedef jobject T;
typedef jobject Scaling;
typedef jobject WritableNamespace;
typedef jobject MultiLevelImage;
typedef jobject ROI;
typedef jobject Collection;
typedef jobject GeoTIFFMetadata;
typedef jobject MapInfo;
typedef jobject Histogram;
typedef jobject BufferedImage;
typedef jobject SimpleFeature;
typedef jobject ProductSubsetDef;
typedef jobject BorderExtender;
typedef jobject Logger;
typedef jobject ProgressMonitor;
typedef jobject Mask_ImageType;
typedef jobject GeneralPath;
typedef jobject ImageInputStream;
typedef jobject RenderingHints;


/* Functions for class GeoCoding */

/**
 * Checks whether or not the longitudes of this geo-coding cross the +/- 180 degree meridian.
 */
boolean GeoCoding_isCrossingMeridianAt180(GeoCoding _self);
/**
 * Checks whether or not this geo-coding can determine the pixel position from a geodetic position.
 */
boolean GeoCoding_canGetPixelPos(GeoCoding _self);
/**
 * Checks whether or not this geo-coding can determine the geodetic position from a pixel position.
 */
boolean GeoCoding_canGetGeoPos(GeoCoding _self);
/**
 * Returns the pixel co-ordinates as x/y for a given geographical position given as lat/lon.
 */
PixelPos GeoCoding_getPixelPos(GeoCoding _self, GeoPos geoPos, PixelPos pixelPos);
/**
 * Returns the latitude and longitude value for a given pixel co-ordinate.
 */
GeoPos GeoCoding_getGeoPos(GeoCoding _self, PixelPos pixelPos, GeoPos geoPos);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 */
void GeoCoding_dispose(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getImageCRS(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getMapCRS(GeoCoding _self);
/**
 * 
 */
CoordinateReferenceSystem GeoCoding_getGeoCRS(GeoCoding _self);
/**
 * 
 */
MathTransform GeoCoding_getImageToMapTransform(GeoCoding _self);

/* Functions for class OperatorException */

/**
 * Constructs a new exception with the specified detail message.
 */
OperatorException OperatorException_newOperatorException1(const char* message);
/**
 * Constructs a new exception with the specified detail message and cause.
 */
OperatorException OperatorException_newOperatorException2(const char* message, Throwable cause);
/**
 * Constructs a new exception by delegating to
 {@link #OperatorException(String,Throwable) this(cause.getMessage(), cause)}.
 */
OperatorException OperatorException_newOperatorException3(Throwable cause);
/**
 * 
 */
char* OperatorException_getMessage(OperatorException _self);
/**
 * 
 */
char* OperatorException_getLocalizedMessage(OperatorException _self);
/**
 * 
 */
Throwable OperatorException_getCause(OperatorException _self);
/**
 * 
 */
Throwable OperatorException_initCause(OperatorException _self, Throwable arg0);
/**
 * 
 */
char* OperatorException_toString(OperatorException _self);
/**
 * 
 */
void OperatorException_printStackTrace1(OperatorException _self);
/**
 * 
 */
void OperatorException_printStackTrace2(OperatorException _self, PrintStream arg0);
/**
 * 
 */
void OperatorException_printStackTrace3(OperatorException _self, PrintWriter arg0);
/**
 * 
 */
Throwable OperatorException_fillInStackTrace(OperatorException _self);
/**
 * 
 */
StackTraceElement* OperatorException_getStackTrace(OperatorException _self, int* resultArrayLength);
/**
 * 
 */
void OperatorException_setStackTrace(OperatorException _self, const StackTraceElement* arg0Elems, int arg0Length);
/**
 * 
 */
void OperatorException_addSuppressed(OperatorException _self, Throwable arg0);
/**
 * 
 */
Throwable* OperatorException_getSuppressed(OperatorException _self, int* resultArrayLength);

/* Functions for class ProductWriter */

/**
 * Returns the plug-in which created this product writer.
 */
ProductWriterPlugIn ProductWriter_getWriterPlugIn(ProductWriter _self);
/**
 * Retrives the current output destination object. Thie return value might be <code>null</code> if the
 <code>setOutput</code> has not been called so far.
 */
Object ProductWriter_getOutput(ProductWriter _self);
/**
 * Writes the in-memory representation of a data product.
 <p/>
 <p> Whether the band data - the actual pixel values - is written out immediately or later when pixels are
 flushed, is up to the implementation.
 */
void ProductWriter_writeProductNodes(ProductWriter _self, Product product, Object output);
/**
 * Writes raster data from the given in-memory source buffer into the data sink specified by the given source band
 and region.
 <p/>
 <h3>Source band</h3> The source band is used to identify the data sink in which this method transfers the sample
 values given in the source buffer. The method does not modify the pixel data of the given source band at all.
 <p/>
 <h3>Source buffer</h3> The first element of the source buffer corresponds to the given <code>sourceOffsetX</code>
 and <code>sourceOffsetY</code> of the source region. These parameters are an offset within the band's raster data
 and <b>not</b> an offset within the source buffer.<br> The number of elements in the buffer must be exactly be
 <code>sourceWidth * sourceHeight</code>. The pixel values to be writte are considered to be stored in
 line-by-line order, so the raster X co-ordinate varies faster than the Y.
 <p/>
 <h3>Source region</h3> The given destination region specified by the <code>sourceOffsetX</code>,
 <code>sourceOffsetY</code>, <code>sourceWidth</code> and <code>sourceHeight</code> parameters is given in the
 source band's raster co-ordinates. These co-ordinates are identical with the destination raster co-ordinates
 since product writers do not support spectral or spatial subsets.
 */
void ProductWriter_writeBandRasterData(ProductWriter _self, Band sourceBand, int sourceOffsetX, int sourceOffsetY, int sourceWidth, int sourceHeight, ProductData sourceBuffer, ProgressMonitor pm);
/**
 * Writes all data in memory to the data sink(s) associated with this writer.
 */
void ProductWriter_flush(ProductWriter _self);
/**
 * Closes all output streams currently open. A concrete implementation should call <code>flush</code> before
 performing the actual close-operation.
 */
void ProductWriter_close(ProductWriter _self);
/**
 * Returns wether the given product node is to be written.
 */
boolean ProductWriter_shouldWrite(ProductWriter _self, ProductNode node);
/**
 * Returns whether this product writer writes only modified product nodes.
 */
boolean ProductWriter_isIncrementalMode(ProductWriter _self);
/**
 * Enables resp. disables incremental writing of this product writer. By default, a reader should enable progress
 listening.
 */
void ProductWriter_setIncrementalMode(ProductWriter _self, boolean enabled);
/**
 * Complete deletes the physical representation of the given product from the file system.
 */
void ProductWriter_deleteOutput(ProductWriter _self);
/**
 * Physically deletes a <code>Band</code> in a product writer's output.
 */
void ProductWriter_removeBand(ProductWriter _self, Band band);

/* Functions for class GPF */

/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct1(const char* operatorName, Map parameters);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct2(const char* operatorName, Map parameters, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct3(const char* operatorName, Map parameters, Product sourceProduct);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct4(const char* operatorName, Map parameters, Product sourceProduct, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct5(const char* operatorName, Map parameters, const Product* sourceProductsElems, int sourceProductsLength);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct6(const char* operatorName, Map parameters, const Product* sourceProductsElems, int sourceProductsLength, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct7(const char* operatorName, Map parameters, Map sourceProducts);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 */
Product GPF_createProduct8(const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Creates a product by using the operator specified by the given name.
 The resulting product can be used as input product for a further call to {@code createProduct()}.
 By concatenating multiple calls it is possible to set up a processing graph.
 <p>All static {@code createProduct} methods delegate to this non-static (= NS) version.
 It can be overriden by clients in order to alter product creation behaviour of the static
 {@code createProduct} methods of the current GPF instance.</p>
 */
Product GPF_createProductNS(GPF _self, const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Creates an operator instance by using the given operator (alias) name.
 */
Operator GPF_createOperator(GPF _self, const char* operatorName, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Gets the registry for operator SPIs.
 */
OperatorSpiRegistry GPF_getOperatorSpiRegistry(GPF _self);
/**
 * Sets the registry for operator SPIs.
 */
void GPF_setOperatorSpiRegistry(GPF _self, OperatorSpiRegistry spiRegistry);
/**
 * Gets the default GPF instance.
 */
GPF GPF_getDefaultInstance();
/**
 * Sets the default GPF instance.
 */
void GPF_setDefaultInstance(GPF defaultInstance);

/* Functions for class IndexCoding */

/**
 * Constructs a new index coding object with the given name.
 */
IndexCoding IndexCoding_newIndexCoding(const char* name);
/**
 * Returns a metadata attribute wich is the representation of the index with the given name. This method delegates to
 getPropertyValue(String).
 */
MetadataAttribute IndexCoding_getIndex(IndexCoding _self, const char* name);
/**
 * Returns a string array which contains the names of all indexes contained in this <code>IndexCoding</code> object.
 */
char** IndexCoding_getIndexNames(IndexCoding _self, int* resultArrayLength);
/**
 * Adds a new index definition to this flags coding.
 */
MetadataAttribute IndexCoding_addIndex(IndexCoding _self, const char* name, int value, const char* description);
/**
 * Returns the flag mask value for the specified flag name.
 */
int IndexCoding_getIndexValue(IndexCoding _self, const char* name);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void IndexCoding_acceptVisitor(IndexCoding _self, ProductVisitor visitor);
/**
 * Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.
 */
void IndexCoding_addElement(IndexCoding _self, MetadataElement element);
/**
 * Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.
 */
void IndexCoding_addAttribute(IndexCoding _self, MetadataAttribute attribute);
/**
 * Adds a new coding value to this sample coding.
 */
MetadataAttribute IndexCoding_addSample(IndexCoding _self, const char* name, int value, const char* description);
/**
 * Gets the number of coded sample values.
 */
int IndexCoding_getSampleCount(IndexCoding _self);
/**
 * Gets the sample name at the specified attribute index.
 */
char* IndexCoding_getSampleName(IndexCoding _self, int index);
/**
 * Gets the sample value at the specified attribute index.
 */
int IndexCoding_getSampleValue(IndexCoding _self, int index);
/**
 * Gets the group of child elements. The method returns null, if this element has no children.
 */
ProductNodeGroup IndexCoding_getElementGroup(IndexCoding _self);
/**
 * 
 */
MetadataElement IndexCoding_getParentElement(IndexCoding _self);
/**
 * Adds the given element to this element at index.
 */
void IndexCoding_addElementAt(IndexCoding _self, MetadataElement element, int index);
/**
 * Removes the given element from this element.
 */
boolean IndexCoding_removeElement(IndexCoding _self, MetadataElement element);
/**
 * 
 */
int IndexCoding_getNumElements(IndexCoding _self);
/**
 * Returns the element at the given index.
 */
MetadataElement IndexCoding_getElementAt(IndexCoding _self, int index);
/**
 * Returns a string array containing the names of the groups contained in this element
 */
char** IndexCoding_getElementNames(IndexCoding _self, int* resultArrayLength);
/**
 * Returns an array of elements contained in this element.
 */
MetadataElement* IndexCoding_getElements(IndexCoding _self, int* resultArrayLength);
/**
 * Returns the element with the given name.
 */
MetadataElement IndexCoding_getElement(IndexCoding _self, const char* name);
/**
 * Tests if a element with the given name is contained in this element.
 */
boolean IndexCoding_containsElement(IndexCoding _self, const char* name);
/**
 * Gets the index of the given element.
 */
int IndexCoding_getElementIndex(IndexCoding _self, MetadataElement element);
/**
 * Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.
 */
boolean IndexCoding_removeAttribute(IndexCoding _self, MetadataAttribute attribute);
/**
 * Returns the number of attributes attaached to this node.
 */
int IndexCoding_getNumAttributes(IndexCoding _self);
/**
 * Returns the attribute at the given index.
 */
MetadataAttribute IndexCoding_getAttributeAt(IndexCoding _self, int index);
/**
 * Returns the names of all attributes of this node.
 */
char** IndexCoding_getAttributeNames(IndexCoding _self, int* resultArrayLength);
/**
 * Returns an array of attributes contained in this element.
 */
MetadataAttribute* IndexCoding_getAttributes(IndexCoding _self, int* resultArrayLength);
/**
 * Returns the attribute with the given name.
 */
MetadataAttribute IndexCoding_getAttribute(IndexCoding _self, const char* name);
/**
 * Checks whether this node has an element with the given name.
 */
boolean IndexCoding_containsAttribute(IndexCoding _self, const char* name);
/**
 * Gets the index of the given attribute.
 */
int IndexCoding_getAttributeIndex(IndexCoding _self, MetadataAttribute attribute);
/**
 * Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
double IndexCoding_getAttributeDouble1(IndexCoding _self, const char* name, double defaultValue);
/**
 * Returns the double value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
double IndexCoding_getAttributeDouble2(IndexCoding _self, const char* name);
/**
 * Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
ProductData_UTC IndexCoding_getAttributeUTC1(IndexCoding _self, const char* name, ProductData_UTC defaultValue);
/**
 * Returns the UTC value of the attribute with the given name.
 */
ProductData_UTC IndexCoding_getAttributeUTC2(IndexCoding _self, const char* name);
/**
 * Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
int IndexCoding_getAttributeInt1(IndexCoding _self, const char* name, int defaultValue);
/**
 * Returns the integer value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
int IndexCoding_getAttributeInt2(IndexCoding _self, const char* name);
/**
 * Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void IndexCoding_setAttributeInt(IndexCoding _self, const char* name, int value);
/**
 * Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void IndexCoding_setAttributeDouble(IndexCoding _self, const char* name, double value);
/**
 * Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void IndexCoding_setAttributeUTC(IndexCoding _self, const char* name, ProductData_UTC value);
/**
 * Returns the string value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
char* IndexCoding_getAttributeString1(IndexCoding _self, const char* name);
/**
 * Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
char* IndexCoding_getAttributeString2(IndexCoding _self, const char* name, const char* defaultValue);
/**
 * Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void IndexCoding_setAttributeString(IndexCoding _self, const char* name, const char* value);
/**
 * 
 */
void IndexCoding_setModified(IndexCoding _self, boolean modified);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong IndexCoding_getRawStorageSize1(IndexCoding _self, ProductSubsetDef subsetDef);
/**
 * 
 */
MetadataElement IndexCoding_createDeepClone(IndexCoding _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void IndexCoding_dispose(IndexCoding _self);
/**
 * 
 */
ProductNode IndexCoding_getOwner(IndexCoding _self);
/**
 * 
 */
char* IndexCoding_getName(IndexCoding _self);
/**
 * Sets this product's name.
 */
void IndexCoding_setName(IndexCoding _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* IndexCoding_getDescription(IndexCoding _self);
/**
 * Sets a short textual description for this products node.
 */
void IndexCoding_setDescription(IndexCoding _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean IndexCoding_isModified(IndexCoding _self);
/**
 * 
 */
char* IndexCoding_toString(IndexCoding _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean IndexCoding_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product IndexCoding_getProduct(IndexCoding _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader IndexCoding_getProductReader(IndexCoding _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter IndexCoding_getProductWriter(IndexCoding _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* IndexCoding_getDisplayName(IndexCoding _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* IndexCoding_getProductRefString(IndexCoding _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong IndexCoding_getRawStorageSize2(IndexCoding _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void IndexCoding_updateExpression(IndexCoding _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void IndexCoding_fireProductNodeChanged1(IndexCoding _self, const char* propertyName);
/**
 * 
 */
void IndexCoding_fireProductNodeChanged2(IndexCoding _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void IndexCoding_removeFromFile(IndexCoding _self, ProductWriter productWriter);
/**
 * 
 */
E IndexCoding_getExtension(IndexCoding _self, Class arg0);

/* Functions for class PixelPos */

/**
 * Constructs and initializes a <code>PixelPos</code> with coordinate (0,&nbsp;0).
 */
PixelPos PixelPos_newPixelPos1();
/**
 * Constructs and initializes a <code>PixelPos</code> with the specified coordinate.
 */
PixelPos PixelPos_newPixelPos2(float x, float y);
/**
 * Tests whether or not this pixel position is valid.
 */
boolean PixelPos_isValid(PixelPos _self);
/**
 * Sets this pixel position so that is becomes invalid.
 */
void PixelPos_setInvalid(PixelPos _self);
/**
 * 
 */
double PixelPos_getX(PixelPos _self);
/**
 * 
 */
double PixelPos_getY(PixelPos _self);
/**
 * 
 */
void PixelPos_setLocation1(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
void PixelPos_setLocation2(PixelPos _self, float arg0, float arg1);
/**
 * 
 */
char* PixelPos_toString(PixelPos _self);
/**
 * 
 */
void PixelPos_setLocation3(PixelPos _self, Point2D arg0);
/**
 * 
 */
double PixelPos_distanceSq1(double arg0, double arg1, double arg2, double arg3);
/**
 * 
 */
double PixelPos_distance1(double arg0, double arg1, double arg2, double arg3);
/**
 * 
 */
double PixelPos_distanceSq2(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
double PixelPos_distanceSq3(PixelPos _self, Point2D arg0);
/**
 * 
 */
double PixelPos_distance2(PixelPos _self, double arg0, double arg1);
/**
 * 
 */
double PixelPos_distance3(PixelPos _self, Point2D arg0);
/**
 * 
 */
Object PixelPos_clone(PixelPos _self);
/**
 * 
 */
int PixelPos_hashCode(PixelPos _self);
/**
 * 
 */
boolean PixelPos_equals(PixelPos _self, Object arg0);

/* Functions for class ProductIO */

/**
 * Gets a product reader for the given format name.
 */
ProductReader ProductIO_getProductReader(const char* formatName);
/**
 * Gets an array of writer product file extensions for the given format name.
 */
char** ProductIO_getProductWriterExtensions(const char* formatName, int* resultArrayLength);
/**
 * Gets a product writer for the given format name.
 */
ProductWriter ProductIO_getProductWriter(const char* formatName);
/**
 * Reads the data product specified by the given file.
 <p>The returned product will be associated with a reader capable of decoding the file (also
 see {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).
 If more than one appropriate reader exists in the registry, the returned product will be
 associated with the reader which is the most preferred according to the product format names
 supplied as last argument. If no reader capable of decoding the file is capable of handling
 any of these product formats, the returned product will be associated with the first reader
 found in the registry which is capable of decoding the file.</p>
 <p/>
 <p>The method does not automatically load band raster data, so
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct1(File file, const char** formatNamesElems, int formatNamesLength);
/**
 * Reads the data product specified by the given file path.
 <p>The product returned will be associated with the reader appropriate for the given
 file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>
 <p>The method does not automatically read band data, thus
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct2(const char* filePath);
/**
 * Reads the data product specified by the given file.
 <p>The product returned will be associated with the reader appropriate for the given
 file format (see also {@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader}).</p>
 <p>The method does not automatically read band data, thus
 {@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} will always be null
 for all bands in the product returned by this method.</p>
 */
Product ProductIO_readProduct3(File file);
/**
 * Tries to find a product reader instance suitable for the given input.
 The method returns {@code null}, if no
 registered product reader can handle the given {@code input} value.
 <p/>
 The {@code input} may be of any type, but most likely it will be a file path given by a {@code String} or
 {@code File} value. Some readers may also directly support an {@link javax.imageio.stream.ImageInputStream} object.
 */
ProductReader ProductIO_getProductReaderForInput(Object input);
/**
 * Writes a product with the specified format to the given file path.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct1(Product product, const char* filePath, const char* formatName);
/**
 * Writes a product with the specified format to the given file path.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct2(Product product, const char* filePath, const char* formatName, ProgressMonitor pm);
/**
 * Writes a product with the specified format to the given file.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct3(Product product, File file, const char* formatName, boolean incremental);
/**
 * Writes a product with the specified format to the given file.
 <p>The method also writes all band data to the file. Therefore the band data must either
 <ld>
 <li>be completely loaded ({@link org.esa.beam.framework.datamodel.Band#getRasterData() Band.rasterData} is not null)</li>
 <li>or the product must be associated with a product reader ({@link org.esa.beam.framework.datamodel.Product#getProductReader() Product.productReader} is not null) so that unloaded data can be reloaded.</li>
 </ld>.
 */
void ProductIO_writeProduct4(Product product, File file, const char* formatName, boolean incremental, ProgressMonitor pm);

/* Functions for class SampleCoding */

/**
 * 
 */
SampleCoding SampleCoding_newSampleCoding(const char* name);
/**
 * Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.
 */
void SampleCoding_addElement(SampleCoding _self, MetadataElement element);
/**
 * Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.
 */
void SampleCoding_addAttribute(SampleCoding _self, MetadataAttribute attribute);
/**
 * Adds a new coding value to this sample coding.
 */
MetadataAttribute SampleCoding_addSample(SampleCoding _self, const char* name, int value, const char* description);
/**
 * Gets the number of coded sample values.
 */
int SampleCoding_getSampleCount(SampleCoding _self);
/**
 * Gets the sample name at the specified attribute index.
 */
char* SampleCoding_getSampleName(SampleCoding _self, int index);
/**
 * Gets the sample value at the specified attribute index.
 */
int SampleCoding_getSampleValue(SampleCoding _self, int index);
/**
 * Gets the group of child elements. The method returns null, if this element has no children.
 */
ProductNodeGroup SampleCoding_getElementGroup(SampleCoding _self);
/**
 * 
 */
MetadataElement SampleCoding_getParentElement(SampleCoding _self);
/**
 * Adds the given element to this element at index.
 */
void SampleCoding_addElementAt(SampleCoding _self, MetadataElement element, int index);
/**
 * Removes the given element from this element.
 */
boolean SampleCoding_removeElement(SampleCoding _self, MetadataElement element);
/**
 * 
 */
int SampleCoding_getNumElements(SampleCoding _self);
/**
 * Returns the element at the given index.
 */
MetadataElement SampleCoding_getElementAt(SampleCoding _self, int index);
/**
 * Returns a string array containing the names of the groups contained in this element
 */
char** SampleCoding_getElementNames(SampleCoding _self, int* resultArrayLength);
/**
 * Returns an array of elements contained in this element.
 */
MetadataElement* SampleCoding_getElements(SampleCoding _self, int* resultArrayLength);
/**
 * Returns the element with the given name.
 */
MetadataElement SampleCoding_getElement(SampleCoding _self, const char* name);
/**
 * Tests if a element with the given name is contained in this element.
 */
boolean SampleCoding_containsElement(SampleCoding _self, const char* name);
/**
 * Gets the index of the given element.
 */
int SampleCoding_getElementIndex(SampleCoding _self, MetadataElement element);
/**
 * Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.
 */
boolean SampleCoding_removeAttribute(SampleCoding _self, MetadataAttribute attribute);
/**
 * Returns the number of attributes attaached to this node.
 */
int SampleCoding_getNumAttributes(SampleCoding _self);
/**
 * Returns the attribute at the given index.
 */
MetadataAttribute SampleCoding_getAttributeAt(SampleCoding _self, int index);
/**
 * Returns the names of all attributes of this node.
 */
char** SampleCoding_getAttributeNames(SampleCoding _self, int* resultArrayLength);
/**
 * Returns an array of attributes contained in this element.
 */
MetadataAttribute* SampleCoding_getAttributes(SampleCoding _self, int* resultArrayLength);
/**
 * Returns the attribute with the given name.
 */
MetadataAttribute SampleCoding_getAttribute(SampleCoding _self, const char* name);
/**
 * Checks whether this node has an element with the given name.
 */
boolean SampleCoding_containsAttribute(SampleCoding _self, const char* name);
/**
 * Gets the index of the given attribute.
 */
int SampleCoding_getAttributeIndex(SampleCoding _self, MetadataAttribute attribute);
/**
 * Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
double SampleCoding_getAttributeDouble1(SampleCoding _self, const char* name, double defaultValue);
/**
 * Returns the double value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
double SampleCoding_getAttributeDouble2(SampleCoding _self, const char* name);
/**
 * Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
ProductData_UTC SampleCoding_getAttributeUTC1(SampleCoding _self, const char* name, ProductData_UTC defaultValue);
/**
 * Returns the UTC value of the attribute with the given name.
 */
ProductData_UTC SampleCoding_getAttributeUTC2(SampleCoding _self, const char* name);
/**
 * Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
int SampleCoding_getAttributeInt1(SampleCoding _self, const char* name, int defaultValue);
/**
 * Returns the integer value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
int SampleCoding_getAttributeInt2(SampleCoding _self, const char* name);
/**
 * Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void SampleCoding_setAttributeInt(SampleCoding _self, const char* name, int value);
/**
 * Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void SampleCoding_setAttributeDouble(SampleCoding _self, const char* name, double value);
/**
 * Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void SampleCoding_setAttributeUTC(SampleCoding _self, const char* name, ProductData_UTC value);
/**
 * Returns the string value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
char* SampleCoding_getAttributeString1(SampleCoding _self, const char* name);
/**
 * Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
char* SampleCoding_getAttributeString2(SampleCoding _self, const char* name, const char* defaultValue);
/**
 * Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void SampleCoding_setAttributeString(SampleCoding _self, const char* name, const char* value);
/**
 * 
 */
void SampleCoding_setModified(SampleCoding _self, boolean modified);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then
 visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.
 */
void SampleCoding_acceptVisitor(SampleCoding _self, ProductVisitor visitor);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong SampleCoding_getRawStorageSize1(SampleCoding _self, ProductSubsetDef subsetDef);
/**
 * 
 */
MetadataElement SampleCoding_createDeepClone(SampleCoding _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void SampleCoding_dispose(SampleCoding _self);
/**
 * 
 */
ProductNode SampleCoding_getOwner(SampleCoding _self);
/**
 * 
 */
char* SampleCoding_getName(SampleCoding _self);
/**
 * Sets this product's name.
 */
void SampleCoding_setName(SampleCoding _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* SampleCoding_getDescription(SampleCoding _self);
/**
 * Sets a short textual description for this products node.
 */
void SampleCoding_setDescription(SampleCoding _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean SampleCoding_isModified(SampleCoding _self);
/**
 * 
 */
char* SampleCoding_toString(SampleCoding _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean SampleCoding_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product SampleCoding_getProduct(SampleCoding _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader SampleCoding_getProductReader(SampleCoding _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter SampleCoding_getProductWriter(SampleCoding _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* SampleCoding_getDisplayName(SampleCoding _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* SampleCoding_getProductRefString(SampleCoding _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong SampleCoding_getRawStorageSize2(SampleCoding _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void SampleCoding_updateExpression(SampleCoding _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void SampleCoding_fireProductNodeChanged1(SampleCoding _self, const char* propertyName);
/**
 * 
 */
void SampleCoding_fireProductNodeChanged2(SampleCoding _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void SampleCoding_removeFromFile(SampleCoding _self, ProductWriter productWriter);
/**
 * 
 */
E SampleCoding_getExtension(SampleCoding _self, Class arg0);

/* Functions for class Placemark */

/**
 * Constructor.
 */
Placemark Placemark_newPlacemark(PlacemarkDescriptor descriptor, SimpleFeature feature);
/**
 * Creates a point placemark.
 */
Placemark Placemark_createPointPlacemark(PlacemarkDescriptor descriptor, const char* name, const char* label, const char* text, PixelPos pixelPos, GeoPos geoPos, GeoCoding geoCoding);
/**
 * 
 */
PlacemarkDescriptor Placemark_getDescriptor(Placemark _self);
/**
 * 
 */
SimpleFeature Placemark_getFeature(Placemark _self);
/**
 * Gets the attribute value of the underlying feature.
 */
Object Placemark_getAttributeValue(Placemark _self, const char* attributeName);
/**
 * Sets the attribute value of the underlying feature.
 */
void Placemark_setAttributeValue(Placemark _self, const char* attributeName, Object attributeValue);
/**
 * Sets this placemark's label.
 */
void Placemark_setLabel(Placemark _self, const char* label);
/**
 * 
 */
char* Placemark_getLabel(Placemark _self);
/**
 * Sets this placemark's (XHTML) text.
 */
void Placemark_setText(Placemark _self, const char* text);
/**
 * 
 */
char* Placemark_getText(Placemark _self);
/**
 * Sets this placemark's CSS style.
 */
void Placemark_setStyleCss(Placemark _self, const char* styleCss);
/**
 * 
 */
char* Placemark_getStyleCss(Placemark _self);
/**
 * Returns an estimated, raw storage size in bytes of this placemark.
 */
dlong Placemark_getRawStorageSize1(Placemark _self, ProductSubsetDef subsetDef);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 */
void Placemark_acceptVisitor(Placemark _self, ProductVisitor visitor);
/**
 * 
 */
PixelPos Placemark_getPixelPos(Placemark _self);
/**
 * 
 */
void Placemark_setPixelPos(Placemark _self, PixelPos pixelPos);
/**
 * 
 */
GeoPos Placemark_getGeoPos(Placemark _self);
/**
 * 
 */
void Placemark_setGeoPos(Placemark _self, GeoPos geoPos);
/**
 * Updates pixel and geo position according to the current geometry (model coordinates).
 */
void Placemark_updatePositions(Placemark _self);
/**
 * 
 */
SimpleFeatureType Placemark_createPinFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGcpFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createGeometryFeatureType();
/**
 * 
 */
SimpleFeatureType Placemark_createPointFeatureType(const char* name);
/**
 * 
 */
ProductNode Placemark_getOwner(Placemark _self);
/**
 * 
 */
char* Placemark_getName(Placemark _self);
/**
 * Sets this product's name.
 */
void Placemark_setName(Placemark _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* Placemark_getDescription(Placemark _self);
/**
 * Sets a short textual description for this products node.
 */
void Placemark_setDescription(Placemark _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean Placemark_isModified(Placemark _self);
/**
 * Sets this node's modified flag.
 <p/>
 If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to
 true.
 */
void Placemark_setModified(Placemark _self, boolean modified);
/**
 * 
 */
char* Placemark_toString(Placemark _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void Placemark_dispose(Placemark _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean Placemark_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product Placemark_getProduct(Placemark _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader Placemark_getProductReader(Placemark _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter Placemark_getProductWriter(Placemark _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* Placemark_getDisplayName(Placemark _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* Placemark_getProductRefString(Placemark _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong Placemark_getRawStorageSize2(Placemark _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void Placemark_updateExpression(Placemark _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void Placemark_fireProductNodeChanged1(Placemark _self, const char* propertyName);
/**
 * 
 */
void Placemark_fireProductNodeChanged2(Placemark _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void Placemark_removeFromFile(Placemark _self, ProductWriter productWriter);
/**
 * 
 */
E Placemark_getExtension(Placemark _self, Class arg0);

/* Functions for class MetadataElement */

/**
 * Constructs a new metadata element.
 */
MetadataElement MetadataElement_newMetadataElement(const char* name);
/**
 * Gets the group of child elements. The method returns null, if this element has no children.
 */
ProductNodeGroup MetadataElement_getElementGroup(MetadataElement _self);
/**
 * 
 */
MetadataElement MetadataElement_getParentElement(MetadataElement _self);
/**
 * Adds the given element to this element.
 */
void MetadataElement_addElement(MetadataElement _self, MetadataElement element);
/**
 * Adds the given element to this element at index.
 */
void MetadataElement_addElementAt(MetadataElement _self, MetadataElement element, int index);
/**
 * Removes the given element from this element.
 */
boolean MetadataElement_removeElement(MetadataElement _self, MetadataElement element);
/**
 * 
 */
int MetadataElement_getNumElements(MetadataElement _self);
/**
 * Returns the element at the given index.
 */
MetadataElement MetadataElement_getElementAt(MetadataElement _self, int index);
/**
 * Returns a string array containing the names of the groups contained in this element
 */
char** MetadataElement_getElementNames(MetadataElement _self, int* resultArrayLength);
/**
 * Returns an array of elements contained in this element.
 */
MetadataElement* MetadataElement_getElements(MetadataElement _self, int* resultArrayLength);
/**
 * Returns the element with the given name.
 */
MetadataElement MetadataElement_getElement(MetadataElement _self, const char* name);
/**
 * Tests if a element with the given name is contained in this element.
 */
boolean MetadataElement_containsElement(MetadataElement _self, const char* name);
/**
 * Gets the index of the given element.
 */
int MetadataElement_getElementIndex(MetadataElement _self, MetadataElement element);
/**
 * Adds an attribute to this node.
 */
void MetadataElement_addAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 * Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.
 */
boolean MetadataElement_removeAttribute(MetadataElement _self, MetadataAttribute attribute);
/**
 * Returns the number of attributes attaached to this node.
 */
int MetadataElement_getNumAttributes(MetadataElement _self);
/**
 * Returns the attribute at the given index.
 */
MetadataAttribute MetadataElement_getAttributeAt(MetadataElement _self, int index);
/**
 * Returns the names of all attributes of this node.
 */
char** MetadataElement_getAttributeNames(MetadataElement _self, int* resultArrayLength);
/**
 * Returns an array of attributes contained in this element.
 */
MetadataAttribute* MetadataElement_getAttributes(MetadataElement _self, int* resultArrayLength);
/**
 * Returns the attribute with the given name.
 */
MetadataAttribute MetadataElement_getAttribute(MetadataElement _self, const char* name);
/**
 * Checks whether this node has an element with the given name.
 */
boolean MetadataElement_containsAttribute(MetadataElement _self, const char* name);
/**
 * Gets the index of the given attribute.
 */
int MetadataElement_getAttributeIndex(MetadataElement _self, MetadataAttribute attribute);
/**
 * Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
double MetadataElement_getAttributeDouble1(MetadataElement _self, const char* name, double defaultValue);
/**
 * Returns the double value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
double MetadataElement_getAttributeDouble2(MetadataElement _self, const char* name);
/**
 * Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
ProductData_UTC MetadataElement_getAttributeUTC1(MetadataElement _self, const char* name, ProductData_UTC defaultValue);
/**
 * Returns the UTC value of the attribute with the given name.
 */
ProductData_UTC MetadataElement_getAttributeUTC2(MetadataElement _self, const char* name);
/**
 * Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
int MetadataElement_getAttributeInt1(MetadataElement _self, const char* name, int defaultValue);
/**
 * Returns the integer value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
int MetadataElement_getAttributeInt2(MetadataElement _self, const char* name);
/**
 * Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeInt(MetadataElement _self, const char* name, int value);
/**
 * Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeDouble(MetadataElement _self, const char* name, double value);
/**
 * Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeUTC(MetadataElement _self, const char* name, ProductData_UTC value);
/**
 * Returns the string value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
char* MetadataElement_getAttributeString1(MetadataElement _self, const char* name);
/**
 * Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
char* MetadataElement_getAttributeString2(MetadataElement _self, const char* name, const char* defaultValue);
/**
 * Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void MetadataElement_setAttributeString(MetadataElement _self, const char* name, const char* value);
/**
 * 
 */
void MetadataElement_setModified(MetadataElement _self, boolean modified);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method first visits (calls <code>acceptVisitor</code> for) all elements contained in this element and then
 visits all attributes. Finally the method calls <code>visitor.visit(this)</code>.
 */
void MetadataElement_acceptVisitor(MetadataElement _self, ProductVisitor visitor);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong MetadataElement_getRawStorageSize1(MetadataElement _self, ProductSubsetDef subsetDef);
/**
 * 
 */
MetadataElement MetadataElement_createDeepClone(MetadataElement _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void MetadataElement_dispose(MetadataElement _self);
/**
 * 
 */
ProductNode MetadataElement_getOwner(MetadataElement _self);
/**
 * 
 */
char* MetadataElement_getName(MetadataElement _self);
/**
 * Sets this product's name.
 */
void MetadataElement_setName(MetadataElement _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* MetadataElement_getDescription(MetadataElement _self);
/**
 * Sets a short textual description for this products node.
 */
void MetadataElement_setDescription(MetadataElement _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean MetadataElement_isModified(MetadataElement _self);
/**
 * 
 */
char* MetadataElement_toString(MetadataElement _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean MetadataElement_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product MetadataElement_getProduct(MetadataElement _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader MetadataElement_getProductReader(MetadataElement _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter MetadataElement_getProductWriter(MetadataElement _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* MetadataElement_getDisplayName(MetadataElement _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* MetadataElement_getProductRefString(MetadataElement _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong MetadataElement_getRawStorageSize2(MetadataElement _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void MetadataElement_updateExpression(MetadataElement _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void MetadataElement_fireProductNodeChanged1(MetadataElement _self, const char* propertyName);
/**
 * 
 */
void MetadataElement_fireProductNodeChanged2(MetadataElement _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void MetadataElement_removeFromFile(MetadataElement _self, ProductWriter productWriter);
/**
 * 
 */
E MetadataElement_getExtension(MetadataElement _self, Class arg0);

/* Functions for class Product */

/**
 * Creates a new product without any reader (in-memory product)
 */
Product Product_newProduct1(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight);
/**
 * Constructs a new product with the given name and the given reader.
 */
Product Product_newProduct2(const char* name, const char* type, int sceneRasterWidth, int sceneRasterHeight, ProductReader reader);
/**
 * Retrieves the disk location of this product. The return value can be <code>null</code> when the product has no
 disk location (pure virtual memory product)
 */
File Product_getFileLocation(Product _self);
/**
 * Sets the file location for this product.
 */
void Product_setFileLocation(Product _self, File fileLocation);
/**
 * Gets the product type string.
 */
char* Product_getProductType(Product _self);
/**
 * Sets the product type of this product.
 */
void Product_setProductType(Product _self, const char* productType);
/**
 * Sets the product reader which will be used to create this product in-memory represention from an external source
 and which will be used to (re-)load band rasters.
 */
void Product_setProductReader(Product _self, ProductReader reader);
/**
 * Returns the reader which was used to create this product in-memory represention from an external source and which
 will be used to (re-)load band rasters.
 */
ProductReader Product_getProductReader(Product _self);
/**
 * Sets the writer which will be used to write modifications of this product's in-memory represention to an external
 destination.
 */
void Product_setProductWriter(Product _self, ProductWriter writer);
/**
 * Returns the writer which will be used to write modifications of this product's in-memory represention to an
 external destination.
 */
ProductWriter Product_getProductWriter(Product _self);
/**
 * <p>Writes the header of a data product.<p/>
 */
void Product_writeHeader(Product _self, Object output);
/**
 * Closes and clears this product's reader (if any).
 */
void Product_closeProductReader(Product _self);
/**
 * Closes and clears this product's writer (if any).
 */
void Product_closeProductWriter(Product _self);
/**
 * Closes the file I/O for this product. Calls in sequence <code>{@link #closeProductReader}</code>  and
 <code>{@link #closeProductWriter}</code>. The <code>{@link #dispose}</code> method is <b>not</b> called, but
 should be called if the product instance is no longer in use.
 */
void Product_closeIO(Product _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 </p>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 </p>
 <p>This implementation also calls the <code>closeIO</code> in order to release all open I/O resources.
 */
void Product_dispose(Product _self);
/**
 * Gets the pointing factory associated with this data product.
 */
PointingFactory Product_getPointingFactory(Product _self);
/**
 * Sets the pointing factory for this data product.
 */
void Product_setPointingFactory(Product _self, PointingFactory pointingFactory);
/**
 * Geo-codes this data product.
 */
void Product_setGeoCoding(Product _self, GeoCoding geoCoding);
/**
 * Returns the geo-coding used for this data product.
 */
GeoCoding Product_getGeoCoding(Product _self);
/**
 * Tests if all bands of this product are using a single, uniform geo-coding. Uniformity is tested by comparing
 the band's geo-coding against the geo-coding of this product using the {@link Object#equals(Object)} method.
 If this product does not have a geo-coding, the method returns false.
 */
boolean Product_isUsingSingleGeoCoding(Product _self);
/**
 * Transfers the geo-coding of this product instance to the {@link Product destProduct} with respect to
 the given {@link ProductSubsetDef subsetDef}.
 */
boolean Product_transferGeoCodingTo(Product _self, Product destProduct, ProductSubsetDef subsetDef);
/**
 * Returns the scene width in pixels for this data product.
 */
int Product_getSceneRasterWidth(Product _self);
/**
 * Returns the scene height in pixels for this data product.
 */
int Product_getSceneRasterHeight(Product _self);
/**
 * Gets the (sensing) start time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>
 */
ProductData_UTC Product_getStartTime(Product _self);
/**
 * Sets the (sensing) start time of this product.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the first raster data line.
 For Level-3 products, this could be the start time of first input product
 contributing data.</p>
 */
void Product_setStartTime(Product _self, ProductData_UTC startTime);
/**
 * Gets the (sensing) stop time associated with the last raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>
 */
ProductData_UTC Product_getEndTime(Product _self);
/**
 * Sets the (sensing) stop time associated with the first raster data line.
 <p/>
 <p>For Level-1/2 products this is
 the data-take time associated with the last raster data line.
 For Level-3 products, this could be the end time of last input product
 contributing data.</p>
 */
void Product_setEndTime(Product _self, ProductData_UTC endTime);
/**
 * Gets the root element of the associated metadata.
 */
MetadataElement Product_getMetadataRoot(Product _self);
/**
 * Gets the band group of this product.
 */
ProductNodeGroup Product_getBandGroup(Product _self);
/**
 * Gets the tie-point grid group of this product.
 */
ProductNodeGroup Product_getTiePointGridGroup(Product _self);
/**
 * Adds the given tie-point grid to this product.
 */
void Product_addTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 * Removes the tie-point grid from this product.
 */
boolean Product_removeTiePointGrid(Product _self, TiePointGrid tiePointGrid);
/**
 * Returns the number of tie-point grids contained in this product
 */
int Product_getNumTiePointGrids(Product _self);
/**
 * Returns the tie-point grid at the given index.
 */
TiePointGrid Product_getTiePointGridAt(Product _self, int index);
/**
 * Returns a string array containing the names of the tie-point grids contained in this product
 */
char** Product_getTiePointGridNames(Product _self, int* resultArrayLength);
/**
 * Returns an array of tie-point grids contained in this product
 */
TiePointGrid* Product_getTiePointGrids(Product _self, int* resultArrayLength);
/**
 * Returns the tie-point grid with the given name.
 */
TiePointGrid Product_getTiePointGrid(Product _self, const char* name);
/**
 * Tests if a tie-point grid with the given name is contained in this product.
 */
boolean Product_containsTiePointGrid(Product _self, const char* name);
/**
 * Adds the given band to this product.
 */
void Product_addBand1(Product _self, Band band);
/**
 * Creates a new band with the given name and data type and adds it to this product and returns it.
 */
Band Product_addBand2(Product _self, const char* bandName, int dataType);
/**
 * Creates a new band with the given name and adds it to this product and returns it.
 The new band's data type is {@code float} and it's samples are computed from the given band maths expression.
 */
Band Product_addBand3(Product _self, const char* bandName, const char* expression);
/**
 * Creates a new band with the given name and data type and adds it to this product and returns it.
 The new band's samples are computed from the given band maths expression.
 */
Band Product_addBand4(Product _self, const char* bandName, const char* expression, int dataType);
/**
 * Removes the given band from this product.
 */
boolean Product_removeBand(Product _self, Band band);
/**
 * 
 */
int Product_getNumBands(Product _self);
/**
 * Returns the band at the given index.
 */
Band Product_getBandAt(Product _self, int index);
/**
 * Returns a string array containing the names of the bands contained in this product
 */
char** Product_getBandNames(Product _self, int* resultArrayLength);
/**
 * Returns an array of bands contained in this product
 */
Band* Product_getBands(Product _self, int* resultArrayLength);
/**
 * Returns the band with the given name.
 */
Band Product_getBand(Product _self, const char* name);
/**
 * Returns the index for the band with the given name.
 */
int Product_getBandIndex(Product _self, const char* name);
/**
 * Tests if a band with the given name is contained in this product.
 */
boolean Product_containsBand(Product _self, const char* name);
/**
 * Tests if a raster data node with the given name is contained in this product. Raster data nodes can be bands or
 tie-point grids.
 */
boolean Product_containsRasterDataNode(Product _self, const char* name);
/**
 * Gets the raster data node with the given name. The method first searches for bands with the given name, then for
 tie-point grids. If neither bands nor tie-point grids exist with the given name, <code>null</code> is returned.
 */
RasterDataNode Product_getRasterDataNode(Product _self, const char* name);
/**
 * 
 */
ProductNodeGroup Product_getMaskGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getVectorDataGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getFlagCodingGroup(Product _self);
/**
 * 
 */
ProductNodeGroup Product_getIndexCodingGroup(Product _self);
/**
 * Tests if the given pixel position is within the product pixel bounds.
 */
boolean Product_containsPixel1(Product _self, float x, float y);
/**
 * Tests if the given pixel position is within the product pixel bounds.
 */
boolean Product_containsPixel2(Product _self, PixelPos pixelPos);
/**
 * Gets the group of ground-control points (GCPs).
 Note that this method will create the group, if none exists already.
 */
PlacemarkGroup Product_getGcpGroup(Product _self);
/**
 * Gets the group of pins.
 Note that this method will create the group, if none exists already.
 */
PlacemarkGroup Product_getPinGroup(Product _self);
/**
 * Checks whether or not the given product is compatible with this product.
 */
boolean Product_isCompatibleProduct(Product _self, Product product, float eps);
/**
 * Parses a mathematical expression given as a text string.
 */
Term Product_parseExpression(Product _self, const char* expression);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method subsequentially visits (calls <code>acceptVisitor</code> for) all bands, tie-point grids and flag
 codings. Finally it visits product metadata root element and calls <code>visitor.visit(this)</code>.
 */
void Product_acceptVisitor(Product _self, ProductVisitor visitor);
/**
 * Adds a <code>ProductNodeListener</code> to this product. The <code>ProductNodeListener</code> is informed each
 time a node in this product changes.
 */
boolean Product_addProductNodeListener(Product _self, ProductNodeListener listener);
/**
 * Removes a <code>ProductNodeListener</code> from this product.
 */
void Product_removeProductNodeListener(Product _self, ProductNodeListener listener);
/**
 * 
 */
ProductNodeListener* Product_getProductNodeListeners(Product _self, int* resultArrayLength);
/**
 * 
 */
int Product_getRefNo(Product _self);
/**
 * Sets the reference number.
 */
void Product_setRefNo(Product _self, int refNo);
/**
 * 
 */
void Product_resetRefNo(Product _self);
/**
 * Returns the product manager for this product.
 */
ProductManager Product_getProductManager(Product _self);
/**
 * Tests if the given band arithmetic expression can be computed using this product.
 */
boolean Product_isCompatibleBandArithmeticExpression1(Product _self, const char* expression);
/**
 * Tests if the given band arithmetic expression can be computed using this product and a given expression parser.
 */
boolean Product_isCompatibleBandArithmeticExpression2(Product _self, const char* expression, Parser parser);
/**
 * Creates a parser for band arithmetic expressions.
 The parser created will use a namespace comprising all tie-point grids, bands and flags of this product.
 */
Parser Product_createBandArithmeticParser(Product _self);
/**
 * Creates a namespace to be used by parsers for band arithmetic expressions.
 The namespace created comprises all tie-point grids, bands and flags of this product.
 */
WritableNamespace Product_createBandArithmeticDefaultNamespace(Product _self);
/**
 * Creates a subset of this product. The returned product represents a true spatial and spectral subset of this
 product, but it has not loaded any bands into memory. If name or desc are null or empty, the name and the
 description from this product was used.
 */
Product Product_createSubset(Product _self, ProductSubsetDef subsetDef, const char* name, const char* desc);
/**
 * Creates a map-projected version of this product.
 */
Product Product_createProjectedProduct(Product _self, MapInfo mapInfo, const char* name, const char* desc);
/**
 * Creates flipped raster-data version of this product.
 */
Product Product_createFlippedProduct(Product _self, int flipType, const char* name, const char* desc);
/**
 * 
 */
void Product_setModified(Product _self, boolean modified);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong Product_getRawStorageSize1(Product _self, ProductSubsetDef subsetDef);
/**
 * Gets the name of the band suitable for quicklook generation.
 */
char* Product_getQuicklookBandName(Product _self);
/**
 * Sets the name of the band suitable for quicklook generation.
 */
void Product_setQuicklookBandName(Product _self, const char* quicklookBandName);
/**
 * Creates a string containing all available information at the given pixel position. The string returned is a line
 separated text with each line containing a key/value pair.
 */
char* Product_createPixelInfoString(Product _self, int pixelX, int pixelY);
/**
 * 
 */
ProductNode* Product_getRemovedChildNodes(Product _self, int* resultArrayLength);
/**
 * Checks whether or not this product can be ortorectified.
 */
boolean Product_canBeOrthorectified(Product _self);
/**
 * Gets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
Dimension Product_getPreferredTileSize(Product _self);
/**
 * Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
void Product_setPreferredTileSize1(Product _self, int tileWidth, int tileHeight);
/**
 * Sets the preferred tile size which may be used for a the {@link java.awt.image.RenderedImage rendered image}
 created for a {@link RasterDataNode} of this product.
 */
void Product_setPreferredTileSize2(Product _self, Dimension preferredTileSize);
/**
 * Returns the names of all flags of all flag datasets contained this product.
 <p/>
 <p>A flag name contains the dataset (a band of this product) and the actual flag name as defined in the
 flag-coding associated with the dataset. The general format for the flag name strings returned is therefore
 <code>"<i>dataset</i>.<i>flag_name</i>"</code>.
 </p>
 <p>The method is used to find out which flags a product has in order to use them in bit-mask expressions.
 */
char** Product_getAllFlagNames(Product _self, int* resultArrayLength);
/**
 * Gets the auto-grouping applicable to product nodes contained in this product.
 */
Product_AutoGrouping Product_getAutoGrouping(Product _self);
/**
 * Sets the auto-grouping applicable to product nodes contained in this product.
 */
void Product_setAutoGrouping1(Product _self, Product_AutoGrouping autoGrouping);
/**
 * Sets the auto-grouping applicable to product nodes contained in this product.
 A given {@code pattern} parameter is a textual representation of the auto-grouping.
 The syntax for the pattern is:
 <pre>
 pattern    :=  &lt;groupPath&gt; {':' &lt;groupPath&gt;} | "" (empty string)
 groupPath  :=  &lt;groupName&gt; {'/' &lt;groupName&gt;}
 groupName  :=  any non-empty string without characters ':' and '/'
 </pre>
 An example for {@code pattern} applicable to Envisat AATSR data is
 <pre>
 nadir/reflec:nadir/btemp:fward/reflec:fward/btemp:nadir:fward
 </pre>
 */
void Product_setAutoGrouping2(Product _self, const char* pattern);
/**
 * Creates a new mask with the given name and image type and adds it to this product and returns it.
 The new mask's samples are computed from the given image type.
 */
Mask Product_addMask1(Product _self, const char* maskName, Mask_ImageType imageType);
/**
 * Creates a new mask using a band arithmetic expression
 and adds it to this product and returns it.
 */
Mask Product_addMask2(Product _self, const char* maskName, const char* expression, const char* description, Color color, double transparency);
/**
 * Creates a new mask based on the geometries contained in a vector data node,
 adds it to this product and returns it.
 */
Mask Product_addMask3(Product _self, const char* maskName, VectorDataNode vectorDataNode, const char* description, Color color, double transparency);
/**
 * 
 */
ProductNode Product_getOwner(Product _self);
/**
 * 
 */
char* Product_getName(Product _self);
/**
 * Sets this product's name.
 */
void Product_setName(Product _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* Product_getDescription(Product _self);
/**
 * Sets a short textual description for this products node.
 */
void Product_setDescription(Product _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean Product_isModified(Product _self);
/**
 * 
 */
char* Product_toString(Product _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean Product_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product Product_getProduct(Product _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* Product_getDisplayName(Product _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* Product_getProductRefString(Product _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong Product_getRawStorageSize2(Product _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void Product_updateExpression(Product _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void Product_fireProductNodeChanged1(Product _self, const char* propertyName);
/**
 * 
 */
void Product_fireProductNodeChanged2(Product _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void Product_removeFromFile(Product _self, ProductWriter productWriter);
/**
 * 
 */
E Product_getExtension(Product _self, Class arg0);

/* Functions for class ColorPaletteDef */

/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef1(double minSample, double maxSample);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef2(double minSample, double centerSample, double maxSample);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef3(const ColorPaletteDef_Point* pointsElems, int pointsLength);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_newColorPaletteDef4(const ColorPaletteDef_Point* pointsElems, int pointsLength, int numColors);
/**
 * 
 */
boolean ColorPaletteDef_isDiscrete(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setDiscrete(ColorPaletteDef _self, boolean discrete);
/**
 * 
 */
int ColorPaletteDef_getNumColors(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumColors(ColorPaletteDef _self, int numColors);
/**
 * 
 */
int ColorPaletteDef_getNumPoints(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setNumPoints(ColorPaletteDef _self, int numPoints);
/**
 * 
 */
boolean ColorPaletteDef_isAutoDistribute(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_setAutoDistribute(ColorPaletteDef _self, boolean autoDistribute);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getPointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getFirstPoint(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_getLastPoint(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMinDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
double ColorPaletteDef_getMaxDisplaySample(ColorPaletteDef _self);
/**
 * 
 */
void ColorPaletteDef_insertPointAfter(ColorPaletteDef _self, int index, ColorPaletteDef_Point point);
/**
 * creates a new point between the point at the given index
 */
boolean ColorPaletteDef_createPointAfter(ColorPaletteDef _self, int index, Scaling scaling);
/**
 * Creates the center color between the given two colors.
 */
Color ColorPaletteDef_getCenterColor(Color c1, Color c2);
/**
 * 
 */
void ColorPaletteDef_removePointAt(ColorPaletteDef _self, int index);
/**
 * 
 */
void ColorPaletteDef_addPoint(ColorPaletteDef _self, ColorPaletteDef_Point point);
/**
 * 
 */
ColorPaletteDef_Point* ColorPaletteDef_getPoints(ColorPaletteDef _self, int* resultArrayLength);
/**
 * 
 */
void ColorPaletteDef_setPoints(ColorPaletteDef _self, const ColorPaletteDef_Point* pointsElems, int pointsLength);
/**
 * 
 */
Iterator ColorPaletteDef_getIterator(ColorPaletteDef _self);
/**
 * 
 */
Object ColorPaletteDef_clone(ColorPaletteDef _self);
/**
 * 
 */
ColorPaletteDef ColorPaletteDef_createDeepCopy(ColorPaletteDef _self);
/**
 * Loads a color palette definition from the given file
 */
ColorPaletteDef ColorPaletteDef_loadColorPaletteDef(File file);
/**
 * Stores this color palette definition in the given file
 */
void ColorPaletteDef_storeColorPaletteDef(ColorPaletteDef colorPaletteDef, File file);
/**
 * Releases all of the resources used by this color palette definition and all of its owned children. Its primary
 use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void ColorPaletteDef_dispose(ColorPaletteDef _self);
/**
 * 
 */
Color* ColorPaletteDef_getColors(ColorPaletteDef _self, int* resultArrayLength);
/**
 * 
 */
Color* ColorPaletteDef_createColorPalette(ColorPaletteDef _self, Scaling scaling, int* resultArrayLength);
/**
 * 
 */
Color ColorPaletteDef_computeColor(ColorPaletteDef _self, Scaling scaling, double sample);

/* Functions for class ImageInfo */

/**
 * Constructs a new image information instance.
 */
ImageInfo ImageInfo_newImageInfo1(ColorPaletteDef colorPaletteDef);
/**
 * Constructs a new RGB image information instance.
 */
ImageInfo ImageInfo_newImageInfo2(RGBChannelDef rgbChannelDef);
/**
 * Gets the color palette definition as used for images created from single bands.
 */
ColorPaletteDef ImageInfo_getColorPaletteDef(ImageInfo _self);
/**
 * Gets the RGB(A) channel definition as used for images created from 3 tp 4 bands.
 */
RGBChannelDef ImageInfo_getRgbChannelDef(ImageInfo _self);
/**
 * 
 */
Color ImageInfo_getNoDataColor(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setNoDataColor(ImageInfo _self, Color noDataColor);
/**
 * 
 */
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching1(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setHistogramMatching(ImageInfo _self, ImageInfo_HistogramMatching histogramMatching);
/**
 * 
 */
boolean ImageInfo_isLogScaled(ImageInfo _self);
/**
 * 
 */
void ImageInfo_setLogScaled(ImageInfo _self, boolean logScaled);
/**
 * 
 */
Color* ImageInfo_getColors(ImageInfo _self, int* resultArrayLength);
/**
 * Gets the number of color components the image shall have using an instance of this {@code ImageInfo}.
 */
int ImageInfo_getColorComponentCount(ImageInfo _self);
/**
 * 
 */
IndexColorModel ImageInfo_createIndexColorModel(ImageInfo _self, Scaling scaling);
/**
 * 
 */
ComponentColorModel ImageInfo_createComponentColorModel(ImageInfo _self);
/**
 * Creates and returns a copy of this object.
 */
Object ImageInfo_clone(ImageInfo _self);
/**
 * Creates and returns a "deep" copy of this object. The method simply returns the value of
 {@link #clone()}.
 */
ImageInfo ImageInfo_createDeepCopy(ImageInfo _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void ImageInfo_dispose(ImageInfo _self);
/**
 * Sets the colours of the colour palette of this image info.
 */
void ImageInfo_setColors(ImageInfo _self, const Color* colorsElems, int colorsLength);
/**
 * Transfers the colour palette into this image info.
 */
void ImageInfo_setColorPaletteDef(ImageInfo _self, ColorPaletteDef colorPaletteDef, double minSample, double maxSample, boolean autoDistribute);
/**
 * Converts a string to a histogram matching.
 */
ImageInfo_HistogramMatching ImageInfo_getHistogramMatching2(const char* mode);

/* Functions for class Tile_Pos */

/**
 * 
 */
Tile_Pos Tile_Pos_newTile_Pos(int x, int y);
/**
 * 
 */
boolean Tile_Pos_equals(Tile_Pos _self, Object obj);
/**
 * 
 */
int Tile_Pos_hashCode(Tile_Pos _self);
/**
 * 
 */
char* Tile_Pos_toString(Tile_Pos _self);

/* Functions for class ProductManager */

/**
 * Constructs an product manager with an empty list of products.
 */
ProductManager ProductManager_newProductManager();
/**
 * 
 */
int ProductManager_getProductCount(ProductManager _self);
/**
 * Gets the product at the given index.
 */
Product ProductManager_getProduct1(ProductManager _self, int index);
/**
 * Returns the display names of all products currently managed.
 */
char** ProductManager_getProductDisplayNames(ProductManager _self, int* resultArrayLength);
/**
 * Returns the names of all products currently managed.
 */
char** ProductManager_getProductNames(ProductManager _self, int* resultArrayLength);
/**
 * Returns an array of all products currently managed.
 */
Product* ProductManager_getProducts(ProductManager _self, int* resultArrayLength);
/**
 * 
 */
Product ProductManager_getProductByDisplayName(ProductManager _self, const char* displayName);
/**
 * 
 */
Product ProductManager_getProductByRefNo(ProductManager _self, int refNo);
/**
 * 
 */
Product ProductManager_getProduct2(ProductManager _self, const char* name);
/**
 * 
 */
int ProductManager_getProductIndex(ProductManager _self, Product product);
/**
 * Tests whether a product with the given name is contained in this list.
 */
boolean ProductManager_containsProduct(ProductManager _self, const char* name);
/**
 * Tests whether the given product is contained in this list.
 */
boolean ProductManager_contains(ProductManager _self, Product product);
/**
 * Adds the given product to this product manager if it does not already exists and sets it's reference number one
 biger than the greatest reference number in this product manager.
 */
void ProductManager_addProduct(ProductManager _self, Product product);
/**
 * Removes the given product from this product manager if it exists.
 */
boolean ProductManager_removeProduct(ProductManager _self, Product product);
/**
 * Removes all product from this list.
 */
void ProductManager_removeAllProducts(ProductManager _self);
/**
 * Adds a <code>ProductManagerListener</code> to this product manager. The <code>ProductManagerListener</code> is
 informed each time a product was added or removed.
 */
boolean ProductManager_addListener(ProductManager _self, ProductManager_Listener listener);
/**
 * Removes a <code>ProductManagerListener</code> from this product manager.
 */
boolean ProductManager_removeListener(ProductManager _self, ProductManager_Listener listener);

/* Functions for class OperatorSpiRegistry */

/**
 * Loads the SPI's defined in {@code META-INF/services}.
 */
void OperatorSpiRegistry_loadOperatorSpis(OperatorSpiRegistry _self);
/**
 * Gets the {@link ServiceRegistry ServiceRegistry}
 */
ServiceRegistry OperatorSpiRegistry_getServiceRegistry(OperatorSpiRegistry _self);
/**
 * Gets a registrered operator SPI. The given <code>operatorName</code> can be
 either the fully qualified class name of the {@link OperatorSpi}
 or an alias name.
 */
OperatorSpi OperatorSpiRegistry_getOperatorSpi(OperatorSpiRegistry _self, const char* operatorName);
/**
 * Adds the given {@link OperatorSpi operatorSpi} to this registry.
 */
boolean OperatorSpiRegistry_addOperatorSpi(OperatorSpiRegistry _self, OperatorSpi operatorSpi);
/**
 * Removes the given {@link OperatorSpi operatorSpi} this registry.
 */
boolean OperatorSpiRegistry_removeOperatorSpi(OperatorSpiRegistry _self, OperatorSpi operatorSpi);
/**
 * Sets an alias for the given SPI class name.
 */
void OperatorSpiRegistry_setAlias(OperatorSpiRegistry _self, const char* aliasName, const char* spiClassName);

/* Functions for class ImageGeometry */

/**
 * 
 */
ImageGeometry ImageGeometry_newImageGeometry(Rectangle bounds, CoordinateReferenceSystem mapCrs, AffineTransform image2map);
/**
 * 
 */
AffineTransform ImageGeometry_getImage2MapTransform(ImageGeometry _self);
/**
 * 
 */
Rectangle ImageGeometry_getImageRect(ImageGeometry _self);
/**
 * 
 */
CoordinateReferenceSystem ImageGeometry_getMapCrs(ImageGeometry _self);
/**
 * 
 */
void ImageGeometry_changeYAxisDirection(ImageGeometry _self);
/**
 * 
 */
Point2D ImageGeometry_calculateEastingNorthing(Product sourceProduct, CoordinateReferenceSystem targetCrs, double referencePixelX, double referencePixelY, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
Rectangle ImageGeometry_calculateProductSize(Product sourceProduct, CoordinateReferenceSystem targetCrs, double pixelSizeX, double pixelSizeY);
/**
 * 
 */
ImageGeometry ImageGeometry_createTargetGeometry(Product sourceProduct, CoordinateReferenceSystem targetCrs, Double pixelSizeX, Double pixelSizeY, Integer width, Integer height, Double orientation, Double easting, Double northing, Double referencePixelX, Double referencePixelY);
/**
 * 
 */
ImageGeometry ImageGeometry_createCollocationTargetGeometry(Product targetProduct, Product collocationProduct);

/* Functions for class Band */

/**
 * Constructs a new <code>Band</code>.
 */
Band Band_newBand(const char* name, int dataType, int width, int height);
/**
 * Gets the flag coding for this band.
 */
FlagCoding Band_getFlagCoding(Band _self);
/**
 * Tests whether or not this band is a flag band (<code>getFlagCoding() != null</code>).
 */
boolean Band_isFlagBand(Band _self);
/**
 * Gets the index coding for this band.
 */
IndexCoding Band_getIndexCoding(Band _self);
/**
 * Tests whether or not this band is an index band (<code>getIndexCoding() != null</code>).
 */
boolean Band_isIndexBand(Band _self);
/**
 * Gets the sample coding.
 */
SampleCoding Band_getSampleCoding(Band _self);
/**
 * Sets the sample coding for this band.
 */
void Band_setSampleCoding(Band _self, SampleCoding sampleCoding);
/**
 * Gets the (zero-based) spectral band index.
 */
int Band_getSpectralBandIndex(Band _self);
/**
 * Sets the (zero-based) spectral band index.
 */
void Band_setSpectralBandIndex(Band _self, int spectralBandIndex);
/**
 * Gets the spectral wavelength in <code>nm</code> (nanomater) units.
 */
float Band_getSpectralWavelength(Band _self);
/**
 * Sets the spectral wavelength in <code>nm</code> (nanomater) units.
 */
void Band_setSpectralWavelength(Band _self, float spectralWavelength);
/**
 * Gets the spectral bandwidth in <code>nm</code> (nanomater) units.
 */
float Band_getSpectralBandwidth(Band _self);
/**
 * Sets the spectral bandwidth in <code>nm</code> (nanomater) units.
 */
void Band_setSpectralBandwidth(Band _self, float spectralBandwidth);
/**
 * Gets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.
 */
float Band_getSolarFlux(Band _self);
/**
 * Sets the solar flux in <code>mW/(m^2 nm)</code> (milli-watts per square metre per nanometer)
 units for the wavelength of this band.
 */
void Band_setSolarFlux(Band _self, float solarFlux);
/**
 * Reads raster data from its associated data source into the given data buffer.
 */
void Band_readRasterData1(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_readRasterDataFully1(Band _self, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_writeRasterData1(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void Band_writeRasterDataFully1(Band _self, ProgressMonitor pm);
/**
 * Gets an estimated raw storage size in bytes of this product node.
 */
dlong Band_getRawStorageSize1(Band _self, ProductSubsetDef subsetDef);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void Band_acceptVisitor(Band _self, ProductVisitor visitor);
/**
 * Creates a string defining this band object.
 */
char* Band_toString(Band _self);
/**
 * 
 */
void Band_removeFromFile(Band _self, ProductWriter productWriter);
/**
 * 
 */
ImageInfo Band_createDefaultImageInfo1(Band _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void Band_dispose(Band _self);
/**
 * Gets a raster data holding this band's pixel data for an entire product scene. If the data has'nt been loaded so
 far the method returns <code>null</code>.
 <p/>
 <p>In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the
 scene's pixels.
 */
ProductData Band_getSceneRasterData(Band _self);
/**
 * Gets the sample for the pixel located at (x,y) as an integer value.
 */
int Band_getPixelInt(Band _self, int x, int y);
/**
 * Gets the sample for the pixel located at (x,y) as a float value.
 */
float Band_getPixelFloat(Band _self, int x, int y);
/**
 * Gets the sample for the pixel located at (x,y) as a double value.
 */
double Band_getPixelDouble(Band _self, int x, int y);
/**
 * Sets the pixel at the given pixel co-ordinate to the given pixel value.
 */
void Band_setPixelInt(Band _self, int x, int y, int pixelValue);
/**
 * Sets the pixel at the given pixel coordinate to the given pixel value.
 */
void Band_setPixelFloat(Band _self, int x, int y, float pixelValue);
/**
 * Sets the pixel value at the given pixel coordinate to the given pixel value.
 */
void Band_setPixelDouble(Band _self, int x, int y, double pixelValue);
/**
 * Retrieves the band data at the given offset (x, y), width and height as integer data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
int* Band_readPixels1(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves the band data at the given offset (x, y), width and height as float data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
float* Band_readPixels2(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves the band data at the given offset (x, y), width and height as double data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
double* Band_readPixels3(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as integer array. Reads the data from disk if ot is
 not in memory yet. If the data is loaded, just copies the data..
 */
void Band_writePixels1(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * Retrieves the range of pixels specified by the coordinates as float array. Reads the data from disk if ot is not
 in memory yet. If the data is loaded, just copies the data..
 */
void Band_writePixels2(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * Retrieves the range of pixels specified by the coordinates as double array. Reads the data from disk if ot is not
 in memory yet. If the data is loaded, just copies the data..
 */
void Band_writePixels3(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * Retrieves the range of pixels specified by the coordinates as integer array. Throws exception when the data is
 not read from disk yet. If the given array is <code>null</code> a new one was created and returned.
 */
int* Band_getPixels1(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as float array. Throws exception when the data is not
 read from disk yet. If the given array is <code>null</code> a new one was created and returned.
 */
float* Band_getPixels2(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as double array. Throws exception when the data is not
 read from disk yet. If the given array is <code>null</code> a new one was created and returned.
 */
double* Band_getPixels3(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of
 data at the specified location. Throws exception when the target buffer is not in memory.
 */
void Band_setPixels1(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.
 */
void Band_setPixels2(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.
 */
void Band_setPixels3(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * Ensures that raster data exists
 */
void Band_ensureRasterData(Band _self);
/**
 * Loads the complete underlying raster data.
 <p/>
 <p>After this method has been called successfully, <code>hasRasterData()</code> should always return
 <code>true</code> and <code>getRasterData()</code> should always return a valid <code>ProductData</code> instance
 with at least <code>getRasterWidth()*getRasterHeight()</code> elements (samples).
 <p/>
 <p> In opposite to the <code>readRasterDataFully</code> method, <code>loadRasterData</code> will only read data
 if this has not already been done.
 */
void Band_loadRasterData1(Band _self, ProgressMonitor pm);
/**
 * Un-loads the raster data for this band.
 <p/>
 <p>After this method has been called successfully, the <code>hasRasterData()</code> method returns
 <code>false</code> and <code>getRasterData()</code> returns <code>null</code>.
 <p/>
 */
void Band_unloadRasterData(Band _self);
/**
 * 
 */
char* Band_getViewModeId(Band _self, const char* bandName);
/**
 * Returns the width in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterWidth()</code>.
 */
int Band_getSceneRasterWidth(Band _self);
/**
 * Returns the height in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterHeight()</code>.
 */
int Band_getSceneRasterHeight(Band _self);
/**
 * Returns the width of the raster used by this product raster.
 */
int Band_getRasterWidth(Band _self);
/**
 * Returns the height of the raster used by this product raster.
 */
int Band_getRasterHeight(Band _self);
/**
 * 
 */
void Band_setModified(Band _self, boolean modified);
/**
 * Returns the geo-coding of this {@link RasterDataNode}.
 */
GeoCoding Band_getGeoCoding(Band _self);
/**
 * Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>
 */
void Band_setGeoCoding(Band _self, GeoCoding geoCoding);
/**
 * Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.
 */
Pointing Band_getPointing(Band _self);
/**
 * Tests if this raster data node can be orthorectified.
 */
boolean Band_canBeOrthorectified(Band _self);
/**
 * Returns <code>true</code> if the pixel data contained in this band is "naturally" a floating point number type.
 */
boolean Band_isFloatingPointType(Band _self);
/**
 * Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.
 */
int Band_getGeophysicalDataType(Band _self);
/**
 * Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).
 */
double Band_getScalingFactor(Band _self);
/**
 * Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.
 */
void Band_setScalingFactor(Band _self, double scalingFactor);
/**
 * Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).
 */
double Band_getScalingOffset(Band _self);
/**
 * Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.
 */
void Band_setScalingOffset(Band _self, double scalingOffset);
/**
 * Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.
 */
boolean Band_isLog10Scaled(Band _self);
/**
 * Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.
 */
void Band_setLog10Scaled(Band _self, boolean log10Scaled);
/**
 * Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.
 */
boolean Band_isScalingApplied(Band _self);
/**
 * Tests if the given name is the name of a property which is relevant for the computation of the valid mask.
 */
boolean Band_isValidMaskProperty(const char* propertyName);
/**
 * Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.
 */
boolean Band_isNoDataValueSet(Band _self);
/**
 * Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.
 */
void Band_clearNoDataValue(Band _self);
/**
 * Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean Band_isNoDataValueUsed(Band _self);
/**
 * Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.
 */
void Band_setNoDataValueUsed(Band _self, boolean noDataValueUsed);
/**
 * Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.
 */
double Band_getNoDataValue(Band _self);
/**
 * Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void Band_setNoDataValue(Band _self, double noDataValue);
/**
 * Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
double Band_getGeophysicalNoDataValue(Band _self);
/**
 * Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void Band_setGeophysicalNoDataValue(Band _self, double noDataValue);
/**
 * Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
char* Band_getValidPixelExpression(Band _self);
/**
 * Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.
 */
void Band_setValidPixelExpression(Band _self, const char* validPixelExpression);
/**
 * Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean Band_isValidMaskUsed(Band _self);
/**
 * Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.
 */
void Band_resetValidMask(Band _self);
/**
 * Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.
 */
char* Band_getValidMaskExpression(Band _self);
/**
 * {@inheritDoc}
 */
void Band_updateExpression(Band _self, const char* oldExternalName, const char* newExternalName);
/**
 * Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.
 */
boolean Band_hasRasterData(Band _self);
/**
 * Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.
 */
ProductData Band_getRasterData(Band _self);
/**
 * Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!
 */
void Band_setRasterData(Band _self, ProductData rasterData);
/**
 * 
 */
void Band_loadRasterData2(Band _self);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>
 */
boolean Band_isPixelValid1(Band _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
int Band_getSampleInt(Band _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
float Band_getSampleFloat(Band _self, int x, int y);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 */
boolean Band_isPixelValid2(Band _self, int pixelIndex);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,
 and secondly, if the pixel is within the ROI (if any).
 */
boolean Band_isPixelValid3(Band _self, int x, int y, ROI roi);
/**
 * 
 */
int* Band_getPixels4(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
float* Band_getPixels5(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
double* Band_getPixels6(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
int* Band_readPixels4(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
float* Band_readPixels5(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
double* Band_readPixels6(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
void Band_writePixels4(Band _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * 
 */
void Band_writePixels5(Band _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * 
 */
void Band_writePixels6(Band _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * 
 */
boolean* Band_readValidMask(Band _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
/**
 * 
 */
void Band_readRasterDataFully2(Band _self);
/**
 * Reads raster data from the node's associated data source into the given data
 buffer.
 */
void Band_readRasterData2(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * 
 */
void Band_writeRasterDataFully2(Band _self);
/**
 * 
 */
void Band_writeRasterData2(Band _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.
 */
ProductData Band_createCompatibleRasterData1(Band _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.
 */
ProductData Band_createCompatibleSceneRasterData(Band _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.
 */
ProductData Band_createCompatibleRasterData2(Band _self, int width, int height);
/**
 * Tests whether the given parameters specify a compatible raster or not.
 */
boolean Band_isCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
/**
 * Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.
 */
void Band_checkCompatibleRasterData(Band _self, ProductData rasterData, int w, int h);
/**
 * Determines whether this raster data node contains integer samples.
 */
boolean Band_hasIntPixels(Band _self);
/**
 * Creates a transect profile for the given shape (-outline).
 */
TransectProfileData Band_createTransectProfileData(Band _self, Shape shape);
/**
 * Gets the image information for image display.
 */
ImageInfo Band_getImageInfo1(Band _self);
/**
 * Sets the image information for image display.
 */
void Band_setImageInfo(Band _self, ImageInfo imageInfo);
/**
 * Notifies listeners that the image (display) information has changed.
 */
void Band_fireImageInfoChanged(Band _self);
/**
 * Returns the image information for this raster data node.
 <p/>
 <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.
 */
ImageInfo Band_getImageInfo2(Band _self, ProgressMonitor pm);
/**
 * Gets the image creation information.
 <p/>
 <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is
 called with the given parameters passed to this method.
 */
ImageInfo Band_getImageInfo3(Band _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Creates an instance of a default image information.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.
 */
ImageInfo Band_createDefaultImageInfo2(Band _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
/**
 * 
 */
ProductNodeGroup Band_getOverlayMaskGroup(Band _self);
/**
 * Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.
 */
BufferedImage Band_createColorIndexedImage(Band _self, ProgressMonitor pm);
/**
 * Creates an RGB image for this raster data node.
 */
BufferedImage Band_createRgbImage(Band _self, ProgressMonitor pm);
/**
 * 
 */
byte* Band_quantizeRasterData1(Band _self, double newMin, double newMax, double gamma, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
void Band_quantizeRasterData2(Band _self, double newMin, double newMax, double gamma, const byte* samplesElems, int samplesLength, int offset, int stride, ProgressMonitor pm);
/**
 * Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.
 */
IndexValidator Band_createPixelValidator(Band _self, int lineOffset, ROI roi);
/**
 * Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.
 */
double Band_scale(Band _self, double v);
/**
 * Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.
 */
double Band_scaleInverse(Band _self, double v);
/**
 * Returns the pixel located at (x,y) as a string value.
 */
char* Band_getPixelString(Band _self, int x, int y);
/**
 * Returns whether the source image is set on this {@code RasterDataNode}.
 */
boolean Band_isSourceImageSet(Band _self);
/**
 * Gets the source image associated with this {@code RasterDataNode}.
 */
MultiLevelImage Band_getSourceImage(Band _self);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void Band_setSourceImage1(Band _self, RenderedImage sourceImage);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void Band_setSourceImage2(Band _self, MultiLevelImage sourceImage);
/**
 * Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
boolean Band_isGeophysicalImageSet(Band _self);
/**
 * 
 */
MultiLevelImage Band_getGeophysicalImage(Band _self);
/**
 * Returns wether the valid mask image is set on this {@code RasterDataNode}.
 */
boolean Band_isValidMaskImageSet(Band _self);
/**
 * Gets the valid-mask image associated with this {@code RasterDataNode}.
 */
MultiLevelImage Band_getValidMaskImage(Band _self);
/**
 * 
 */
boolean Band_isStxSet(Band _self);
/**
 * Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx Band_getStx1(Band _self);
/**
 * Gets the statistics.
 If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx Band_getStx2(Band _self, boolean accurate, ProgressMonitor pm);
/**
 * Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
void Band_setStx(Band _self, Stx stx);
/**
 * Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.
 */
Shape Band_getValidShape(Band _self);
/**
 * Gets the data type of this data node.
 */
int Band_getDataType(Band _self);
/**
 * Gets the number of data elements in this data node.
 */
dlong Band_getNumDataElems(Band _self);
/**
 * Sets the data of this data node.
 */
void Band_setData(Band _self, ProductData data);
/**
 * Gets the data of this data node.
 */
ProductData Band_getData(Band _self);
/**
 * Sets the data elements of this data node.
 */
void Band_setDataElems(Band _self, Object elems);
/**
 * Gets the data elements of this data node.
 */
Object Band_getDataElems(Band _self);
/**
 * Gets the data element size in bytes.
 */
int Band_getDataElemSize(Band _self);
/**
 * 
 */
void Band_setReadOnly(Band _self, boolean readOnly);
/**
 * 
 */
boolean Band_isReadOnly(Band _self);
/**
 * 
 */
void Band_setUnit(Band _self, const char* unit);
/**
 * 
 */
char* Band_getUnit(Band _self);
/**
 * Fires a node data changed event. This method is called after the data of this data node changed.
 */
void Band_fireProductNodeDataChanged(Band _self);
/**
 * Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.
 */
ProductData Band_createCompatibleProductData(Band _self, int numElems);
/**
 * 
 */
ProductNode Band_getOwner(Band _self);
/**
 * 
 */
char* Band_getName(Band _self);
/**
 * Sets this product's name.
 */
void Band_setName(Band _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* Band_getDescription(Band _self);
/**
 * Sets a short textual description for this products node.
 */
void Band_setDescription(Band _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean Band_isModified(Band _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean Band_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product Band_getProduct(Band _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader Band_getProductReader(Band _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter Band_getProductWriter(Band _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* Band_getDisplayName(Band _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* Band_getProductRefString(Band _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong Band_getRawStorageSize2(Band _self);
/**
 * 
 */
void Band_fireProductNodeChanged1(Band _self, const char* propertyName);
/**
 * 
 */
void Band_fireProductNodeChanged2(Band _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * 
 */
E Band_getExtension(Band _self, Class arg0);

/* Functions for class PlacemarkGroup */

/**
 * 
 */
VectorDataNode PlacemarkGroup_getVectorDataNode(PlacemarkGroup _self);
/**
 * 
 */
Placemark PlacemarkGroup_getPlacemark(PlacemarkGroup _self, SimpleFeature feature);
/**
 * 
 */
boolean PlacemarkGroup_add1(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_add2(PlacemarkGroup _self, int index, Placemark placemark);
/**
 * 
 */
boolean PlacemarkGroup_remove1(PlacemarkGroup _self, Placemark placemark);
/**
 * 
 */
void PlacemarkGroup_dispose(PlacemarkGroup _self);
/**
 * 
 */
boolean PlacemarkGroup_isTakingOverNodeOwnership(PlacemarkGroup _self);
/**
 * 
 */
int PlacemarkGroup_getNodeCount(PlacemarkGroup _self);
/**
 * 
 */
T PlacemarkGroup_get1(PlacemarkGroup _self, int index);
/**
 * Returns the display names of all products currently managed.
 */
char** PlacemarkGroup_getNodeDisplayNames(PlacemarkGroup _self, int* resultArrayLength);
/**
 * Returns the names of all products currently managed.
 */
char** PlacemarkGroup_getNodeNames(PlacemarkGroup _self, int* resultArrayLength);
/**
 * Returns an array of all products currently managed.
 */
ProductNode* PlacemarkGroup_toArray1(PlacemarkGroup _self, int* resultArrayLength);
/**
 * 
 */
T* PlacemarkGroup_toArray2(PlacemarkGroup _self, const T* arrayElems, int arrayLength, int* resultArrayLength);
/**
 * 
 */
int PlacemarkGroup_indexOf1(PlacemarkGroup _self, const char* name);
/**
 * 
 */
int PlacemarkGroup_indexOf2(PlacemarkGroup _self, T element);
/**
 * 
 */
T PlacemarkGroup_getByDisplayName(PlacemarkGroup _self, const char* displayName);
/**
 * 
 */
T PlacemarkGroup_get2(PlacemarkGroup _self, const char* name);
/**
 * Tests whether a node with the given name is contained in this group.
 */
boolean PlacemarkGroup_contains1(PlacemarkGroup _self, const char* name);
/**
 * Tests whether the given product is contained in this list.
 */
boolean PlacemarkGroup_contains2(PlacemarkGroup _self, T node);
/**
 * Adds the given node to this group.
 */
boolean PlacemarkGroup_add3(PlacemarkGroup _self, T node);
/**
 * Adds the given node to this group.
 */
void PlacemarkGroup_add4(PlacemarkGroup _self, int index, T node);
/**
 * Removes the given node from this group.
 */
boolean PlacemarkGroup_remove2(PlacemarkGroup _self, T node);
/**
 * Removes all nodes from this group.
 */
void PlacemarkGroup_removeAll(PlacemarkGroup _self);
/**
 * 
 */
void PlacemarkGroup_clearRemovedList(PlacemarkGroup _self);
/**
 * Gets all removed node nodes.
 */
Collection PlacemarkGroup_getRemovedNodes(PlacemarkGroup _self);
/**
 * 
 */
dlong PlacemarkGroup_getRawStorageSize1(PlacemarkGroup _self, ProductSubsetDef subsetDef);
/**
 * 
 */
void PlacemarkGroup_setModified(PlacemarkGroup _self, boolean modified);
/**
 * 
 */
void PlacemarkGroup_acceptVisitor(PlacemarkGroup _self, ProductVisitor visitor);
/**
 * 
 */
void PlacemarkGroup_updateExpression(PlacemarkGroup _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
ProductNode PlacemarkGroup_getOwner(PlacemarkGroup _self);
/**
 * 
 */
char* PlacemarkGroup_getName(PlacemarkGroup _self);
/**
 * Sets this product's name.
 */
void PlacemarkGroup_setName(PlacemarkGroup _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* PlacemarkGroup_getDescription(PlacemarkGroup _self);
/**
 * Sets a short textual description for this products node.
 */
void PlacemarkGroup_setDescription(PlacemarkGroup _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean PlacemarkGroup_isModified(PlacemarkGroup _self);
/**
 * 
 */
char* PlacemarkGroup_toString(PlacemarkGroup _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean PlacemarkGroup_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product PlacemarkGroup_getProduct(PlacemarkGroup _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader PlacemarkGroup_getProductReader(PlacemarkGroup _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter PlacemarkGroup_getProductWriter(PlacemarkGroup _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* PlacemarkGroup_getDisplayName(PlacemarkGroup _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* PlacemarkGroup_getProductRefString(PlacemarkGroup _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong PlacemarkGroup_getRawStorageSize2(PlacemarkGroup _self);
/**
 * 
 */
void PlacemarkGroup_fireProductNodeChanged1(PlacemarkGroup _self, const char* propertyName);
/**
 * 
 */
void PlacemarkGroup_fireProductNodeChanged2(PlacemarkGroup _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void PlacemarkGroup_removeFromFile(PlacemarkGroup _self, ProductWriter productWriter);
/**
 * 
 */
E PlacemarkGroup_getExtension(PlacemarkGroup _self, Class arg0);

/* Functions for class ColorPaletteDef_Point */

/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point1();
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point2(double sample, Color color);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_newColorPaletteDef_Point3(double sample, Color color, const char* label);
/**
 * 
 */
double ColorPaletteDef_Point_getSample(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setSample(ColorPaletteDef_Point _self, double sample);
/**
 * 
 */
Color ColorPaletteDef_Point_getColor(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setColor(ColorPaletteDef_Point _self, Color color);
/**
 * 
 */
char* ColorPaletteDef_Point_getLabel(ColorPaletteDef_Point _self);
/**
 * 
 */
void ColorPaletteDef_Point_setLabel(ColorPaletteDef_Point _self, const char* label);
/**
 * 
 */
Object ColorPaletteDef_Point_clone(ColorPaletteDef_Point _self);
/**
 * 
 */
ColorPaletteDef_Point ColorPaletteDef_Point_createClone(ColorPaletteDef_Point _self);

/* Functions for class TiePointGrid */

/**
 * Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.
 */
TiePointGrid TiePointGrid_newTiePointGrid1(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength);
/**
 * Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.
 */
TiePointGrid TiePointGrid_newTiePointGrid2(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, int discontinuity);
/**
 * Constructs a new <code>TiePointGrid</code> with the given tie point grid properties.
 */
TiePointGrid TiePointGrid_newTiePointGrid3(const char* name, int gridWidth, int gridHeight, float offsetX, float offsetY, float subSamplingX, float subSamplingY, const float* tiePointsElems, int tiePointsLength, boolean containsAngles);
/**
 * Determines the angular discontinuity of the given tie point values.
 */
int TiePointGrid_getDiscontinuity1(const float* tiePointsElems, int tiePointsLength);
/**
 * Gets the angular discontinuity.
 */
int TiePointGrid_getDiscontinuity2(TiePointGrid _self);
/**
 * Sets the angular discontinuity.
 */
void TiePointGrid_setDiscontinuity(TiePointGrid _self, int discontinuity);
/**
 * Returns <code>true</code>
 */
boolean TiePointGrid_isFloatingPointType(TiePointGrid _self);
/**
 * Returns the geophysical data type of this <code>RasterDataNode</code>. The value retuned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.
 */
int TiePointGrid_getGeophysicalDataType(TiePointGrid _self);
/**
 * Gets a raster data holding this tie-point's interpolated pixel data for an entire product scene. <p/>
 <p/>
 In opposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store
 the scene's pixels.
 */
ProductData TiePointGrid_getSceneRasterData(TiePointGrid _self);
/**
 * Returns the width in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterWidth() - 1) * getSubSamplingX() + 1</code>
 */
int TiePointGrid_getSceneRasterWidth(TiePointGrid _self);
/**
 * Returns the height in pixels of the scene represented by this tie-point grid. The value returned is
 <code>(getRasterHeight() - 1) * getSubSamplingY() + 1</code>
 */
int TiePointGrid_getSceneRasterHeight(TiePointGrid _self);
/**
 * Retrieves the x co-ordinate of the first (upper-left) tie-point in pixels.
 */
float TiePointGrid_getOffsetX(TiePointGrid _self);
/**
 * Retrieves the y co-ordinate of the first (upper-left) tie-point in pixels.
 */
float TiePointGrid_getOffsetY(TiePointGrid _self);
/**
 * Returns the sub-sampling in X-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.
 */
float TiePointGrid_getSubSamplingX(TiePointGrid _self);
/**
 * Returns the sub-sampling in Y-direction given in the pixel co-ordinates of the data product to which this
 tie-pint grid belongs to.
 */
float TiePointGrid_getSubSamplingY(TiePointGrid _self);
/**
 * Gets the data array holding this band's pixel samples.
 */
float* TiePointGrid_getTiePoints(TiePointGrid _self, int* resultArrayLength);
/**
 * Gets the interpolated sample for the pixel located at (x,y) as an integer value. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
int TiePointGrid_getPixelInt(TiePointGrid _self, int x, int y);
/**
 * 
 */
void TiePointGrid_dispose(TiePointGrid _self);
/**
 * Computes the interpolated sample for the pixel located at (x,y). <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
float TiePointGrid_getPixelFloat1(TiePointGrid _self, int x, int y);
/**
 * Computes the interpolated sample for the pixel located at (x,y) given as floating point co-ordinates. <p/>
 <p/>
 If the pixel co-odinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
float TiePointGrid_getPixelFloat2(TiePointGrid _self, float x, float y);
/**
 * Gets the interpolated sample for the pixel located at (x,y) as a double value. <p/>
 <p/>
 If the pixel co-ordinates given by (x,y) are not covered by this tie-point grid, the method extrapolates.
 */
double TiePointGrid_getPixelDouble(TiePointGrid _self, int x, int y);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelInt(TiePointGrid _self, int x, int y, int pixelValue);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelFloat(TiePointGrid _self, int x, int y, float pixelValue);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixelDouble(TiePointGrid _self, int x, int y, double pixelValue);
/**
 * Retrieves an array of tie point data interpolated to the product with and height as integer array. If the given
 array is <code>null</code> a new one was created and returned.
 */
int* TiePointGrid_getPixels1(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves an array of tie point data interpolated to the product width and height as float array. If the given
 array is <code>null</code> a new one is created and returned.
 */
float* TiePointGrid_getPixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves an array of tie point data interpolated to the product with and height as double array. If the given
 array is <code>null</code> a new one was created and returned.
 */
double* TiePointGrid_getPixels3(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixels1(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_setPixels3(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * Retrieves an array of tie point data interpolated to the product with and height as float array. If the given
 array is <code>null</code> a new one was created and returned.
 */
int* TiePointGrid_readPixels1(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves an array of tie point data interpolated to the product with and height as float array. If the given
 array is <code>null</code> a new one was created and returned. *
 */
float* TiePointGrid_readPixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Retrieves an array of tie point data interpolated to the product with and height as double array. If the given
 array is <code>null</code> a new one was created and returned.
 */
double* TiePointGrid_readPixels3(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_writePixels1(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_writePixels2(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * This method is not implemented because pixels are read-only in tie-point grids.
 */
void TiePointGrid_writePixels3(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * Reads raster data from this dataset into the user-supplied raster data buffer. <p/>
 <p/>
 This method always directly (re-)reads this band's data from its associated data source into the given data
 buffer.
 */
void TiePointGrid_readRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_readRasterDataFully1(TiePointGrid _self, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_writeRasterData1(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * {@inheritDoc}
 */
void TiePointGrid_writeRasterDataFully1(TiePointGrid _self, ProgressMonitor pm);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor. <p/>
 <p/>
 The method simply calls <code>visitor.visit(this)</code>.
 */
void TiePointGrid_acceptVisitor(TiePointGrid _self, ProductVisitor visitor);
/**
 * 
 */
TiePointGrid TiePointGrid_cloneTiePointGrid(TiePointGrid _self);
/**
 * 
 */
TiePointGrid TiePointGrid_createZenithFromElevationAngleTiePointGrid(TiePointGrid elevationAngleGrid);
/**
 * 
 */
TiePointGrid TiePointGrid_createSubset(TiePointGrid sourceTiePointGrid, ProductSubsetDef subsetDef);
/**
 * Returns the width of the raster used by this product raster.
 */
int TiePointGrid_getRasterWidth(TiePointGrid _self);
/**
 * Returns the height of the raster used by this product raster.
 */
int TiePointGrid_getRasterHeight(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setModified(TiePointGrid _self, boolean modified);
/**
 * Returns the geo-coding of this {@link RasterDataNode}.
 */
GeoCoding TiePointGrid_getGeoCoding(TiePointGrid _self);
/**
 * Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>
 */
void TiePointGrid_setGeoCoding(TiePointGrid _self, GeoCoding geoCoding);
/**
 * Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.
 */
Pointing TiePointGrid_getPointing(TiePointGrid _self);
/**
 * Tests if this raster data node can be orthorectified.
 */
boolean TiePointGrid_canBeOrthorectified(TiePointGrid _self);
/**
 * Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).
 */
double TiePointGrid_getScalingFactor(TiePointGrid _self);
/**
 * Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.
 */
void TiePointGrid_setScalingFactor(TiePointGrid _self, double scalingFactor);
/**
 * Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).
 */
double TiePointGrid_getScalingOffset(TiePointGrid _self);
/**
 * Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.
 */
void TiePointGrid_setScalingOffset(TiePointGrid _self, double scalingOffset);
/**
 * Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.
 */
boolean TiePointGrid_isLog10Scaled(TiePointGrid _self);
/**
 * Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.
 */
void TiePointGrid_setLog10Scaled(TiePointGrid _self, boolean log10Scaled);
/**
 * Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.
 */
boolean TiePointGrid_isScalingApplied(TiePointGrid _self);
/**
 * Tests if the given name is the name of a property which is relevant for the computation of the valid mask.
 */
boolean TiePointGrid_isValidMaskProperty(const char* propertyName);
/**
 * Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.
 */
boolean TiePointGrid_isNoDataValueSet(TiePointGrid _self);
/**
 * Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.
 */
void TiePointGrid_clearNoDataValue(TiePointGrid _self);
/**
 * Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean TiePointGrid_isNoDataValueUsed(TiePointGrid _self);
/**
 * Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.
 */
void TiePointGrid_setNoDataValueUsed(TiePointGrid _self, boolean noDataValueUsed);
/**
 * Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.
 */
double TiePointGrid_getNoDataValue(TiePointGrid _self);
/**
 * Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void TiePointGrid_setNoDataValue(TiePointGrid _self, double noDataValue);
/**
 * Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
double TiePointGrid_getGeophysicalNoDataValue(TiePointGrid _self);
/**
 * Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void TiePointGrid_setGeophysicalNoDataValue(TiePointGrid _self, double noDataValue);
/**
 * Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
char* TiePointGrid_getValidPixelExpression(TiePointGrid _self);
/**
 * Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.
 */
void TiePointGrid_setValidPixelExpression(TiePointGrid _self, const char* validPixelExpression);
/**
 * Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean TiePointGrid_isValidMaskUsed(TiePointGrid _self);
/**
 * Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.
 */
void TiePointGrid_resetValidMask(TiePointGrid _self);
/**
 * Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.
 */
char* TiePointGrid_getValidMaskExpression(TiePointGrid _self);
/**
 * {@inheritDoc}
 */
void TiePointGrid_updateExpression(TiePointGrid _self, const char* oldExternalName, const char* newExternalName);
/**
 * Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.
 */
boolean TiePointGrid_hasRasterData(TiePointGrid _self);
/**
 * Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.
 */
ProductData TiePointGrid_getRasterData(TiePointGrid _self);
/**
 * Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!
 */
void TiePointGrid_setRasterData(TiePointGrid _self, ProductData rasterData);
/**
 * 
 */
void TiePointGrid_loadRasterData1(TiePointGrid _self);
/**
 * Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,
 <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should
 always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>
 elements (samples).
 <p/>
 <p>The default implementation of this method does nothing.
 */
void TiePointGrid_loadRasterData2(TiePointGrid _self, ProgressMonitor pm);
/**
 * Un-loads the raster data for this <code>RasterDataNode</code>.
 <p/>
 <p>It is up to the implementation whether after this method has been called successfully, the
 <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.
 <p/>
 <p>The default implementation of this method does nothing.
 */
void TiePointGrid_unloadRasterData(TiePointGrid _self);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>
 */
boolean TiePointGrid_isPixelValid1(TiePointGrid _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
int TiePointGrid_getSampleInt(TiePointGrid _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
float TiePointGrid_getSampleFloat(TiePointGrid _self, int x, int y);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 */
boolean TiePointGrid_isPixelValid2(TiePointGrid _self, int pixelIndex);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,
 and secondly, if the pixel is within the ROI (if any).
 */
boolean TiePointGrid_isPixelValid3(TiePointGrid _self, int x, int y, ROI roi);
/**
 * 
 */
int* TiePointGrid_getPixels4(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
float* TiePointGrid_getPixels5(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
double* TiePointGrid_getPixels6(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
int* TiePointGrid_readPixels4(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
float* TiePointGrid_readPixels5(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
double* TiePointGrid_readPixels6(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * 
 */
void TiePointGrid_writePixels4(TiePointGrid _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * 
 */
void TiePointGrid_writePixels5(TiePointGrid _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * 
 */
void TiePointGrid_writePixels6(TiePointGrid _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * 
 */
boolean* TiePointGrid_readValidMask(TiePointGrid _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
/**
 * 
 */
void TiePointGrid_readRasterDataFully2(TiePointGrid _self);
/**
 * Reads raster data from the node's associated data source into the given data
 buffer.
 */
void TiePointGrid_readRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * 
 */
void TiePointGrid_writeRasterDataFully2(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_writeRasterData2(TiePointGrid _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.
 */
ProductData TiePointGrid_createCompatibleRasterData1(TiePointGrid _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.
 */
ProductData TiePointGrid_createCompatibleSceneRasterData(TiePointGrid _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.
 */
ProductData TiePointGrid_createCompatibleRasterData2(TiePointGrid _self, int width, int height);
/**
 * Tests whether the given parameters specify a compatible raster or not.
 */
boolean TiePointGrid_isCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
/**
 * Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.
 */
void TiePointGrid_checkCompatibleRasterData(TiePointGrid _self, ProductData rasterData, int w, int h);
/**
 * Determines whether this raster data node contains integer samples.
 */
boolean TiePointGrid_hasIntPixels(TiePointGrid _self);
/**
 * Creates a transect profile for the given shape (-outline).
 */
TransectProfileData TiePointGrid_createTransectProfileData(TiePointGrid _self, Shape shape);
/**
 * Gets the image information for image display.
 */
ImageInfo TiePointGrid_getImageInfo1(TiePointGrid _self);
/**
 * Sets the image information for image display.
 */
void TiePointGrid_setImageInfo(TiePointGrid _self, ImageInfo imageInfo);
/**
 * Notifies listeners that the image (display) information has changed.
 */
void TiePointGrid_fireImageInfoChanged(TiePointGrid _self);
/**
 * Returns the image information for this raster data node.
 <p/>
 <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.
 */
ImageInfo TiePointGrid_getImageInfo2(TiePointGrid _self, ProgressMonitor pm);
/**
 * Gets the image creation information.
 <p/>
 <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is
 called with the given parameters passed to this method.
 */
ImageInfo TiePointGrid_getImageInfo3(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Creates a default image information instance.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.
 */
ImageInfo TiePointGrid_createDefaultImageInfo1(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Creates an instance of a default image information.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.
 */
ImageInfo TiePointGrid_createDefaultImageInfo2(TiePointGrid _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
/**
 * 
 */
ProductNodeGroup TiePointGrid_getOverlayMaskGroup(TiePointGrid _self);
/**
 * Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.
 */
BufferedImage TiePointGrid_createColorIndexedImage(TiePointGrid _self, ProgressMonitor pm);
/**
 * Creates an RGB image for this raster data node.
 */
BufferedImage TiePointGrid_createRgbImage(TiePointGrid _self, ProgressMonitor pm);
/**
 * 
 */
byte* TiePointGrid_quantizeRasterData1(TiePointGrid _self, double newMin, double newMax, double gamma, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
void TiePointGrid_quantizeRasterData2(TiePointGrid _self, double newMin, double newMax, double gamma, const byte* samplesElems, int samplesLength, int offset, int stride, ProgressMonitor pm);
/**
 * Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.
 */
IndexValidator TiePointGrid_createPixelValidator(TiePointGrid _self, int lineOffset, ROI roi);
/**
 * Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.
 */
double TiePointGrid_scale(TiePointGrid _self, double v);
/**
 * Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.
 */
double TiePointGrid_scaleInverse(TiePointGrid _self, double v);
/**
 * Returns the pixel located at (x,y) as a string value.
 */
char* TiePointGrid_getPixelString(TiePointGrid _self, int x, int y);
/**
 * Returns whether the source image is set on this {@code RasterDataNode}.
 */
boolean TiePointGrid_isSourceImageSet(TiePointGrid _self);
/**
 * Gets the source image associated with this {@code RasterDataNode}.
 */
MultiLevelImage TiePointGrid_getSourceImage(TiePointGrid _self);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void TiePointGrid_setSourceImage1(TiePointGrid _self, RenderedImage sourceImage);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void TiePointGrid_setSourceImage2(TiePointGrid _self, MultiLevelImage sourceImage);
/**
 * Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
boolean TiePointGrid_isGeophysicalImageSet(TiePointGrid _self);
/**
 * 
 */
MultiLevelImage TiePointGrid_getGeophysicalImage(TiePointGrid _self);
/**
 * Returns wether the valid mask image is set on this {@code RasterDataNode}.
 */
boolean TiePointGrid_isValidMaskImageSet(TiePointGrid _self);
/**
 * Gets the valid-mask image associated with this {@code RasterDataNode}.
 */
MultiLevelImage TiePointGrid_getValidMaskImage(TiePointGrid _self);
/**
 * 
 */
boolean TiePointGrid_isStxSet(TiePointGrid _self);
/**
 * Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx TiePointGrid_getStx1(TiePointGrid _self);
/**
 * Gets the statistics.
 If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx TiePointGrid_getStx2(TiePointGrid _self, boolean accurate, ProgressMonitor pm);
/**
 * Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
void TiePointGrid_setStx(TiePointGrid _self, Stx stx);
/**
 * Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.
 */
Shape TiePointGrid_getValidShape(TiePointGrid _self);
/**
 * Gets the data type of this data node.
 */
int TiePointGrid_getDataType(TiePointGrid _self);
/**
 * Gets the number of data elements in this data node.
 */
dlong TiePointGrid_getNumDataElems(TiePointGrid _self);
/**
 * Sets the data of this data node.
 */
void TiePointGrid_setData(TiePointGrid _self, ProductData data);
/**
 * Gets the data of this data node.
 */
ProductData TiePointGrid_getData(TiePointGrid _self);
/**
 * Sets the data elements of this data node.
 */
void TiePointGrid_setDataElems(TiePointGrid _self, Object elems);
/**
 * Gets the data elements of this data node.
 */
Object TiePointGrid_getDataElems(TiePointGrid _self);
/**
 * Gets the data element size in bytes.
 */
int TiePointGrid_getDataElemSize(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setReadOnly(TiePointGrid _self, boolean readOnly);
/**
 * 
 */
boolean TiePointGrid_isReadOnly(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_setUnit(TiePointGrid _self, const char* unit);
/**
 * 
 */
char* TiePointGrid_getUnit(TiePointGrid _self);
/**
 * Fires a node data changed event. This method is called after the data of this data node changed.
 */
void TiePointGrid_fireProductNodeDataChanged(TiePointGrid _self);
/**
 * Gets the estimated size in bytes of this product node.
 */
dlong TiePointGrid_getRawStorageSize1(TiePointGrid _self, ProductSubsetDef subsetDef);
/**
 * Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.
 */
ProductData TiePointGrid_createCompatibleProductData(TiePointGrid _self, int numElems);
/**
 * 
 */
ProductNode TiePointGrid_getOwner(TiePointGrid _self);
/**
 * 
 */
char* TiePointGrid_getName(TiePointGrid _self);
/**
 * Sets this product's name.
 */
void TiePointGrid_setName(TiePointGrid _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* TiePointGrid_getDescription(TiePointGrid _self);
/**
 * Sets a short textual description for this products node.
 */
void TiePointGrid_setDescription(TiePointGrid _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean TiePointGrid_isModified(TiePointGrid _self);
/**
 * 
 */
char* TiePointGrid_toString(TiePointGrid _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean TiePointGrid_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product TiePointGrid_getProduct(TiePointGrid _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader TiePointGrid_getProductReader(TiePointGrid _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter TiePointGrid_getProductWriter(TiePointGrid _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* TiePointGrid_getDisplayName(TiePointGrid _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* TiePointGrid_getProductRefString(TiePointGrid _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong TiePointGrid_getRawStorageSize2(TiePointGrid _self);
/**
 * 
 */
void TiePointGrid_fireProductNodeChanged1(TiePointGrid _self, const char* propertyName);
/**
 * 
 */
void TiePointGrid_fireProductNodeChanged2(TiePointGrid _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void TiePointGrid_removeFromFile(TiePointGrid _self, ProductWriter productWriter);
/**
 * 
 */
E TiePointGrid_getExtension(TiePointGrid _self, Class arg0);

/* Functions for class VectorDataNode */

/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode1(const char* name, SimpleFeatureType featureType);
/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode2(const char* name, FeatureCollection featureCollection);
/**
 * Constructs a new vector data node for the given feature collection.
 */
VectorDataNode VectorDataNode_newVectorDataNode3(const char* name, FeatureCollection featureCollection, PlacemarkDescriptor placemarkDescriptor);
/**
 * 
 */
PlacemarkDescriptor VectorDataNode_getPlacemarkDescriptor(VectorDataNode _self);
/**
 * 
 */
PlacemarkGroup VectorDataNode_getPlacemarkGroup(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setModified(VectorDataNode _self, boolean modified);
/**
 * Informs clients which have registered a {@link ProductNodeListener} with the {@link Product}
 containing this {@link VectorDataNode}, that one or more OpenGIS {@code SimpleFeature}s have
 been added to the underlying {@code FeatureCollection}.
 <p/>
 The method fires a product node property change event, where the {@code propertyName}
 is {@link #PROPERTY_NAME_FEATURE_COLLECTION}, the {@code oldValue} is {@code null}, and
 the {@code newValue} is the array of features added.
 */
void VectorDataNode_fireFeaturesAdded(VectorDataNode _self, const SimpleFeature* featuresElems, int featuresLength);
/**
 * Informs clients which have registered a {@link ProductNodeListener} with the {@link Product}
 containing this {@link VectorDataNode}, that one or more OpenGIS {@code SimpleFeature}s have
 been removed from the underlying {@code FeatureCollection}.
 <p/>
 The method fires a product node property change event, where the {@code propertyName}
 is {@link #PROPERTY_NAME_FEATURE_COLLECTION}, the {@code oldValue} is the array of features
 removed, and the {@code newValue} is {@code null}.
 */
void VectorDataNode_fireFeaturesRemoved(VectorDataNode _self, const SimpleFeature* featuresElems, int featuresLength);
/**
 * Informs clients which have registered a {@link ProductNodeListener} with the {@link Product}
 containing this {@link VectorDataNode}, that one or more OpenGIS {@code SimpleFeature}s from
 from the underlying {@code FeatureCollection} have been changed.
 <p/>
 The method fires a product node property change event, where the {@code propertyName}
 is {@link #PROPERTY_NAME_FEATURE_COLLECTION}, and both {@code oldValue} and {@code newValue}
 are the same array of features changed.
 */
void VectorDataNode_fireFeaturesChanged(VectorDataNode _self, const SimpleFeature* featuresElems, int featuresLength);
/**
 * 
 */
SimpleFeatureType VectorDataNode_getFeatureType(VectorDataNode _self);
/**
 * 
 */
FeatureCollection VectorDataNode_getFeatureCollection(VectorDataNode _self);
/**
 * Gets the bounding box for the features in this feature collection.
 */
ReferencedEnvelope VectorDataNode_getEnvelope(VectorDataNode _self);
/**
 * 
 */
dlong VectorDataNode_getRawStorageSize1(VectorDataNode _self, ProductSubsetDef subsetDef);
/**
 * 
 */
char* VectorDataNode_getDefaultStyleCss(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setDefaultStyleCss(VectorDataNode _self, const char* defaultStyleCss);
/**
 * 
 */
char* VectorDataNode_getStyleCss(VectorDataNode _self);
/**
 * 
 */
void VectorDataNode_setStyleCss(VectorDataNode _self, const char* styleCss);
/**
 * 
 */
void VectorDataNode_acceptVisitor(VectorDataNode _self, ProductVisitor visitor);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void VectorDataNode_dispose(VectorDataNode _self);
/**
 * Internal API. Don't use.
 */
boolean VectorDataNode_isPermanent(VectorDataNode _self);
/**
 * Internal API. Don't use.
 */
void VectorDataNode_setPermanent(VectorDataNode _self, boolean permanent);
/**
 * 
 */
ProductNode VectorDataNode_getOwner(VectorDataNode _self);
/**
 * 
 */
char* VectorDataNode_getName(VectorDataNode _self);
/**
 * Sets this product's name.
 */
void VectorDataNode_setName(VectorDataNode _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* VectorDataNode_getDescription(VectorDataNode _self);
/**
 * Sets a short textual description for this products node.
 */
void VectorDataNode_setDescription(VectorDataNode _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean VectorDataNode_isModified(VectorDataNode _self);
/**
 * 
 */
char* VectorDataNode_toString(VectorDataNode _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean VectorDataNode_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product VectorDataNode_getProduct(VectorDataNode _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader VectorDataNode_getProductReader(VectorDataNode _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter VectorDataNode_getProductWriter(VectorDataNode _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* VectorDataNode_getDisplayName(VectorDataNode _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* VectorDataNode_getProductRefString(VectorDataNode _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong VectorDataNode_getRawStorageSize2(VectorDataNode _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void VectorDataNode_updateExpression(VectorDataNode _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void VectorDataNode_fireProductNodeChanged1(VectorDataNode _self, const char* propertyName);
/**
 * 
 */
void VectorDataNode_fireProductNodeChanged2(VectorDataNode _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void VectorDataNode_removeFromFile(VectorDataNode _self, ProductWriter productWriter);
/**
 * 
 */
E VectorDataNode_getExtension(VectorDataNode _self, Class arg0);

/* Functions for class OperatorSpi */

/**
 * <p>Creates an operator instance with no arguments. The default implemrentation calls
 the default constructor. If no such is defined in the operator, an exception is thrown.</p>
 <p>This method may be overridden by clients in order to provide a no-argument instance of their operator.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator1(OperatorSpi _self);
/**
 * <p>Creates an operator instance for the given source products and processing parameters.</p>
 <p>This method may be overridden by clients in order to process the passed parameters and
 source products and optionally construct the operator in a specific way.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator2(OperatorSpi _self, Map parameters, Map sourceProducts);
/**
 * <p>Creates an operator instance for the given source products and processing parameters.</p>
 <p>This method may be overridden by clients in order to process the passed parameters and
 source products and optionally construct the operator in a specific way.
 Implementors should call {@link Operator#setSpi(OperatorSpi) operator.setSpi(this)}
 in order to set the operator's SPI.</p>
 */
Operator OperatorSpi_createOperator3(OperatorSpi _self, Map parameters, Map sourceProducts, RenderingHints renderingHints);
/**
 * Gets the operator class.
 The operator class must be public and provide a public zero-argument constructor.
 */
Class OperatorSpi_getOperatorClass(OperatorSpi _self);
/**
 * The alias name under which the operator can be accessed.
 */
char* OperatorSpi_getOperatorAlias1(OperatorSpi _self);
/**
 * 
 */
char* OperatorSpi_getOperatorAlias2(Class operatorClass);

/* Functions for class RasterDataNode */

/**
 * Returns the width in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterWidth()</code>.
 */
int RasterDataNode_getSceneRasterWidth(RasterDataNode _self);
/**
 * Returns the height in pixels of the scene represented by this product raster. By default, the method simply
 returns <code>getRasterHeight()</code>.
 */
int RasterDataNode_getSceneRasterHeight(RasterDataNode _self);
/**
 * Returns the width of the raster used by this product raster.
 */
int RasterDataNode_getRasterWidth(RasterDataNode _self);
/**
 * Returns the height of the raster used by this product raster.
 */
int RasterDataNode_getRasterHeight(RasterDataNode _self);
/**
 * 
 */
void RasterDataNode_setModified(RasterDataNode _self, boolean modified);
/**
 * Returns the geo-coding of this {@link RasterDataNode}.
 */
GeoCoding RasterDataNode_getGeoCoding(RasterDataNode _self);
/**
 * Sets the geo-coding for this {@link RasterDataNode}.
 Also sets the geo-coding of the parent {@link Product} if it has no geo-coding yet.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_GEOCODING}.</p>
 */
void RasterDataNode_setGeoCoding(RasterDataNode _self, GeoCoding geoCoding);
/**
 * Gets a {@link Pointing} if one is available for this raster.
 The methods calls {@link #createPointing()} if a pointing has not been set so far or if its {@link GeoCoding} changed
 since the last creation of this raster's {@link Pointing} instance.
 */
Pointing RasterDataNode_getPointing(RasterDataNode _self);
/**
 * Tests if this raster data node can be orthorectified.
 */
boolean RasterDataNode_canBeOrthorectified(RasterDataNode _self);
/**
 * Returns <code>true</code> if the pixel data contained in this band is "naturally" a floating point number type.
 */
boolean RasterDataNode_isFloatingPointType(RasterDataNode _self);
/**
 * Returns the geophysical data type of this <code>RasterDataNode</code>. The value returned is always one of the
 <code>ProductData.TYPE_XXX</code> constants.
 */
int RasterDataNode_getGeophysicalDataType(RasterDataNode _self);
/**
 * Gets the scaling factor which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>1.0</code> (no factor).
 */
double RasterDataNode_getScalingFactor(RasterDataNode _self);
/**
 * Sets the scaling factor which is applied to raw {@link <code>ProductData</code>}.
 */
void RasterDataNode_setScalingFactor(RasterDataNode _self, double scalingFactor);
/**
 * Gets the scaling offset which is applied to raw {@link <code>ProductData</code>}. The default value is
 <code>0.0</code> (no offset).
 */
double RasterDataNode_getScalingOffset(RasterDataNode _self);
/**
 * Sets the scaling offset which is applied to raw {@link <code>ProductData</code>}.
 */
void RasterDataNode_setScalingOffset(RasterDataNode _self, double scalingOffset);
/**
 * Gets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data. The default value is
 <code>false</code>.
 */
boolean RasterDataNode_isLog10Scaled(RasterDataNode _self);
/**
 * Sets whether or not the {@link <code>ProductData</code>} of this band has a negative binominal distribution and
 thus the common logarithm (base 10) of the values is stored in the raw data.
 */
void RasterDataNode_setLog10Scaled(RasterDataNode _self, boolean log10Scaled);
/**
 * Tests whether scaling of raw raster data values is applied before they are returned as geophysically meaningful
 pixel values. <p>The methods which return geophysical pixel values are all {@link #getPixels(int, int, int, int, int[])},
 {@link #setPixels(int, int, int, int, int[])}, {@link #readPixels(int, int, int, int, int[])} and
 {@link #writePixels(int, int, int, int, int[])} methods as well as the <code>getPixel&lt;Type&gt;</code> and
 <code>setPixel&lt;Type&gt;</code> methods such as  {@link #getPixelFloat(int, int)} * and
 {@link #setPixelFloat(int, int, float)}.
 */
boolean RasterDataNode_isScalingApplied(RasterDataNode _self);
/**
 * Tests if the given name is the name of a property which is relevant for the computation of the valid mask.
 */
boolean RasterDataNode_isValidMaskProperty(const char* propertyName);
/**
 * Tests whether or not a no-data value has been specified. The no-data value is not-specified unless either
 {@link #setNoDataValue(double)} or {@link #setGeophysicalNoDataValue(double)} is called.
 */
boolean RasterDataNode_isNoDataValueSet(RasterDataNode _self);
/**
 * Clears the no-data value, so that {@link #isNoDataValueSet()} will return <code>false</code>.
 */
void RasterDataNode_clearNoDataValue(RasterDataNode _self);
/**
 * Tests whether or not the no-data value is used.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean RasterDataNode_isNoDataValueUsed(RasterDataNode _self);
/**
 * Sets whether or not the no-data value is used.
 If the no-data value is enabled and the no-data value has not been set so far,
 a default no-data value it is set with a value of to zero.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE_USED}.
 */
void RasterDataNode_setNoDataValueUsed(RasterDataNode _self, boolean noDataValueUsed);
/**
 * Gets the no-data value as a primitive <code>double</code>.
 <p>Note that the value returned is NOT necessarily the same as the value returned by
 {@link #getGeophysicalNoDataValue()} because no scaling is applied.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>The method returns <code>0.0</code>, if no no-data value has been specified so far.
 */
double RasterDataNode_getNoDataValue(RasterDataNode _self);
/**
 * Sets the no-data value as a primitive <code>double</code>.
 <p>Note that the given value is related to the "raw", un-scaled raster data.
 In order to set the geophysical, scaled no-data value use the method
 {@link #setGeophysicalNoDataValue(double)}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void RasterDataNode_setNoDataValue(RasterDataNode _self, double noDataValue);
/**
 * Gets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
double RasterDataNode_getGeophysicalNoDataValue(RasterDataNode _self);
/**
 * Sets the geophysical no-data value which is simply the scaled "raw" no-data value
 returned by {@link #getNoDataValue()}.
 <p>The no-data value is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_NO_DATA_VALUE}.
 */
void RasterDataNode_setGeophysicalNoDataValue(RasterDataNode _self, double noDataValue);
/**
 * Gets the expression that is used to determine whether a pixel is valid or not.
 For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
char* RasterDataNode_getValidPixelExpression(RasterDataNode _self);
/**
 * Sets the expression that is used to determine whether a pixel is valid or not.
 <p>The valid-pixel expression is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 <p>On property change, the method calls {@link #fireProductNodeChanged(String)} with the property
 name {@link #PROPERTY_NAME_VALID_PIXEL_EXPRESSION}.
 */
void RasterDataNode_setValidPixelExpression(RasterDataNode _self, const char* validPixelExpression);
/**
 * Tests whether or not this raster data node uses a data-mask in order to determine valid pixels. The method returns
 true if either {@link #isValidPixelExpressionSet()} or {@link #isNoDataValueUsed()} returns true.
 <p>The data-mask is used to determine valid pixels. For more information
 on valid pixels, please refer to the documentation of the {@link #isPixelValid(int, int, javax.media.jai.ROI)}
 method.
 */
boolean RasterDataNode_isValidMaskUsed(RasterDataNode _self);
/**
 * Resets the valid mask of this raster.
 The mask will be lazily regenerated when requested the next time.
 */
void RasterDataNode_resetValidMask(RasterDataNode _self);
/**
 * Gets the expression used for the computation of the mask which identifies valid pixel values.
 It recognizes the value of the {@link #getNoDataValue() noDataValue} and the
 {@link #getValidPixelExpression() validPixelExpression} properties, if any.
 The method returns {@code null},  if none of these properties are set.
 */
char* RasterDataNode_getValidMaskExpression(RasterDataNode _self);
/**
 * {@inheritDoc}
 */
void RasterDataNode_updateExpression(RasterDataNode _self, const char* oldExternalName, const char* newExternalName);
/**
 * Gets a raster data holding this dataset's pixel data for an entire product scene. If the data has'nt been loaded
 so far the method returns <code>null</code>.
 <p/>
 <p>In oposite to the <code>getRasterData</code> method, this method returns raster data that has at least
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of the given data type to store the
 scene's pixels.
 */
ProductData RasterDataNode_getSceneRasterData(RasterDataNode _self);
/**
 * Returns true if the raster data of this <code>RasterDataNode</code> is loaded or elsewhere available, otherwise
 false.
 */
boolean RasterDataNode_hasRasterData(RasterDataNode _self);
/**
 * Gets the raster data for this dataset. If the data has'nt been loaded so far the method returns
 <code>null</code>.
 */
ProductData RasterDataNode_getRasterData(RasterDataNode _self);
/**
 * Sets the raster data of this dataset.
 <p/>
 <p> Note that this method does not copy data at all. If the supplied raster data is compatible with this product
 raster, then simply its reference is stored. Modifications in the supplied raster data will also affect this
 dataset's data!
 */
void RasterDataNode_setRasterData(RasterDataNode _self, ProductData rasterData);
/**
 * 
 */
void RasterDataNode_loadRasterData1(RasterDataNode _self);
/**
 * Loads the raster data for this <code>RasterDataNode</code>. After this method has been called successfully,
 <code>hasRasterData()</code> should always return <code>true</code> and <code>getRasterData()</code> should
 always return a valid <code>ProductData</code> instance with at least <code>getRasterWidth()*getRasterHeight()</code>
 elements (samples).
 <p/>
 <p>The default implementation of this method does nothing.
 */
void RasterDataNode_loadRasterData2(RasterDataNode _self, ProgressMonitor pm);
/**
 * Un-loads the raster data for this <code>RasterDataNode</code>.
 <p/>
 <p>It is up to the implementation whether after this method has been called successfully, the
 <code>hasRasterData()</code> method returns <code>false</code> or <code>true</code>.
 <p/>
 <p>The default implementation of this method does nothing.
 */
void RasterDataNode_unloadRasterData(RasterDataNode _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void RasterDataNode_dispose(RasterDataNode _self);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 <p/>
 <i>Note: Implementation changed by Norman (2011-08-09) in order to increase performance since
 a synchronised block was used due to problem with the JAI ROI class that has been used in
 the former implementation.</i>
 */
boolean RasterDataNode_isPixelValid1(RasterDataNode _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code int} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
int RasterDataNode_getSampleInt(RasterDataNode _self, int x, int y);
/**
 * Gets a geo-physical sample value at the given pixel coordinate as {@code float} value.
 <p/>
 <i>Note: This method does not belong to the public API.
 It has been added by Norman (2011-08-09) in order to perform performance tests.</i>
 */
float RasterDataNode_getSampleFloat(RasterDataNode _self, int x, int y);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 A pixel is assumed to be valid either if  {@link #getValidMaskImage() validMaskImage} is null or
 or if the bit corresponding to (x,y) is set within the returned mask image.
 */
boolean RasterDataNode_isPixelValid2(RasterDataNode _self, int pixelIndex);
/**
 * Checks whether or not the pixel located at (x,y) is valid.
 The method first test whether a pixel is valid by using the {@link #isPixelValid(int, int)} method,
 and secondly, if the pixel is within the ROI (if any).
 */
boolean RasterDataNode_isPixelValid3(RasterDataNode _self, int x, int y, ROI roi);
/**
 * Returns the pixel located at (x,y) as an integer value.
 */
int RasterDataNode_getPixelInt(RasterDataNode _self, int x, int y);
/**
 * Returns the pixel located at (x,y) as a float value.
 */
float RasterDataNode_getPixelFloat(RasterDataNode _self, int x, int y);
/**
 * Returns the pixel located at (x,y) as a double value.
 */
double RasterDataNode_getPixelDouble(RasterDataNode _self, int x, int y);
/**
 * Sets the pixel located at (x,y) to the given integer value.
 */
void RasterDataNode_setPixelInt(RasterDataNode _self, int x, int y, int pixelValue);
/**
 * Sets the pixel located at (x,y) to the given float value.
 */
void RasterDataNode_setPixelFloat(RasterDataNode _self, int x, int y, float pixelValue);
/**
 * Sets the pixel located at (x,y) to the given double value.
 */
void RasterDataNode_setPixelDouble(RasterDataNode _self, int x, int y, double pixelValue);
/**
 * 
 */
int* RasterDataNode_getPixels1(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as integer array. Throws exception when the data is
 not read from disk yet. If the given array is <code>null</code> a new one was created and returned.
 */
int* RasterDataNode_getPixels2(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
float* RasterDataNode_getPixels3(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as float array. Throws exception when the data is not
 read from disk yet. If the given array is <code>null</code> a new one is created and returned.
 */
float* RasterDataNode_getPixels4(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
double* RasterDataNode_getPixels5(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the range of pixels specified by the coordinates as double array. Throws exception when the data is not
 read from disk yet. If the given array is <code>null</code> a new one is created and returned.
 */
double* RasterDataNode_getPixels6(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * Sets a range of pixels specified by the coordinates as integer array. Copies the data to the memory buffer of
 data at the specified location. Throws exception when the target buffer is not in memory.
 */
void RasterDataNode_setPixels1(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * Sets a range of pixels specified by the coordinates as float array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.
 */
void RasterDataNode_setPixels2(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * Sets a range of pixels specified by the coordinates as double array. Copies the data to the memory buffer of data
 at the specified location. Throws exception when the target buffer is not in memory.
 */
void RasterDataNode_setPixels3(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * 
 */
int* RasterDataNode_readPixels1(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the band data at the given offset (x, y), width and height as int data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
int* RasterDataNode_readPixels2(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
float* RasterDataNode_readPixels3(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the band data at the given offset (x, y), width and height as float data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
float* RasterDataNode_readPixels4(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
double* RasterDataNode_readPixels5(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, int* resultArrayLength);
/**
 * Retrieves the band data at the given offset (x, y), width and height as double data. If the data is already in
 memory, it merely copies the data to the buffer provided. If not, it calls the attached product reader to
 retrieve the data from the disk file. If the given buffer is <code>null</code> a new one was created and
 returned.
 */
double* RasterDataNode_readPixels6(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
void RasterDataNode_writePixels1(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength);
/**
 * Writes the range of given pixels specified to the specified coordinates as integers.
 */
void RasterDataNode_writePixels2(RasterDataNode _self, int x, int y, int w, int h, const int* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writePixels3(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength);
/**
 * Writes the range of given pixels specified to the specified coordinates as floats.
 */
void RasterDataNode_writePixels4(RasterDataNode _self, int x, int y, int w, int h, const float* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writePixels5(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength);
/**
 * Writes the range of given pixels specified to the specified coordinates as doubles.
 */
void RasterDataNode_writePixels6(RasterDataNode _self, int x, int y, int w, int h, const double* pixelsElems, int pixelsLength, ProgressMonitor pm);
/**
 * 
 */
boolean* RasterDataNode_readValidMask(RasterDataNode _self, int x, int y, int w, int h, const boolean* validMaskElems, int validMaskLength, int* resultArrayLength);
/**
 * 
 */
void RasterDataNode_readRasterDataFully1(RasterDataNode _self);
/**
 * Reads the complete underlying raster data.
 <p/>
 <p>After this method has been called successfully, <code>hasRasterData()</code> should always return
 <code>true</code> and <code>getRasterData()</code> should always return a valid <code>ProductData</code> instance
 with at least <code>getRasterWidth()*getRasterHeight()</code> elements (samples).
 <p/>
 <p>In opposite to the <code>loadRasterData</code> method, the <code>readRasterDataFully</code> method always
 reloads the data of this product raster, independently of whether its has already been loaded or not.
 */
void RasterDataNode_readRasterDataFully2(RasterDataNode _self, ProgressMonitor pm);
/**
 * Reads raster data from the node's associated data source into the given data
 buffer.
 */
void RasterDataNode_readRasterData1(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * The method behaves exactly as {@link #readRasterData(int, int, int, int, ProductData)},
 but clients can additionally pass a {@link ProgressMonitor}.
 */
void RasterDataNode_readRasterData2(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writeRasterDataFully1(RasterDataNode _self);
/**
 * Writes the complete underlying raster data.
 */
void RasterDataNode_writeRasterDataFully2(RasterDataNode _self, ProgressMonitor pm);
/**
 * 
 */
void RasterDataNode_writeRasterData1(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData);
/**
 * Writes data from this product raster into the specified region of the user-supplied raster.
 <p/>
 <p> It is important to know that this method does not change this product raster's internal state nor does it
 write into this product raster's internal raster.
 */
void RasterDataNode_writeRasterData2(RasterDataNode _self, int offsetX, int offsetY, int width, int height, ProductData rasterData, ProgressMonitor pm);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getRasterWidth()*getRasterHeight()</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleRasterData1(RasterDataNode _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>getBandOutputRasterWidth()*getBandOutputRasterHeight()</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleSceneRasterData(RasterDataNode _self);
/**
 * Creates raster data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>width*height</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleRasterData2(RasterDataNode _self, int width, int height);
/**
 * Tests whether the given parameters specify a compatible raster or not.
 */
boolean RasterDataNode_isCompatibleRasterData(RasterDataNode _self, ProductData rasterData, int w, int h);
/**
 * Throws an <code>IllegalArgumentException</code> if the given parameters dont specify a compatible raster.
 */
void RasterDataNode_checkCompatibleRasterData(RasterDataNode _self, ProductData rasterData, int w, int h);
/**
 * Determines whether this raster data node contains integer samples.
 */
boolean RasterDataNode_hasIntPixels(RasterDataNode _self);
/**
 * Creates a transect profile for the given shape (-outline).
 */
TransectProfileData RasterDataNode_createTransectProfileData(RasterDataNode _self, Shape shape);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 */
void RasterDataNode_acceptVisitor(RasterDataNode _self, ProductVisitor visitor);
/**
 * Gets the image information for image display.
 */
ImageInfo RasterDataNode_getImageInfo1(RasterDataNode _self);
/**
 * Sets the image information for image display.
 */
void RasterDataNode_setImageInfo(RasterDataNode _self, ImageInfo imageInfo);
/**
 * Notifies listeners that the image (display) information has changed.
 */
void RasterDataNode_fireImageInfoChanged(RasterDataNode _self);
/**
 * Returns the image information for this raster data node.
 <p/>
 <p>The method simply returns the value of <code>ensureValidImageInfo(null, ProgressMonitor.NULL)</code>.
 */
ImageInfo RasterDataNode_getImageInfo2(RasterDataNode _self, ProgressMonitor pm);
/**
 * Gets the image creation information.
 <p/>
 <p>If no image information has been assigned before, the <code>{@link #createDefaultImageInfo(double[], com.bc.ceres.core.ProgressMonitor)}</code> method is
 called with the given parameters passed to this method.
 */
ImageInfo RasterDataNode_getImageInfo3(RasterDataNode _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Creates a default image information instance.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.
 */
ImageInfo RasterDataNode_createDefaultImageInfo1(RasterDataNode _self, const double* histoSkipAreasElems, int histoSkipAreasLength, ProgressMonitor pm);
/**
 * Creates an instance of a default image information.
 <p/>
 <p>An <code>IllegalStateException</code> is thrown in the case that this raster data node has no raster data.
 */
ImageInfo RasterDataNode_createDefaultImageInfo2(RasterDataNode _self, const double* histoSkipAreasElems, int histoSkipAreasLength, Histogram histogram);
/**
 * 
 */
ProductNodeGroup RasterDataNode_getOverlayMaskGroup(RasterDataNode _self);
/**
 * Creates an image for this raster data node. The method simply returns <code>ProductUtils.createColorIndexedImage(this,
 null)</code>.
 */
BufferedImage RasterDataNode_createColorIndexedImage(RasterDataNode _self, ProgressMonitor pm);
/**
 * Creates an RGB image for this raster data node.
 */
BufferedImage RasterDataNode_createRgbImage(RasterDataNode _self, ProgressMonitor pm);
/**
 * 
 */
byte* RasterDataNode_quantizeRasterData1(RasterDataNode _self, double newMin, double newMax, double gamma, ProgressMonitor pm, int* resultArrayLength);
/**
 * 
 */
void RasterDataNode_quantizeRasterData2(RasterDataNode _self, double newMin, double newMax, double gamma, const byte* samplesElems, int samplesLength, int offset, int stride, ProgressMonitor pm);
/**
 * Creates a validator which can be used to validate indexes of pixels in a flat raster data buffer.
 */
IndexValidator RasterDataNode_createPixelValidator(RasterDataNode _self, int lineOffset, ROI roi);
/**
 * Applies the scaling <code>v * scalingFactor + scalingOffset</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the result is taken to the power of 10 <i>after</i> the actual
 scaling.
 */
double RasterDataNode_scale(RasterDataNode _self, double v);
/**
 * Applies the inverse scaling <code>(v - scalingOffset) / scalingFactor</code> the the given input value. If the
 <code>log10Scaled</code> property is true, the common logarithm is applied to the input <i>before</i> the actual
 scaling.
 */
double RasterDataNode_scaleInverse(RasterDataNode _self, double v);
/**
 * Returns the pixel located at (x,y) as a string value.
 */
char* RasterDataNode_getPixelString(RasterDataNode _self, int x, int y);
/**
 * Returns whether the source image is set on this {@code RasterDataNode}.
 */
boolean RasterDataNode_isSourceImageSet(RasterDataNode _self);
/**
 * Gets the source image associated with this {@code RasterDataNode}.
 */
MultiLevelImage RasterDataNode_getSourceImage(RasterDataNode _self);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void RasterDataNode_setSourceImage1(RasterDataNode _self, RenderedImage sourceImage);
/**
 * Sets the source image associated with this {@code RasterDataNode}.
 */
void RasterDataNode_setSourceImage2(RasterDataNode _self, MultiLevelImage sourceImage);
/**
 * Returns whether the geophysical image is set on this {@code RasterDataNode}.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
boolean RasterDataNode_isGeophysicalImageSet(RasterDataNode _self);
/**
 * 
 */
MultiLevelImage RasterDataNode_getGeophysicalImage(RasterDataNode _self);
/**
 * Returns wether the valid mask image is set on this {@code RasterDataNode}.
 */
boolean RasterDataNode_isValidMaskImageSet(RasterDataNode _self);
/**
 * Gets the valid-mask image associated with this {@code RasterDataNode}.
 */
MultiLevelImage RasterDataNode_getValidMaskImage(RasterDataNode _self);
/**
 * 
 */
boolean RasterDataNode_isStxSet(RasterDataNode _self);
/**
 * Gets the statistics. If statistcs are not yet available,
 the method will compute (possibly inaccurate) statistics and return those.
 <p/>
 If accurate statistics are required, the {@link #getStx(boolean, com.bc.ceres.core.ProgressMonitor)}
 shall be used instead.
 <p/>
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx RasterDataNode_getStx1(RasterDataNode _self);
/**
 * Gets the statistics.
 If the statistics have not been set before they are computed using the given progress monitor {@code pm} and then set.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
Stx RasterDataNode_getStx2(RasterDataNode _self, boolean accurate, ProgressMonitor pm);
/**
 * Sets the statistics. It is the responsibility of the caller to ensure that the given statistics
 are really related to this {@code RasterDataNode}'s raster data.
 The method fires a property change event for the property {@link #PROPERTY_NAME_STX}.
 This method belongs to preliminary API and may be removed or changed in the future.
 */
void RasterDataNode_setStx(RasterDataNode _self, Stx stx);
/**
 * Gets the shape of the area where this raster data contains valid samples.
 The method returns <code>null</code>, if the entire raster contains valid samples.
 */
Shape RasterDataNode_getValidShape(RasterDataNode _self);
/**
 * Gets the data type of this data node.
 */
int RasterDataNode_getDataType(RasterDataNode _self);
/**
 * Gets the number of data elements in this data node.
 */
dlong RasterDataNode_getNumDataElems(RasterDataNode _self);
/**
 * Sets the data of this data node.
 */
void RasterDataNode_setData(RasterDataNode _self, ProductData data);
/**
 * Gets the data of this data node.
 */
ProductData RasterDataNode_getData(RasterDataNode _self);
/**
 * Sets the data elements of this data node.
 */
void RasterDataNode_setDataElems(RasterDataNode _self, Object elems);
/**
 * Gets the data elements of this data node.
 */
Object RasterDataNode_getDataElems(RasterDataNode _self);
/**
 * Gets the data element size in bytes.
 */
int RasterDataNode_getDataElemSize(RasterDataNode _self);
/**
 * 
 */
void RasterDataNode_setReadOnly(RasterDataNode _self, boolean readOnly);
/**
 * 
 */
boolean RasterDataNode_isReadOnly(RasterDataNode _self);
/**
 * 
 */
void RasterDataNode_setUnit(RasterDataNode _self, const char* unit);
/**
 * 
 */
char* RasterDataNode_getUnit(RasterDataNode _self);
/**
 * Fires a node data changed event. This method is called after the data of this data node changed.
 */
void RasterDataNode_fireProductNodeDataChanged(RasterDataNode _self);
/**
 * Gets the estimated size in bytes of this product node.
 */
dlong RasterDataNode_getRawStorageSize1(RasterDataNode _self, ProductSubsetDef subsetDef);
/**
 * Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.
 */
ProductData RasterDataNode_createCompatibleProductData(RasterDataNode _self, int numElems);
/**
 * 
 */
ProductNode RasterDataNode_getOwner(RasterDataNode _self);
/**
 * 
 */
char* RasterDataNode_getName(RasterDataNode _self);
/**
 * Sets this product's name.
 */
void RasterDataNode_setName(RasterDataNode _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* RasterDataNode_getDescription(RasterDataNode _self);
/**
 * Sets a short textual description for this products node.
 */
void RasterDataNode_setDescription(RasterDataNode _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean RasterDataNode_isModified(RasterDataNode _self);
/**
 * 
 */
char* RasterDataNode_toString(RasterDataNode _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean RasterDataNode_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product RasterDataNode_getProduct(RasterDataNode _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader RasterDataNode_getProductReader(RasterDataNode _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter RasterDataNode_getProductWriter(RasterDataNode _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* RasterDataNode_getDisplayName(RasterDataNode _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* RasterDataNode_getProductRefString(RasterDataNode _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong RasterDataNode_getRawStorageSize2(RasterDataNode _self);
/**
 * 
 */
void RasterDataNode_fireProductNodeChanged1(RasterDataNode _self, const char* propertyName);
/**
 * 
 */
void RasterDataNode_fireProductNodeChanged2(RasterDataNode _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void RasterDataNode_removeFromFile(RasterDataNode _self, ProductWriter productWriter);
/**
 * 
 */
E RasterDataNode_getExtension(RasterDataNode _self, Class arg0);

/* Functions for class AngularDirection */

/**
 * 
 */
AngularDirection AngularDirection_newAngularDirection1();
/**
 * 
 */
AngularDirection AngularDirection_newAngularDirection2(double azimuth, double zenith);
/**
 * 
 */
boolean AngularDirection_equals(AngularDirection _self, Object obj);
/**
 * 
 */
char* AngularDirection_toString(AngularDirection _self);

/* Functions for class FlagCoding */

/**
 * Constructs a new flag coding object with the given name.
 */
FlagCoding FlagCoding_newFlagCoding(const char* name);
/**
 * Returns a metadata attribute wich is the representation of the flag with the given name. This method delegates to
 getPropertyValue(String).
 */
MetadataAttribute FlagCoding_getFlag(FlagCoding _self, const char* name);
/**
 * Returns a string array which contains the names of all flags contained in this <code>FlagCoding</code> object.
 */
char** FlagCoding_getFlagNames(FlagCoding _self, int* resultArrayLength);
/**
 * Adds a new flag definition to this flags coding.
 */
MetadataAttribute FlagCoding_addFlag(FlagCoding _self, const char* name, int flagMask, const char* description);
/**
 * Returns the flag mask value for the specified flag name.
 */
int FlagCoding_getFlagMask(FlagCoding _self, const char* name);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void FlagCoding_acceptVisitor(FlagCoding _self, ProductVisitor visitor);
/**
 * Overrides the base class <code>addElement</code> in order to <b>not</b> add an element to this flag coding
 because flag codings do not support inner elements.
 */
void FlagCoding_addElement(FlagCoding _self, MetadataElement element);
/**
 * Adds an attribute to this node. If an attribute with the same name already exists, the method does nothing.
 */
void FlagCoding_addAttribute(FlagCoding _self, MetadataAttribute attribute);
/**
 * Adds a new coding value to this sample coding.
 */
MetadataAttribute FlagCoding_addSample(FlagCoding _self, const char* name, int value, const char* description);
/**
 * Gets the number of coded sample values.
 */
int FlagCoding_getSampleCount(FlagCoding _self);
/**
 * Gets the sample name at the specified attribute index.
 */
char* FlagCoding_getSampleName(FlagCoding _self, int index);
/**
 * Gets the sample value at the specified attribute index.
 */
int FlagCoding_getSampleValue(FlagCoding _self, int index);
/**
 * Gets the group of child elements. The method returns null, if this element has no children.
 */
ProductNodeGroup FlagCoding_getElementGroup(FlagCoding _self);
/**
 * 
 */
MetadataElement FlagCoding_getParentElement(FlagCoding _self);
/**
 * Adds the given element to this element at index.
 */
void FlagCoding_addElementAt(FlagCoding _self, MetadataElement element, int index);
/**
 * Removes the given element from this element.
 */
boolean FlagCoding_removeElement(FlagCoding _self, MetadataElement element);
/**
 * 
 */
int FlagCoding_getNumElements(FlagCoding _self);
/**
 * Returns the element at the given index.
 */
MetadataElement FlagCoding_getElementAt(FlagCoding _self, int index);
/**
 * Returns a string array containing the names of the groups contained in this element
 */
char** FlagCoding_getElementNames(FlagCoding _self, int* resultArrayLength);
/**
 * Returns an array of elements contained in this element.
 */
MetadataElement* FlagCoding_getElements(FlagCoding _self, int* resultArrayLength);
/**
 * Returns the element with the given name.
 */
MetadataElement FlagCoding_getElement(FlagCoding _self, const char* name);
/**
 * Tests if a element with the given name is contained in this element.
 */
boolean FlagCoding_containsElement(FlagCoding _self, const char* name);
/**
 * Gets the index of the given element.
 */
int FlagCoding_getElementIndex(FlagCoding _self, MetadataElement element);
/**
 * Removes the given attribute from this annotation. If an attribute with the same name already exists, the method
 does nothing.
 */
boolean FlagCoding_removeAttribute(FlagCoding _self, MetadataAttribute attribute);
/**
 * Returns the number of attributes attaached to this node.
 */
int FlagCoding_getNumAttributes(FlagCoding _self);
/**
 * Returns the attribute at the given index.
 */
MetadataAttribute FlagCoding_getAttributeAt(FlagCoding _self, int index);
/**
 * Returns the names of all attributes of this node.
 */
char** FlagCoding_getAttributeNames(FlagCoding _self, int* resultArrayLength);
/**
 * Returns an array of attributes contained in this element.
 */
MetadataAttribute* FlagCoding_getAttributes(FlagCoding _self, int* resultArrayLength);
/**
 * Returns the attribute with the given name.
 */
MetadataAttribute FlagCoding_getAttribute(FlagCoding _self, const char* name);
/**
 * Checks whether this node has an element with the given name.
 */
boolean FlagCoding_containsAttribute(FlagCoding _self, const char* name);
/**
 * Gets the index of the given attribute.
 */
int FlagCoding_getAttributeIndex(FlagCoding _self, MetadataAttribute attribute);
/**
 * Returns the double value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
double FlagCoding_getAttributeDouble1(FlagCoding _self, const char* name, double defaultValue);
/**
 * Returns the double value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
double FlagCoding_getAttributeDouble2(FlagCoding _self, const char* name);
/**
 * Returns the UTC value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
ProductData_UTC FlagCoding_getAttributeUTC1(FlagCoding _self, const char* name, ProductData_UTC defaultValue);
/**
 * Returns the UTC value of the attribute with the given name.
 */
ProductData_UTC FlagCoding_getAttributeUTC2(FlagCoding _self, const char* name);
/**
 * Returns the integer value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
int FlagCoding_getAttributeInt1(FlagCoding _self, const char* name, int defaultValue);
/**
 * Returns the integer value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
int FlagCoding_getAttributeInt2(FlagCoding _self, const char* name);
/**
 * Sets the attribute with the given name to the given integer value. <p>A new attribute with
 <code>ProductData.TYPE_INT32</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void FlagCoding_setAttributeInt(FlagCoding _self, const char* name, int value);
/**
 * Sets the attribute with the given name to the given double value. <p>A new attribute with
 <code>ProductData.TYPE_FLOAT64</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void FlagCoding_setAttributeDouble(FlagCoding _self, const char* name, double value);
/**
 * Sets the attribute with the given name to the given utc value. <p>A new attribute with
 <code>ProductData.UTC</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void FlagCoding_setAttributeUTC(FlagCoding _self, const char* name, ProductData_UTC value);
/**
 * Returns the string value of the attribute with the given name. <p>An Exception is thrown if an
 attribute with the given name could not be found in this node.
 */
char* FlagCoding_getAttributeString1(FlagCoding _self, const char* name);
/**
 * Returns the string value of the attribute with the given name. <p>The given default value is returned if an
 attribute with the given name could not be found in this node.
 */
char* FlagCoding_getAttributeString2(FlagCoding _self, const char* name, const char* defaultValue);
/**
 * Sets the attribute with the given name to the given string value. <p>A new attribute with
 <code>ProductData.TYPE_ASCII</code> is added to this node if an attribute with the given name could not be found
 in this node.
 */
void FlagCoding_setAttributeString(FlagCoding _self, const char* name, const char* value);
/**
 * 
 */
void FlagCoding_setModified(FlagCoding _self, boolean modified);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong FlagCoding_getRawStorageSize1(FlagCoding _self, ProductSubsetDef subsetDef);
/**
 * 
 */
MetadataElement FlagCoding_createDeepClone(FlagCoding _self);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void FlagCoding_dispose(FlagCoding _self);
/**
 * 
 */
ProductNode FlagCoding_getOwner(FlagCoding _self);
/**
 * 
 */
char* FlagCoding_getName(FlagCoding _self);
/**
 * Sets this product's name.
 */
void FlagCoding_setName(FlagCoding _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* FlagCoding_getDescription(FlagCoding _self);
/**
 * Sets a short textual description for this products node.
 */
void FlagCoding_setDescription(FlagCoding _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean FlagCoding_isModified(FlagCoding _self);
/**
 * 
 */
char* FlagCoding_toString(FlagCoding _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean FlagCoding_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product FlagCoding_getProduct(FlagCoding _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader FlagCoding_getProductReader(FlagCoding _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter FlagCoding_getProductWriter(FlagCoding _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* FlagCoding_getDisplayName(FlagCoding _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* FlagCoding_getProductRefString(FlagCoding _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong FlagCoding_getRawStorageSize2(FlagCoding _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void FlagCoding_updateExpression(FlagCoding _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void FlagCoding_fireProductNodeChanged1(FlagCoding _self, const char* propertyName);
/**
 * 
 */
void FlagCoding_fireProductNodeChanged2(FlagCoding _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void FlagCoding_removeFromFile(FlagCoding _self, ProductWriter productWriter);
/**
 * 
 */
E FlagCoding_getExtension(FlagCoding _self, Class arg0);

/* Functions for class ProductReader */

/**
 * Returns the plug-in which created this product reader.
 */
ProductReaderPlugIn ProductReader_getReaderPlugIn(ProductReader _self);
/**
 * Retrives the current input destination object. Thie return value might be <code>null</code> if the
 <code>setInput</code> has not been called so far.
 */
Object ProductReader_getInput(ProductReader _self);
/**
 * Returns the subset information with which this a data product is read from its physical source.
 */
ProductSubsetDef ProductReader_getSubsetDef(ProductReader _self);
/**
 * Reads a data product and returns a in-memory representation of it.
 <p/>
 <p> The given subset info can be used to specify spatial and spectral portions of the original proudct. If the
 subset is omitted, the complete product is read in.
 <p/>
 <p> Whether the band data - the actual pixel values - is read in immediately or later when pixels are requested,
 is up to the implementation.
 */
Product ProductReader_readProductNodes(ProductReader _self, Object input, ProductSubsetDef subsetDef);
/**
 * Reads raster data from the data source specified by the given destination band into the given in-memory buffer
 and region.
 <p/>
 <h3>Destination band</h3> The destination band is used to identify the data source from which this method
 transfers the sample values into the given destination buffer. The method does not modify the given destination
 band at all. If this product reader has a <code>ProductSubsetDef</code> instance attached to it, the method
 should also consider the specified spatial subset and sub-sampling (if any) applied to the destination band.
 <p/>
 <h3>Destination region</h3> The given destination region specified by the <code>destOffsetX</code>,
 <code>destOffsetY</code>, <code>destWidth</code> and <code>destHeight</code> parameters are given in the band's
 raster co-ordinates of the raster which results <i>after</i> applying the optional spatial subset and
 sub-sampling given by the <code>ProductSubsetDef</code> instance to the <i>data source</i>. If no spatial subset
 and sub-sampling is specified, the destination co-ordinates are identical with the source co-ordinates. The
 destination region should always specify a sub-region of the band's scene raster.
 <p/>
 <h3>Destination buffer</h3> The first element of the destination buffer corresponds to the given
 <code>destOffsetX</code> and <code>destOffsetY</code> of the destination region. The offset parameters are
 <b>not</b> an offset within the buffer.<br> The number of elements in the buffer exactly be <code>destWidth *
 destHeight</code>. The pixel values read are stored in line-by-line order, so the raster X co-ordinate varies
 faster than the Y co-ordinate.
 */
void ProductReader_readBandRasterData(ProductReader _self, Band destBand, int destOffsetX, int destOffsetY, int destWidth, int destHeight, ProductData destBuffer, ProgressMonitor pm);
/**
 * Closes the access to all currently opened resources such as file input streams and all resources of this children
 directly owned by this reader. Its primary use is to allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>close()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.close();</code> after disposing this instance.
 */
void ProductReader_close(ProductReader _self);

/* Functions for class RGBChannelDef */

/**
 * 
 */
RGBChannelDef RGBChannelDef_newRGBChannelDef1();
/**
 * 
 */
RGBChannelDef RGBChannelDef_newRGBChannelDef2(const char** bandNamesElems, int bandNamesLength);
/**
 * 
 */
char* RGBChannelDef_getSourceName(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setSourceName(RGBChannelDef _self, int index, const char* sourceName);
/**
 * 
 */
char** RGBChannelDef_getSourceNames(RGBChannelDef _self, int* resultArrayLength);
/**
 * 
 */
void RGBChannelDef_setSourceNames(RGBChannelDef _self, const char** bandNamesElems, int bandNamesLength);
/**
 * 
 */
boolean RGBChannelDef_isAlphaUsed(RGBChannelDef _self);
/**
 * 
 */
boolean RGBChannelDef_isGammaUsed(RGBChannelDef _self, int index);
/**
 * 
 */
double RGBChannelDef_getGamma(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setGamma(RGBChannelDef _self, int index, double gamma);
/**
 * 
 */
double RGBChannelDef_getMinDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMinDisplaySample(RGBChannelDef _self, int index, double min);
/**
 * 
 */
double RGBChannelDef_getMaxDisplaySample(RGBChannelDef _self, int index);
/**
 * 
 */
void RGBChannelDef_setMaxDisplaySample(RGBChannelDef _self, int index, double max);
/**
 * 
 */
Object RGBChannelDef_clone(RGBChannelDef _self);

/* Functions for class Tile */

/**
 * Gets the {@code RasterDataNode} associated with this tile,
 e.g. a {@link org.esa.beam.framework.datamodel.Band Band} for source and target tiles or
 {@link org.esa.beam.framework.datamodel.TiePointGrid TiePointGrid} for a source tile.
 */
RasterDataNode Tile_getRasterDataNode(Tile _self);
/**
 * Checks if this is a target tile. Non-target tiles are read only.
 */
boolean Tile_isTarget(Tile _self);
/**
 * Converts a raw sample value (e.g. digital counts) to a (geo-)physically scaled sample value
 of type {@code float}.
 */
float Tile_toGeoPhysical1(Tile _self, float rawSample);
/**
 * Converts a raw sample value (e.g. digital counts) to a (geo-)physically scaled sample value
 of type {@code double}.
 */
double Tile_toGeoPhysical2(Tile _self, double rawSample);
/**
 * Converts a (geo-)physically scaled sample value of type {@code float} to a
 its corresponding raw sample value (e.g. digital counts).
 */
float Tile_toRaw1(Tile _self, float sample);
/**
 * Converts a (geo-)physically scaled sample value of type {@code double} to a
 its corresponding raw sample value (e.g. digital counts).
 */
double Tile_toRaw2(Tile _self, double sample);
/**
 * Gets the tile rectangle in pixel coordinates within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 Simply returns <code>new Rectangle(
 {@link #getMinX() minX},
 {@link #getMinY() minY},
 {@link #getWidth() width},
 {@link #getHeight() height})</code>.
 */
Rectangle Tile_getRectangle(Tile _self);
/**
 * Gets the minimum pixel x-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMinX(Tile _self);
/**
 * Gets the maximum pixel x-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMaxX(Tile _self);
/**
 * Gets the minimum pixel y-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMinY(Tile _self);
/**
 * Gets the maximum pixel y-coordinate within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getMaxY(Tile _self);
/**
 * Gets the width in pixels within the scene covered by the tile's {@link #getRasterDataNode RasterDataNode}.
 */
int Tile_getWidth(Tile _self);
/**
 * Gets the height in pixels within the scene covered by the tile's {@link RasterDataNode}.
 */
int Tile_getHeight(Tile _self);
/**
 * Gets the index into the underlying raw sample buffer for the given pixel coordinates.
 <p>The pixel coordinates are absolute; meaning they are defined in the scene raster coordinate system
 of this tile's {@link #getRasterDataNode()  RasterDataNode}.
 </p>
 <p>The returned index is computed as follows:
 <pre>
   int dx = x - {@link #getMinX()};
   int dy = y - {@link #getMinY()};
   int index = {@link #getScanlineOffset()} + dy * {@link #getScanlineStride()} + dx;
 </pre>
 </p>
 */
int Tile_getDataBufferIndex(Tile _self, int x, int y);
/**
 * <p>Obtains access to the underlying raw sample buffer. The data buffer holds the
 raw (unscaled, uncalibrated) sample data (e.g. detector counts).</p>
 Elements in this array must be addressed
 by an index computed via the {@link #getScanlineStride() scanlineStride} and
 {@link #getScanlineOffset() scanlineOffset} properties.
 The index can also be directly computed using the  {@link #getDataBufferIndex(int, int)} method.
 <p/>
 <p>The most efficient way to access and/or modify the samples in the raw data buffer is using
 the following nested loops:</p>
 <pre>
   int lineStride = tile.{@link #getScanlineStride()};
   int lineOffset = tile.{@link #getScanlineOffset()};
   for (int y = tile.{@link #getMinY()}; y &lt;= tile.{@link #getMaxY()}; y++) {
      int index = lineOffset;
      for (int x = tile.{@link #getMinX()}; x &lt;= tile.{@link #getMaxX()}; x++) {
           // use index here to access raw data buffer...
           index++;
       }
       lineOffset += lineStride;
   }
 </pre>
 <p/>
 <p>If the absolute x,y pixel coordinates are not required, the following construct maybe more
 readable:</p>
 <pre>
   int lineStride = tile.{@link #getScanlineStride()};
   int lineOffset = tile.{@link #getScanlineOffset()};
   for (int y = 0; y &lt; tile.{@link #getHeight()}; y++) {
      int index = lineOffset;
      for (int x = 0; x &lt; tile.{@link #getWidth()}; x++) {
           // use index here to access raw data buffer...
           index++;
       }
       lineOffset += lineStride;
   }
 </pre>
 */
ProductData Tile_getDataBuffer(Tile _self);
/**
 * Gets the underlying raw sample array of type <code>byte</code> (signed or unsigned).
 If the underlying data buffer is not of type <code>byte</code>, <code>null</code> is returned.
 <p>Refer to {@link #getDataBuffer()} for using the primitive array.</p>
 */
byte* Tile_getDataBufferByte(Tile _self, int* resultArrayLength);
/**
 * Gets the underlying raw sample array of type <code>short</code> (signed or unsigned).
 If the underlying data buffer is not of type <code>short</code>, <code>null</code> is returned.
 <p>Refer to {@link #getDataBuffer()} for using the primitive array.</p>
 */
short* Tile_getDataBufferShort(Tile _self, int* resultArrayLength);
/**
 * Gets the underlying raw sample array of type <code>int</code>.
 If the underlying data buffer is not of type <code>int</code>, <code>null</code> is returned.
 <p>Refer to {@link #getDataBuffer()} for using the primitive array.</p>
 */
int* Tile_getDataBufferInt(Tile _self, int* resultArrayLength);
/**
 * Gets the underlying raw sample array of type <code>float</code>.
 If the underlying data buffer is not of type <code>float</code>, <code>null</code> is returned.
 <p>Refer to {@link #getDataBuffer()} for using the primitive array.</p>
 */
float* Tile_getDataBufferFloat(Tile _self, int* resultArrayLength);
/**
 * Gets the underlying raw sample array of type <code>double</code>.
 If the underlying data buffer is not of type <code>double</code>, <code>null</code> is returned.
 <p>Refer to {@link #getDataBuffer()} for using the primitive array.</p>
 */
double* Tile_getDataBufferDouble(Tile _self, int* resultArrayLength);
/**
 * Gets the scanline offset.
 The scanline offset is the index to the first valid sample element in the data buffer.
 */
int Tile_getScanlineOffset(Tile _self);
/**
 * Gets the raster scanline stride for addressing the internal data buffer.
 The scanline stride is added to the scanline offset in order to compute offsets of subsequent scanlines.
 */
int Tile_getScanlineStride(Tile _self);
/**
 * Gets the raw (unscaled, uncalibrated) samples, e.g. detector counts, copied from or wrapping the underlying
 data buffer. In contradiction to the {@link #getDataBuffer()} method, the returned samples
 will cover exactly the region {@link #getRectangle()} rectangle} of this tile. Thus, the number
 of returned samples will always equal {@link #getWidth() width} {@code *} {@link #getHeight() height}.
 <p>In order to apply changes of the samples values to this tile, it is mandatory to call
 {@link #setRawSamples(org.esa.beam.framework.datamodel.ProductData)} with the modified
 {@code ProductData} instance.</p>
 */
ProductData Tile_getRawSamples(Tile _self);
/**
 * Sets this tile's raw (unscaled, uncalibrated) samples.
 The number of given samples must be equal {@link #getWidth() width} {@code *} {@link #getHeight() height}
 of this tile.
 <p>This method must be used
 in order to apply changes made to the samples returned by the {@link #getRawSamples()} method.</p>
 */
void Tile_setRawSamples(Tile _self, ProductData rawSamples);
/**
 * Gets the scaled, (geo-)physical array of {@code int} samples, copied from or directly returning the underlying
 data buffer. In contradiction to the {@link #getDataBuffer()} method, the returned samples
 will cover exactly the region {@link #getRectangle()} rectangle} of this tile. Thus, the number
 of returned samples will always equal {@link #getWidth() width} {@code *} {@link #getHeight() height}.
 <p/>
 <p>Sample values that are masked out (see {@link #isSampleValid(int, int)}) are returned as array elements
 having the value {@link Float#NaN}.</p>
 */
int* Tile_getSamplesInt(Tile _self, int* resultArrayLength);
/**
 * Gets the scaled, (geo-)physical array of {@code double} samples, copied from or directly returning the underlying
 data buffer. In contradiction to the {@link #getDataBuffer()} method, the returned samples
 will cover exactly the region {@link #getRectangle()} rectangle} of this tile. Thus, the number
 of returned samples will always equal {@link #getWidth() width} {@code *} {@link #getHeight() height}.
 <p/>
 <p>Sample values that are masked out (see {@link #isSampleValid(int, int)}) are returned as array elements
 having the value {@link Float#NaN}.</p>
 */
float* Tile_getSamplesFloat(Tile _self, int* resultArrayLength);
/**
 * Gets the scaled, (geo-)physical array of {@code double} samples, copied from or directly returning the underlying
 data buffer. In contradiction to the {@link #getDataBuffer()} method, the returned samples
 will cover exactly the region {@link #getRectangle()} rectangle} of this tile. Thus, the number
 of returned samples will always equal {@link #getWidth() width} {@code *} {@link #getHeight() height}.
 <p/>
 <p>Sample values that are masked out (see {@link #isSampleValid(int, int)}) are returned as array elements
 having the value {@link Float#NaN}.</p>
 */
double* Tile_getSamplesDouble(Tile _self, int* resultArrayLength);
/**
 * Sets this tile's scaled, (geo-)physical samples as array of {@code floats}s.
 The number of given samples must be equal {@link #getWidth() width} {@code *} {@link #getHeight() height}
 of this tile.
 */
void Tile_setSamples1(Tile _self, const int* samplesElems, int samplesLength);
/**
 * Sets this tile's scaled, (geo-)physical samples as array of {@code floats}s.
 The number of given samples must be equal {@link #getWidth() width} {@code *} {@link #getHeight() height}
 of this tile.
 */
void Tile_setSamples2(Tile _self, const float* samplesElems, int samplesLength);
/**
 * Sets this tile's scaled, (geo-)physical samples as array of {@code double}s.
 The number of given samples must be equal {@link #getWidth() width} {@code *} {@link #getHeight() height}
 of this tile.
 <p>This method must be used
 in order to apply changes made to the samples returned by the {@link #getRawSamples()} method.</p>
 */
void Tile_setSamples3(Tile _self, const double* samplesElems, int samplesLength);
/**
 * Checks whether or not the sample value exists and is valid at a given image pixel position.
 */
boolean Tile_isSampleValid(Tile _self, int x, int y);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
boolean Tile_getSampleBoolean(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample1(Tile _self, int x, int y, boolean sample);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code int} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
int Tile_getSampleInt(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code int} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample2(Tile _self, int x, int y, int sample);
/**
 * Gets the (geo-)physically scaled sample at the given pixel coordinate as {@code float} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
float Tile_getSampleFloat(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code float} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample3(Tile _self, int x, int y, float sample);
/**
 * Gets the (geo-)physically scaled sample value for the given pixel coordinate as {@code double}.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
double Tile_getSampleDouble(Tile _self, int x, int y);
/**
 * Sets the (geo-)physically scaled sample at the given pixel coordinate from a {@code double} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.
 The conversion ensures that no overflow happens. If necessary the value is cropped to the value range.</p>
 <p>Note that in most cases, accessing the tile's {@link #getDataBuffer() dataBuffer} directly in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties
 gives a better performance.</p>
 */
void Tile_setSample4(Tile _self, int x, int y, double sample);
/**
 * Gets the bit-coded sample value for the given pixel coordinate and the specified bit index as a {@code boolean}.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
boolean Tile_getSampleBit(Tile _self, int x, int y, int bitIndex);
/**
 * Sets the bit-coded sample at the given pixel coordinate and the specified bit index from a {@code boolean} value.
 <p>If the underlying data buffer is of a different sample data type, an appropriate type conversion is performed.</p>
 <p>Note that in most cases it is more performant to directly access the tile's {@link #getDataBuffer() dataBuffer} in conjunction
 with the {@link #getScanlineOffset() scanlineOffset} and {@link #getScanlineStride() scanlineStride} properties.</p>
 */
void Tile_setSample5(Tile _self, int x, int y, int bitIndex, boolean sample);
/**
 * Gets an iterator which can be used to visit all pixels in the tile.
 The method allows this tile to be the target of the Java "foreach" statement.
 Using the tile as an iterator in a single loop
 <pre>
 for (Tile.Pos pos: tile) {
    int x = pos.x;
    int y = pos.y;
    // ...
 }
 </pre>
 is equivalent to iterating over all pixels using two nested loops
 <pre>
 for (int y = tile.getMinY(); y <= tile.getMaxY(); y++) {
     for (int x = tile.getMinX(); x <= tile.getMaxX(); x++) {
         // ...
     }
 }
 </pre>
 */
Iterator Tile_iterator(Tile _self);

/* Functions for class ProductData */

/**
 * Factory method which creates a value instance of the given type and with exactly one element.
 */
ProductData ProductData_createInstance1(int type);
/**
 * Factory method which creates a value instance of the given type and with the specified number of elements.
 */
ProductData ProductData_createInstance2(int type, int numElems);
/**
 * Factory method which creates a value instance of the given type and with the specified number of elements.
 */
ProductData ProductData_createInstance3(int type, Object data);
/**
 * 
 */
ProductData ProductData_createInstance4(const byte* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance1(const byte* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance5(const short* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance2(const short* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance6(const int* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createUnsignedInstance3(const int* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance7(const long* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance8(const char* strData);
/**
 * 
 */
ProductData ProductData_createInstance9(const float* elemsElems, int elemsLength);
/**
 * 
 */
ProductData ProductData_createInstance10(const double* elemsElems, int elemsLength);
/**
 * Returns this value's type ID.
 */
int ProductData_getType1(ProductData _self);
/**
 * Gets the element size of an element of the given type in bytes.
 */
int ProductData_getElemSize1(int type);
/**
 * Gets the element size of an element of this product data in bytes.
 */
int ProductData_getElemSize2(ProductData _self);
/**
 * Returns a textual representation of the given data type.
 */
char* ProductData_getTypeString1(int type);
/**
 * Returns a integer representation of the given data type string.
 */
int ProductData_getType2(const char* type);
/**
 * Returns this value's data type String.
 */
char* ProductData_getTypeString2(ProductData _self);
/**
 * Tests whether this value has an integer.
 */
boolean ProductData_isInt(ProductData _self);
/**
 * Tests whether the given value type is a signed or unsigned integer type.
 */
boolean ProductData_isIntType(int type);
/**
 * Tests whether the actual instance is an signed data type.
 */
boolean ProductData_isSigned(ProductData _self);
/**
 * Tests whether the actual instance is an unsigned data type.
 */
boolean ProductData_isUnsigned(ProductData _self);
/**
 * Tests whether the given value type is an unsigned integer type.
 */
boolean ProductData_isUIntType(int type);
/**
 * Tests whether the given value type is a floating point type.
 */
boolean ProductData_isFloatingPointType(int type);
/**
 * Tests if this value is a scalar.
 */
boolean ProductData_isScalar(ProductData _self);
/**
 * Returns the number of data elements this value has.
 */
int ProductData_getNumElems(ProductData _self);
/**
 * Returns the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 returns <code>getElemIntAt(0)</code>.
 */
int ProductData_getElemInt(ProductData _self);
/**
 * Returns the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply returns <code>getElemUIntAt(0)</code>.
 */
dlong ProductData_getElemUInt(ProductData _self);
/**
 * Returns the value as an <code>float</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemFloatAt(0)</code>.
 */
float ProductData_getElemFloat(ProductData _self);
/**
 * Returns the value as an <code>double</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemDoubleAt(0)</code>.
 */
double ProductData_getElemDouble(ProductData _self);
/**
 * Returns the value as a <code>String</code>. The text returned is the comma-separated list of elements contained
 in this value.
 */
char* ProductData_getElemString(ProductData _self);
/**
 * Returns the value as an <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore
 simply returns <code>getElemBooleanAt(0)</code>.
 */
boolean ProductData_getElemBoolean(ProductData _self);
/**
 * Gets the value element with the given index as an <code>int</code>.
 */
int ProductData_getElemIntAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>long</code>.
 */
dlong ProductData_getElemUIntAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>float</code>.
 */
float ProductData_getElemFloatAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>double</code>.
 */
double ProductData_getElemDoubleAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>String</code>.
 */
char* ProductData_getElemStringAt(ProductData _self, int index);
/**
 * Gets the value element with the given index as a <code>boolean</code>.
 */
boolean ProductData_getElemBooleanAt(ProductData _self, int index);
/**
 * Sets the value as an <code>int</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemInt(0, value)</code>.
 */
void ProductData_setElemInt(ProductData _self, int value);
/**
 * Sets the value as an unsigned <code>int</code> given as a <code>long</code>. <p>The method assumes that this
 value is a scalar and therefore simply calls <code>setElemUInt(0, value)</code>.
 */
void ProductData_setElemUInt(ProductData _self, dlong value);
/**
 * Sets the value as a <code>float</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemFloatAt(0, value)</code>.
 */
void ProductData_setElemFloat(ProductData _self, float value);
/**
 * Sets the value as a <code>double</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.
 */
void ProductData_setElemDouble(ProductData _self, double value);
/**
 * Sets the value as a <code>String</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemStringAt(0)</code>.
 */
void ProductData_setElemString(ProductData _self, const char* value);
/**
 * Sets the value as a <code>boolean</code>. <p>The method assumes that this value is a scalar and therefore simply
 calls <code>setElemDoubleAt(0)</code>.
 */
void ProductData_setElemBoolean(ProductData _self, boolean value);
/**
 * Sets the value at the specified index as an <code>int</code>.
 */
void ProductData_setElemIntAt(ProductData _self, int index, int value);
/**
 * Sets the value at the specified index as an unsigned <code>int</code> given as a <code>long</code>.
 */
void ProductData_setElemUIntAt(ProductData _self, int index, dlong value);
/**
 * Sets the value at the specified index as a <code>float</code>.
 */
void ProductData_setElemFloatAt(ProductData _self, int index, float value);
/**
 * Sets the value at the specified index as a <code>double</code>.
 */
void ProductData_setElemDoubleAt(ProductData _self, int index, double value);
/**
 * Sets the value at the specified index as a <code>String</code>.
 <p/>
 <p><i>THE METHOD IS CURRENTLY NOT IMPLEMENTED.</i>
 */
void ProductData_setElemStringAt(ProductData _self, int index, const char* value);
/**
 * Sets the value at the specified index as a <code>boolean</code>.
 */
void ProductData_setElemBooleanAt(ProductData _self, int index, boolean value);
/**
 * Returns the internal value. The actual type of the returned object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> </ol>
 */
Object ProductData_getElems(ProductData _self);
/**
 * Sets the internal value. The actual type of the given data object should only be one of <ol>
 <li><code>byte[]</code> - for signed/unsigned 8-bit integer fields</li> <li><code>short[]</code> - for
 signed/unsigned 16-bit integer fields</li> <li><code>int[]</code> - for signed/unsigned 32-bit integer
 fields</li> <li><code>float[]</code> - for signed 32-bit floating point fields</li> <li><code>double[]</code> -
 for signed 64-bit floating point fields</li> <li><code>String[]</code> - for all field types</li> </ol>
 */
void ProductData_setElems(ProductData _self, Object data);
/**
 * Reads all elements of this <code>ProductData</code> instance from to the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek position
 within the input stream.
 */
void ProductData_readFrom1(ProductData _self, ImageInputStream input);
/**
 * Reads a single element of this <code>ProductData</code> instance from to the given output stream.
 <p/>
 <p> The method reads the element at <code>pos</code> of this <code>ProductData</code> instance from the given
 output stream.<br> Reading starts at the current seek position within the output stream.
 */
void ProductData_readFrom2(ProductData _self, int pos, ImageInputStream input);
/**
 * Reads elements of this <code>ProductData</code> instance from the given output stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at the current seek
 position of the input stream.
 */
void ProductData_readFrom3(ProductData _self, int startPos, int numElems, ImageInputStream input);
/**
 * Reads elements into this <code>ProductData</code> instance from the given input stream.
 <p/>
 <p> The method subsequentially reads the elements at <code>startPos</code> to <code>startPos+numElems-1</code> of
 this <code>ProductData</code> instance from the given input stream.<br> Reading starts at <code>inputPos</code>
 within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.
 */
void ProductData_readFrom4(ProductData _self, int startPos, int numElems, ImageInputStream input, dlong inputPos);
/**
 * Writes all elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>0</code> to <code>getNumElems()-1</code> of this
 <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek position
 within the output stream.
 */
void ProductData_writeTo1(ProductData _self, ImageOutputStream output);
/**
 * Writes a single element of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method writes the element at <code>pos</code> of this <code>ProductData</code> instance to the given
 output stream.<br> Writing starts at the current seek position within the output stream.
 */
void ProductData_writeTo2(ProductData _self, int pos, ImageOutputStream output);
/**
 * Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at the current seek
 position within the output stream.
 */
void ProductData_writeTo3(ProductData _self, int startPos, int numElems, ImageOutputStream output);
/**
 * Writes elements of this <code>ProductData</code> instance to to the given output stream.
 <p/>
 <p> The method subsequentially writes the elements at <code>startPos</code> to <code>startPos+numElems-1</code>
 of this <code>ProductData</code> instance to the given output stream.<br> Writing starts at
 <code>outputPos</code> within the output stream. The method multiplies this position with the value returned by
 <code>getElemSize()</code> in order to find the correct stream offset in bytes.
 */
void ProductData_writeTo4(ProductData _self, int startPos, int numElems, ImageOutputStream output, dlong outputPos);
/**
 * Returns a string representation of this value which can be used for debugging purposes.
 */
char* ProductData_toString(ProductData _self);
/**
 * Returns {@link Object#hashCode()}.
 */
int ProductData_hashCode(ProductData _self);
/**
 * Returns {@link Object#equals(Object)}.
 Use {@link #equalElems} in order to perform an element-wise comparision.
 */
boolean ProductData_equals(ProductData _self, Object other);
/**
 * Tests whether this ProductData is equal to another one.
 Performs an element-wise comparision if the other object is a {@link ProductData} instance of the same data type.
 Otherwise the method behaves like {@link Object#equals(Object)}.
 */
boolean ProductData_equalElems(ProductData _self, ProductData other);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 */
void ProductData_dispose(ProductData _self);

/* Functions for class GeoPos */

/**
 * Constructs a new geo-position with latitude and longitude set to zero.
 */
GeoPos GeoPos_newGeoPos1();
/**
 * Constructs a new geo-position with latitude and longitude set to that of the given geo-position.
 */
GeoPos GeoPos_newGeoPos2(GeoPos geoPos);
/**
 * Constructs a new geo-position with the given latitude and longitude values.
 */
GeoPos GeoPos_newGeoPos3(float lat, float lon);
/**
 * Gets the latitude value.
 */
float GeoPos_getLat(GeoPos _self);
/**
 * Gets the longitude value.
 */
float GeoPos_getLon(GeoPos _self);
/**
 * Sets the geographical location of this point.
 */
void GeoPos_setLocation(GeoPos _self, float lat, float lon);
/**
 * Tests whether or not this geo-position is valid.
 */
boolean GeoPos_isValid(GeoPos _self);
/**
 * Tests whether or not all given geo-positions are valid.
 */
boolean GeoPos_areValid(const GeoPos* aElems, int aLength);
/**
 * Sets the lat/lon fields so that {@link #isValid()} will return false.
 */
void GeoPos_setInvalid(GeoPos _self);
/**
 * Indicates whether some other object is "equal to" this one.
 */
boolean GeoPos_equals(GeoPos _self, Object obj);
/**
 * Returns a hash code value for the object.
 */
int GeoPos_hashCode(GeoPos _self);
/**
 * Returns a string representation of the object. In general, the <code>toString</code> method returns a string that
 "textually represents" this object.
 */
char* GeoPos_toString(GeoPos _self);
/**
 * Normalizes this position so that its longitude is in the range -180 to +180 degree.
 */
void GeoPos_normalize(GeoPos _self);
/**
 * Normalizes the given longitude so that it is in the range -180 to +180 degree and returns it.
 Note that -180 will remain as is, although -180 is equivalent to +180 degrees.
 */
float GeoPos_normalizeLon(float lon);
/**
 * Returns a string representation of the latitude value.
 */
char* GeoPos_getLatString1(GeoPos _self);
/**
 * Returns a string representation of the latitude value.
 */
char* GeoPos_getLonString1(GeoPos _self);
/**
 * Returns a string representation of the given longitude value.
 */
char* GeoPos_getLatString2(float lat);
/**
 * Returns a string representation of the given longitude value.
 */
char* GeoPos_getLonString2(float lon);

/* Functions for class ProductNodeGroup */

/**
 * Constructs a node group with no owner and which will not take ownership of added children.
 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup1(const char* name);
/**
 * Constructs a node group for the given owner.
 */
ProductNodeGroup ProductNodeGroup_newProductNodeGroup2(ProductNode owner, const char* name, boolean takingOverNodeOwnership);
/**
 * 
 */
boolean ProductNodeGroup_isTakingOverNodeOwnership(ProductNodeGroup _self);
/**
 * 
 */
int ProductNodeGroup_getNodeCount(ProductNodeGroup _self);
/**
 * 
 */
T ProductNodeGroup_get1(ProductNodeGroup _self, int index);
/**
 * Returns the display names of all products currently managed.
 */
char** ProductNodeGroup_getNodeDisplayNames(ProductNodeGroup _self, int* resultArrayLength);
/**
 * Returns the names of all products currently managed.
 */
char** ProductNodeGroup_getNodeNames(ProductNodeGroup _self, int* resultArrayLength);
/**
 * Returns an array of all products currently managed.
 */
ProductNode* ProductNodeGroup_toArray1(ProductNodeGroup _self, int* resultArrayLength);
/**
 * 
 */
T* ProductNodeGroup_toArray2(ProductNodeGroup _self, const T* arrayElems, int arrayLength, int* resultArrayLength);
/**
 * 
 */
int ProductNodeGroup_indexOf1(ProductNodeGroup _self, const char* name);
/**
 * 
 */
int ProductNodeGroup_indexOf2(ProductNodeGroup _self, T element);
/**
 * 
 */
T ProductNodeGroup_getByDisplayName(ProductNodeGroup _self, const char* displayName);
/**
 * 
 */
T ProductNodeGroup_get2(ProductNodeGroup _self, const char* name);
/**
 * Tests whether a node with the given name is contained in this group.
 */
boolean ProductNodeGroup_contains1(ProductNodeGroup _self, const char* name);
/**
 * Tests whether the given product is contained in this list.
 */
boolean ProductNodeGroup_contains2(ProductNodeGroup _self, T node);
/**
 * Adds the given node to this group.
 */
boolean ProductNodeGroup_add1(ProductNodeGroup _self, T node);
/**
 * Adds the given node to this group.
 */
void ProductNodeGroup_add2(ProductNodeGroup _self, int index, T node);
/**
 * Removes the given node from this group.
 */
boolean ProductNodeGroup_remove(ProductNodeGroup _self, T node);
/**
 * Removes all nodes from this group.
 */
void ProductNodeGroup_removeAll(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_clearRemovedList(ProductNodeGroup _self);
/**
 * Gets all removed node nodes.
 */
Collection ProductNodeGroup_getRemovedNodes(ProductNodeGroup _self);
/**
 * 
 */
dlong ProductNodeGroup_getRawStorageSize1(ProductNodeGroup _self, ProductSubsetDef subsetDef);
/**
 * 
 */
void ProductNodeGroup_setModified(ProductNodeGroup _self, boolean modified);
/**
 * 
 */
void ProductNodeGroup_acceptVisitor(ProductNodeGroup _self, ProductVisitor visitor);
/**
 * 
 */
void ProductNodeGroup_dispose(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_updateExpression(ProductNodeGroup _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
ProductNode ProductNodeGroup_getOwner(ProductNodeGroup _self);
/**
 * 
 */
char* ProductNodeGroup_getName(ProductNodeGroup _self);
/**
 * Sets this product's name.
 */
void ProductNodeGroup_setName(ProductNodeGroup _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* ProductNodeGroup_getDescription(ProductNodeGroup _self);
/**
 * Sets a short textual description for this products node.
 */
void ProductNodeGroup_setDescription(ProductNodeGroup _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean ProductNodeGroup_isModified(ProductNodeGroup _self);
/**
 * 
 */
char* ProductNodeGroup_toString(ProductNodeGroup _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean ProductNodeGroup_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product ProductNodeGroup_getProduct(ProductNodeGroup _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader ProductNodeGroup_getProductReader(ProductNodeGroup _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter ProductNodeGroup_getProductWriter(ProductNodeGroup _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* ProductNodeGroup_getDisplayName(ProductNodeGroup _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* ProductNodeGroup_getProductRefString(ProductNodeGroup _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong ProductNodeGroup_getRawStorageSize2(ProductNodeGroup _self);
/**
 * 
 */
void ProductNodeGroup_fireProductNodeChanged1(ProductNodeGroup _self, const char* propertyName);
/**
 * 
 */
void ProductNodeGroup_fireProductNodeChanged2(ProductNodeGroup _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void ProductNodeGroup_removeFromFile(ProductNodeGroup _self, ProductWriter productWriter);
/**
 * 
 */
E ProductNodeGroup_getExtension(ProductNodeGroup _self, Class arg0);

/* Functions for class Operator */

/**
 * Initializes this operator and sets the one and only target product.
 <p>The target product can be either defined by a field of type {@link Product} annotated with the
 {@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation or
 by calling {@link #setTargetProduct} method.
 </p>
 <p> This method shall never be called directly. The framework calls this method after it has created
 an instance of this {@code Operator}. This will occur
 only once durting the lifetime of an {@code Operator} instance.
 If not already done, calling the {@link #getTargetProduct()} will always trigger
 a call to the {@code initialize()} method.
 </p>
 Any client code that must be performed before computation of tile data
 should be placed here.
 */
void Operator_initialize(Operator _self);
/**
 * Updates this operator forcing it to recreate the target product.
 <i>Warning: Experimental API added by nf (25.02.2010)</i><br/>
 */
void Operator_update(Operator _self);
/**
 * Called by the framework in order to compute a tile for the given target band.
 <p>The default implementation throws a runtime exception with the message "not implemented".</p>
 <p>This method shall never be called directly.
 </p>
 */
void Operator_computeTile(Operator _self, Band targetBand, Tile targetTile, ProgressMonitor pm);
/**
 * Called by the framework in order to compute the stack of tiles for the given target bands.
 <p>The default implementation throws a runtime exception with the message "not implemented".</p>
 <p>This method shall never be called directly.
 </p>
 */
void Operator_computeTileStack(Operator _self, Map targetTiles, Rectangle targetRectangle, ProgressMonitor pm);
/**
 * Releases the resources the operator has acquired during its lifetime.
 The default implementation does nothing.
 <p/>
 Overrides should make sure to call {@code super.dispose()} as well.
 */
void Operator_dispose(Operator _self);
/**
 * 
 */
char* Operator_getId(Operator _self);
/**
 * Gets the source products in the order they have been declared.
 */
Product* Operator_getSourceProducts(Operator _self, int* resultArrayLength);
/**
 * Sets the source products.
 */
void Operator_setSourceProducts(Operator _self, const Product* productsElems, int productsLength);
/**
 * Gets a single source product. This method is a shortcut for
 {@code getSourceProduct("sourceProduct")}.
 */
Product Operator_getSourceProduct1(Operator _self);
/**
 * Sets a single source product. This method is a shortcut for
 {@code setSourceProduct("sourceProduct", sourceProduct)}.
 */
void Operator_setSourceProduct1(Operator _self, Product sourceProduct);
/**
 * Gets the source product using the specified name.
 */
Product Operator_getSourceProduct2(Operator _self, const char* id);
/**
 * Sets a source product.
 One product instance can be registered with different identifiers, e.g. "source", "source1" and "input"
 in consecutive calls.
 */
void Operator_setSourceProduct2(Operator _self, const char* id, Product product);
/**
 * Gets the identifier for the given source product.
 */
char* Operator_getSourceProductId(Operator _self, Product product);
/**
 * Gets the target product for the operator.
 <p/>
 <p>If the target product is not set, calling this method results in a
 call to {@link #initialize()}.</p>
 */
Product Operator_getTargetProduct(Operator _self);
/**
 * Gets a target property of the operator.
 <p/>
 <p>If the requested target property is not set, calling this method results in a
 call to {@link #initialize()}.</p>
 */
Object Operator_getTargetProperty(Operator _self, const char* name);
/**
 * Gets the value for the parameter with the given name.
 */
Object Operator_getParameter(Operator _self, const char* name);
/**
 * Sets the value for the parameter with the given name.
 */
void Operator_setParameter(Operator _self, const char* name, Object value);
/**
 * Gets a {@link Tile} for a given band and image region.
 */
Tile Operator_getSourceTile1(Operator _self, RasterDataNode rasterDataNode, Rectangle region);
/**
 * Gets a {@link Tile} for a given band and image region. The region can overlap the bounds of source image.
 This method is particulary useful if you need to compute target pixels from an n x m region around a corresponding source pixel.
 In this case an extended tile will need to be read from the source.
 */
Tile Operator_getSourceTile2(Operator _self, RasterDataNode rasterDataNode, Rectangle region, BorderExtender borderExtender);
/**
 * Gets the logger whuich can be used to log information during initialisation and tile computation.
 */
Logger Operator_getLogger(Operator _self);
/**
 * Non-API.
 */
void Operator_stopTileComputationObservation(Operator _self);
/**
 * Sets the logger which can be used to log information during initialisation and tile computation.
 */
void Operator_setLogger(Operator _self, Logger logger);
/**
 * Gets the SPI which was used to create this operator.
 If no operator has been explicitly set, the method will return an anonymous
 SPI.
 */
OperatorSpi Operator_getSpi(Operator _self);
/**
 * Sets the SPI which was used to create this operator.
 */
void Operator_setSpi(Operator _self, OperatorSpi operatorSpi);

/* Functions for class ProductUtils */

/**
 * 
 */
ProductUtils ProductUtils_newProductUtils();
/**
 * Creates image creation information.
 */
ImageInfo ProductUtils_createImageInfo(const RasterDataNode* rastersElems, int rastersLength, boolean assignMissingImageInfos, ProgressMonitor pm);
/**
 * Creates a RGB image from the given array of <code>{@link RasterDataNode}</code>s.
 The given array <code>rasters</code> containing one or three raster data nodes. If three rasters are given
 RGB image is created, if only one raster is provided a gray scale image created.
 */
BufferedImage ProductUtils_createRgbImage(const RasterDataNode* rastersElems, int rastersLength, ImageInfo imageInfo, ProgressMonitor pm);
/**
 * Creates a greyscale image from the given <code>{@link RasterDataNode}</code>.
 <p/>
 <p>The method uses the given raster data node's image information (an instance of <code>{@link
 ImageInfo}</code>) to create the image.
 */
BufferedImage ProductUtils_createColorIndexedImage(RasterDataNode rasterDataNode, ProgressMonitor pm);
/**
 * Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be
 the upper left pixel's center (0.5, 0.5).
 */
MapInfo ProductUtils_createSuitableMapInfo1(Product product, Rectangle rect, MapProjection mapProjection);
/**
 * Retuns a suitable <code>MapInfo</code> instance for the given (geo-coded) product which includes the entire or a
 subset of the product's scene region for the given map projection. The position of the reference pixel will be the scene center.
 */
MapInfo ProductUtils_createSuitableMapInfo2(Product product, MapProjection mapProjection, double orientation, double noDataValue);
/**
 * 
 */
Dimension ProductUtils_getOutputRasterSize(Product product, Rectangle rect, MapTransform mapTransform, double pixelSizeX, double pixelSizeY);
/**
 * Creates the boundary in map coordinates for the given product, source rectangle (in product pixel coordinates)
 and the given map transfromation. The method delegates to {@link #createMapEnvelope(org.esa.beam.framework.datamodel.Product,
 java.awt.Rectangle, int, org.esa.beam.framework.dataop.maptransf.MapTransform) createMapEnvelope(product, rect,
 step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene raster width and
 height.
 */
Point2D* ProductUtils_createMapEnvelope1(Product product, Rectangle rect, MapTransform mapTransform, int* resultArrayLength);
/**
 * Creates the boundary in map coordinates for the given product, source rectangle (in product
 pixel coordinates) and the given map transfromation. The method delegates to
 {@link #createMapBoundary(Product, Rectangle, int, MapTransform) createMapBoundary(product, rect,
 step, mapTransform)} where <code>step</code> is the half of the minimum of the product scene
 raster width and height.
 */
Point2D* ProductUtils_createMapEnvelope2(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
/**
 * 
 */
Point2D* ProductUtils_getMinMax(const Point2D* boundaryElems, int boundaryLength, int* resultArrayLength);
/**
 * 
 */
Point2D* ProductUtils_createMapBoundary(Product product, Rectangle rect, int step, MapTransform mapTransform, int* resultArrayLength);
/**
 * Creates the geographical boundary of the given product and returns it as a list of geographical coordinates.
 */
GeoPos* ProductUtils_createGeoBoundary1(Product product, int step, int* resultArrayLength);
/**
 * Creates the geographical boundary of the given region within the given product and returns it as a list of
 geographical coordinates.
 <p> This method delegates to {@link #createGeoBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundary(Product, Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.
 */
GeoPos* ProductUtils_createGeoBoundary2(Product product, Rectangle region, int step, int* resultArrayLength);
/**
 * Creates the geographical boundary of the given region within the given product and returns it as a list of
 geographical coordinates.
 */
GeoPos* ProductUtils_createGeoBoundary3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 * Creates the geographical boundary of the given region within the given raster and returns it as a list of
 geographical coordinates.
 */
GeoPos* ProductUtils_createGeoBoundary4(RasterDataNode raster, Rectangle region, int step, int* resultArrayLength);
/**
 * Converts the geographic boundary entire product into one, two or three shape objects. If the product does not
 intersect the 180 degree meridian, a single general path is returned. Otherwise two or three shapes are created
 and returned in the order from west to east.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.
 */
GeneralPath* ProductUtils_createGeoBoundaryPaths1(Product product, int* resultArrayLength);
/**
 * Converts the geographic boundary of the region within the given product into one, two or three shape objects. If
 the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three
 shapes are created and returned in the order from west to east.
 <p/>
 This method delegates to {@link #createGeoBoundaryPaths(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createGeoBoundaryPaths(Product, Rectangle, int, boolean)}
 and the additional parameter <code>usePixelCenter</code> is <code>true</code>.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.
 */
GeneralPath* ProductUtils_createGeoBoundaryPaths2(Product product, Rectangle region, int step, int* resultArrayLength);
/**
 * Converts the geographic boundary of the region within the given product into one, two or three shape objects. If
 the product does not intersect the 180 degree meridian, a single general path is returned. Otherwise two or three
 shapes are created and returned in the order from west to east.
 <p/>
 The geographic boundary of the given product are returned as shapes comprising (longitude,latitude) pairs.
 */
GeneralPath* ProductUtils_createGeoBoundaryPaths3(Product product, Rectangle region, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 * Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p> This method delegates to {@link #createPixelBoundary(org.esa.beam.framework.datamodel.Product, java.awt.Rectangle, int, boolean) createPixelBoundary(Product, Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.
 */
PixelPos* ProductUtils_createPixelBoundary1(Product product, Rectangle rect, int step, int* resultArrayLength);
/**
 * Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 */
PixelPos* ProductUtils_createPixelBoundary2(Product product, Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 * Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 <p>This method is used for an intermediate step when determining a raster boundary expressed in geographical
 co-ordinates.
 */
PixelPos* ProductUtils_createPixelBoundary3(RasterDataNode raster, Rectangle rect, int step, int* resultArrayLength);
/**
 * Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p>This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p> This method delegates to {@link #createRectBoundary(java.awt.Rectangle, int, boolean) createRectBoundary(Rectangle, int, boolean)}
 and the additional boolean parameter <code>usePixelCenter</code> is <code>true</code>.
 */
PixelPos* ProductUtils_createRectBoundary1(Rectangle rect, int step, int* resultArrayLength);
/**
 * Creates a rectangular boundary expressed in pixel positions for the given source rectangle. If the source
 <code>rect</code> is 100 x 50 pixels and <code>step</code> is 10 the returned array will countain exactly 2 * 10
 + 2 * (5 - 2) = 26 pixel positions.
 <p/>
 This method is used for an intermediate step when determining a product boundary expressed in geographical
 co-ordinates.
 <p/>
 */
PixelPos* ProductUtils_createRectBoundary2(Rectangle rect, int step, boolean usePixelCenter, int* resultArrayLength);
/**
 * Copies the flag codings from the source product to the target.
 */
void ProductUtils_copyFlagCodings(Product source, Product target);
/**
 * Copies the given source flag coding to the target product.
 If it exists already, the method simply returns the existing instance.
 */
FlagCoding ProductUtils_copyFlagCoding(FlagCoding sourceFlagCoding, Product target);
/**
 * Copies the given source index coding to the target product
 If it exists already, the method simply returns the existing instance.
 */
IndexCoding ProductUtils_copyIndexCoding(IndexCoding sourceIndexCoding, Product target);
/**
 * Copies the {@link Mask}s from the source product to the target product.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks from the source bands to the target bands. Also
 note that a source mask is not copied to the target product, when there already
 is a mask in the target product with the same name as the source mask.
 */
void ProductUtils_copyMasks(Product sourceProduct, Product targetProduct);
/**
 * Copies the overlay {@link Mask}s from the source product's raster data nodes to
 the target product's raster data nodes.
 <p/>
 IMPORTANT NOTE: This method should only be used, if it is known that all masks
 in the source product will also be valid in the target product. This method does
 <em>not</em> copy overlay masks, which are not contained in the target product's
 mask group.
 */
void ProductUtils_copyOverlayMasks(Product sourceProduct, Product targetProduct);
/**
 * Copies all bands which contain a flagcoding from the source product to the target product.
 */
void ProductUtils_copyFlagBands(Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 * Copies the named tie-point grid from the source product to the target product.
 */
TiePointGrid ProductUtils_copyTiePointGrid(const char* gridName, Product sourceProduct, Product targetProduct);
/**
 * Copies the named band from the source product to the target product.
 */
Band ProductUtils_copyBand1(const char* sourceBandName, Product sourceProduct, Product targetProduct, boolean copySourceImage);
/**
 * Copies the named band from the source product to the target product.
 */
Band ProductUtils_copyBand2(const char* sourceBandName, Product sourceProduct, const char* targetBandName, Product targetProduct, boolean copySourceImage);
/**
 * Copies all properties from source band to the target band.
 */
void ProductUtils_copyRasterDataNodeProperties(RasterDataNode sourceRaster, RasterDataNode targetRaster);
/**
 * Copies the spectral properties from source band to target band. These properties are:
 <ul>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandIndex() spectral band index},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralWavelength() the central wavelength},</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSpectralBandwidth() the spectral bandwidth} and</li>
 <li>{@link org.esa.beam.framework.datamodel.Band#getSolarFlux() the solar spectral flux}.</li>
 </ul>
 */
void ProductUtils_copySpectralBandProperties(Band sourceBand, Band targetBand);
/**
 * Copies the geocoding from the source product to target product.
 */
void ProductUtils_copyGeoCoding(Product sourceProduct, Product targetProduct);
/**
 * Copies all tie point grids from one product to another.
 */
void ProductUtils_copyTiePointGrids(Product sourceProduct, Product targetProduct);
/**
 * 
 */
void ProductUtils_copyVectorData(Product sourceProduct, Product targetProduct);
/**
 * Returns whether or not a product can return a pixel position from a given geographical position.
 */
boolean ProductUtils_canGetPixelPos1(Product product);
/**
 * Returns whether or not a raster can return a pixel position from a given geographical position.
 */
boolean ProductUtils_canGetPixelPos2(RasterDataNode raster);
/**
 * Creates a density plot image from two raster data nodes.
 */
BufferedImage ProductUtils_createDensityPlotImage(RasterDataNode raster1, float sampleMin1, float sampleMax1, RasterDataNode raster2, float sampleMin2, float sampleMax2, Mask roiMask, int width, int height, Color background, BufferedImage image, ProgressMonitor pm);
/**
 * Draws all the masks contained overlay mask group of the given raster to the ovelayBIm image.
 */
BufferedImage ProductUtils_overlayMasks(RasterDataNode raster, BufferedImage overlayBIm, ProgressMonitor pm);
/**
 * 
 */
GeoPos ProductUtils_getCenterGeoPos(Product product);
/**
 * Normalizes the given geographical polygon so that maximum longitude differences between two points are 180
 degrees. The method operates only on the longitude values of the given polygon.
 */
int ProductUtils_normalizeGeoPolygon(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
int ProductUtils_normalizeGeoPolygon_old(const GeoPos* polygonElems, int polygonLength);
/**
 * Denormalizes the longitude values which have been normalized using the
 {@link #normalizeGeoPolygon(org.esa.beam.framework.datamodel.GeoPos[])} method. The
 method operates only on the longitude values of the given polygon.
 */
void ProductUtils_denormalizeGeoPolygon(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos(GeoPos geoPos);
/**
 * 
 */
void ProductUtils_denormalizeGeoPos_old(GeoPos geoPos);
/**
 * 
 */
int ProductUtils_getRotationDirection(const GeoPos* polygonElems, int polygonLength);
/**
 * 
 */
double ProductUtils_getAngleSum(const GeoPos* polygonElems, int polygonLength);
/**
 * Converts a <code>GeneralPath</code> given in geographic lon/lat coordinates into a <code>GeneralPath</code> in
 pixel coordinates using the supplied geo coding.
 */
GeneralPath ProductUtils_convertToPixelPath(GeneralPath geoPath, GeoCoding geoCoding);
/**
 * Converts a <code>Shape</code> given in pixel X/Y coordinates into a <code>GeneralPath</code> in geografic
 coordinates using the supplied geo coding.
 */
GeneralPath ProductUtils_convertToGeoPath(Shape shape, GeoCoding geoCoding);
/**
 * Copies all metadata elements and attributes of the source product to the target product.
 The copied elements and attributes are deeply cloned.
 */
void ProductUtils_copyMetadata1(Product source, Product target);
/**
 * Copies all metadata elements and attributes of the source element to the target element.
 The copied elements and attributes are deeply cloned.
 */
void ProductUtils_copyMetadata2(MetadataElement source, MetadataElement target);
/**
 * Copies the source product's preferred tile size (if any) to the target product.
 */
void ProductUtils_copyPreferredTileSize(Product sourceProduct, Product targetProduct);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata1(Product product);
/**
 * 
 */
GeoTIFFMetadata ProductUtils_createGeoTIFFMetadata2(GeoCoding geoCoding, int width, int height);
/**
 * 
 */
GeneralPath ProductUtils_areaToPath(Area negativeArea, double deltaX);
/**
 * Adds a given elem to the history of the given product. If the products metadata root
 does not contain a history entry a new one will be created.
 */
void ProductUtils_addElementToHistory(Product product, MetadataElement elem);
/**
 * Validates all the expressions contained in the given (output) product. If an expression is not applicable to the given
 product, the related element is removed.
 */
char** ProductUtils_removeInvalidExpressions(Product product, int* resultArrayLength);
/**
 * Finds the name of a band in the given product which is suitable to product a good quicklook.
 The method prefers bands with longer wavelengths, in order to produce good results for night-time scenes.
 */
char* ProductUtils_findSuitableQuicklookBandName(Product product);
/**
 * 
 */
PixelPos* ProductUtils_computeSourcePixelCoordinates(GeoCoding sourceGeoCoding, int sourceWidth, int sourceHeight, GeoCoding destGeoCoding, Rectangle destArea, int* resultArrayLength);
/**
 * Computes the minimum and maximum y value of the given {@link PixelPos} array.
 */
float* ProductUtils_computeMinMaxY(const PixelPos* pixelPositionsElems, int pixelPositionsLength, int* resultArrayLength);
/**
 * Copies only the bands from source to target.
 */
void ProductUtils_copyBandsForGeomTransform1(Product sourceProduct, Product targetProduct, double defaultNoDataValue, Map addedRasterDataNodes);
/**
 * Adds raster data nodes of a source product as bands to the given target product. This method is especially usefull if the target
 product is a geometric transformation (e.g. map-projection) of the source product.
 <p>If
 {@link RasterDataNode#isScalingApplied() sourceBand.scalingApplied} is true,
 this method will always create the related target band with the raw data type {@link ProductData#TYPE_FLOAT32},
 regardless which raw data type the source band has.
 In this case, {@link RasterDataNode#getScalingFactor() targetBand.scalingFactor}
 will always be 1.0, {@link RasterDataNode#getScalingOffset() targetBand.scalingOffset}
 will always be 0.0 and
 {@link RasterDataNode#isLog10Scaled() targetBand.log10Scaled} will be taken from the source band.
 This ensures that source pixel resampling methods operating on floating point
 data can be stored without loss in accuracy in the target band.
 <p/>
 <p>Furthermore, the
 {@link RasterDataNode#isNoDataValueSet() targetBands.noDataValueSet}
 and {@link RasterDataNode#isNoDataValueUsed() targetBands.noDataValueUsed}
 properties will always be true for all added target bands. The {@link RasterDataNode#getGeophysicalNoDataValue() targetBands.geophysicalNoDataValue},
 will be either the one from the source band, if any, or otherwise the one passed into this method.
 */
void ProductUtils_copyBandsForGeomTransform2(Product sourceProduct, Product targetProduct, boolean includeTiePointGrids, double defaultNoDataValue, Map targetToSourceMap);
/**
 * 
 */
ProductData_UTC ProductUtils_getScanLineTime(Product product, double y);
/**
 * 
 */
double ProductUtils_getGeophysicalSampleDouble(Band band, int pixelX, int pixelY, int level);
/**
 * 
 */
dlong ProductUtils_getGeophysicalSampleLong(Band band, int pixelX, int pixelY, int level);

/* Functions for class MetadataAttribute */

/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute1(const char* name, int type);
/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute2(const char* name, int type, int numElems);
/**
 * 
 */
MetadataAttribute MetadataAttribute_newMetadataAttribute3(const char* name, ProductData data, boolean readOnly);
/**
 * 
 */
MetadataElement MetadataAttribute_getParentElement(MetadataAttribute _self);
/**
 * 
 */
boolean MetadataAttribute_equals(MetadataAttribute _self, Object object);
/**
 * Accepts the given visitor. This method implements the well known 'Visitor' design pattern of the gang-of-four.
 The visitor pattern allows to define new operations on the product data model without the need to add more code
 to it. The new operation is implemented by the visitor.
 <p/>
 <p>The method simply calls <code>visitor.visit(this)</code>.
 */
void MetadataAttribute_acceptVisitor(MetadataAttribute _self, ProductVisitor visitor);
/**
 * 
 */
MetadataAttribute MetadataAttribute_createDeepClone(MetadataAttribute _self);
/**
 * Gets the data type of this data node.
 */
int MetadataAttribute_getDataType(MetadataAttribute _self);
/**
 * Tests whether the data type of this node is a floating point type.
 */
boolean MetadataAttribute_isFloatingPointType(MetadataAttribute _self);
/**
 * Gets the number of data elements in this data node.
 */
dlong MetadataAttribute_getNumDataElems(MetadataAttribute _self);
/**
 * Sets the data of this data node.
 */
void MetadataAttribute_setData(MetadataAttribute _self, ProductData data);
/**
 * Gets the data of this data node.
 */
ProductData MetadataAttribute_getData(MetadataAttribute _self);
/**
 * Sets the data elements of this data node.
 */
void MetadataAttribute_setDataElems(MetadataAttribute _self, Object elems);
/**
 * Gets the data elements of this data node.
 */
Object MetadataAttribute_getDataElems(MetadataAttribute _self);
/**
 * Gets the data element size in bytes.
 */
int MetadataAttribute_getDataElemSize(MetadataAttribute _self);
/**
 * 
 */
void MetadataAttribute_setReadOnly(MetadataAttribute _self, boolean readOnly);
/**
 * 
 */
boolean MetadataAttribute_isReadOnly(MetadataAttribute _self);
/**
 * 
 */
void MetadataAttribute_setUnit(MetadataAttribute _self, const char* unit);
/**
 * 
 */
char* MetadataAttribute_getUnit(MetadataAttribute _self);
/**
 * Fires a node data changed event. This method is called after the data of this data node changed.
 */
void MetadataAttribute_fireProductNodeDataChanged(MetadataAttribute _self);
/**
 * Gets the estimated size in bytes of this product node.
 */
dlong MetadataAttribute_getRawStorageSize1(MetadataAttribute _self, ProductSubsetDef subsetDef);
/**
 * Releases all of the resources used by this object instance and all of its owned children. Its primary use is to
 allow the garbage collector to perform a vanilla job.
 <p/>
 <p>This method should be called only if it is for sure that this object instance will never be used again. The
 results of referencing an instance of this class after a call to <code>dispose()</code> are undefined.
 <p/>
 <p>Overrides of this method should always call <code>super.dispose();</code> after disposing this instance.
 */
void MetadataAttribute_dispose(MetadataAttribute _self);
/**
 * Creates product data that is compatible to this dataset's data type. The data buffer returned contains exactly
 <code>numElems</code> elements of a compatible data type.
 */
ProductData MetadataAttribute_createCompatibleProductData(MetadataAttribute _self, int numElems);
/**
 * 
 */
ProductNode MetadataAttribute_getOwner(MetadataAttribute _self);
/**
 * 
 */
char* MetadataAttribute_getName(MetadataAttribute _self);
/**
 * Sets this product's name.
 */
void MetadataAttribute_setName(MetadataAttribute _self, const char* name);
/**
 * Returns a short textual description for this products node.
 */
char* MetadataAttribute_getDescription(MetadataAttribute _self);
/**
 * Sets a short textual description for this products node.
 */
void MetadataAttribute_setDescription(MetadataAttribute _self, const char* description);
/**
 * Returns whether or not this node is modified.
 */
boolean MetadataAttribute_isModified(MetadataAttribute _self);
/**
 * Sets this node's modified flag.
 <p/>
 If the modified flag changes to true and this node has an owner, the owner's modified flag is also set to
 true.
 */
void MetadataAttribute_setModified(MetadataAttribute _self, boolean modified);
/**
 * 
 */
char* MetadataAttribute_toString(MetadataAttribute _self);
/**
 * Tests whether the given name is valid name for a node.
 A valid node name must not start with a dot. Also a valid node name must not contain
 any of the character  <code>\/:*?"&lt;&gt;|</code>
 */
boolean MetadataAttribute_isValidNodeName(const char* name);
/**
 * Returns the product to which this node belongs to.
 */
Product MetadataAttribute_getProduct(MetadataAttribute _self);
/**
 * Returns the product reader for the product to which this node belongs to.
 */
ProductReader MetadataAttribute_getProductReader(MetadataAttribute _self);
/**
 * Returns the product writer for the product to which this node belongs to.
 */
ProductWriter MetadataAttribute_getProductWriter(MetadataAttribute _self);
/**
 * Returns this node's display name. The display name is the product reference string with the node name appended.
 <p>Example: The string <code>"[2] <i>node-name</i>"</code> means node <code><i>node-name</i></code> of the
 product with the reference number <code>2</code>.
 */
char* MetadataAttribute_getDisplayName(MetadataAttribute _self);
/**
 * Gets the product reference string. The product reference string is the product reference number enclosed in
 square brackets. <p>Example: The string <code>"[2]"</code> stands for a product with the reference number
 <code>2</code>.
 */
char* MetadataAttribute_getProductRefString(MetadataAttribute _self);
/**
 * Gets an estimated, raw storage size in bytes of this product node.
 */
dlong MetadataAttribute_getRawStorageSize2(MetadataAttribute _self);
/**
 * Asks a product node to replace all occurences of and references to the node name
 given by {@code oldExternalName} with {@code oldExternalName}. Such references most often occur
 in band arithmetic expressions.
 */
void MetadataAttribute_updateExpression(MetadataAttribute _self, const char* oldExternalName, const char* newExternalName);
/**
 * 
 */
void MetadataAttribute_fireProductNodeChanged1(MetadataAttribute _self, const char* propertyName);
/**
 * 
 */
void MetadataAttribute_fireProductNodeChanged2(MetadataAttribute _self, const char* propertyName, Object oldValue, Object newValue);
/**
 * Physically remove this node from the file associated with the given product writer. The default implementation
 does nothing.
 */
void MetadataAttribute_removeFromFile(MetadataAttribute _self, ProductWriter productWriter);
/**
 * 
 */
E MetadataAttribute_getExtension(MetadataAttribute _self, Class arg0);
